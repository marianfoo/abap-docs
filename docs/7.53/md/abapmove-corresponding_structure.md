  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assigning Structure Components](javascript:call_link\('abencorresponding.htm'\)) →  [MOVE-CORRESPONDING](javascript:call_link\('abapmove-corresponding.htm'\)) → 

MOVE-CORRESPONDING - structure

[Quick Reference](javascript:call_link\('abapmove-corresponding_shortref.htm'\))

Syntax

MOVE-CORRESPONDING *\[*EXACT*\]* struc1 TO struc2
  *\[*EXPANDING NESTED TABLES*\]*.

Extras:

[1\. ... EXACT](#!ABAP_ADDITION_1@1@)
[2\. ... EXPANDING NESTED TABLES](#!ABAP_ADDITION_2@2@)

Effect

This variant of the statement MOVE-CORRESPONDING requires [structures](javascript:call_link\('abenstructure_glosry.htm'\) "Glossary Entry") to be specified for struc1 and struc2. [Meshes](javascript:call_link\('abenmesh_glosry.htm'\) "Glossary Entry") - as operands of statement MOVE-CORRESPONDING - are handled in the same way as normal structures and can also be specified.

The system searches for all components with the same name in struc1 and struc2 and the content of components in struc1 is assigned to the components with the same name in struc2. Other components are not affected. If field symbols are used as operands, the names of the components are evaluated in accordance with the data type of the field symbols. A [casting](javascript:call_link\('abencast_casting_glosry.htm'\) "Glossary Entry") may be used to make this type different from the names of the actual structures.

Nested structures are fully expanded. The names of the components are compared down to the lowest common level. If the addition EXPANDING NESTED TABLES is not specified, the following statement is executed for each identically named component pair comp:

[struc2-comp = struc1-comp.](javascript:call_link\('abapmove.htm'\))

Any associated conversions are performed and the relevant exceptions may be raised. In particular, if the components are table-like, the entire table body is mapped in accordance with the [conversion rules for internal tables](javascript:call_link\('abenconversion_itab.htm'\)).

If struc1 or struc2 are empty [customizing includes](javascript:call_link\('abencustomizing_include_glosry.htm'\) "Glossary Entry") when the statement is executed (that is they do not contain any components), the statement is ignored. If struc1 is a structure that contains empty customizing includes as components, these are also ignored when the structure is evaluated.

Notes

-   If structures are specified for struc1 and struc2 and the structures are known statically, the names are compared once when the program is generated by ABAP Compiler. If untyped field symbols or formal parameters are used, the names must be compared each time the statement is executed.
    
-   Field symbols that point to structures can have different names for the components than the structure itself, as specified by the [CASTING](javascript:call_link\('abapassign_casting.htm'\)) addition of the statement [ASSIGN](javascript:call_link\('abapassign.htm'\)). The statement MOVE-CORRESPONDING evaluates the names of the data type of the current operand. In this way, components in the same structure can also be assigned to each other. Note that the order of editing, and hence the result in a component that is both source and target, is usually undefined. No temporary intermediate result is created and it is not possible to exchange the content of two components from the same structure in a single statement. See the executable example [Reflexive Component Assignments](javascript:call_link\('abenreflexive_corresponding_abexa.htm'\)).
    
-   The compiler optimizes the MOVE-CORRESPONDING statement for structures so that sequences of components that have the same names in both structures are grouped and copied together. It is therefore advisable to construct the structures in question in the same way whenever possible.
    
-   MOVE-CORRESPONDING for structures ignores names that were only defined with the AS name addition of the [INCLUDE](javascript:call_link\('abapinclude_type.htm'\)) statement or when structures were integrated into ABAP Dictionary. Any components renamed using the addition RENAMING WITH SUFFIX of the statement INCLUDE (or renamed similarly in ABAP Dictionary) are, however, not ignored.
    

Addition 1

... EXACT

Effect

If the addition EXACT is specified for MOVE-CORRESPONDING the following [lossless assignment](javascript:call_link\('abenlossless_move.htm'\)) is made for each identically named component pair comp

struc2-comp = [EXACT](javascript:call_link\('abenconstructor_expression_exact.htm'\)) #( struc1-comp ).

and the corresponding checks are performed. If an exception is raised, all components are assigned up to the component that raised the exception. This component, and all following components, are not assigned.

Addition 2

... EXPANDING NESTED TABLES

Effect

This addition specifies that, for two components with the same name and which are both internal tables, no [assignment](javascript:call_link\('abapmove.htm'\)) is made and that the variant [MOVE-CORRESPONDING *\[*EXACT*\]* for internal tables](javascript:call_link\('abapmove-corresponding_itab.htm'\)) with the addition EXPANDING NESTED TABLES and without the addition KEEPING TARGET LINES is executed instead.

Tabular components are resolved at every hierarchy level and identically named components are mapped row by row. The target tables are deleted before a mapping.

Note

If one of two identically named components is an internal table and the other not, MOVE-CORRESPONDING is never possible, regardless of whether EXPANDING NESTED TABLES is used.

Example

In the following example, the structure struc1 contains the components:

-   struc1-comp1
    
-   struc1-struci-comp1
    
-   struc1-struci-comp2-col1
    
-   struc1-struci-comp2-col2
    
-   struc1-itab
    

The structure struc2 contains the components:

-   struc2-struci-comp1
    
-   struc2-struci-comp2
    
-   struc2-struci-comp3
    
-   struc2-itab
    

Over the length of the shorter path, the components struci-comp1, struci-comp2, and itab have the same name. These are assigned from struc1 to struc2 in both MOVE-CORRESPONDING statements. In struc1, struci-comp2 is self-structured; in struc2, struci-comp2 is elementary. When struc1-struci-comp2 is assigned to struc2-struci-comp2, the source field is documented as an elementary field of type c in accordance with the conversion rules for structures.

The components itab are table-like and have compatible row types. The statement MOVE-CORRESPONDING without the addition EXPANDING NESTED TABLE maps the table body and the content of itab in struc2 then matches the content of itab in struc1. If the addition EXPANDING NESTED TABLE is used, only the component col2 is mapped and col3 remains initial.

The components struc1-comp1 and struc2-struci-comp3 do not have any equivalents with the same name and are ignored in the assignment.

TYPES: BEGIN OF line1,
         col1 TYPE i,
         col2 TYPE i,
       END OF line1,
       BEGIN OF line2,
         col2 TYPE i,
         col3 TYPE i,
       END OF line2.
DATA: BEGIN OF struc1,
        comp1 TYPE c LENGTH 1 VALUE 'U',
        BEGIN OF struci,
          comp1 TYPE c LENGTH 1 VALUE 'V',
          BEGIN OF comp2,
            col1 TYPE c LENGTH 1 VALUE 'X',
            col2 TYPE c LENGTH 1 VALUE 'Y',
          END OF comp2,
        END OF struci,
        itab TYPE TABLE OF line1 WITH EMPTY KEY,
     END OF struc1.
DATA: BEGIN OF struc2,
        BEGIN OF struci,
          comp1 TYPE string,
          comp2 TYPE string,
          comp3 TYPE string,
        END OF struci,
        itab TYPE TABLE OF line2 WITH EMPTY KEY,
     END OF struc2.
struc1-itab = VALUE #(
  ( col1 = 11 col2 = 12 )
  ( col1 = 21 col2 = 22 ) ).
MOVE-CORRESPONDING struc1 TO struc2.
MOVE-CORRESPONDING struc1 TO struc2 EXPANDING NESTED TABLES.

Example

This example shows how MOVE-CORRESPONDING is applied to two structures with the same type t\_str and which are cast using field symbols with different types. The statement evaluates the names of the types of the field symbols, which assigns the content of components that actually have different names.

TYPES: BEGIN OF t\_str,
         a1 TYPE i,
         a2 TYPE i,
       END OF t\_str.
TYPES: BEGIN OF t\_str1,
         b1 TYPE i,
         b2 TYPE i,
       END OF t\_str1.
TYPES: BEGIN OF t\_str2,
         b2 TYPE i,
         b1 TYPE i,
       END OF t\_str2.
DATA(str1) = VALUE t\_str( a1 = 1 a2 = 2 ).
DATA str2 LIKE str1.
FIELD-SYMBOLS <fs1> TYPE t\_str1.
ASSIGN str1 TO <fs1> CASTING.
FIELD-SYMBOLS <fs2> TYPE t\_str2.
ASSIGN str2 TO <fs2> CASTING.
MOVE-CORRESPONDING <fs1> TO <fs2>.
cl\_demo\_output=>write(   str1 ).
cl\_demo\_output=>display( str2 ).

Executable Example

[MOVE-CORRESPONDING for Structures](javascript:call_link\('abenmove_corresponding_struc_abexa.htm'\))