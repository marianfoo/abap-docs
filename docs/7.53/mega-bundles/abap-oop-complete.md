# ABAP OOP - Complete Reference (7.53)

**Generated**: 2025-09-01T11:14:58.481Z
**Bundles Combined**: 129
**Category**: oop

---



## 🔗 Complete Source Documentation

**📖 Official Documentation**: [ABAP Keyword Documentation 7.53](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/index.htm)
**🏷️ Category**: OOP
**🔍 Search Specific Topics**: Use `abap_search query:"oop"` for focused results
**📄 Individual Pages**: All source URLs included in each section below

### 🎯 Quick Navigation
- **Search for specific statements**: `abap_search query:"SELECT"` or `abap_search query:"LOOP"`
- **Get individual bundles**: Use `abap_get` with specific bundle doc_id
- **Browse by difficulty**: Look for **Difficulty** markers in each section

---

## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Data Elements

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Data Elements

Included pages: 7


### abenddic_data_elements.htm

> **📖 Official SAP Documentation**: [abenddic_data_elements.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_data_elements.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) → 

Data Elements

A data element in ABAP Dictionary defines an [elementary data type](javascript:call_link\('abenelementary_data_type_glosry.htm'\) "Glossary Entry") or a [reference type](javascript:call_link\('abenreference_type_glosry.htm'\) "Glossary Entry") and describes, alongside the technical type attributes, the semantic meaning of an object defined with reference to the data element. Data elements are the elementary parts of complex types such as [structures](javascript:call_link\('abenddic_structures.htm'\)), [table types](javascript:call_link\('abenddic_table_types.htm'\)), or [database tables](javascript:call_link\('abenddic_database_tables.htm'\)). An internal program object declared with reference to a data element always has one of the elementary built-in ABAP types. The type in question is defined by the mapping of the [built-in types](javascript:call_link\('abenddic_builtin_types.htm'\)) in ABAP Dictionary to ABAP types.

-   [Technical attributes of data elements](javascript:call_link\('abenddic_data_elements_tech.htm'\))

-   [Semantic attributes of data elements](javascript:call_link\('abenddic_data_elements_sema.htm'\))

Notes

-   The technical attributes of a data element can be defined either directly or by using a reusable [domain](javascript:call_link\('abenddic_domains.htm'\)). This is why the concept is known as a two-level domain concept.

-   Data elements can be edited in form-based editors both in the ABAP Dictionary [tool](javascript:call_link\('abenddic_tools.htm'\)) and in the [ABAP Development Tools (ADT)](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry").

Continue
[Technical Attributes of Data Elements](javascript:call_link\('abenddic_data_elements_tech.htm'\))
[Semantic Attributes of Data Elements](javascript:call_link\('abenddic_data_elements_sema.htm'\))
[Domains](javascript:call_link\('abenddic_domains.htm'\))



**📖 Source**: [abenddic_data_elements.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_data_elements.htm)

### abenddic_data_elements_tech.htm

> **📖 Official SAP Documentation**: [abenddic_data_elements_tech.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_data_elements_tech.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Data Elements](javascript:call_link\('abenddic_data_elements.htm'\)) → 

Technical Attributes of Data Elements

A data element describes an [elementary data type](javascript:call_link\('abenelementary_data_type_glosry.htm'\) "Glossary Entry") or a [reference type](javascript:call_link\('abenreference_type_glosry.htm'\) "Glossary Entry") with the following technical attributes:

-   Elementary type

A data element that describes an elementary type has a [built-in data type](javascript:call_link\('abenddic_builtin_types.htm'\)) from ABAP Dictionary, a length, and an (optional) number of fractional digits as its technical attributes. These technical attributes are defined either directly in the data element or are applied from a [domain](javascript:call_link\('abenddic_domains.htm'\)).

-   Reference type

A data element that describes a reference type is either a type for a [data reference variable](javascript:call_link\('abendata_reference_variable_glosry.htm'\) "Glossary Entry") or for an [object reference variable](javascript:call_link\('abenobject_refer_variable_glosry.htm'\) "Glossary Entry").

-   The [static type](javascript:call_link\('abenstatic_type_glosry.htm'\) "Glossary Entry") for a data reference variable is either the generic type DATA, any data type from ABAP Dictionary (including [database tables](javascript:call_link\('abenddic_database_tables.htm'\)) or [views](javascript:call_link\('abenddic_views.htm'\))), or a directly specified [built-in data type](javascript:call_link\('abenddic_builtin_types.htm'\)).

-   The [static type](javascript:call_link\('abenstatic_type_glosry.htm'\) "Glossary Entry") for an object reference variable is either the generic type OBJECT or a global class or global interface from the [class library](javascript:call_link\('abenclass_library_glosry.htm'\) "Glossary Entry").

Notes

-   When existing data elements are modified, all consumers of the data element are also affected. In particular, [foreign keys](javascript:call_link\('abenddic_database_tables_forkey.htm'\)) can become inconsistent when used for fields of database tables, which makes [conversions](javascript:call_link\('abenddic_database_tables_conv.htm'\)) necessary.

-   Global reference types in ABAP Dictionary can be used to specify types in ABAP programs. They cannot, however, be used for fields of database tables or in CDS views.

Example

The data element S\_CONN\_ID takes its technical attributes (data type NUMC, length 4) from the domain S\_CONN\_ID. The data element S\_CONN\_ID has documentation and further texts that describe its semantics. It is used as a data type of many table fields that match these semantic attributes, such as the column CONNID of the database tables SPFLI, SBOOK, and SFLIGHT.



**📖 Source**: [abenddic_data_elements_tech.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_data_elements_tech.htm)

### abenddic_data_elements_sema.htm

> **📖 Official SAP Documentation**: [abenddic_data_elements_sema.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_data_elements_sema.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Data Elements](javascript:call_link\('abenddic_data_elements.htm'\)) → 

Semantic Attributes of Data Elements

The semantic attributes of data elements are mainly significant when they are used as types of fields on user interfaces such as [dynpro](javascript:call_link\('abendynpro_glosry.htm'\) "Glossary Entry") (or [Web Dynpro](javascript:call_link\('abenweb_dynpro_glosry.htm'\) "Glossary Entry")) fields . The only exceptions to this are the default component name and the flag for the change document. ABAP data objects declared with reference to a data element ignore the semantic attributes of the element.

-   Short text

Short text of the data element. The short text assigned to a data element appears as a header in a [field help](javascript:call_link\('abenfield_help_glosry.htm'\) "Glossary Entry") of all dynpro fields or Web Dynpro fields defined with a direct or indirect reference to the data element.

-   Field label

The short, medium, and long field labels assigned to a data element, plus a header, can be created where appropriate as descriptions or column headers of lists for fields on screens of dynpros or Web Dynpros with direct or indirect reference to the data element. A freely definable maximum length with varying upper limits for the different field labels is applied to all languages and must be set accordingly.

-   Documentation

Documentation of the data element. The documentation created for a data element appears by default as [field help](javascript:call_link\('abenfield_help_glosry.htm'\) "Glossary Entry") for all dynpro fields or Web Dynpro fields defined with a direct or indirect reference to the data element. If no documentation was created, only the short text appears.

-   Supplement documentation

Additional supplement documentation objects can be created for a data element, with each documentation object identified by a four-digit number. This supplement documentation can be used for program-specific and dynpro-specific [field helps](javascript:call_link\('abendynp_field_help.htm'\)). The assignment of supplement documentation to a dynpro field is saved in the database table THLPF.

-   Documentation status

The status of the documentation for a data element can be noted as follows for any check tools:

-   Object is documented
    The default setting, indicating that the data element requires documentation.

-   Object not used on a screen
    The data element is not implemented for screen fields of dynpro fields or Web Dynpro fields and no further documentation is required.

-   Object is documented by its short text.
    The short text provides enough documentation.

-   Documentation is currently on hold
    The data element requires documentation but it does not yet exist.

-   Search help

A data element with an elementary data type can be assigned a [search help](javascript:call_link\('abensearch_help_glosry.htm'\) "Glossary Entry") and a parameter can be passed to this search help.
This search help is used for the [input help](javascript:call_link\('abeninput_help_glosry.htm'\) "Glossary Entry") of all dynpro fields or Web Dynpro fields defined with direct or indirect reference to the data element, unless the dynpro field is itself associated with a search help. Search helps cannot be assigned to a data element with a reference type.

-   SPA/GPA parameter

A data element with an elementary data type can be associated with an [SPA/GPA parameter](javascript:call_link\('abenmemory.htm'\)).
Dynpro fields defined with direct or indirect reference to the data element are filled with the content of the parameter, unless the dynpro field is itself associated with an SPA/GPA parameter. A data element with a reference type cannot be associated with an SPA/GPA parameter.

-   Flag for input history

The flag for the input history defines whether the input history in SAP GUI is active for dynpro fields defined with direct or indirect reference to the data element. This makes it possible to switch the input history off for sensitive fields.

-   Flag for bidirectional fonts

This flag defines the behavior of dynpro fields or Web Dynpro fields defined with direct or indirect reference to the data element when handling bidirectional fonts (such as Hebrew or Arabic).

-   Writing direction
    This flag can specify the writing direction of a dynpro field as "From left to right", which overwrites the direction "From right to left" specified by logons in a bidirectional font. This flag can be useful for fields with numeric texts.

-   BIDI filter
    This flag can be used to prevent the Unicode formatting characters that specify the writing direction of bidirectional fonts in data transports between GUI and AS ABAP from being filtered out, regardless of the global system settings. The global system setting is made in the program I18N\_SET\_DATAELEMENT\_FLAGS.

-   Default component name

The default component name of a data element is a naming suggestion for structure components or table fields defined with reference to this data element. Structures used in APIs in particular should use this proposal.

-   Flag for change document

The flag for change documents specifies whether changes to fields in database tables defined with reference to this data element are logged when change document objects are involved. A change document object groups multiple tables and is used to generate function modules that can be integrated into ABAP programs and that log changes. This flag cannot be set for data elements with a reference type.

-   Further semantic attributes can be defined in the [domain](javascript:call_link\('abenddic_domains.htm'\)) referenced by a data element.

The texts in the semantic attributes (the short text, field labels, and documentation) are, like all AS ABAP texts, passed to the translation tools.

Note

It is highly significant that many semantic attributes of a data element define the behavior of dynpro fields or Web Dynpro fields. For example, a data element whose documentation describes the internal attributes of a technical type is not usually suitable for use in UI fields. One example are the data elements SYST\_... that define the components of the system structure SYST. The documentation of these data elements describes the corresponding system fields and must not appear on a UI. Ideally, separate data elements are created with their own semantic attributes for UIs and database tables. Any data elements not used for UI fields do not usually need semantic attributes (except for the short text and possibly documentation). Conversely, attributes such as the flag for change documents are not relevant for data elements for UIs.



**📖 Source**: [abenddic_data_elements_sema.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_data_elements_sema.htm)

### abenddic_domains.htm

> **📖 Official SAP Documentation**: [abenddic_domains.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_domains.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Data Elements](javascript:call_link\('abenddic_data_elements.htm'\)) → 

Domains

A domain is a standalone dictionary object that defines technical and semantic attributes of elementary data types. [Data elements](javascript:call_link\('abenddic_data_elements.htm'\)) can be defined with reference to a domain and inherit its attributes. Domains can only be used in data elements. A domain can be used by any number of data elements.

-   [Technical attributes of domains](javascript:call_link\('abenddic_domains_tech.htm'\))

-   [Semantic attributes of domains](javascript:call_link\('abenddic_domains_sema.htm'\))

Notes

-   Domains are located in a different namespace from data types. A domain can have the exact same name as a data type and, more particularly, a data element.

-   Redundant domains within an application component or a package should be avoided. Domains that only have technical attributes must be created as reusable domains in central basis packages. One example is the domain CHAR255.

-   The [fixed values](javascript:call_link\('abenfixed_value_glosry.htm'\) "Glossary Entry") of a domain can be used as special literals in [CDS views](javascript:call_link\('abencds_view_glosry.htm'\) "Glossary Entry") as well as the full domain being used in data elements.

-   A domain describes the attributes of an elementary data type but is not a data type itself. More specifically, a domain cannot be specified after a TYPE addition in ABAP.

-   Domains can be edited in form-based editors both in the ABAP Dictionary [tool](javascript:call_link\('abenddic_tools.htm'\)) and in the [ABAP Development Tools (ADT)](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry").

Continue
[Technical Attributes of Domains](javascript:call_link\('abenddic_domains_tech.htm'\))
[Semantic Attributes of Domains](javascript:call_link\('abenddic_domains_sema.htm'\))



**📖 Source**: [abenddic_domains.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_domains.htm)

### abenddic_domains_tech.htm

> **📖 Official SAP Documentation**: [abenddic_domains_tech.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_domains_tech.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Data Elements](javascript:call_link\('abenddic_data_elements.htm'\)) →  [Domains](javascript:call_link\('abenddic_domains.htm'\)) → 

Technical Attributes of Domains

The only technical attribute of a domain is the description of an elementary data type whose following technical attributes are defined directly in the domain:

-   [Built-in data type](javascript:call_link\('abenddic_builtin_types.htm'\)) in ABAP Dictionary

-   Length

-   A number of decimal places (optional)

Note

When existing domains are modified, all consumers of the domain are also affected. In particular, [foreign keys](javascript:call_link\('abenddic_database_tables_forkey.htm'\)) can become inconsistent when used for the fields of database tables, which makes [conversions](javascript:call_link\('abenddic_database_tables_conv.htm'\)) necessary.



**📖 Source**: [abenddic_domains_tech.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_domains_tech.htm)

### abenddic_domains_sema.htm

> **📖 Official SAP Documentation**: [abenddic_domains_sema.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_domains_sema.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Data Elements](javascript:call_link\('abenddic_data_elements.htm'\)) →  [Domains](javascript:call_link\('abenddic_domains.htm'\)) → 

Semantic Attributes of Domains

Domains can be given the following semantic attributes:

-   Short text

Each domain has a short description specified when it is created.

-   Documentation

A domain can be given (optional) documentation.

-   Output attributes

The output attributes determine how fields defined with reference to a data element (that itself references the domain) are displayed on [dynpros or Web Dynpros](javascript:call_link\('abendynpro_glosry.htm'\) "Glossary Entry") or when formatted with the statements [WRITE](javascript:call_link\('abapwrite-.htm'\)) or [WRITE TO](javascript:call_link\('abapwrite_to.htm'\)). .

-   Output length
    The (optional) output length overrides the [implicit output length](javascript:call_link\('abenwrite_output_length.htm'\)) as assigned to the built-in elementary data types. The potential output length is determined by the data type and is checked by ABAP Dictionary [tools](javascript:call_link\('abenddic_tools.htm'\)). If a format is assigned to the built-in data type in question, the output length should be long enough for all formatting characters.

-   Output style
    A domain with the type of a decimal floating point number must be assigned an [output style](javascript:call_link\('abenddic_decimal_floating_point.htm'\)).

-   Conversion routine
    If a domain is assigned to a [conversion routine](javascript:call_link\('abenconversion_routine_glosry.htm'\) "Glossary Entry"), the associated function module ...\_INPUT (for each input in a [dynpro field](javascript:call_link\('abendynpro_field_glosry.htm'\) "Glossary Entry") defined with reference to a data element that itself references the domain) is called. Similarly, the associated function module ...\_OUTPUT (for each output using a dynpro field defined with reference to a data element that itself references the domain) is also called. The function module ...\_OUTPUT is executed in the same way when a data object is formatted using [WRITE](javascript:call_link\('abapwrite-.htm'\)) or [WRITE TO](javascript:call_link\('abapwrite_to.htm'\)) when the data object is declared with reference to a data element of this type.
    

-   Sign
    If a data type of a [dynpro field](javascript:call_link\('abendynpro_field_glosry.htm'\) "Glossary Entry") defined in ABAP Dictionary is numeric, the "Sign" attribute must be set so that negative numbers can be displayed on the screen. This attribute can only be specified using a domain.

-   Lowercase letters
    If a data type of a [dynpro field](javascript:call_link\('abendynpro_field_glosry.htm'\) "Glossary Entry") defined in ABAP Dictionary is character-like, the "Lowercase Letters" attribute can be set so that these letters are not transformed to uppercase. This attribute can only be specified using a domain.

-   Time format
    For the data type [TIMS](javascript:call_link\('abenddic_builtin_types.htm'\)), a 24-hour or 12-hour format can be set for displaying dynpro fields in accordance with the ABAP [time formats](javascript:call_link\('abentime_formats.htm'\)).

-   Value range

Value ranges for fields on user interfaces can be defined for domains of the [built-in types](javascript:call_link\('abenddic_builtin_types.htm'\)) CHAR, NUMC, DEC, INT1, INT2, INT4, and INT8. For domains of the types CHAR and NUMC, this range specifies the valid input values in dynpro fields defined with reference to a data element of the domain in question. The value range is evaluated for all types for the [input help](javascript:call_link\('abeninput_help_glosry.htm'\) "Glossary Entry") of [dynpro fields](javascript:call_link\('abendynpro_field_glosry.htm'\) "Glossary Entry") if no input help with a higher priority exists. The value range is ignored for the content of data objects in ABAP programs or of database table fields that reference a data element with a domain of this type. A value range can be defined using the following:

-   Fixed values

-   Intervals

Fixed values and intervals can be combined here as required. The following can be specified as fixed values and interval boundaries:

-   Alphanumeric characters including blanks and special characters for the type CHAR. The length is restricted to 10.

-   Positive integers (including 0) for the types NUMC, INT1, INT2, INT4, INT8, and DEC within the [value range](javascript:call_link\('abenddic_builtin_types.htm'\)) defined by the technical attributes.

A short text can be specified for each fixed value or interval, which is then displayed when used in an input help. The fixed values of a domain can be specified as special [literals](javascript:call_link\('abencds_f1_literal.htm'\)) in a [CDS view](javascript:call_link\('abencds_view_glosry.htm'\) "Glossary Entry"). The fixed values provided by SAP can be enhanced by customers or partners using [fixed value appends](javascript:call_link\('abenddic_fixed_value_appends.htm'\)).

-   Value table

A value table can be a database table that is used as a default for the [check table](javascript:call_link\('abenddic_database_tables_checktab.htm'\)) in cases where a table field of a database table that references a data element with this domain is included in a [foreign key](javascript:call_link\('abenddic_database_tables_forkey.htm'\)). Just specifying a value table does not trigger a check.

Example

The domain S\_CLASS with the type CHAR describes the possible classes in a flight booking. The value range of the domain is defined by the fixed values "C" (Business Class), "F“ (First Class), and "Y“ (Economy Class). This means that only the values "C", "F", and "Y" can be entered for all dynpro fields that point to this domain.



**📖 Source**: [abenddic_domains_sema.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_domains_sema.htm)

### abenddic_domains.htm

> **📖 Official SAP Documentation**: [abenddic_domains.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_domains.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Data Elements](javascript:call_link\('abenddic_data_elements.htm'\)) → 

Domains

A domain is a standalone dictionary object that defines technical and semantic attributes of elementary data types. [Data elements](javascript:call_link\('abenddic_data_elements.htm'\)) can be defined with reference to a domain and inherit its attributes. Domains can only be used in data elements. A domain can be used by any number of data elements.

-   [Technical attributes of domains](javascript:call_link\('abenddic_domains_tech.htm'\))

-   [Semantic attributes of domains](javascript:call_link\('abenddic_domains_sema.htm'\))

Notes

-   Domains are located in a different namespace from data types. A domain can have the exact same name as a data type and, more particularly, a data element.

-   Redundant domains within an application component or a package should be avoided. Domains that only have technical attributes must be created as reusable domains in central basis packages. One example is the domain CHAR255.

-   The [fixed values](javascript:call_link\('abenfixed_value_glosry.htm'\) "Glossary Entry") of a domain can be used as special literals in [CDS views](javascript:call_link\('abencds_view_glosry.htm'\) "Glossary Entry") as well as the full domain being used in data elements.

-   A domain describes the attributes of an elementary data type but is not a data type itself. More specifically, a domain cannot be specified after a TYPE addition in ABAP.

-   Domains can be edited in form-based editors both in the ABAP Dictionary [tool](javascript:call_link\('abenddic_tools.htm'\)) and in the [ABAP Development Tools (ADT)](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry").

Continue
[Technical Attributes of Domains](javascript:call_link\('abenddic_domains_tech.htm'\))
[Semantic Attributes of Domains](javascript:call_link\('abenddic_domains_sema.htm'\))


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Structures / Technical Attributes of Structures

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Structures / Dictionary DDL for Structure Definitions

Included pages: 11



**📖 Source**: [abenddic_domains.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_domains.htm)

### abenddic_define_structure.htm

> **📖 Official SAP Documentation**: [abenddic_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_define_structure.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) → 

Dictionary DDL for Structure Definitions

In the [ABAP Development Tools (ADT)](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry"), a structure can be displayed and modified using source-code-based methods in the [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry"). Here, the source code of a structure is not saved and transported. Instead, the source code of an existing structure is generated from the metadata of the associated system tables. When saved, the metadata is derived directly from the source code and saved to the system tables.

-   [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\))

Note

All properties of a structure described in the preceding sections can be defined using DEFINE STRUCTURE or in transaction SE11.

Continue
[DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\))



**📖 Source**: [abenddic_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_define_structure.htm)

### abenddicddl_define_structure.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_structure.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) → 

DEFINE STRUCTURE

Syntax

[structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\))
DEFINE STRUCTURE struct {
  ...
  [component;](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))
  ...
  [include;](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))
  ...
}

Effect

[Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry") statement for defining an ABAP Dictionary [structure](javascript:call_link\('abenddic_structures.htm'\)) struct in the [ABAP Development Tools](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry").

-   A structure is defined using the statement DEFINE STRUCTURE. The usual restrictions for ABAP Dictionary [data types](javascript:call_link\('abenddic_data_types.htm'\)) apply to the name struct.

-   The mandatory structure properties must be specified as annotations [structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\)) in front of the statement DEFINE STRUCTURE.

-   The structure components are defined in a semicolon-separated list in curly brackets { } by one of the following methods:

-   Defining individual components [component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))

-   Including include structures [include](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))

Notes

-   As in the [CDS syntax](javascript:call_link\('abencds_general_syntax_rules.htm'\)), an ABAP Dictionary structure definition can contain comments after // and between /\* ... \*/.

-   A more detailed description of the syntax is available in the ADT documentation Syntax of ABAP Dictionary Objects.

Example

Defines the structure DEMOFLI in the ADT.

@EndUserText.label : 'Structure for ALV Demo'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demofli {
  fldate   : s\_date;
  seatsmax : s\_seatsmax;
  seatsocc : s\_seatsocc; }

Continue
[DEFINE STRUCTURE - structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\))
[DEFINE STRUCTURE - component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))
[DEFINE STRUCTURE - include](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))



**📖 Source**: [abenddicddl_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_structure.htm)

### abenddicddl_define_struct_props.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_props.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_props.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) → 

DEFINE STRUCTURE - structure\_annos

Syntax

@EndUserText.label : '...'
@AbapCatalog.enhancementCategory : enh\_cat

Effect

Mandatory annotations for specifying structure properties in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   In quotation marks, @EndUserText.label defines the [short text of the structure](javascript:call_link\('abenddic_structures_sema.htm'\)) in its original language.

-   @AbapCatalog.enhancementCategory defines the [enhancement category of the structure](javascript:call_link\('abenddic_structures_enh_cat.htm'\)). The following can be specified for enh\_cat:

-   #NOT\_CLASSIFIED - [Not classified](javascript:call_link\('abenddic_structures_enh_cat.htm'\))

-   #NOT\_EXTENSIBLE - [Cannot be enhanced (extended)](javascript:call_link\('abenddic_structures_enh_cat.htm'\))

-   #EXTENSIBLE\_CHARACTER - [Can be enhanced (extended) and is character-like](javascript:call_link\('abenddic_structures_enh_cat.htm'\))

-   #EXTENSIBLE\_CHARACTER\_NUMERIC - [Can be enhanced (extended) and is character-like or numeric](javascript:call_link\('abenddic_structures_enh_cat.htm'\))

-   #EXTENSIBLE\_ANY - [Can be enhanced (extended) in any way](javascript:call_link\('abenddic_structures_enh_cat.htm'\))

Notes

-   If specified, #NOT\_CLASSIFIED is used only to display existing structures with this property. Any new or modified structures should always have an enhancement category.

-   The same annotations must also be specified in the definition of a database table using [DEFINE TABLE](javascript:call_link\('abenddicddl_define_table.htm'\)) and an append structure using [EXTEND TYPE](javascript:call_link\('abenddicddl_extend_type.htm'\)).

-   The syntax used to specify the properties is based on [CDS annotations](javascript:call_link\('abencds_annotation_glosry.htm'\) "Glossary Entry"). There are, however, no visible associated [annotation definitions](javascript:call_link\('abencds_anno_definition_glosry.htm'\) "Glossary Entry").



**📖 Source**: [abenddicddl_define_struct_props.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_props.htm)

### abenddicddl_define_struct_comps.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_comps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comps.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) → 

DEFINE STRUCTURE - component

Syntax

*\[*component\_annos*\]*
*\[*[foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\))*\]*
*\[*KEY*\]* comp : *{* *{*data\_element *\[* [value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\))*\]*
                             *\[*[foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\))*\]**}*
               *|*abap. [type](javascript:call_link\('abenddic_builtin_types.htm'\))*\[*(n)*|*(n,m)*\]* *}*
           *|* *{* REFERENCE TO any\_type *}*
           *|* *{* struct *\[*BOXED*\]* *}*
           *|* *{* table\_type *}*
           *\[*NOT NULL*\]*;

Effect

Defines a single [component](javascript:call_link\('abenddic_structures_tech.htm'\)) in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   Optional component properties can be specified using annotations [component\_annos](javascript:call_link\('abenddicddl_define_struct_cmpprps.htm'\)) before the component itself is specified.

-   [foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\)) can be used to specify the properties of a foreign key dependency defined with [foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\)).

-   comp indicates the name of the component.

-   data\_element or abap.type is used to define an elementary component or a component with a reference type:

-   data\_element can be used to specify an existing [data element](javascript:call_link\('abendata_element_glosry.htm'\) "Glossary Entry"). If the data element has an elementary data type, an elementary component is defined. If the data element has a reference type, the component is defined with this reference type.

-   abap.type*\[*(n)*|*(n,m)*\]* can be used to specify a built-in data type from ABAP Dictionary and an elementary component of this type is defined. When specified after the mandatory prefix abap, [type](javascript:call_link\('abenddic_builtin_types.htm'\)) indicates the type. n and m must be used to specify the length and number of decimal places, as specified by the type.

-   REFERENCE TO any\_type is used to define a reference type. For any\_type, the syntax abap.type*\[*(n)*|*(n,m)*\]* can be used to specify any existing data types from ABAP Dictionary, classes or interfaces from the class library, the generic types DATA or OBJECT, or built-in types.

-   struct *\[*BOXED*\]* is used to define a substructure. Structures, database tables, or views from ABAP Dictionary can all be specified for struct. BOXED can be used to define the substructure as a [static box](javascript:call_link\('abenstatic_box_glosry.htm'\) "Glossary Entry").

-   table\_type is used to define a tabular component. [Table types](javascript:call_link\('abentable_type_glosry.htm'\) "Glossary Entry") from ABAP Dictionary can be specified for table\_type.

-   The additions KEY and NOT NULL can be used to define the component as a [key field](javascript:call_link\('abenddic_structures_sema.htm'\)) and to set a [flag for initial values](javascript:call_link\('abenddic_structures_sema.htm'\)). Both these additions are only applicable to structures that are included in database tables.

-   The addition [value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\)) can be used to assign a search help to a structure component whose data type is defined using a data element with elementary data type.

-   The addition [foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\)) can be used to define a [foreign key dependency](javascript:call_link\('abenforeign_key_dependency_glosry.htm'\) "Glossary Entry") for a structure component whose data type is defined using a data element with elementary data type. This addition is only applicable to structures that are included in database tables.

Note

The [activation type](javascript:call_link\('abenddic_structures_tech.htm'\)) (relevant only for database tables) cannot be modified using DEFINE STRUCTURE.

Example

Defines elementary components of the structure DEMO\_DAY with reference to built-in dictionary types. In the example for [include structures](javascript:call_link\('abenddicddl_define_struct_incl.htm'\)), the structure is included more than once in another structure.

@EndUserText.label : 'Demo for include structure'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demo\_day {
  work : abap.char(8);
  free : abap.char(16); }

Continue
[DEFINE STRUCTURE - component\_annos](javascript:call_link\('abenddicddl_define_struct_cmpprps.htm'\))
[DEFINE STRUCTURE - value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\))



**📖 Source**: [abenddicddl_define_struct_comps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comps.htm)

### abenddicddl_define_struct_cmpprps.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_cmpprps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_cmpprps.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) →  [DEFINE STRUCTURE - component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\)) → 

DEFINE STRUCTURE - component\_annos

Syntax

*\[*@EndUserText.label : '...'*\]*
*\[*@Semantics.amount.currencyCode : 'struct.comp'*\]*
*\[*@Semantics.quantity.unitOfMeasure : 'struct.comp'*\]*

Effect

Applies annotations to specify optional properties of a [component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\)) in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   In quotation marks, @EndUserText.label defines the [short text of the component](javascript:call_link\('abenddic_structures_sema.htm'\)) in the original language of the structure.

-   @Semantics.amount.currencyCode - Definition of a [reference field](javascript:call_link\('abenddic_structures_sema.htm'\)) for a [currency field](javascript:call_link\('abenddic_currency_field.htm'\)). A component comp with the built-in dictionary type CUKY from the same or from a different structure struc must be specified in quotation marks.

-   @Semantics.quantity.unitOfMeasure - Definition of a [reference field](javascript:call_link\('abenddic_structures_sema.htm'\)) for a [quantity field](javascript:call_link\('abenddic_quantity_field.htm'\)). A component comp with the built-in dictionary type UNIT from the same or from a different structure struc must be specified in quotation marks.

Note

The syntax used to specify the properties is based on [CDS annotations](javascript:call_link\('abencds_annotation_glosry.htm'\) "Glossary Entry"). There are, however, no visible associated [annotation definitions](javascript:call_link\('abencds_anno_definition_glosry.htm'\) "Glossary Entry").

Example

Defines the component weight\_unit as a reference field for the quantity field weight in the same structure.

...
define structure struct {
  ...
  @Semantics.quantity.unitOfMeasure : 'struct.weight\_unit'
  weight :      abap.quan(2);
  weight\_unit : abap.unit(2);
  ...
  }



**📖 Source**: [abenddicddl_define_struct_cmpprps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_cmpprps.htm)

### abenddicddl_define_struct_valuhelp.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_valuhelp.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_valuhelp.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) →  [DEFINE STRUCTURE - component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\)) → 

DEFINE STRUCTURE - value\_help

Syntax

...  WITH VALUE HELP value\_help
       WHERE parameter1 = structure.component1
         *\[*AND parameter2 = structure.component2 ...*\]* ...

Effect

Assigns a [search help](javascript:call_link\('abensearch_help_glosry.htm'\) "Glossary Entry") to a [structure component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\)) whose data type is defined by a data element with an elementary data type in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry"). Here, value\_help is an existing search help in ABAP Dictionary. All parameters of the search help must be associated with structure components after WHERE.

Note

The addition WITH VALUE HELP can be used, with the same meaning, in the definition of a database using [DEFINE TABLE](javascript:call_link\('abenddicddl_define_table.htm'\)).

Example

Defines elementary components with reference to data elements and binds a search help to the second component.

...
define structure struct {
  comp1 : s\_carr\_id;
  comp2 : s\_conn\_id
    with value help demo\_f4\_field
      where carrid = struct.comp1
        and connid = struct.comp2;
  ...
  }



**📖 Source**: [abenddicddl_define_struct_valuhelp.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_valuhelp.htm)

### abenddicddl_define_struct_comps.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_comps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comps.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) → 

DEFINE STRUCTURE - component

Syntax

*\[*component\_annos*\]*
*\[*[foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\))*\]*
*\[*KEY*\]* comp : *{* *{*data\_element *\[* [value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\))*\]*
                             *\[*[foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\))*\]**}*
               *|*abap. [type](javascript:call_link\('abenddic_builtin_types.htm'\))*\[*(n)*|*(n,m)*\]* *}*
           *|* *{* REFERENCE TO any\_type *}*
           *|* *{* struct *\[*BOXED*\]* *}*
           *|* *{* table\_type *}*
           *\[*NOT NULL*\]*;

Effect

Defines a single [component](javascript:call_link\('abenddic_structures_tech.htm'\)) in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   Optional component properties can be specified using annotations [component\_annos](javascript:call_link\('abenddicddl_define_struct_cmpprps.htm'\)) before the component itself is specified.

-   [foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\)) can be used to specify the properties of a foreign key dependency defined with [foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\)).

-   comp indicates the name of the component.

-   data\_element or abap.type is used to define an elementary component or a component with a reference type:

-   data\_element can be used to specify an existing [data element](javascript:call_link\('abendata_element_glosry.htm'\) "Glossary Entry"). If the data element has an elementary data type, an elementary component is defined. If the data element has a reference type, the component is defined with this reference type.

-   abap.type*\[*(n)*|*(n,m)*\]* can be used to specify a built-in data type from ABAP Dictionary and an elementary component of this type is defined. When specified after the mandatory prefix abap, [type](javascript:call_link\('abenddic_builtin_types.htm'\)) indicates the type. n and m must be used to specify the length and number of decimal places, as specified by the type.

-   REFERENCE TO any\_type is used to define a reference type. For any\_type, the syntax abap.type*\[*(n)*|*(n,m)*\]* can be used to specify any existing data types from ABAP Dictionary, classes or interfaces from the class library, the generic types DATA or OBJECT, or built-in types.

-   struct *\[*BOXED*\]* is used to define a substructure. Structures, database tables, or views from ABAP Dictionary can all be specified for struct. BOXED can be used to define the substructure as a [static box](javascript:call_link\('abenstatic_box_glosry.htm'\) "Glossary Entry").

-   table\_type is used to define a tabular component. [Table types](javascript:call_link\('abentable_type_glosry.htm'\) "Glossary Entry") from ABAP Dictionary can be specified for table\_type.

-   The additions KEY and NOT NULL can be used to define the component as a [key field](javascript:call_link\('abenddic_structures_sema.htm'\)) and to set a [flag for initial values](javascript:call_link\('abenddic_structures_sema.htm'\)). Both these additions are only applicable to structures that are included in database tables.

-   The addition [value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\)) can be used to assign a search help to a structure component whose data type is defined using a data element with elementary data type.

-   The addition [foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\)) can be used to define a [foreign key dependency](javascript:call_link\('abenforeign_key_dependency_glosry.htm'\) "Glossary Entry") for a structure component whose data type is defined using a data element with elementary data type. This addition is only applicable to structures that are included in database tables.

Note

The [activation type](javascript:call_link\('abenddic_structures_tech.htm'\)) (relevant only for database tables) cannot be modified using DEFINE STRUCTURE.

Example

Defines elementary components of the structure DEMO\_DAY with reference to built-in dictionary types. In the example for [include structures](javascript:call_link\('abenddicddl_define_struct_incl.htm'\)), the structure is included more than once in another structure.

@EndUserText.label : 'Demo for include structure'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demo\_day {
  work : abap.char(8);
  free : abap.char(16); }

Continue
[DEFINE STRUCTURE - component\_annos](javascript:call_link\('abenddicddl_define_struct_cmpprps.htm'\))
[DEFINE STRUCTURE - value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\))



**📖 Source**: [abenddicddl_define_struct_comps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comps.htm)

### abenddicddl_define_struct_incl.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_incl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_incl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) → 

DEFINE STRUCTURE - include

Syntax

*\[*group :*\]* INCLUDE struct *\[*WITH SUFFIX suffix*\]*
                  *\[*...
                   [extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\))
                   ...*\]*;

Effect

Includes an [include structure](javascript:call_link\('abenddic_include_structure.htm'\)) in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   Any existing structure from ABAP Dictionary, including database tables or views, can be specified as struct.

-   group can be used to specify an optional name of a [group](javascript:call_link\('abenddic_include_structure.htm'\)).

-   suffix can be used to specify an optional three-character [suffix](javascript:call_link\('abenddic_include_structure.htm'\)).

-   A blank-separated list of additions, [extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\)), can be used to overwrite the assignment to a search help and the definition of a foreign key dependency for each included component.

Note

The addition INCLUDE can be used with the same semantics in the statement [DEFINE TABLE](javascript:call_link\('abenddicddl_define_table.htm'\)) in cases where the include structure is suitable for database tables.

Example

Syntax for defining the structure DEMO\_WEEK in the ADT.

...
define structure demo\_week {
  monday    : include demo\_day with suffix \_mo;
  tuesday   : include demo\_day with suffix \_tu;
  wednesday : include demo\_day with suffix \_we;
  thursday  : include demo\_day with suffix \_th;
  friday    : include demo\_day with suffix \_fr;
}

Continue
[DEFINE STRUCTURE - extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\))



**📖 Source**: [abenddicddl_define_struct_incl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_incl.htm)

### abenddicddl_define_struct_comp_ext.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_comp_ext.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comp_ext.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) →  [DEFINE STRUCTURE - include](javascript:call_link\('abenddicddl_define_struct_incl.htm'\)) → 

DEFINE STRUCTURE - extend

Syntax

... *\[*[foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\))*\]*
    EXTEND component : *\[*[value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\))*\]* *\[*foreign\_key*\]* ...

Effect

Defines component properties when [including](javascript:call_link\('abenddicddl_define_struct_incl.htm'\)) include structures using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry"). The addition EXTEND can be specified for the every component component in the included [include structure](javascript:call_link\('abenddic_include_structure.htm'\)) and defines the following properties for this structure. If any of the properties of the included component already exist, they are overwritten.

-   [foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\)) - Properties of a foreign key relationship

-   [value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\)) - Assignment to a search help.

-   foreign\_key - Definition of a foreign key dependency.

At least one of the additions value\_help and foreign\_key must be specified.

Note

The addition EXTEND can be used for individual components and with the same meaning in the definition of a database table with [DEFINE TABLE](javascript:call_link\('abenddicddl_define_table.htm'\)) or an append structure with [EXTEND TYPE](javascript:call_link\('abenddicddl_extend_type.htm'\)).

Example

Includes a structure include\_struct in a structure struct, where EXTEND is used to assign a search help to the components comp1 and comp2.

...
define structure struct {
  ...
  include include\_struct
    extend comp1 :
      with value help demo\_f4\_field
        where carrid = struct.comp1
          and connid = struct.comp2
    extend comp2 :
      with value help demo\_f4\_field
        where carrid = struct.comp1
          and connid = struct.comp2;
  ...
  }



**📖 Source**: [abenddicddl_define_struct_comp_ext.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comp_ext.htm)

### abenddicddl_define_struct_incl.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_incl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_incl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) → 

DEFINE STRUCTURE - include

Syntax

*\[*group :*\]* INCLUDE struct *\[*WITH SUFFIX suffix*\]*
                  *\[*...
                   [extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\))
                   ...*\]*;

Effect

Includes an [include structure](javascript:call_link\('abenddic_include_structure.htm'\)) in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   Any existing structure from ABAP Dictionary, including database tables or views, can be specified as struct.

-   group can be used to specify an optional name of a [group](javascript:call_link\('abenddic_include_structure.htm'\)).

-   suffix can be used to specify an optional three-character [suffix](javascript:call_link\('abenddic_include_structure.htm'\)).

-   A blank-separated list of additions, [extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\)), can be used to overwrite the assignment to a search help and the definition of a foreign key dependency for each included component.

Note

The addition INCLUDE can be used with the same semantics in the statement [DEFINE TABLE](javascript:call_link\('abenddicddl_define_table.htm'\)) in cases where the include structure is suitable for database tables.

Example

Syntax for defining the structure DEMO\_WEEK in the ADT.

...
define structure demo\_week {
  monday    : include demo\_day with suffix \_mo;
  tuesday   : include demo\_day with suffix \_tu;
  wednesday : include demo\_day with suffix \_we;
  thursday  : include demo\_day with suffix \_th;
  friday    : include demo\_day with suffix \_fr;
}

Continue
[DEFINE STRUCTURE - extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\))



**📖 Source**: [abenddicddl_define_struct_incl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_incl.htm)

### abenddicddl_define_structure.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_structure.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) → 

DEFINE STRUCTURE

Syntax

[structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\))
DEFINE STRUCTURE struct {
  ...
  [component;](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))
  ...
  [include;](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))
  ...
}

Effect

[Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry") statement for defining an ABAP Dictionary [structure](javascript:call_link\('abenddic_structures.htm'\)) struct in the [ABAP Development Tools](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry").

-   A structure is defined using the statement DEFINE STRUCTURE. The usual restrictions for ABAP Dictionary [data types](javascript:call_link\('abenddic_data_types.htm'\)) apply to the name struct.

-   The mandatory structure properties must be specified as annotations [structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\)) in front of the statement DEFINE STRUCTURE.

-   The structure components are defined in a semicolon-separated list in curly brackets { } by one of the following methods:

-   Defining individual components [component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))

-   Including include structures [include](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))

Notes

-   As in the [CDS syntax](javascript:call_link\('abencds_general_syntax_rules.htm'\)), an ABAP Dictionary structure definition can contain comments after // and between /\* ... \*/.

-   A more detailed description of the syntax is available in the ADT documentation Syntax of ABAP Dictionary Objects.

Example

Defines the structure DEMOFLI in the ADT.

@EndUserText.label : 'Structure for ALV Demo'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demofli {
  fldate   : s\_date;
  seatsmax : s\_seatsmax;
  seatsocc : s\_seatsocc; }

Continue
[DEFINE STRUCTURE - structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\))
[DEFINE STRUCTURE - component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))
[DEFINE STRUCTURE - include](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Structures / Dictionary DDL for Structure Definitions

**Files**: 11 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Structures / Dictionary DDL for Structure Definitions

Included pages: 11



**📖 Source**: [abenddicddl_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_structure.htm)

### abenddic_define_structure.htm

> **📖 Official SAP Documentation**: [abenddic_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_define_structure.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) → 

Dictionary DDL for Structure Definitions

In the [ABAP Development Tools (ADT)](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry"), a structure can be displayed and modified using source-code-based methods in the [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry"). Here, the source code of a structure is not saved and transported. Instead, the source code of an existing structure is generated from the metadata of the associated system tables. When saved, the metadata is derived directly from the source code and saved to the system tables.

-   [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\))

Note

All properties of a structure described in the preceding sections can be defined using DEFINE STRUCTURE or in transaction SE11.

Continue
[DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\))



**📖 Source**: [abenddic_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_define_structure.htm)

### abenddicddl_define_structure.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_structure.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) → 

DEFINE STRUCTURE

Syntax

[structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\))
DEFINE STRUCTURE struct {
  ...
  [component;](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))
  ...
  [include;](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))
  ...
}

Effect

[Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry") statement for defining an ABAP Dictionary [structure](javascript:call_link\('abenddic_structures.htm'\)) struct in the [ABAP Development Tools](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry").

-   A structure is defined using the statement DEFINE STRUCTURE. The usual restrictions for ABAP Dictionary [data types](javascript:call_link\('abenddic_data_types.htm'\)) apply to the name struct.

-   The mandatory structure properties must be specified as annotations [structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\)) in front of the statement DEFINE STRUCTURE.

-   The structure components are defined in a semicolon-separated list in curly brackets { } by one of the following methods:

-   Defining individual components [component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))

-   Including include structures [include](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))

Notes

-   As in the [CDS syntax](javascript:call_link\('abencds_general_syntax_rules.htm'\)), an ABAP Dictionary structure definition can contain comments after // and between /\* ... \*/.

-   A more detailed description of the syntax is available in the ADT documentation Syntax of ABAP Dictionary Objects.

Example

Defines the structure DEMOFLI in the ADT.

@EndUserText.label : 'Structure for ALV Demo'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demofli {
  fldate   : s\_date;
  seatsmax : s\_seatsmax;
  seatsocc : s\_seatsocc; }

Continue
[DEFINE STRUCTURE - structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\))
[DEFINE STRUCTURE - component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))
[DEFINE STRUCTURE - include](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))



**📖 Source**: [abenddicddl_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_structure.htm)

### abenddicddl_define_struct_props.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_props.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_props.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) → 

DEFINE STRUCTURE - structure\_annos

Syntax

@EndUserText.label : '...'
@AbapCatalog.enhancementCategory : enh\_cat

Effect

Mandatory annotations for specifying structure properties in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   In quotation marks, @EndUserText.label defines the [short text of the structure](javascript:call_link\('abenddic_structures_sema.htm'\)) in its original language.

-   @AbapCatalog.enhancementCategory defines the [enhancement category of the structure](javascript:call_link\('abenddic_structures_enh_cat.htm'\)). The following can be specified for enh\_cat:

-   #NOT\_CLASSIFIED - [Not classified](javascript:call_link\('abenddic_structures_enh_cat.htm'\))

-   #NOT\_EXTENSIBLE - [Cannot be enhanced (extended)](javascript:call_link\('abenddic_structures_enh_cat.htm'\))

-   #EXTENSIBLE\_CHARACTER - [Can be enhanced (extended) and is character-like](javascript:call_link\('abenddic_structures_enh_cat.htm'\))

-   #EXTENSIBLE\_CHARACTER\_NUMERIC - [Can be enhanced (extended) and is character-like or numeric](javascript:call_link\('abenddic_structures_enh_cat.htm'\))

-   #EXTENSIBLE\_ANY - [Can be enhanced (extended) in any way](javascript:call_link\('abenddic_structures_enh_cat.htm'\))

Notes

-   If specified, #NOT\_CLASSIFIED is used only to display existing structures with this property. Any new or modified structures should always have an enhancement category.

-   The same annotations must also be specified in the definition of a database table using [DEFINE TABLE](javascript:call_link\('abenddicddl_define_table.htm'\)) and an append structure using [EXTEND TYPE](javascript:call_link\('abenddicddl_extend_type.htm'\)).

-   The syntax used to specify the properties is based on [CDS annotations](javascript:call_link\('abencds_annotation_glosry.htm'\) "Glossary Entry"). There are, however, no visible associated [annotation definitions](javascript:call_link\('abencds_anno_definition_glosry.htm'\) "Glossary Entry").



**📖 Source**: [abenddicddl_define_struct_props.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_props.htm)

### abenddicddl_define_struct_comps.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_comps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comps.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) → 

DEFINE STRUCTURE - component

Syntax

*\[*component\_annos*\]*
*\[*[foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\))*\]*
*\[*KEY*\]* comp : *{* *{*data\_element *\[* [value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\))*\]*
                             *\[*[foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\))*\]**}*
               *|*abap. [type](javascript:call_link\('abenddic_builtin_types.htm'\))*\[*(n)*|*(n,m)*\]* *}*
           *|* *{* REFERENCE TO any\_type *}*
           *|* *{* struct *\[*BOXED*\]* *}*
           *|* *{* table\_type *}*
           *\[*NOT NULL*\]*;

Effect

Defines a single [component](javascript:call_link\('abenddic_structures_tech.htm'\)) in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   Optional component properties can be specified using annotations [component\_annos](javascript:call_link\('abenddicddl_define_struct_cmpprps.htm'\)) before the component itself is specified.

-   [foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\)) can be used to specify the properties of a foreign key dependency defined with [foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\)).

-   comp indicates the name of the component.

-   data\_element or abap.type is used to define an elementary component or a component with a reference type:

-   data\_element can be used to specify an existing [data element](javascript:call_link\('abendata_element_glosry.htm'\) "Glossary Entry"). If the data element has an elementary data type, an elementary component is defined. If the data element has a reference type, the component is defined with this reference type.

-   abap.type*\[*(n)*|*(n,m)*\]* can be used to specify a built-in data type from ABAP Dictionary and an elementary component of this type is defined. When specified after the mandatory prefix abap, [type](javascript:call_link\('abenddic_builtin_types.htm'\)) indicates the type. n and m must be used to specify the length and number of decimal places, as specified by the type.

-   REFERENCE TO any\_type is used to define a reference type. For any\_type, the syntax abap.type*\[*(n)*|*(n,m)*\]* can be used to specify any existing data types from ABAP Dictionary, classes or interfaces from the class library, the generic types DATA or OBJECT, or built-in types.

-   struct *\[*BOXED*\]* is used to define a substructure. Structures, database tables, or views from ABAP Dictionary can all be specified for struct. BOXED can be used to define the substructure as a [static box](javascript:call_link\('abenstatic_box_glosry.htm'\) "Glossary Entry").

-   table\_type is used to define a tabular component. [Table types](javascript:call_link\('abentable_type_glosry.htm'\) "Glossary Entry") from ABAP Dictionary can be specified for table\_type.

-   The additions KEY and NOT NULL can be used to define the component as a [key field](javascript:call_link\('abenddic_structures_sema.htm'\)) and to set a [flag for initial values](javascript:call_link\('abenddic_structures_sema.htm'\)). Both these additions are only applicable to structures that are included in database tables.

-   The addition [value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\)) can be used to assign a search help to a structure component whose data type is defined using a data element with elementary data type.

-   The addition [foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\)) can be used to define a [foreign key dependency](javascript:call_link\('abenforeign_key_dependency_glosry.htm'\) "Glossary Entry") for a structure component whose data type is defined using a data element with elementary data type. This addition is only applicable to structures that are included in database tables.

Note

The [activation type](javascript:call_link\('abenddic_structures_tech.htm'\)) (relevant only for database tables) cannot be modified using DEFINE STRUCTURE.

Example

Defines elementary components of the structure DEMO\_DAY with reference to built-in dictionary types. In the example for [include structures](javascript:call_link\('abenddicddl_define_struct_incl.htm'\)), the structure is included more than once in another structure.

@EndUserText.label : 'Demo for include structure'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demo\_day {
  work : abap.char(8);
  free : abap.char(16); }

Continue
[DEFINE STRUCTURE - component\_annos](javascript:call_link\('abenddicddl_define_struct_cmpprps.htm'\))
[DEFINE STRUCTURE - value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\))



**📖 Source**: [abenddicddl_define_struct_comps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comps.htm)

### abenddicddl_define_struct_cmpprps.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_cmpprps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_cmpprps.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) →  [DEFINE STRUCTURE - component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\)) → 

DEFINE STRUCTURE - component\_annos

Syntax

*\[*@EndUserText.label : '...'*\]*
*\[*@Semantics.amount.currencyCode : 'struct.comp'*\]*
*\[*@Semantics.quantity.unitOfMeasure : 'struct.comp'*\]*

Effect

Applies annotations to specify optional properties of a [component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\)) in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   In quotation marks, @EndUserText.label defines the [short text of the component](javascript:call_link\('abenddic_structures_sema.htm'\)) in the original language of the structure.

-   @Semantics.amount.currencyCode - Definition of a [reference field](javascript:call_link\('abenddic_structures_sema.htm'\)) for a [currency field](javascript:call_link\('abenddic_currency_field.htm'\)). A component comp with the built-in dictionary type CUKY from the same or from a different structure struc must be specified in quotation marks.

-   @Semantics.quantity.unitOfMeasure - Definition of a [reference field](javascript:call_link\('abenddic_structures_sema.htm'\)) for a [quantity field](javascript:call_link\('abenddic_quantity_field.htm'\)). A component comp with the built-in dictionary type UNIT from the same or from a different structure struc must be specified in quotation marks.

Note

The syntax used to specify the properties is based on [CDS annotations](javascript:call_link\('abencds_annotation_glosry.htm'\) "Glossary Entry"). There are, however, no visible associated [annotation definitions](javascript:call_link\('abencds_anno_definition_glosry.htm'\) "Glossary Entry").

Example

Defines the component weight\_unit as a reference field for the quantity field weight in the same structure.

...
define structure struct {
  ...
  @Semantics.quantity.unitOfMeasure : 'struct.weight\_unit'
  weight :      abap.quan(2);
  weight\_unit : abap.unit(2);
  ...
  }



**📖 Source**: [abenddicddl_define_struct_cmpprps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_cmpprps.htm)

### abenddicddl_define_struct_valuhelp.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_valuhelp.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_valuhelp.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) →  [DEFINE STRUCTURE - component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\)) → 

DEFINE STRUCTURE - value\_help

Syntax

...  WITH VALUE HELP value\_help
       WHERE parameter1 = structure.component1
         *\[*AND parameter2 = structure.component2 ...*\]* ...

Effect

Assigns a [search help](javascript:call_link\('abensearch_help_glosry.htm'\) "Glossary Entry") to a [structure component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\)) whose data type is defined by a data element with an elementary data type in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry"). Here, value\_help is an existing search help in ABAP Dictionary. All parameters of the search help must be associated with structure components after WHERE.

Note

The addition WITH VALUE HELP can be used, with the same meaning, in the definition of a database using [DEFINE TABLE](javascript:call_link\('abenddicddl_define_table.htm'\)).

Example

Defines elementary components with reference to data elements and binds a search help to the second component.

...
define structure struct {
  comp1 : s\_carr\_id;
  comp2 : s\_conn\_id
    with value help demo\_f4\_field
      where carrid = struct.comp1
        and connid = struct.comp2;
  ...
  }



**📖 Source**: [abenddicddl_define_struct_valuhelp.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_valuhelp.htm)

### abenddicddl_define_struct_comps.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_comps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comps.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) → 

DEFINE STRUCTURE - component

Syntax

*\[*component\_annos*\]*
*\[*[foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\))*\]*
*\[*KEY*\]* comp : *{* *{*data\_element *\[* [value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\))*\]*
                             *\[*[foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\))*\]**}*
               *|*abap. [type](javascript:call_link\('abenddic_builtin_types.htm'\))*\[*(n)*|*(n,m)*\]* *}*
           *|* *{* REFERENCE TO any\_type *}*
           *|* *{* struct *\[*BOXED*\]* *}*
           *|* *{* table\_type *}*
           *\[*NOT NULL*\]*;

Effect

Defines a single [component](javascript:call_link\('abenddic_structures_tech.htm'\)) in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   Optional component properties can be specified using annotations [component\_annos](javascript:call_link\('abenddicddl_define_struct_cmpprps.htm'\)) before the component itself is specified.

-   [foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\)) can be used to specify the properties of a foreign key dependency defined with [foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\)).

-   comp indicates the name of the component.

-   data\_element or abap.type is used to define an elementary component or a component with a reference type:

-   data\_element can be used to specify an existing [data element](javascript:call_link\('abendata_element_glosry.htm'\) "Glossary Entry"). If the data element has an elementary data type, an elementary component is defined. If the data element has a reference type, the component is defined with this reference type.

-   abap.type*\[*(n)*|*(n,m)*\]* can be used to specify a built-in data type from ABAP Dictionary and an elementary component of this type is defined. When specified after the mandatory prefix abap, [type](javascript:call_link\('abenddic_builtin_types.htm'\)) indicates the type. n and m must be used to specify the length and number of decimal places, as specified by the type.

-   REFERENCE TO any\_type is used to define a reference type. For any\_type, the syntax abap.type*\[*(n)*|*(n,m)*\]* can be used to specify any existing data types from ABAP Dictionary, classes or interfaces from the class library, the generic types DATA or OBJECT, or built-in types.

-   struct *\[*BOXED*\]* is used to define a substructure. Structures, database tables, or views from ABAP Dictionary can all be specified for struct. BOXED can be used to define the substructure as a [static box](javascript:call_link\('abenstatic_box_glosry.htm'\) "Glossary Entry").

-   table\_type is used to define a tabular component. [Table types](javascript:call_link\('abentable_type_glosry.htm'\) "Glossary Entry") from ABAP Dictionary can be specified for table\_type.

-   The additions KEY and NOT NULL can be used to define the component as a [key field](javascript:call_link\('abenddic_structures_sema.htm'\)) and to set a [flag for initial values](javascript:call_link\('abenddic_structures_sema.htm'\)). Both these additions are only applicable to structures that are included in database tables.

-   The addition [value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\)) can be used to assign a search help to a structure component whose data type is defined using a data element with elementary data type.

-   The addition [foreign\_key](javascript:call_link\('abenddicddl_define_table_forkey.htm'\)) can be used to define a [foreign key dependency](javascript:call_link\('abenforeign_key_dependency_glosry.htm'\) "Glossary Entry") for a structure component whose data type is defined using a data element with elementary data type. This addition is only applicable to structures that are included in database tables.

Note

The [activation type](javascript:call_link\('abenddic_structures_tech.htm'\)) (relevant only for database tables) cannot be modified using DEFINE STRUCTURE.

Example

Defines elementary components of the structure DEMO\_DAY with reference to built-in dictionary types. In the example for [include structures](javascript:call_link\('abenddicddl_define_struct_incl.htm'\)), the structure is included more than once in another structure.

@EndUserText.label : 'Demo for include structure'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demo\_day {
  work : abap.char(8);
  free : abap.char(16); }

Continue
[DEFINE STRUCTURE - component\_annos](javascript:call_link\('abenddicddl_define_struct_cmpprps.htm'\))
[DEFINE STRUCTURE - value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\))



**📖 Source**: [abenddicddl_define_struct_comps.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comps.htm)

### abenddicddl_define_struct_incl.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_incl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_incl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) → 

DEFINE STRUCTURE - include

Syntax

*\[*group :*\]* INCLUDE struct *\[*WITH SUFFIX suffix*\]*
                  *\[*...
                   [extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\))
                   ...*\]*;

Effect

Includes an [include structure](javascript:call_link\('abenddic_include_structure.htm'\)) in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   Any existing structure from ABAP Dictionary, including database tables or views, can be specified as struct.

-   group can be used to specify an optional name of a [group](javascript:call_link\('abenddic_include_structure.htm'\)).

-   suffix can be used to specify an optional three-character [suffix](javascript:call_link\('abenddic_include_structure.htm'\)).

-   A blank-separated list of additions, [extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\)), can be used to overwrite the assignment to a search help and the definition of a foreign key dependency for each included component.

Note

The addition INCLUDE can be used with the same semantics in the statement [DEFINE TABLE](javascript:call_link\('abenddicddl_define_table.htm'\)) in cases where the include structure is suitable for database tables.

Example

Syntax for defining the structure DEMO\_WEEK in the ADT.

...
define structure demo\_week {
  monday    : include demo\_day with suffix \_mo;
  tuesday   : include demo\_day with suffix \_tu;
  wednesday : include demo\_day with suffix \_we;
  thursday  : include demo\_day with suffix \_th;
  friday    : include demo\_day with suffix \_fr;
}

Continue
[DEFINE STRUCTURE - extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\))



**📖 Source**: [abenddicddl_define_struct_incl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_incl.htm)

### abenddicddl_define_struct_comp_ext.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_comp_ext.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comp_ext.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) →  [DEFINE STRUCTURE - include](javascript:call_link\('abenddicddl_define_struct_incl.htm'\)) → 

DEFINE STRUCTURE - extend

Syntax

... *\[*[foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\))*\]*
    EXTEND component : *\[*[value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\))*\]* *\[*foreign\_key*\]* ...

Effect

Defines component properties when [including](javascript:call_link\('abenddicddl_define_struct_incl.htm'\)) include structures using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry"). The addition EXTEND can be specified for the every component component in the included [include structure](javascript:call_link\('abenddic_include_structure.htm'\)) and defines the following properties for this structure. If any of the properties of the included component already exist, they are overwritten.

-   [foreign\_key\_annos](javascript:call_link\('abenddicddl_define_table_fkprps.htm'\)) - Properties of a foreign key relationship

-   [value\_help](javascript:call_link\('abenddicddl_define_struct_valuhelp.htm'\)) - Assignment to a search help.

-   foreign\_key - Definition of a foreign key dependency.

At least one of the additions value\_help and foreign\_key must be specified.

Note

The addition EXTEND can be used for individual components and with the same meaning in the definition of a database table with [DEFINE TABLE](javascript:call_link\('abenddicddl_define_table.htm'\)) or an append structure with [EXTEND TYPE](javascript:call_link\('abenddicddl_extend_type.htm'\)).

Example

Includes a structure include\_struct in a structure struct, where EXTEND is used to assign a search help to the components comp1 and comp2.

...
define structure struct {
  ...
  include include\_struct
    extend comp1 :
      with value help demo\_f4\_field
        where carrid = struct.comp1
          and connid = struct.comp2
    extend comp2 :
      with value help demo\_f4\_field
        where carrid = struct.comp1
          and connid = struct.comp2;
  ...
  }



**📖 Source**: [abenddicddl_define_struct_comp_ext.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_comp_ext.htm)

### abenddicddl_define_struct_incl.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_struct_incl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_incl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) →  [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) → 

DEFINE STRUCTURE - include

Syntax

*\[*group :*\]* INCLUDE struct *\[*WITH SUFFIX suffix*\]*
                  *\[*...
                   [extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\))
                   ...*\]*;

Effect

Includes an [include structure](javascript:call_link\('abenddic_include_structure.htm'\)) in the definition of a structure using the statement [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)) in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry").

-   Any existing structure from ABAP Dictionary, including database tables or views, can be specified as struct.

-   group can be used to specify an optional name of a [group](javascript:call_link\('abenddic_include_structure.htm'\)).

-   suffix can be used to specify an optional three-character [suffix](javascript:call_link\('abenddic_include_structure.htm'\)).

-   A blank-separated list of additions, [extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\)), can be used to overwrite the assignment to a search help and the definition of a foreign key dependency for each included component.

Note

The addition INCLUDE can be used with the same semantics in the statement [DEFINE TABLE](javascript:call_link\('abenddicddl_define_table.htm'\)) in cases where the include structure is suitable for database tables.

Example

Syntax for defining the structure DEMO\_WEEK in the ADT.

...
define structure demo\_week {
  monday    : include demo\_day with suffix \_mo;
  tuesday   : include demo\_day with suffix \_tu;
  wednesday : include demo\_day with suffix \_we;
  thursday  : include demo\_day with suffix \_th;
  friday    : include demo\_day with suffix \_fr;
}

Continue
[DEFINE STRUCTURE - extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\))



**📖 Source**: [abenddicddl_define_struct_incl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_struct_incl.htm)

### abenddicddl_define_structure.htm

> **📖 Official SAP Documentation**: [abenddicddl_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_structure.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Structures](javascript:call_link\('abenddic_structures.htm'\)) →  [Dictionary DDL for Structure Definitions](javascript:call_link\('abenddic_define_structure.htm'\)) → 

DEFINE STRUCTURE

Syntax

[structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\))
DEFINE STRUCTURE struct {
  ...
  [component;](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))
  ...
  [include;](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))
  ...
}

Effect

[Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry") statement for defining an ABAP Dictionary [structure](javascript:call_link\('abenddic_structures.htm'\)) struct in the [ABAP Development Tools](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry").

-   A structure is defined using the statement DEFINE STRUCTURE. The usual restrictions for ABAP Dictionary [data types](javascript:call_link\('abenddic_data_types.htm'\)) apply to the name struct.

-   The mandatory structure properties must be specified as annotations [structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\)) in front of the statement DEFINE STRUCTURE.

-   The structure components are defined in a semicolon-separated list in curly brackets { } by one of the following methods:

-   Defining individual components [component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))

-   Including include structures [include](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))

Notes

-   As in the [CDS syntax](javascript:call_link\('abencds_general_syntax_rules.htm'\)), an ABAP Dictionary structure definition can contain comments after // and between /\* ... \*/.

-   A more detailed description of the syntax is available in the ADT documentation Syntax of ABAP Dictionary Objects.

Example

Defines the structure DEMOFLI in the ADT.

@EndUserText.label : 'Structure for ALV Demo'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demofli {
  fldate   : s\_date;
  seatsmax : s\_seatsmax;
  seatsocc : s\_seatsocc; }

Continue
[DEFINE STRUCTURE - structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\))
[DEFINE STRUCTURE - component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))
[DEFINE STRUCTURE - include](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Table Types

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Table Types

Included pages: 4



**📖 Source**: [abenddicddl_define_structure.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_define_structure.htm)

### abenddic_table_types.htm

> **📖 Official SAP Documentation**: [abenddic_table_types.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_table_types.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) → 

Table Types

A table type in ABAP Dictionary defines the data type of an [internal table](javascript:call_link\('abeninternal_table_glosry.htm'\) "Glossary Entry") in ABAP. The table type defines the following in an internal table:

-   [Row type](javascript:call_link\('abenrow_type_glosry.htm'\) "Glossary Entry")

-   The [table category](javascript:call_link\('abentable_category_glosry.htm'\) "Glossary Entry")

-   The [table key](javascript:call_link\('abentable_key_glosry.htm'\) "Glossary Entry")

An internal program object declared with reference to a table type is an internal table of this type.

-   [Technical attributes of table types](javascript:call_link\('abenddic_table_types_tech.htm'\))

-   [Semantic attributes of table types](javascript:call_link\('abenddic_table_types_sema.htm'\))

Note

Unlike in [data elements](javascript:call_link\('abenddic_data_elements.htm'\)) and [structures](javascript:call_link\('abenddic_structures.htm'\)), the table types in ABAP Dictionary exist only to create globally visible definitions of internal tables. Table types replace the definition of internal tables in [type groups](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") and can themselves be replaced using the declaration of internal table types in global classes and interfaces (if the context where the type is required is suitable). The attributes of an internal table that can be defined in ABAP Dictionary match in full those that can be specified using the statement [TYPES ... TABLE OF](javascript:call_link\('abaptypes_itab.htm'\)) in ABAP programs. More information can be found in the in-depth documentation about internal tables in [ABAP - Reference](javascript:call_link\('abenitab.htm'\)).

Example

The table type SPFLI\_KEY\_TAB describes a hashed table with the structured row type SPFLI with a unique primary key and two non-unique secondary table keys.

Continue
[Technical Attributes of Table Types](javascript:call_link\('abenddic_table_types_tech.htm'\))
[Semantic Attributes of Table Types](javascript:call_link\('abenddic_table_types_sema.htm'\))
[Ranges Table Type](javascript:call_link\('abenddic_table_types_ranges.htm'\))



**📖 Source**: [abenddic_table_types.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_table_types.htm)

### abenddic_table_types_tech.htm

> **📖 Official SAP Documentation**: [abenddic_table_types_tech.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_table_types_tech.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Table Types](javascript:call_link\('abenddic_table_types.htm'\)) → 

Technical Attributes of Table Types

A table type describes an [internal table](javascript:call_link\('abeninternal_table_glosry.htm'\) "Glossary Entry") with the following technical attributes:

-   Row type

The row type can be defined as follows:

-   Any row type can be defined by referencing any [data type](javascript:call_link\('abenddic_data_types.htm'\)), including [database tables](javascript:call_link\('abenddic_database_tables.htm'\)) and [classic views](javascript:call_link\('abenddic_classical_views.htm'\)) in ABAP Dictionary.

-   Elementary or reference-like row types can also be specified by using their technical attributes directly. This is done in the same way as with [data elements](javascript:call_link\('abenddic_data_elements.htm'\)) or [structure components](javascript:call_link\('abenddic_structures_tech.htm'\)).

-   Table category

The table category can be specified as follows:

-   [Standard table](javascript:call_link\('abenstandard_table_glosry.htm'\) "Glossary Entry")

-   [Sorted table](javascript:call_link\('abensorted_table_glosry.htm'\) "Glossary Entry")

-   [Hashed table](javascript:call_link\('abenhashed_table_glosry.htm'\) "Glossary Entry")

-   [Index table](javascript:call_link\('abenindex_table_glosry.htm'\) "Glossary Entry") as a generic table category for standard tables and sorted tables

-   Any table as a generic table category for all table categories

These methods are the same as defining the table category using the statement [TYPES](javascript:call_link\('abaptypes_tabkind.htm'\)).

-   Table key

The following can be defined as table keys:

-   A primary key as a [primary table key](javascript:call_link\('abenprimary_table_key_glosry.htm'\) "Glossary Entry"). The primary key is either the [standard key](javascript:call_link\('abenstandard_key_glosry.htm'\) "Glossary Entry"), the entire table row (if this is not a table type or does not contain a table type as component), or is defined using individual components of a structured row type in the relevant order. A primary key of sorted tables and hashed tables can be given a unique [alias name](javascript:call_link\('abenalias_glosry.htm'\) "Glossary Entry") from the namespace of the secondary keys. It is not currently possible to specify an [empty primary table key](javascript:call_link\('abenitab_empty_key.htm'\)) explicitly in ABAP Dictionary. Depending on the table category, the primary key is either unique or non-unique (and cannot be specified at all in the case of generic table categories). If no primary key is specified or its uniqueness is not defined, the table type is generic with respect to this attribute.

-   Up to 15 secondary keys as [secondary table keys](javascript:call_link\('abensecondary_table_key_glosry.htm'\) "Glossary Entry"). Each secondary key has a unique name, which cannot be PRIMARY\_KEY or LOOP\_KEY, and is either a sorted key or a hash key. Sorted keys can be either unique or non-unique and a hash key is always unique. A secondary key is defined either by the entire table row (if this is not a table type or does not contain a table type as component), or is defined using individual components of a structured row type in the relevant order. Using the additions [WITH](javascript:call_link\('abaptypes_keydef.htm'\)) or [WITHOUT FURTHER SECONDARY KEYS](javascript:call_link\('abaptypes_keydef.htm'\)) of the statement TYPES, it is possible to define explicitly whether the table type is generic with respect to the secondary keys.

-   Initial row count

This is information for internal memory management of internal tables and corresponds to the addition [INITIAL SIZE](javascript:call_link\('abaptypes_itab.htm'\)) in the declaration of an internal table in an ABAP program.

Notes

-   Generic table types (namely table types for which one or more attributes are generic) can only be used in ABAP for [generic typings](javascript:call_link\('abengeneric_typing_glosry.htm'\) "Glossary Entry") of formal parameters or field symbols.

-   A row type cannot be defined using a reference to a [CDS entity](javascript:call_link\('abencds_entity_glosry.htm'\) "Glossary Entry"), but it can be defined using a reference to a [CDS database view](javascript:call_link\('abencds_database_view_glosry.htm'\) "Glossary Entry") of a [CDS view](javascript:call_link\('abencds_entity_glosry.htm'\) "Glossary Entry").



**📖 Source**: [abenddic_table_types_tech.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_table_types_tech.htm)

### abenddic_table_types_sema.htm

> **📖 Official SAP Documentation**: [abenddic_table_types_sema.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_table_types_sema.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Table Types](javascript:call_link\('abenddic_table_types.htm'\)) → 

Semantic Attributes of Table Types

Table types in ABAP Dictionary can be given the following semantic attributes:

-   Short text of the table type

Each table type has a short description specified when it is created.

-   Documentation

A table type can be given (optional) documentation.

-   Short description of a secondary key

Each secondary key has a short description specified when it is created.



**📖 Source**: [abenddic_table_types_sema.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_table_types_sema.htm)

### abenddic_table_types_ranges.htm

> **📖 Official SAP Documentation**: [abenddic_table_types_ranges.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_table_types_ranges.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Data Types](javascript:call_link\('abenddic_data_types.htm'\)) →  [Table Types](javascript:call_link\('abenddic_table_types.htm'\)) → 

Ranges Table Type

A ranges table type is a table type for a [ranges table](javascript:call_link\('abenranges_table_glosry.htm'\) "Glossary Entry"). A ranges table is a standard table with a standard key and a specially structured row type and can be used in general logical expressions with the relational expression [IN seltab](javascript:call_link\('abenlogexp_select_option.htm'\)) or used after WHERE in ABAP SQL with the relational expression [IN seltab](javascript:call_link\('abenwhere_logexp_seltab.htm'\)). In ABAP Dictionary, ranges table types are created using the statement [TYPES ... RANGE OF](javascript:call_link\('abaptypes_ranges.htm'\)).

The data types of the components SIGN and OPTION are the data elements DDSIGN and DDOPTION. The data type for the components LOW and HIGH must be elementary and can be specified directly as a [built-in data type](javascript:call_link\('abenddic_builtin_types.htm'\)) or using a [data element](javascript:call_link\('abenddic_data_elements.htm'\)).

The structure of the ranges table must be a standalone structure in ABAP Dictionary. When a ranges table type is defined, it can be created from the types specified for the components LOW and HIGH.

Notes

-   In ABAP programs, ranges tables can also be defined with reference to data types other than elementary data types.

-   In ABAP programs, the structure of a ranges table does not need to be a standalone structure.


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Views

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Views

Included pages: 8



**📖 Source**: [abenddic_table_types_ranges.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_table_types_ranges.htm)

### abenddic_views.htm

> **📖 Official SAP Documentation**: [abenddic_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_views.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) → 

Views

A view in ABAP Dictionary is a grouping of columns in one or more database tables in accordance with an application-specific view. In AS ABAP, views are defined in ABAP Dictionary and can be referenced as data types (like flat structures). Views can be used like database tables in ABAP SQL read statements (and sometimes in write statements). For this reason, the ABAP Dictionary views are in the same namespace as all types and database tables in ABAP Dictionary and the global [object types](javascript:call_link\('abenobject_type_glosry.htm'\) "Glossary Entry") in the [class library](javascript:call_link\('abenclass_library_glosry.htm'\) "Glossary Entry").

The name of a view can have a maximum of 16 characters, can consist of letters, numbers, and underscores, must start with a letter, and can be prefixed by a [namespace prefix](javascript:call_link\('abenname_space_prefix_glosry.htm'\) "Glossary Entry") (/.../) of a [prefix namespace](javascript:call_link\('abenprefix_name_space_glosry.htm'\) "Glossary Entry"). The name is in the namespace of the [data types](javascript:call_link\('abenddic_data_types.htm'\)) in ABAP Dictionary.

The data in a view is read from the database tables involved by the database and is not saved physically.

-   Views for a database table can be used to restrict database access to specific fields (known as projection) or to specific rows (known as selection).

-   Views for multiple database tables use joins or subqueries to join these tables and to read the required fields and rows.

The views in ABAP Dictionary are usually platform-independent. With some special exceptions, the views in ABAP Dictionary are, when activated, transformed into platform-specific [SQL views](javascript:call_link\('abensql_view_glosry.htm'\) "Glossary Entry") in the current [standard AS ABAP database](javascript:call_link\('abenstandard_db_glosry.htm'\) "Glossary Entry") in the [ABAP database schema](javascript:call_link\('abenabap_db_schema_glosry.htm'\) "Glossary Entry"). This is done using the [DDL](javascript:call_link\('abenddl_glosry.htm'\) "Glossary Entry") statement CREATE VIEW with the addition AS SELECT, which formulates the corresponding SELECT statement. The definition of a view in the database can be displayed in ABAP Dictionary by choosing Utilities → Database Object.

ABAP Dictionary manages the following categories of views:

-   [Classic views](javascript:call_link\('abenddic_classical_views.htm'\))

In classic views (or views for short), the platform-dependent DDL statement is created from the definition of the view in the form-based ABAP Dictionary [tool](javascript:call_link\('abenddic_tools.htm'\)).

-   [External views](javascript:call_link\('abenddic_external_views.htm'\))

An external view externalizes an [SAP HANA view](javascript:call_link\('abenhana_view_glosry.htm'\) "Glossary Entry") in ABAP programs and makes it usable like a regular view in ABAP Dictionary.

When a view is accessed using the ABAP SQL statement [SELECT](javascript:call_link\('abapselect.htm'\)), the SELECT statement defined in the DDL statement is executed and the results set is returned as if a SELECT were executed on a database table whose structure matches the structure defined by the view.

Notes

-   Views are usually defined in the implementation of data models in ABAP Dictionary and this is not usually the job of a regular ABAP application programmer. Once created, views are used in ABAP programs using ABAP SQL statements and must be stable enough to allow this.

-   When making selections using views, it is also important that suitable [indexes](javascript:call_link\('abenddic_database_tables_index.htm'\)) are created for the basis tables in the view.

-   The [CDS views](javascript:call_link\('abenddic_cds_views.htm'\)) in the [ABAP Core Data Services (CDS)](javascript:call_link\('abencds.htm'\)) are added to the views specified. A CDS view is defined in a (mostly) platform-independent [CDS DDL](javascript:call_link\('abencds_ddl_glosry.htm'\) "Glossary Entry") in [DDL source code](javascript:call_link\('abenddl_source_code_glosry.htm'\) "Glossary Entry"). CDS views expand on the functions provided by the classic views.

Continue
[Classic Views](javascript:call_link\('abenddic_classical_views.htm'\))
[External Views](javascript:call_link\('abenddic_external_views.htm'\))



**📖 Source**: [abenddic_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_views.htm)

### abenddic_classical_views.htm

> **📖 Official SAP Documentation**: [abenddic_classical_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_classical_views.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Views](javascript:call_link\('abenddic_views.htm'\)) → 

Classic Views

A classic view (or view for short) is a repository object in ABAP Dictionary defined for existing database tables and their fields in the form-based ABAP Dictionary [tool](javascript:call_link\('abenddic_tools.htm'\)) in [ABAP Workbench](javascript:call_link\('abenabap_workbench_glosry.htm'\) "Glossary Entry"). As well as the classic views, the ABAP Dictionary also manages the [CDS views](javascript:call_link\('abencds_view_glosry.htm'\) "Glossary Entry") of the [ABAP Core Data Services](javascript:call_link\('abencds.htm'\)), which are defined by the [CDS DDL](javascript:call_link\('abencds_ddl_glosry.htm'\) "Glossary Entry") in [DDL source code](javascript:call_link\('abenddl_source_code_glosry.htm'\) "Glossary Entry").

The definition of a classic view consists of the following:

-   Basis tables

A list of database tables accessed by the view. Multiple tables are joined using joins.

-   View fields

A list of table fields of the basis tables that defines the structure of the view. Except in the case of projection views, a different [data element](javascript:call_link\('abenddic_data_elements.htm'\)) can be assigned to a view field that that used for the corresponding table field of the basis table. This can only happen if the type of the table field is defined using a data element with a [domain](javascript:call_link\('abenddic_domains.htm'\)) and if the new data element references the same domain. This makes it possible to adjust the semantic attributes of the view field to the view.

-   Key

A key of the view that consists of key fields. The tool derives the key of a view from the key fields of the basis tables and the join conditions. All the key fields must be located contiguously at the start of the view. Fields that do not belong to the key, but are located between the key fields, are thus marked as key fields. All rows determined by the view must be unique with respect to the key. If no key with this property can be identified, all fields of the view are key fields, which can be bad for performance. In the case of ABAP SQL accesses to the view, its key behaves like the key of a database table.

-   Join conditions

Conditions for joining multiple basis tables using inner joins or outer joins. A join condition compares two fields from basis tables of a view for equality. If no join conditions are specified for a pair of basis tables, the view is used to select the cross product of the basis tables. Each row in a table is combined with each row of the other table. Each join condition then selects the matching rows from the cross product.

-   Selection conditions

Used to restrict the read rows to specific values of view fields or other fields.

-   The possible relational operators are \=, <>, \>=, \>, <=, <, LIKE, and NOT LIKE.

-   Depending on the data type of the view field, constant texts and numbers are allowed as comparison values. [System fields](javascript:call_link\('abensystem_field_glosry.htm'\) "Glossary Entry") can be specified for maintenance views and help views using SYST-... or SY-....

-   Multiple comparisons can be joined using AND and multiple comparisons for the same field can be joined using OR. Here, OR is stronger than AND.

The following types of classic views exist, of which only the database views are defined as SQL views on the database:

-   [Database views](javascript:call_link\('abenddic_database_views.htm'\))

-   [Projection views](javascript:call_link\('abenddic_projection_views.htm'\))

-   [Maintenance views](javascript:call_link\('abenddic_maintenance_views.htm'\))

-   [Help views](javascript:call_link\('abenddic_help_views.htm'\))

Like database tables, views have a short text description and (optional) documentation. A status known as a maintenance status determines whether a view is read-only or whether data can be inserted or modified in the view.

Notes

-   Projections can be implemented using both database views and with special projection views.

-   Only database tables can be specified as the basis tables of classic views, and no other views.

-   In [ABAP SQL](javascript:call_link\('abenopen_sql_glosry.htm'\) "Glossary Entry"), only views whose key fields are located together at the beginning of the view can be accessed.

-   Views whose fields are all key fields should not be written to using [UPDATE FROM](javascript:call_link\('abapupdate.htm'\)) or [MODIFY FROM](javascript:call_link\('abapmodify_dbtab.htm'\)). For database views, this produces a syntax check warning and for projection views a syntax error or runtime error.

-   As in database tables, the [client dependency](javascript:call_link\('abenclient_dependence_glosry.htm'\) "Glossary Entry") of a classic view that can be accessed using ABAP SQL (a database view or projection view) is determined by a first column with the built-in dictionary type CLNT. The client dependency of the basis tables is ignored here.

-   [CDS views](javascript:call_link\('abenddic_cds_views.htm'\)) defined using the [CDS DDL](javascript:call_link\('abencds_ddl_glosry.htm'\) "Glossary Entry") of the ABAP Core Data Services in [DDL source code](javascript:call_link\('abenddl_source_code_glosry.htm'\) "Glossary Entry") offer all the functions of classic views and more. CDS views are, however, read-only, while some classic views can be modified.

Continue
[Database Views](javascript:call_link\('abenddic_database_views.htm'\))
[Projection Views](javascript:call_link\('abenddic_projection_views.htm'\))
[Maintenance Views](javascript:call_link\('abenddic_maintenance_views.htm'\))
[Help Views](javascript:call_link\('abenddic_help_views.htm'\))



**📖 Source**: [abenddic_classical_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_classical_views.htm)

### abenddic_database_views.htm

> **📖 Official SAP Documentation**: [abenddic_database_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_database_views.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Views](javascript:call_link\('abenddic_views.htm'\)) →  [Classic Views](javascript:call_link\('abenddic_classical_views.htm'\)) → 

Database Views

A database view is a general view for one or more basis tables. If there are multiple basis tables, they are joined using an inner join. A matching [SQL view](javascript:call_link\('abensql_view_glosry.htm'\) "Glossary Entry") is created as a [database object](javascript:call_link\('abendb_object_glosry.htm'\) "Glossary Entry") on the database when the view is activated. The structure type defined using the view fields of the database view can be referenced in ABAP programs using TYPE. A database view can be accessed using ABAP SQL, Native SQL, or AMDP in CDS views, and also from outside AS ABAP using the programming interface of the database. The latter method is, however, [not recommended](javascript:call_link\('abendatabase_access_recomm.htm'\)).

-   [Basis Tables](#abenddic-database-views-1--------view-fields---@ITOC@@ABENDDIC_DATABASE_VIEWS_2)

-   [Join Conditions](#abenddic-database-views-3--------maintenance-status---@ITOC@@ABENDDIC_DATABASE_VIEWS_4)

-   [Table Buffering](#abenddic-database-views-5---notes------a-database-view-can-be-activated-in-abap-dictionary-without-its-basis-tables-being-defined-on-the-database--the-view-is-also-not-created-on-the-database-in-this-case-------as-in-a--database-table--javascript-call-link---abenddic-database-tables-client-htm------the-client-dependency-of-a-database-view-is-determined-by-an-initial-column-with-the-built-in-dictionary-type-clnt--------append-views--javascript-call-link---abenddic-append-views-htm-----are-available-for-enhancing-the-database-views-in-abap-dictionary-delivered-by-sap-without-making-any-modifications-------suitable--cds-views--javascript-call-link---abencds-view-glosry-htm-----glossary-entry---can-be-defined-as--replacement-objects--javascript-call-link---abenddic-replacement-objects-htm-----for-database-views--in-this-case--reads-in--abap-sql--javascript-call-link---abenopen-sql-glosry-htm-----glossary-entry---access-the-replacement-objects-rather-than-the-database-views-------database-views-managed-by-abap-dictionary-should-not-be-accessed-directly-in-the-database--see--access-to-abap-managed-database-objects--javascript-call-link---abendatabase-access-recomm-htm--------basis-tables--the-basis-tables-of-database-views-can-be--transparent-tables--javascript-call-link---abentransparent-table-glosry-htm-----glossary-entry---and--global-temporary-tables--javascript-call-link---abenglobal-temporary-table-glosry-htm-----glossary-entry-----note--the-basis-tables-of--cds-database-views--javascript-call-link---abencds-database-view-glosry-htm-----glossary-entry---that-are-generated-for--cds-views--javascript-call-link---abencds-view-glosry-htm-----glossary-entry---can-also-be-other-database-views---view-fields--an-include-mechanism-can-be-used-to-add-individual-fields-or-all-fields-from-the-basis-tables-as-view-fields-of-a-database-view--when-individual-fields-are-used--a-name-other-than-the-name-in-the-basis-tables-can-be-defined-for-a-view-field--this-name-can-have-a-maximum-of-30-characters--must-meet-the-naming-conventions-for-component-names-of--structures--javascript-call-link---abenddic-structures-htm------and-cannot-be-a-reserved-name--the-reserved-names-that-cannot-be-used-are-specified-in-the-database-table-trese---to-use-all-fields--the----character-is-used-instead-of-the-field-name--if-the----character-is-used-for-individual-fields-of-a-basis-table-included-using-----all-fields-up-to-the-fields-specified-with----become-view-fields--if-the-structure-of-a-database-table-whose-fields-were-added-in-this-way-is-modified--the-structure-of-the-view-is-also-modified---notes------if-a--foreign-key-field--javascript-call-link---abenforeign-key-field-glosry-htm-----glossary-entry---is-added-as-a-view-field--it-keeps-this-attribute-and-all-associated-foreign-key-fields-become-the-foreign-key-of-the-view-------for--cds-database-views--javascript-call-link---abencds-database-view-glosry-htm-----glossary-entry----the-view-fields-displayed-as-key-fields-are-in-no-way-related-to-the-key-fields-defined-using--define-view--javascript-call-link---abencds-f1-define-view-htm-----for-the--cds-entity--javascript-call-link---abencds-entity-glosry-htm-----glossary-entry---------a-database-view-in-the-software-component-sap--basis-can-contain-a-maximum-of-749-view-fields-and-the-total-of-the-field-lengths--the-number-of-bytes-in-non-character-like-fields-plus-the-number-of-characters-in-flat-character-like-fields--must-not-exceed-4096--a-database-view-in-any-other-software-component-can-contain-a-maximum-of-1500-view-fields-and-the-total-of-the-field-lengths-is-not-checked-in-abap-dictionary---join-conditions--the-join-conditions-for-the-inner-join-can-be-formulated-using-equality-relationships-between-any-two-table-fields-in-the-basis-tables--the-inner-join-joins-the-rows-of-the-basis-tables-in-question-as-a-results-set-containing-all-combinations-of-rows-whose-columns-together-meet-the-join-conditions--if-there-are-no-rows-that-meet-the-join-conditions-in-the-basis-tables-in-question--no-row-is-created-in-the-results-set--if-there-is-a-suitable--foreign-key-dependency--javascript-call-link---abenddic-database-tables-forkeyrel-htm------including-generic-and-constant-foreign-keys--between-two-basis-tables--this-dependency-can-be-used-as-a-default-for-defining-join-conditions-in-abap-dictionary---maintenance-status--the-access-setting-in-the-maintenance-status-of-a-database-view-can-have-the-following-values-------read-only--the-database-view-can-only-be-used-to-read-data-with-abap-sql-------read--change--delete--and-insert--if-the-database-view-contains-only-a-single-basis-table--data-can-be--changed--javascript-call-link---abenopen-sql-writing-htm-----using-abap-sql---a-database-view-with-multiple-basis-tables-can-only-be-read-with-abap-sql--if-a-database-view-contains-only-a-single-table--data-can-be-inserted-in-this-table-using-the-view-with-the-abap-sql-statements--insert--javascript-call-link---abapinsert-dbtab-htm-----or--modify--javascript-call-link---abapinsert-dbtab-htm------the-following-options-are-available-for-the-content-of-the-table-fields-not-in-the-view-------if-the-table-field-is-defined-with--not-null--javascript-call-link---abenddic-database-tables-init-htm-----on-the-database--the-field-is-filled-with-the-corresponding-initial-value-------if-the-table-field-is-defined-with--not-null--javascript-call-link---abenddic-database-tables-init-htm-----on-the-database--and-there-is-no-initial-value--nothing-can-be-inserted-and-a-database-error-occurs-with-a-corresponding-exception-------if-the-table-field-is-not-defined-with--not-null--javascript-call-link---abenddic-database-tables-init-htm-----on-the-database--the-field-is-filled-with-the--null-value--javascript-call-link---abennull-value-glosry-htm-----glossary-entry-----notes------a-database-view-should-only-be-used-to-insert-data-in-the-table-if-the-flag-for-initial-values-is-set-for-all-table-fields-that-are-not-in-the-view-------it-is-not-usually-a-problem-to-modify-existing-data-records-using-a-database-view-in-cases-where-the-database-view-contains-all-key-fields-of-the-table-------like-a-database-table--the-maintenance-status-of-a-database-view-has-a--display-and-maintain--javascript-call-link---abenddic-database-tables-maint-htm-----setting-alongside-the-access-setting--the-setting-must-match-the-access-setting--in-database-views-containing-multiple-basis-tables--only-the-setting-display-maintenance-not-allowed-is-possible---table-buffering--just-like-in-database-tables--it-is-possible-to-define-for-a-database-view-whether-the-data-in-the--table-buffer--javascript-call-link---abentable-buffer-glosry-htm-----glossary-entry---is-buffered--the-same--buffering-types--javascript-call-link---abenddic-database-tables-buffer-htm-----can-be-defined-and--table-buffering-in-abap-sql--javascript-call-link---abensap-puffering-htm-----is-handled-in-the-same-way-for-views-and-for-database-tables-with-the-only-difference-being-that--when-data-is-modified-in-one-of-the-basis-tables--the-entire-buffer-is-invalidated-when-the--buffers-are-synchronized--javascript-call-link---abenbuffer-synchro-htm------regardless-of-the-buffering-type-in-client-specific-views--however--this-only-affects-the-content-of-the-current-client---the-following-prerequisites-must-be-met-before-a-database-view-can-be-buffered-------a-basis-table-can-occur-in-no-more-than-nine-buffered-database-views-------if-all-fields-of-the-database-view-are-key-fields--these-fields-must-also-be-key-fields-of-the-basis-tables-------a-view-whose-data-is-written-to-using-abap-sql-cannot-have-a--replacement-object--javascript-call-link---abenddic-replacement-objects-htm-------note--no--replacement-objects--javascript-call-link---abenddic-replacement-objects-htm-----can-be-created-for-an-existing-buffered-view-whose-data-can-be-written-to-using-abap-sql---example--the-database-view-demo--scarr--spfli-contains-fields-of-the-tables-scarr-and-spfli--other-names-are-assigned-to-these-fields-in-the-view---the-associated-database-object-could-be-as-follows---create-view-demo--scarr--spfli-----client-----id-----carrier-----flight-----departure-----destination---as-select----t1--mandt------t2--carrid------t1--carrname------t2--connid------t2--cityfrom------t2--cityto--from------scarr--t1-------spfli--t2-where-----t1--mandt-----t2--mandt--and-----t1--carrid----t2--carrid---the-view-can-be-accessed-as-follows-using-abap-sql---select-----------from-demo--scarr--spfli--------order-by-id--carrier--flight--------into-table-DATA(result).
cl\_demo\_output=>display( result ).



**📖 Source**: [abenddic_database_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_database_views.htm)

### abenddic_projection_views.htm

> **📖 Official SAP Documentation**: [abenddic_projection_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_projection_views.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Views](javascript:call_link\('abenddic_views.htm'\)) →  [Classic Views](javascript:call_link\('abenddic_classical_views.htm'\)) → 

Projection Views

A projection view is a special view for hiding fields from a single basis table. An SQL view is not created on the database. No selection conditions can be specified for a projection view.

The structure type defined using the view fields of the projection view can be referenced in ABAP programs using TYPE. A projection view can be accessed using ABAP SQL but not using CDS views, Native SQL, or AMDP. The database interface transforms an ABAP SQL statement that accesses a projection view to a platform-specific SQL statement that provides the correct result.

The Access setting in the maintenance status of a projection view can have the following values:

-   Read only

The projection view can only be used to read data with ABAP SQL.

-   Read, change, delete, and insert

The projection view can only be used to [change](javascript:call_link\('abenopen_sql_writing.htm'\)) data with ABAP SQL.

When rows are inserted using projection views, all table fields not in the view are given the type-specific initial values of the field. This is done regardless of whether the field is defined as [NOT NULL](javascript:call_link\('abenddic_database_tables_init.htm'\)) on the database.

Notes

-   As in a [database table](javascript:call_link\('abenddic_database_tables_client.htm'\)), the client dependency of a projection view is determined by an initial column with the built-in dictionary type CLNT.

-   Like a database table, the maintenance status of a projection view has a [Display and Maintain](javascript:call_link\('abenddic_database_tables_maint.htm'\)) setting alongside the Access setting. The setting must match the Access setting.

-   The basis table of a projection view can be a [transparent table](javascript:call_link\('abentransparent_table_glosry.htm'\) "Glossary Entry") and a [global temporary table](javascript:call_link\('abenglobal_temporary_table_glosry.htm'\) "Glossary Entry").

Example

The projection view DEMO\_SPFLI contains fields of the tables SPFLI. The view can be accessed as follows using ABAP SQL:

SELECT \*
       FROM demo\_spfli
       ORDER BY carrid, connid
       INTO TABLE @DATA(result).
cl\_demo\_output=>display( result ).



**📖 Source**: [abenddic_projection_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_projection_views.htm)

### abenddic_maintenance_views.htm

> **📖 Official SAP Documentation**: [abenddic_maintenance_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_maintenance_views.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Views](javascript:call_link\('abenddic_views.htm'\)) →  [Classic Views](javascript:call_link\('abenddic_classical_views.htm'\)) → 

Maintenance Views

A maintenance view is a special view for performing writes on multiple tables using extended table maintenance. A single maintenance view can be used to modify the content of multiple related database tables consistently.

A maintenance view is not defined on the database. The structure type defined using a maintenance view can be referenced in ABAP programs using TYPE. A maintenance view cannot, however, be accessed using ABAP SQL. Instead, the transaction SE54 can be used to create dialogs called maintenance dialogs for maintenance views, which can themselves be used to edit the tables of the maintenance views jointly in extended table maintenance (transactions SM30 and SM31).

When data records are inserted using maintenance views, all tables fields not in the view are given the type-specific initial values of the field. This is done regardless of whether the field is defined as [NOT NULL](javascript:call_link\('abenddic_database_tables_init.htm'\)) on the database.

Primary Table and Secondary Tables

All database tables grouped in a maintenance view must be joined using [foreign key dependencies](javascript:call_link\('abenddic_database_tables_forkeyrel.htm'\)), which means that the join conditions are always derived from a foreign key in the case of maintenance views. The first table included in the maintenance view is known as the primary table of the maintenance view. The tables added to this primary table using foreign keys are known as secondary tables. The following restrictions apply when selecting the secondary tables of a maintenance view:

-   The secondary tables must have an N:1 dependency on the primary table or on the transitively preceding secondary table. This makes sure that no more than one dependent data record exists in each of the secondary tables for a specific data record in the primary table. An N:1 dependency exists if the secondary table is the [check table](javascript:call_link\('abencheck_table_glosry.htm'\) "Glossary Entry") in the [foreign key in question](javascript:call_link\('abenforeign_key_glosry.htm'\) "Glossary Entry").

-   If the secondary table is the [foreign key table](javascript:call_link\('abenforeign_key_table_glosry.htm'\) "Glossary Entry"), the foreign key fields must be key fields of a table or the foreign key must have the cardinality N:1 or N:C.

A maintenance view implements an inner join. All key fields in the primary table must be included in its maintenance view. All key fields of secondary tables that are not part of the foreign key (that is, they are not joined with a key field already in the view using a join condition) must also be included in the view. This makes sure that the records inserted using a maintenance view can be written correctly to the tables in the view.

Note

If a database table is joined with its [text table](javascript:call_link\('abentext_table_glosry.htm'\) "Glossary Entry") in a maintenance view, the logon language is selected automatically for this table.

Time-Dependent Key

In maintenance views, the key can be divided into a non-time-dependent area and a time-dependent area. The time-dependent area can, for example, contain date fields and time fields. This means that the rows of these views have chronological importance.

Note

The ability to change time-dependent views makes it possible to restrict the new entries inserted to those that are only missing time information.

Maintenance Status

The Access setting in the maintenance status of a maintenance view can have the following values:

-   Read only

The maintenance view can only be used to read data.

-   Read, change, delete, and insert

The maintenance view can be used to change, delete, and insert data.

-   Read and change

The maintenance view can be used to change data, but not delete or insert it.

-   Read and change (time-dependent views)

The maintenance view can be used to insert only entries whose non-time-dependent part of the key does not differ from existing entries.

Note

Like a database table, the maintenance status of a maintenance view has a [Display and Maintain](javascript:call_link\('abenddic_database_tables_maint.htm'\)) setting alongside the Access setting. The setting must match the Access setting. The setting Display/maintenance not allowed is not possible here.

Maintenance Characteristics of View Fields

Alongside the maintenance status of the view, characteristics called maintenance characteristics can be defined for each view field:

-   Standard

There are no restrictions on the view field.

-   Read-only

The maintenance view cannot be used to perform writes on the view field.

-   Subset

A field of this type is used to construct subsets when data is edited in extended table maintenance. Only a subset of the data is displayed. This subset is defined by entering an appropriate value in this field.

-   Hidden

A field of this type is not displayed in extended table maintenance and cannot be edited there. The content is initialized implicitly.

Delivery Class

A maintenance view also has a [delivery class](javascript:call_link\('abenddic_database_tables_delivery.htm'\)). The delivery class of a maintenance view is analyzed in the extended table maintenance.

-   If the view is assigned one of the delivery classes G or E, the customer namespace for the entries of the view must be defined in the database table TRESC.

-   The transport interface of extended table maintenance must match the delivery class.

Regardless of this, the transport of the basis tables involved in upgrades and in transports between customer systems is determined solely by their [delivery class](javascript:call_link\('abenddic_database_tables_delivery.htm'\)).



**📖 Source**: [abenddic_maintenance_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_maintenance_views.htm)

### abenddic_help_views.htm

> **📖 Official SAP Documentation**: [abenddic_help_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_help_views.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Views](javascript:call_link\('abenddic_views.htm'\)) →  [Classic Views](javascript:call_link\('abenddic_classical_views.htm'\)) → 

Help Views

A help view is a special view for use in [search helps](javascript:call_link\('abensearch_help_glosry.htm'\) "Glossary Entry"). The selection methods of a search help can be database tables, database views, and the special help views. Database tables restrict the search help to one table and database views restrict it to inner joins, whereas help views also make outer joins possible. A help view is not defined on the database. The structure type defined using a help view can be referenced in ABAP programs using TYPE. A help view cannot, however, be accessed using ABAP SQL.

The join conditions of a help view must be applied from existing foreign keys. Tables can be grouped in help views only if they are joined using [foreign keys](javascript:call_link\('abenforeign_key_glosry.htm'\) "Glossary Entry"). The first table included in the help view is known as the primary table of the help view. The tables added to this primary table using foreign keys are known as secondary tables. The same restrictions apply when selecting secondary tables of a help view as to [maintenance views](javascript:call_link\('abenddic_maintenance_views.htm'\)).

A help view implements an outer join, which means that the full content of the primary table of the help view is always displayed. If records in a secondary table cannot be read due to a selection condition, the content of the corresponding fields of the secondary table are displayed with initial values.

Notes

-   Like other views, help views can be used in elementary search helps if the selection is too complex to be defined using a single database table.

-   Unlike database views, help views implement an outer join, which is why this type is particularly well suited for including supplementary information such as explanatory texts from secondary tables. If the supplementary information were missing in an inner join, no part of the dataset would be selected.

-   If the selection is only made using a table and its text table, it is enough to specify the table directly as a selection method of the search help, since the fields of the text table can also be used as parameters in the search help in this case.

-   Help views should not be used if the selection is often restricted using fields of the secondary tables. In this case, a database view should be created instead. It might also be necessary to create additional suitable indexes for the basis tables.

-   Selections using help views can only be made quicker by making restrictions on the primary table. When accessing help views from the ABAP runtime environment, special selection routines are generated. These routines always make the selection using the primary table first and then use the records found as a key for selecting the supplementary information.



**📖 Source**: [abenddic_help_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_help_views.htm)

### abenddic_classical_views.htm

> **📖 Official SAP Documentation**: [abenddic_classical_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_classical_views.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Views](javascript:call_link\('abenddic_views.htm'\)) → 

Classic Views

A classic view (or view for short) is a repository object in ABAP Dictionary defined for existing database tables and their fields in the form-based ABAP Dictionary [tool](javascript:call_link\('abenddic_tools.htm'\)) in [ABAP Workbench](javascript:call_link\('abenabap_workbench_glosry.htm'\) "Glossary Entry"). As well as the classic views, the ABAP Dictionary also manages the [CDS views](javascript:call_link\('abencds_view_glosry.htm'\) "Glossary Entry") of the [ABAP Core Data Services](javascript:call_link\('abencds.htm'\)), which are defined by the [CDS DDL](javascript:call_link\('abencds_ddl_glosry.htm'\) "Glossary Entry") in [DDL source code](javascript:call_link\('abenddl_source_code_glosry.htm'\) "Glossary Entry").

The definition of a classic view consists of the following:

-   Basis tables

A list of database tables accessed by the view. Multiple tables are joined using joins.

-   View fields

A list of table fields of the basis tables that defines the structure of the view. Except in the case of projection views, a different [data element](javascript:call_link\('abenddic_data_elements.htm'\)) can be assigned to a view field that that used for the corresponding table field of the basis table. This can only happen if the type of the table field is defined using a data element with a [domain](javascript:call_link\('abenddic_domains.htm'\)) and if the new data element references the same domain. This makes it possible to adjust the semantic attributes of the view field to the view.

-   Key

A key of the view that consists of key fields. The tool derives the key of a view from the key fields of the basis tables and the join conditions. All the key fields must be located contiguously at the start of the view. Fields that do not belong to the key, but are located between the key fields, are thus marked as key fields. All rows determined by the view must be unique with respect to the key. If no key with this property can be identified, all fields of the view are key fields, which can be bad for performance. In the case of ABAP SQL accesses to the view, its key behaves like the key of a database table.

-   Join conditions

Conditions for joining multiple basis tables using inner joins or outer joins. A join condition compares two fields from basis tables of a view for equality. If no join conditions are specified for a pair of basis tables, the view is used to select the cross product of the basis tables. Each row in a table is combined with each row of the other table. Each join condition then selects the matching rows from the cross product.

-   Selection conditions

Used to restrict the read rows to specific values of view fields or other fields.

-   The possible relational operators are \=, <>, \>=, \>, <=, <, LIKE, and NOT LIKE.

-   Depending on the data type of the view field, constant texts and numbers are allowed as comparison values. [System fields](javascript:call_link\('abensystem_field_glosry.htm'\) "Glossary Entry") can be specified for maintenance views and help views using SYST-... or SY-....

-   Multiple comparisons can be joined using AND and multiple comparisons for the same field can be joined using OR. Here, OR is stronger than AND.

The following types of classic views exist, of which only the database views are defined as SQL views on the database:

-   [Database views](javascript:call_link\('abenddic_database_views.htm'\))

-   [Projection views](javascript:call_link\('abenddic_projection_views.htm'\))

-   [Maintenance views](javascript:call_link\('abenddic_maintenance_views.htm'\))

-   [Help views](javascript:call_link\('abenddic_help_views.htm'\))

Like database tables, views have a short text description and (optional) documentation. A status known as a maintenance status determines whether a view is read-only or whether data can be inserted or modified in the view.

Notes

-   Projections can be implemented using both database views and with special projection views.

-   Only database tables can be specified as the basis tables of classic views, and no other views.

-   In [ABAP SQL](javascript:call_link\('abenopen_sql_glosry.htm'\) "Glossary Entry"), only views whose key fields are located together at the beginning of the view can be accessed.

-   Views whose fields are all key fields should not be written to using [UPDATE FROM](javascript:call_link\('abapupdate.htm'\)) or [MODIFY FROM](javascript:call_link\('abapmodify_dbtab.htm'\)). For database views, this produces a syntax check warning and for projection views a syntax error or runtime error.

-   As in database tables, the [client dependency](javascript:call_link\('abenclient_dependence_glosry.htm'\) "Glossary Entry") of a classic view that can be accessed using ABAP SQL (a database view or projection view) is determined by a first column with the built-in dictionary type CLNT. The client dependency of the basis tables is ignored here.

-   [CDS views](javascript:call_link\('abenddic_cds_views.htm'\)) defined using the [CDS DDL](javascript:call_link\('abencds_ddl_glosry.htm'\) "Glossary Entry") of the ABAP Core Data Services in [DDL source code](javascript:call_link\('abenddl_source_code_glosry.htm'\) "Glossary Entry") offer all the functions of classic views and more. CDS views are, however, read-only, while some classic views can be modified.

Continue
[Database Views](javascript:call_link\('abenddic_database_views.htm'\))
[Projection Views](javascript:call_link\('abenddic_projection_views.htm'\))
[Maintenance Views](javascript:call_link\('abenddic_maintenance_views.htm'\))
[Help Views](javascript:call_link\('abenddic_help_views.htm'\))



**📖 Source**: [abenddic_classical_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_classical_views.htm)

### abenddic_external_views.htm

> **📖 Official SAP Documentation**: [abenddic_external_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_external_views.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Views](javascript:call_link\('abenddic_views.htm'\)) → 

External Views

An external view is a special view in ABAP Dictionary that [defines](javascript:call_link\('abenexternal_views.htm'\)) an [SAP HANA View](javascript:call_link\('abenhana_view_glosry.htm'\) "Glossary Entry") in [SAP HANA XSC](javascript:call_link\('abenxsc_glosry.htm'\) "Glossary Entry") in ABAP programs. The structure type defined using the view fields of an external view can be referenced in ABAP programs using TYPE. An external view can be specified as a source in [ABAP SQL read](javascript:call_link\('abenopen_sql_reading.htm'\)) statements

External views can only be created using the [ABAP Development Tools (ADT)](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry") and only if the current database is an [SAP HANA database](javascript:call_link\('abenhana_database_glosry.htm'\) "Glossary Entry"). The SAP HANA view must exist in the [SAP HANA Repository](javascript:call_link\('abensap_hana_repository_glosry.htm'\) "Glossary Entry").

When an external view is activated, an alias with the name of the view is created on the SAP HANA database that points to the SAP HANA view. The names of the view fields of the external view can be defined differently from the names of the view fields of the SAP HANA view. The [runtime object](javascript:call_link\('abenruntime_object_glosry.htm'\) "Glossary Entry") of the external view accesses the alias on the SAP HANA database. This performs a mapping of HANA-specific data types to the [built-in types](javascript:call_link\('abenddic_builtin_types.htm'\)) in ABAP Dictionary. The following table lists the currently supported HANA-specific data types and indicates which ABAP Dictionary types they are mapped to by default.

HANA Type

Meaning

Type in ABAP Dictionary

SMALLINT

2-byte integer

INT2

INTEGER

4-byte integer

INT4

BIGINT

8-byte integer

INT8

DECIMAL

Packed number

DEC

SMALLDECIMAL

Packed number

DEC

FLOAT

Binary floating point number

FLTP

NVARCHAR

Unicode character string

CHAR

VARBINARY

Byte string

RAW

BLOB

Byte string

RAWSTRING

NCLOB

Unicode character string

STRING

External views can be displayed in the ABAP Dictionary [tool](javascript:call_link\('abenddic_tools.htm'\)) in the SAP GUI-based ABAP Workbench, but not edited.

An external view can only be read using ABAP SQL if an SAP HANA database is being accessed in which the associated SAP HANA view exists. If not, the non-handleable exception DBSQL\_TABLE\_UNKNOWN is raised. External views can exist actively and be used as data types in a system whose standard database is not an SAP HANA database. Views of this type cannot, however, be accessed through the [standard connection](javascript:call_link\('abenstandard_db_connection_glosry.htm'\) "Glossary Entry") using ABAP SQL, only through a [secondary connection](javascript:call_link\('abensecondary_db_connection_glosry.htm'\) "Glossary Entry") to an SAP HANA database. Conversely, when an SAP HANA view in an SAP HANA database is accessed through a secondary connection in the current system, only an identically named database table or a structure suitable for any view in ABAP Dictionary can exist actively in ABAP Dictionary.

Notes

-   The following restrictions currently apply to the use of external views in ABAP programs:

-   The structure of analytic views do not allow them to be read using [SELECT \*](javascript:call_link\('abapselect_list.htm'\)). The same basic rules apply to the statement SELECT in ABAP SQL as when using the HAND SQL statement SELECT, with individual columns and the addition GROUP BY needing to be specified. If SELECT \* is used, a runtime error occurs.

-   Calculation views with parameters can be access only if a default value is defined for each parameter. If not, reads are canceled and produce a runtime error.

-   External views should only be used in those cases that are not covered by [ABAP CDS](javascript:call_link\('abenabap_cds_glosry.htm'\) "Glossary Entry") or [AMDP](javascript:call_link\('abenamdp_glosry.htm'\) "Glossary Entry").

-   Access to SAP HANA views in [SAP HANA XS](javascript:call_link\('abenxs_glosry.htm'\) "Glossary Entry"):

-   SAP HANA views in [SAP HANA XSC](javascript:call_link\('abenxsc_glosry.htm'\) "Glossary Entry") are stored in the SAP HANA Repository and external views can be used for access to these views from ABAP.

-   SAP HANA views in [SAP HANA XSA](javascript:call_link\('abenxsa_glosry.htm'\) "Glossary Entry"), the successor to [SAP HANA XSC](javascript:call_link\('abenxsc_glosry.htm'\) "Glossary Entry"), are usually [HDI objects](javascript:call_link\('abenhdi_object_glosry.htm'\) "Glossary Entry") for which no external views can be created. For access from ABAP, other methods must be used such as [AMDP](javascript:call_link\('abenamdp_glosry.htm'\) "Glossary Entry") or [ADBC](javascript:call_link\('abenadbc_glosry.htm'\) "Glossary Entry").


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Enhancements

**Files**: 9 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Enhancements

Included pages: 9



**📖 Source**: [abenddic_external_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_external_views.htm)

### abenddic_enhancements.htm

> **📖 Official SAP Documentation**: [abenddic_enhancements.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_enhancements.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) → 

Enhancements

A [structure](javascript:call_link\('abenddic_structures.htm'\)), [database table](javascript:call_link\('abenddic_database_tables.htm'\)), [database view](javascript:call_link\('abenddic_database_views.htm'\)), or [domain](javascript:call_link\('abenddic_domains.htm'\)) in ABAP Dictionary created in a system can be enhanced in a different system using customizing includes, append structures, or append views without making any modifications. Customizing includes indicate points already marked by SAP for enhancements, whereas append structures can be appended anywhere.

-   [Customizing includes](javascript:call_link\('abenddic_customizing_includes.htm'\))

-   [Append structures](javascript:call_link\('abenddic_append_structures.htm'\))

-   [Append views](javascript:call_link\('abenddic_append_views.htm'\))

-   [Fixed value appends](javascript:call_link\('abenddic_fixed_value_appends.htm'\))

[Search helps](javascript:call_link\('abensearch_help_glosry.htm'\) "Glossary Entry") can be expanded using [append search helps](javascript:call_link\('abenappend_search_help_glosry.htm'\) "Glossary Entry").

Extensions are connection to [Switch Framework](javascript:call_link\('abenswitch_framework_glosry.htm'\) "Glossary Entry") whenever they are defined in a [package](javascript:call_link\('abenpackage_glosry.htm'\) "Glossary Entry") that is assigned a [switchSchalter](javascript:call_link\('abenswitch_german_glosry.htm'\) "Glossary Entry").

Note

For [CDS views](javascript:call_link\('abencds_view_glosry.htm'\) "Glossary Entry"), [CDS view enhancements](javascript:call_link\('abencds_view_extend_glosry.htm'\) "Glossary Entry") are an option for enhancements that is based on the CDS DDL in ABAP CDS.

Continue
[Customizing Includes](javascript:call_link\('abenddic_customizing_includes.htm'\))
[Append Structures](javascript:call_link\('abenddic_append_structures.htm'\))
[Append Views](javascript:call_link\('abenddic_append_views.htm'\))
[Fixed Value Appends](javascript:call_link\('abenddic_fixed_value_appends.htm'\))



**📖 Source**: [abenddic_enhancements.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_enhancements.htm)

### abenddic_customizing_includes.htm

> **📖 Official SAP Documentation**: [abenddic_customizing_includes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_customizing_includes.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Enhancements](javascript:call_link\('abenddic_enhancements.htm'\)) → 

Customizing Includes

A customizing include is a structure in ABAP Dictionary whose name has the prefix CI\_ for customers and SI\_ for partners and is in the customer namespace. Customizing includes can be included in [structures](javascript:call_link\('abenddic_structures.htm'\)) and [database tables](javascript:call_link\('abenddic_database_tables.htm'\)) delivered by SAP. The customizing includes in structures and database tables delivered by SAP are usually empty. They are not associated with existing structures and reserve only the names of the structures. In customer or partner systems, these includes can be enhanced as part of an [enhancement category](javascript:call_link\('abenddic_structures_enh_cat.htm'\)) in customizing by creating the included customizing includes and using customizing transactions to give them components. Any existing transparent database tables are not transformed, which can put the fields in different orders in the dictionary and on the database.

A customizing include can be included in multiple database tables or structures. Its enhancement is then applied to all database tables or structures in which it is included. An empty customizing include of a database table or structure does not need to be enhanced.

Enhancements of a delivered structure or database table using a customizing include are not modifications. If a customizing include is used to add fields to a database table or structure in the standard system, these fields are inserted automatically in the new structure or database table delivered by SAP in an upgrade.



**📖 Source**: [abenddic_customizing_includes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_customizing_includes.htm)

### abenddic_append_structures.htm

> **📖 Official SAP Documentation**: [abenddic_append_structures.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_append_structures.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Enhancements](javascript:call_link\('abenddic_enhancements.htm'\)) → 

Append Structures

An append structure is a structure in ABAP Dictionary appended to another [structure](javascript:call_link\('abenddic_structures.htm'\)) or [database table](javascript:call_link\('abenddic_database_tables.htm'\)) and which adds its components to this structure or table. In customer systems, append structures can be added to structures and database tables delivered by SAP. An append structure is assigned to exactly one table or structure. There can, however, be more than one append structure for a table or structure. The components of append structures must meet the [prerequisites](javascript:call_link\('abenddic_database_tables_techstruc.htm'\)) for table fields.

The following enhancements can be made to a database table or structure using an append structure:

-   New components inserted (if permitted by the [enhancement category](javascript:call_link\('abenddic_structures_enh_cat.htm'\)))

-   [Foreign keys](javascript:call_link\('abenforeign_key_glosry.htm'\) "Glossary Entry") defined for existing fields of a database table

-   [Search helps](javascript:call_link\('abensearch_help_glosry.htm'\) "Glossary Entry") bound to existing components

All enhancements are part of the append structure, which means that any changes made to these enhancements are made only using the append structure. The same applies to transports. When a database table or structure is activated, all associated append structures are found and their components are appended to the database table or structure. Any foreign keys or search help bindings added using the append structure are also appended. When an append structure is activated, the assigned database table or structure is adapted to the changes made. Any existing tables are not [converted](javascript:call_link\('abenddic_database_tables_conv.htm'\)), which can put the fields in the dictionary in a different order from the order on the database. When a structure or database table with an append structure is copied, the appended fields, foreign keys, and search helps become real elements of the target of the copy.

The following must be noted when using append structures to enhance database tables:

-   Append structures can only be appended to [transparent tables](javascript:call_link\('abentransparent_table_glosry.htm'\) "Glossary Entry").

-   No append structures can be appended to database tables with fields of the type LCHR or LRAW, since these fields must always be the last field of the table.

-   Any fields appended to a database table using an append structure can be added to its [secondary indexes](javascript:call_link\('abenddic_database_tables_index.htm'\)). No secondary index can be defined for the append structure itself.

-   A binding of a check table or search help that already exists for a field of the database table cannot be modified using the append structure.

Enhancements of SAP structures or SAP tables using append structures in customer systems do not constitute modifications. Append structures created for SAP objects in customer systems are in the customer namespace (or in the namespace of a partner of a special development project) and hence are protected from being overwritten by upgrades. It is advisable to also create the components of append structures of this type with names from the customer namespace to avoid naming conflicts. After an upgrade, the associated append structures are again appended to tables modified by SAP.

Append structures can be defined as form-based structures in transaction SE11 or as source-code-based structures using [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry") in the [ABAP Development Tools](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry"). The following section is a summary of the syntax of the source code-based definition:

-   [Dictionary DDL for Structure Enhancements](javascript:call_link\('abenddic_extend_type.htm'\))

Note

The same structure can be appended to multiple database tables or structures by including it in the individual append structures as an include structure.

Example

The append structure DEMO\_APPEND\_STRUCTURE enhances the structure DEMO\_STRUCTURE.

Continue
[Dictionary DDL for Structure Enhancements](javascript:call_link\('abenddic_extend_type.htm'\))



**📖 Source**: [abenddic_append_structures.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_append_structures.htm)

### abenddic_extend_type.htm

> **📖 Official SAP Documentation**: [abenddic_extend_type.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_extend_type.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Enhancements](javascript:call_link\('abenddic_enhancements.htm'\)) →  [Append Structures](javascript:call_link\('abenddic_append_structures.htm'\)) → 

Dictionary DDL for Structure Enhancements

In the [ABAP Development Tools (ADT)](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry"), a structure or database table can be given a source-code-based enhancement known as an append structure in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry"). Here, however, the source code of an append structure is not saved and transported. Instead, the source code of an existing append structure is generated from the metadata of the associated system tables. When saved, the metadata is derived directly from the append structure and saved to the system tables.

-   [EXTEND TYPE](javascript:call_link\('abenddicddl_extend_type.htm'\))

Note

Each property of an append structure can be defined using either EXTEND TYPE or in the transaction SE11.

Continue
[EXTEND TYPE](javascript:call_link\('abenddicddl_extend_type.htm'\))



**📖 Source**: [abenddic_extend_type.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_extend_type.htm)

### abenddicddl_extend_type.htm

> **📖 Official SAP Documentation**: [abenddicddl_extend_type.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_extend_type.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Enhancements](javascript:call_link\('abenddic_enhancements.htm'\)) →  [Append Structures](javascript:call_link\('abenddic_append_structures.htm'\)) →  [Dictionary DDL for Structure Enhancements](javascript:call_link\('abenddic_extend_type.htm'\)) → 

EXTEND TYPE

Syntax

[structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\))
EXTEND TYPE struct*|*dbtab WITH append\_struct {
  ...
  [component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\))
  *\[*...
  [extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\))
  ...*\]*;
  ...
  [include;](javascript:call_link\('abenddicddl_define_struct_incl.htm'\))
  ...
}

Effect

[Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry") statement for defining an ABAP Dictionary [append structure](javascript:call_link\('abenddic_append_structures.htm'\)) append\_struct in the [ABAP Development Tools](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry").

-   The statement EXTEND TYPE adds the append structure append\_struct defined here either to an existing structure struct or to a database table dbtab.

-   The mandatory properties of the append structure must be specified in front of the statement EXTEND TYPE using the same annotations [structure\_annos](javascript:call_link\('abenddicddl_define_struct_props.htm'\)) as in the definition of a structure.

-   As in the definition of a structure using [DEFINE STRUCTURE](javascript:call_link\('abenddicddl_define_structure.htm'\)), the components of the append structure are defined in a semicolon-separated list in curly brackets { }, either as individual components [component](javascript:call_link\('abenddicddl_define_struct_comps.htm'\)) or by including include structures [include](javascript:call_link\('abenddicddl_define_struct_incl.htm'\)).

-   As when including structures, an assignment to a search help and a definition of a foreign key dependency can be overwritten using additions [extend](javascript:call_link\('abenddicddl_define_struct_comp_ext.htm'\)) in a blank-separated list.

Notes

-   As in the [CDS syntax](javascript:call_link\('abencds_general_syntax_rules.htm'\)), the definition of an ABAP Dictionary append structure can contain comments after // and between /\* ... \*/.

-   A more detailed description of the syntax is available in the ADT documentation Syntax of ABAP Dictionary Objects.

Example

Adds the append structure DEMO\_APPEND\_STRUCTURE to the structure DEMO\_STRUCTURE in the ADT.

@EndUserText.label : 'Demo append structure'
@AbapCatalog.enhancementCategory : #EXTENSIBLE\_CHARACTER\_NUMERIC
extend type demo\_structure with demo\_append\_structure {
  comp3 : dats;
  comp4 : tims; }

The source code used to define the structure DEMO\_STRUCTURE is not modified by this enhancement. In the ADT, however, an icon indicates that the structure is enhanced using DEMO\_APPEND\_STRUCTURE.



**📖 Source**: [abenddicddl_extend_type.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddicddl_extend_type.htm)

### abenddic_extend_type.htm

> **📖 Official SAP Documentation**: [abenddic_extend_type.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_extend_type.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Enhancements](javascript:call_link\('abenddic_enhancements.htm'\)) →  [Append Structures](javascript:call_link\('abenddic_append_structures.htm'\)) → 

Dictionary DDL for Structure Enhancements

In the [ABAP Development Tools (ADT)](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry"), a structure or database table can be given a source-code-based enhancement known as an append structure in [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry"). Here, however, the source code of an append structure is not saved and transported. Instead, the source code of an existing append structure is generated from the metadata of the associated system tables. When saved, the metadata is derived directly from the append structure and saved to the system tables.

-   [EXTEND TYPE](javascript:call_link\('abenddicddl_extend_type.htm'\))

Note

Each property of an append structure can be defined using either EXTEND TYPE or in the transaction SE11.

Continue
[EXTEND TYPE](javascript:call_link\('abenddicddl_extend_type.htm'\))



**📖 Source**: [abenddic_extend_type.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_extend_type.htm)

### abenddic_append_structures.htm

> **📖 Official SAP Documentation**: [abenddic_append_structures.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_append_structures.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Enhancements](javascript:call_link\('abenddic_enhancements.htm'\)) → 

Append Structures

An append structure is a structure in ABAP Dictionary appended to another [structure](javascript:call_link\('abenddic_structures.htm'\)) or [database table](javascript:call_link\('abenddic_database_tables.htm'\)) and which adds its components to this structure or table. In customer systems, append structures can be added to structures and database tables delivered by SAP. An append structure is assigned to exactly one table or structure. There can, however, be more than one append structure for a table or structure. The components of append structures must meet the [prerequisites](javascript:call_link\('abenddic_database_tables_techstruc.htm'\)) for table fields.

The following enhancements can be made to a database table or structure using an append structure:

-   New components inserted (if permitted by the [enhancement category](javascript:call_link\('abenddic_structures_enh_cat.htm'\)))

-   [Foreign keys](javascript:call_link\('abenforeign_key_glosry.htm'\) "Glossary Entry") defined for existing fields of a database table

-   [Search helps](javascript:call_link\('abensearch_help_glosry.htm'\) "Glossary Entry") bound to existing components

All enhancements are part of the append structure, which means that any changes made to these enhancements are made only using the append structure. The same applies to transports. When a database table or structure is activated, all associated append structures are found and their components are appended to the database table or structure. Any foreign keys or search help bindings added using the append structure are also appended. When an append structure is activated, the assigned database table or structure is adapted to the changes made. Any existing tables are not [converted](javascript:call_link\('abenddic_database_tables_conv.htm'\)), which can put the fields in the dictionary in a different order from the order on the database. When a structure or database table with an append structure is copied, the appended fields, foreign keys, and search helps become real elements of the target of the copy.

The following must be noted when using append structures to enhance database tables:

-   Append structures can only be appended to [transparent tables](javascript:call_link\('abentransparent_table_glosry.htm'\) "Glossary Entry").

-   No append structures can be appended to database tables with fields of the type LCHR or LRAW, since these fields must always be the last field of the table.

-   Any fields appended to a database table using an append structure can be added to its [secondary indexes](javascript:call_link\('abenddic_database_tables_index.htm'\)). No secondary index can be defined for the append structure itself.

-   A binding of a check table or search help that already exists for a field of the database table cannot be modified using the append structure.

Enhancements of SAP structures or SAP tables using append structures in customer systems do not constitute modifications. Append structures created for SAP objects in customer systems are in the customer namespace (or in the namespace of a partner of a special development project) and hence are protected from being overwritten by upgrades. It is advisable to also create the components of append structures of this type with names from the customer namespace to avoid naming conflicts. After an upgrade, the associated append structures are again appended to tables modified by SAP.

Append structures can be defined as form-based structures in transaction SE11 or as source-code-based structures using [Dictionary DDL](javascript:call_link\('abendictionary_ddl_glosry.htm'\) "Glossary Entry") in the [ABAP Development Tools](javascript:call_link\('abenadt_glosry.htm'\) "Glossary Entry"). The following section is a summary of the syntax of the source code-based definition:

-   [Dictionary DDL for Structure Enhancements](javascript:call_link\('abenddic_extend_type.htm'\))

Note

The same structure can be appended to multiple database tables or structures by including it in the individual append structures as an include structure.

Example

The append structure DEMO\_APPEND\_STRUCTURE enhances the structure DEMO\_STRUCTURE.

Continue
[Dictionary DDL for Structure Enhancements](javascript:call_link\('abenddic_extend_type.htm'\))



**📖 Source**: [abenddic_append_structures.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_append_structures.htm)

### abenddic_append_views.htm

> **📖 Official SAP Documentation**: [abenddic_append_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_append_views.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Enhancements](javascript:call_link\('abenddic_enhancements.htm'\)) → 

Append Views

[Database views](javascript:call_link\('abenddic_database_views.htm'\)) delivered by SAP can be enhanced by partners and customers using views known as append views, without making any modifications. The name of an append view is subject to the same rules as the name of a classic [view](javascript:call_link\('abenddic_views.htm'\)) and should be located in the customer namespace (or in the namespace of a partner or special development) to protect it against being overwritten by upgrades or new releases.

Further fields from basis tables in the database view can be added to append views as view fields. Append views cannot be used to add further basis tables to the view or to modify the join conditions or selection conditions of a database view. An append view is assigned to exactly one database view. More than one append view can be created for a database view.

When an append view is activated, an [append structure](javascript:call_link\('abenappend_structure_glosry.htm'\) "Glossary Entry") with this name is created in ABAP Dictionary and its components become the additional view fields of the append view.

If a database view is activated, all append views for this view are found and their fields are appended to the database view. The append structure of the append view is added to the structure of the database view. If an append view is created or modified, the associated database view is adjusted to this change automatically when the append view is activated.

Notes

-   Append views are possible only for database views and not for other [views](javascript:call_link\('abenddic_views.htm'\)).

-   In the case of [CDS views](javascript:call_link\('abencds_view_glosry.htm'\) "Glossary Entry"), [CDS view enhancements](javascript:call_link\('abencds_view_extend_glosry.htm'\) "Glossary Entry") are a separate option for enhancements and work in the similar way to append views. When a CDS view enhancement is created, an append view is created that enhances the [CDS database view](javascript:call_link\('abencds_database_view_glosry.htm'\) "Glossary Entry").

Example

The database view DEMO\_ORIGINAL is enhanced using the append view DEMO\_APPEND\_VIEW. The program DEMO\_APPEND\_VIEW uses [SELECT](javascript:call_link\('abapselect.htm'\)) to access the enhanced view and also displays the components of the structures in question.



**📖 Source**: [abenddic_append_views.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_append_views.htm)

### abenddic_fixed_value_appends.htm

> **📖 Official SAP Documentation**: [abenddic_fixed_value_appends.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_fixed_value_appends.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Enhancements](javascript:call_link\('abenddic_enhancements.htm'\)) → 

Fixed Value Appends

[Domains](javascript:call_link\('abenddic_domains.htm'\)) delivered by SAP can be enhanced by partners and customers using appends known as fixed value appends, without making any modifications. The name of a fixed value append is subject to the same rules as the name of a domain and should be located in the customer namespace (or in the namespace of a partner or special development) to protect it against being overwritten by upgrades or new releases.

A fixed value append adds further [fixed values](javascript:call_link\('abenfixed_value_glosry.htm'\) "Glossary Entry") or intervals to the value range of a domain. A domain can have more than one fixed value append.

When a domain is activated, all fixed value appends for this domain are found and their fixed values and intervals added to the domain. When a fixed value append is created or modified, the associated domain is adjusted to this change automatically when the fixed value append is activated.

Example

The fixed value append DEMO\_FIXED\_VALUE\_APPEND is added to the domain DEMO\_ORIGINAL. The program DEMO\_FIXED\_VALUE\_APPEND reads the fixed values and intervals of the extended domain and displays them. In the table, the column APPVAL indicates which fixed values and intervals come from the fixed value append.


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Replacement Objects

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Replacement Objects

Included pages: 2



**📖 Source**: [abenddic_fixed_value_appends.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_fixed_value_appends.htm)

### abenddic_replacement_objects.htm

> **📖 Official SAP Documentation**: [abenddic_replacement_objects.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_replacement_objects.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) → 

Replacement Objects

A [CDS view](javascript:call_link\('abencds_view_glosry.htm'\) "Glossary Entry") can be assigned to a [transparent](javascript:call_link\('abentransparent_table_glosry.htm'\) "Glossary Entry") [database table](javascript:call_link\('abenddic_database_tables.htm'\)) and classic [database view](javascript:call_link\('abenddic_database_views.htm'\)) in ABAP Dictionary as a replacement object using the name of its [CDS entity](javascript:call_link\('abencds_entity_glosry.htm'\) "Glossary Entry"). A prerequisite is that the structure type defined by the CDS view matches the structure of the database table or classic view as follows:

-   The number of components must match.

-   It must be possible to assign a component of the CDS view to each component of the database table or classic view:

-   A [client column](javascript:call_link\('abenclient_column_glosry.htm'\) "Glossary Entry") is assigned regardless of its name.

-   For all other components of the database table, an identically named element of the CDS view must exist.

The order of the components in the database table and the CDS view does not need to match.

-   The technical type properties [built-in data type](javascript:call_link\('abenddic_builtin_types.htm'\)), length, and number of decimal places must match for all assigned components.

-   The CDS view cannot have any input parameters.

-   It is not possible to have both a replacement object defined and table buffering switched on for a database view whose maintenance status is modifiable.

If a database table or a classic view is accessed and a replacement object is assigned to the table or view in the following cases, the replacement object is evaluated instead of the database table or classic view:

-   When used as a [data source](javascript:call_link\('abapselect_data_source.htm'\)) of a [SELECT](javascript:call_link\('abapselect.htm'\)) statement in [ABAP SQL](javascript:call_link\('abenopen_sql_glosry.htm'\) "Glossary Entry"). This also applies to [subqueries](javascript:call_link\('abensubquery_glosry.htm'\) "Glossary Entry") in any ABAP SQL statement and to the statements [OPEN CURSOR](javascript:call_link\('abapopen_cursor.htm'\)) and [FETCH](javascript:call_link\('abapfetch.htm'\)). This bypasses any [table buffering](javascript:call_link\('abensap_puffering.htm'\)) defined for the database table or the classic view.

-   When a [foreign key relationship](javascript:call_link\('abenforeign_key_dependency_glosry.htm'\) "Glossary Entry") is checked for Web Dynpros or dynpros.

All other access types are still performed on the database table or classic view, such as:

-   Writes in ABAP SQL

-   [Writes](javascript:call_link\('abenopen_sql_writing.htm'\)) in ABAP SQL

-   Use of the addition [SINGLE FOR UPDATE](javascript:call_link\('abapselect_single.htm'\)) in the statement [SELECT](javascript:call_link\('abapselect.htm'\))

Writes of this type produce a syntax check warning.

-   Use in other database objects, such as:

-   Use as a data source of a view defined on the database

-   Access from database procedures or database functions

Here it is not important how the database object was created, which means that, in addition to native views, the views defined for [classic](javascript:call_link\('abenclassical_view_glosry.htm'\) "Glossary Entry") [database views](javascript:call_link\('abendatabase_view_glosry.htm'\) "Glossary Entry") in ABAP Dictionary or for [CDS views](javascript:call_link\('abencds_view_glosry.htm'\) "Glossary Entry") on the database also do not access the replacement object. A similar principle applies to [AMDP procedures](javascript:call_link\('abenamdp_procedure_glosry.htm'\) "Glossary Entry") and [AMDP functions](javascript:call_link\('abenamdp_function_glosry.htm'\) "Glossary Entry"). Even if ABAP SQL is used to access a classic database view in ABAP Dictionary, a CDS view, or a [CDS table function](javascript:call_link\('abencds_table_function_glosry.htm'\) "Glossary Entry") comprising database tables with replacement objects, no redirection is performed. In these cases, the replacement object must be accessed directly. For classic database views, a replacement object can be created that performs this task without the need to modify the programs.

-   Access types other than with ABAP SQL, for example:

-   Access with [IMPORT](javascript:call_link\('abapimport_data_cluster.htm'\)) FROM [DATABASE](javascript:call_link\('abapimport_medium.htm'\)) or [EXPORT](javascript:call_link\('abapexport_data_cluster.htm'\)) TO [DATABASE](javascript:call_link\('abapexport_data_cluster_medium.htm'\)).

-   Access using [Native SQL](javascript:call_link\('abennative_sql.htm'\)) ([ADBC](javascript:call_link\('abenadbc_glosry.htm'\) "Glossary Entry"), [EXEC SQL](javascript:call_link\('abapexec.htm'\))), and [AMDP](javascript:call_link\('abenamdp_glosry.htm'\) "Glossary Entry").

When a replacement object is defined for a database table for a classic database view, the system checks whether the specified CDS view meets the prerequisites. If a CDS view used as a replacement object is changed later and the prerequisites are no longer met, a runtime error DBSQL\_REDIRECT\_INCONSISTENCY occurs when an ABAP SQL read is performed on the database table or on the database view.

No replacement objects can be defined for [global temporary tables](javascript:call_link\('abenglobal_temporary_table_glosry.htm'\) "Glossary Entry"). In customer systems, replacement objects can only be defined for self-defined database views and not for database tables.

If there is a diversion to a CDS view for which one or more [CDS roles](javascript:call_link\('abencds_role_glosry.htm'\) "Glossary Entry") are defined as part of the [CDS access control,](javascript:call_link\('abencds_access_control_glosry.htm'\) "Glossary Entry") the associated access conditions are not evaluated when the replacement object is accessed.

Notes

-   Extreme care should be taken when specifying a replacement object for a database table or a database view. Incorrect usage can cause inconsistencies.

-   Replacement objects are mainly intended for existing aggregate tables. These are database tables, which contain aggregated data from other tables. Instead of aggregating data in an ABAP program and writing data to an aggregate table, which can be exclusively accessed by reads in programs, the aggregation can be performed for every read using the CDS view. This prevents redundant data from being stored. In addition, aggregation on the database can improve performance if it is necessary to read large volumes of data for aggregation in ABAP. Replacement objects can make this possible without invalidating the programs.

-   A prerequisite for assigning a replacement object to an existing database table or database view is that the CDS view returns the expected data and that, apart from aggregation, only ABAP SQL reads are performed on the aggregate table.

-   Once a replacement object is defined, no further writes should be performed on an aggregate table. These writes produce a syntax check warning and are scheduled to be disallowed in an upcoming release.

-   Make sure that, apart from the use of ABAP SQL, no other type of access is performed on an aggregate table with a replacement object. More specifically, CDS views used as a replacement object are not allowed to access the replaced object, because the content is usually no longer updated.

-   It is not advisable to transport table content for which a replacement object is defined. This content is scheduled to no longer be transported in an upcoming release.

-   Table buffering should be deactivated for an aggregate table for which a replacement object is defined to prevent buffer invalidations.

-   In customer systems, it may be useful to define a replacement object for a self-defined classic database view, if a replacement object was defined for one of their basis tables at SAP. In this case, the replacement object of the view must access the replacement object of the basis table.

-   If a database table or a classical view , which a replacement object is defined for, is [extended](javascript:call_link\('abenddic_enhancements.htm'\)) in a follow-on system, the assigned CDS view must also be extended accordingly with [EXTEND VIEW](javascript:call_link\('abencds_f1_extend_view.htm'\)).

-   The classic [projection view](javascript:call_link\('abenprojection_view_glosry.htm'\) "Glossary Entry"), [maintenance views](javascript:call_link\('abenmaintenance_view_glosry.htm'\) "Glossary Entry"), and [help views](javascript:call_link\('abenhelp_view_glosry.htm'\) "Glossary Entry") are not defined on the database. Access to their basis tables is carried out on AS ABAP by using ABAP SQL. If a basis table has a replacement object, its reads are redirected as required.

-   Frameworks that use ABAP SQL, such as [Data Browser](javascript:call_link\('abendata_browser_glosry.htm'\) "Glossary Entry"), automatically access replacement objects if these objects are defined for a database table or a database view. Frameworks that use Native SQL or AMDP, such as [SADL](javascript:call_link\('abensadl_glosry.htm'\) "Glossary Entry"), have to make sure that they access a replacement object rather than the database table or the database view.

-   Wherever possible, any programs that directly accessed aggregate tables or views with aggregate tables as basis tables should be modified so that they directly access the CDS views that are used as replacement objects. However, this cannot usually be done by simply replacing the data source in the relevant SELECT statements. This is because a [client-specific CDS view](javascript:call_link\('abencds_client_handling.htm'\)) does not have a client column and therefore the used target objects no longer match. Furthermore, if a CDS view is accessed directly, the [CDS roles](javascript:call_link\('abencds_role_glosry.htm'\) "Glossary Entry") defined for it also have an effect.

-   Replacement objects cannot be defined for the following:

-   [Projection Views](javascript:call_link\('abenddic_projection_views.htm'\))

-   [Maintenance Views](javascript:call_link\('abenddic_maintenance_views.htm'\))

-   [Help Views](javascript:call_link\('abenddic_help_views.htm'\))

Executable Example

[Replacement Object for Database Table](javascript:call_link\('abenddic_replacement_object_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Replacement Object for Database Table](javascript:call_link\('abenddic_replacement_object_abexa.htm'\))



**📖 Source**: [abenddic_replacement_objects.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_replacement_objects.htm)

### abenddic_replacement_object_abexa.htm

> **📖 Official SAP Documentation**: [abenddic_replacement_object_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_replacement_object_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP - Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)) →  [Classic Objects in ABAP Dictionary](javascript:call_link\('abenddic_classical_objects.htm'\)) →  [Replacement Objects](javascript:call_link\('abenddic_replacement_objects.htm'\)) → 

Replacement Object for Database Table

This example demonstrates a database table with a [replacement object](javascript:call_link\('abenreplacement_object_glosry.htm'\) "Glossary Entry").

Source Code

REPORT demo\_table\_replacement\_object.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      class\_constructor,
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    "Aggregate table (GTT)
    SELECT FROM demo\_sumdist\_agg
           FIELDS \*
           ORDER BY PRIMARY KEY
           INTO TABLE @DATA(result\_agg).
    DELETE FROM demo\_sumdist\_agg.
    "Table with replacement object
    SELECT FROM demo\_sumdist
           FIELDS \*
           ORDER BY PRIMARY KEY
           INTO TABLE @DATA(result).
    ASSERT result = result\_agg.
    "Direct access to CDS view
    SELECT FROM demo\_cds\_sumdist
           FIELDS @sy-mandt AS mandt, demo\_cds\_sumdist~\*
           ORDER BY PRIMARY KEY
           INTO TABLE @DATA(result\_cds).
    ASSERT result\_cds = result.
    out->write( result ).
    "Classic view on demo\_sumdist without replacement object
    SELECT FROM demo\_sumdist\_obs
           FIELDS \*
           ORDER BY PRIMARY KEY
           INTO TABLE @DATA(result\_view\_obs).
    IF result <> result\_view\_obs.
      out->write(
        'Classic view without replacement object differs.' ).
    ENDIF.
    "Classic view on demo\_sumdist with replacement object
    SELECT FROM demo\_sumdistview
           FIELDS \*
           ORDER BY PRIMARY KEY
           INTO TABLE @DATA(result\_view).
    IF result =  result\_view.
      out->write(
        'Classic view with replacement object is the same.' ).
    ENDIF.
    out->display( ).  ENDMETHOD.
  METHOD class\_constructor.
    DELETE FROM demo\_sumdist\_agg.
    INSERT demo\_sumdist\_agg FROM
      ( SELECT
          FROM scarr AS s
            INNER JOIN spfli AS p ON s~carrid = p~carrid
          FIELDS s~carrname,
                 p~distid,
                 SUM( p~distance ) AS sum\_distance
          GROUP BY s~mandt, s~carrname, p~distid ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This program accesses two database tables, DEMO\_SUMDIST\_AGG and DEMO\_SUMDIST. These tables are identical except for the fact that the [CDS view](javascript:call_link\('abencds_view_glosry.htm'\) "Glossary Entry") DEMO\_CDS\_SUMDIST is defined as a [replacement object](javascript:call_link\('abenddic_replacement_objects.htm'\)) for DEMO\_SUMDIST.

The database table DEMO\_SUMDIST\_AGG is filled with aggregated data (done here in the static constructor of the class demo). When DEMO\_SUMDIST is accessed, the replacement object performs exactly the same aggregation:

@AbapCatalog.sqlViewName: 'DEMO\_CDS\_SUDI'
@AccessControl.authorizationCheck: #NOT\_REQUIRED
define view demo\_cds\_sumdist(
client,
carrname,
distid,
sum\_distance
)
as select from
scarr as s
join spfli as p on
s.carrid = p.carrid
{
key s.mandt,
key s.carrname,
key p.distid,
sum(p.distance)
}
group by
s.mandt,
s.carrname,
p.distid    

Similar access to the database tables produce similar results, which can be verified using the statement [ASSERT](javascript:call_link\('abapassert.htm'\)).

A third SELECT statement accesses the [CDS view](javascript:call_link\('abencds_view_glosry.htm'\) "Glossary Entry") DEMO\_CDS\_SUMDIST directly. To produce the same results set for the comparison with the other results as when accessing the database tables, the [client column](javascript:call_link\('abenclient_column_glosry.htm'\) "Glossary Entry") must be added, since the results set of a [client-specific CDS view](javascript:call_link\('abencds_client_handling.htm'\)) does not contain a column of this type.

A [classic](javascript:call_link\('abenclassical_view_glosry.htm'\) "Glossary Entry") [database view](javascript:call_link\('abendatabase_view_glosry.htm'\) "Glossary Entry") DEMO\_SUMDIST\_OBS contains the database table DEMO\_SUMDIST as a basis table. There is no redirect to the replacement object of DEMO\_SUMDIST in a SELECT. A classic database view DEMO\_SUMDISTVIEW that is otherwise similar has the following CDS view as a replacement object:

@AbapCatalog.sqlViewName: 'DEMO\_CDS\_SUDIV'
@AccessControl.authorizationCheck: #NOT\_REQUIRED
define view demo\_cds\_sumdistview
as select from
demo\_cds\_sumdist
{
key client,
key carrname,
key distid,
sum\_distance
}    

This view accesses the replacement object of the database table DEMO\_SUMDIST. When DEMO\_SUMDISTVIEW is accessed using SELECT, its replacement object is evaluated and the result again matches the preceding result.


---


## ABAP Keyword Documentation / ABAP − Reference / ABAP Syntax / ABAP Statements / Operands / Data Objects in Operand Positions

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / ABAP Syntax / ABAP Statements / Operands / Data Objects in Operand Positions

Included pages: 6



**📖 Source**: [abenddic_replacement_object_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenddic_replacement_object_abexa.htm)

### abenoperands_data_objects.htm

> **📖 Official SAP Documentation**: [abenoperands_data_objects.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenoperands_data_objects.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [ABAP Syntax](javascript:call_link\('abenabap_syntax.htm'\)) →  [ABAP Statements](javascript:call_link\('abenabap_statements.htm'\)) →  [Operands](javascript:call_link\('abenoperands.htm'\)) → 

Data Objects in Operand Positions

When using data objects in operand positions, reading positions and writing positions must be distinguished. The data type and content of the specified data objects must also be appropriate for the operand position.

-   [Reading Positions](javascript:call_link\('abendata_objects_usage_reading.htm'\))

-   [Writing Positions](javascript:call_link\('abendata_objects_usage_writing.htm'\))

-   [Substring Access](javascript:call_link\('abenoffset_length.htm'\))

Continue
[Read Positions](javascript:call_link\('abendata_objects_usage_reading.htm'\))
[Writer Positions](javascript:call_link\('abendata_objects_usage_writing.htm'\))
[Substring Access](javascript:call_link\('abenoffset_length.htm'\))



**📖 Source**: [abenoperands_data_objects.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenoperands_data_objects.htm)

### abendata_objects_usage_reading.htm

> **📖 Official SAP Documentation**: [abendata_objects_usage_reading.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendata_objects_usage_reading.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [ABAP Syntax](javascript:call_link\('abenabap_syntax.htm'\)) →  [ABAP Statements](javascript:call_link\('abenabap_statements.htm'\)) →  [Operands](javascript:call_link\('abenoperands.htm'\)) →  [Data Objects in Operand Positions](javascript:call_link\('abenoperands_data_objects.htm'\)) → 

Read Positions

At a read position, the content of an operand is only read, and not changed, when the statement is executed. Data objects can be specified as followed at read positions:

-   As a [literal](javascript:call_link\('abenliteral_glosry.htm'\) "Glossary Entry").
    

-   As a [data object visible](javascript:call_link\('abenlifetime_and_visibility.htm'\)) in this place using a name dobj, a [field symbol](javascript:call_link\('abenfield_symbol_glosry.htm'\) "Glossary Entry") <fs>, or a data reference dref->\* dereferenced using the [dereferencing operator](javascript:call_link\('abendereferencing_operat_glosry.htm'\) "Glossary Entry") \->\* (providing dref is specified in full).
    Here, the names of data objects also include any [text symbols](javascript:call_link\('abentext_symbol_glosry.htm'\) "Glossary Entry") specified using the following:
    ... text-idf ...,
    Here, idf is the three-character ID of the text symbol or chainings of reference variables. If a field symbol is used, it must be assigned to a memory area and a data reference must point to a data object. Otherwise an unhandleable exception is raised. As an alternative to specifying a text symbol using text-idf, the three-character code of a text symbol can be appended to the [text field literal](javascript:call_link\('abentext_field_literal_glosry.htm'\) "Glossary Entry") in parentheses:
    ... '...'(idf) ...
    If the text symbol exists in the currently loaded [text pool](javascript:call_link\('abentext_pool_glosry.htm'\) "Glossary Entry"), the content of the text symbol is used instead of the text field literal, otherwise the literal is used.

-   If the data object is an internal table, the expressions dobj\[\], <fs>\[\], or dref->\*\[\] can also be used. An exception to this is when specifying the internal table of a [table expression](javascript:call_link\('abentable_expression_glosry.htm'\) "Glossary Entry"), where \[\] cannot be appended to the name. In the case of dobj\[\], this ensures that the [table body](javascript:call_link\('abentable_body_glosry.htm'\) "Glossary Entry") is addressed and no [header lines](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry"). If an internal table does not have a header line, its simple name dobj (without \[\]) is interpreted as the table body in all operand positions. However, if an internal table does have a header line, its simple name dobj (without \[\]) is interpreted as the header line and not the table body in almost all operand positions. The operand positions in which the name of an internal table with a header line is interpreted as the internal table are specified under [internal tables with headers](javascript:call_link\('abenitab_header_line.htm'\)).

-   As a [subarea](javascript:call_link\('abenoffset_length.htm'\)) of a character-like or byte-like data object (or a character-like initial part of a structure) by specifying an [offset/length](javascript:call_link\('abenoffset_length_specific_glosry.htm'\) "Glossary Entry").

-   In some positions, number values must be specified directly as digits, although it is often not possible to specify a sign (which is not the case with [numeric literals](javascript:call_link\('abennumeric_literal_glosry.htm'\) "Glossary Entry")). Examples are numbers specified in declarative statements for the length of elementary data objects or for the initial memory requirements of internal tables.

Notes

-   Text symbols cannot be listed at all read positions. For example, they are not permitted for specifying the target of dynamic [executions](javascript:call_link\('abenabap_execution.htm'\)).

-   A [system field](javascript:call_link\('abensystem_field_glosry.htm'\) "Glossary Entry") should only be specified as an operand in a reading position if its content is not set by the same statement, since otherwise undefined behavior may occur.

-   The predicate expressions [IS ASSIGNED](javascript:call_link\('abenlogexp_assigned.htm'\)) and [IS BOUND](javascript:call_link\('abenlogexp_assigned.htm'\)) can be used to check whether field symbols or data references.

-   A data reference variable with a generic static type can only be deserialized using the statement [ASSIGN dref->\* TO <fs>](javascript:call_link\('abapassign_mem_area_dynamic_dobj.htm'\)).

-   In many reading positions, [functions or expressions](javascript:call_link\('abenoperands_expressions.htm'\)) can be specified as well as data objects.

-   [Enumerated objects](javascript:call_link\('abenenumerated_object_glosry.htm'\) "Glossary Entry") with an [enumerated type](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry") can be used in all reading positions in which the operand type is their enumerated type or in which the operand is converted to one of the character-like types c or string.



**📖 Source**: [abendata_objects_usage_reading.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendata_objects_usage_reading.htm)

### abendata_objects_usage_writing.htm

> **📖 Official SAP Documentation**: [abendata_objects_usage_writing.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendata_objects_usage_writing.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [ABAP Syntax](javascript:call_link\('abenabap_syntax.htm'\)) →  [ABAP Statements](javascript:call_link\('abenabap_statements.htm'\)) →  [Operands](javascript:call_link\('abenoperands.htm'\)) →  [Data Objects in Operand Positions](javascript:call_link\('abenoperands_data_objects.htm'\)) → 

Writer Positions

In a writer position, the content of the operand is changed when the statement is executed. Only modifiable data objects (that is, no literals, text symbols, constants, or non-modifiable formal parameters) can be specified as follows in writer positions:

-   A [visible data object](javascript:call_link\('abenlifetime_and_visibility.htm'\)) specified in this place using a name dobj, a field symbol <fs>, or a dereferenced data reference dref->\* (if dref is typed in full). Like in [reading positions](javascript:call_link\('abenreading_position_glosry.htm'\) "Glossary Entry"), \[\] can be appended in internal tables, to address the [table body](javascript:call_link\('abentable_body_glosry.htm'\) "Glossary Entry").

-   A [subarea](javascript:call_link\('abenoffset_length.htm'\)) of a [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like or byte-like data object specified using an [offset/length](javascript:call_link\('abenoffset_length_specific_glosry.htm'\) "Glossary Entry"). An offset or length cannot be specified in writing positions for data objects of the [deep](javascript:call_link\('abendeep_glosry.htm'\) "Glossary Entry") data types string and xstring.

-   In a [declaration position](javascript:call_link\('abendeclaration_position_glosry.htm'\) "Glossary Entry"), an [inline declaration](javascript:call_link\('abeninline_declaration_glosry.htm'\) "Glossary Entry") of a data object or field symbol can be made using a [declaration expression](javascript:call_link\('abendeclaration_expression_glosry.htm'\) "Glossary Entry").

-   [Writable expressions](javascript:call_link\('abenwritable_expression_glosry.htm'\) "Glossary Entry") can be specified in a [result position](javascript:call_link\('abenresult_position_glosry.htm'\) "Glossary Entry").

Writer-only positions, where an operand is overwritten without being read, and writer positions where an operand is read and written are both available.

Notes

-   In [some writing positions](javascript:call_link\('abenexpression_positions_write.htm'\)), certain expressions can also be specified.

-   [Enumerated variables](javascript:call_link\('abenenumerated_variable_glosry.htm'\) "Glossary Entry") can only be used in writing positions in which the operand type is the enumerated type and only the associated [enumerated values](javascript:call_link\('abenenumerated_value_glosry.htm'\) "Glossary Entry") can be written.



**📖 Source**: [abendata_objects_usage_writing.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendata_objects_usage_writing.htm)

### abenoffset_length.htm

> **📖 Official SAP Documentation**: [abenoffset_length.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenoffset_length.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [ABAP Syntax](javascript:call_link\('abenabap_syntax.htm'\)) →  [ABAP Statements](javascript:call_link\('abenabap_statements.htm'\)) →  [Operands](javascript:call_link\('abenoperands.htm'\)) →  [Data Objects in Operand Positions](javascript:call_link\('abenoperands_data_objects.htm'\)) → 

Substring Access

In operand positions, subareas of certain data objects can be accessed by specifying an offset/length:

Syntax

dobj*\[*+off*\]**\[*(len)*\]*

<fs>*\[*+off*\]**\[*(len)*\]*

dref->\**\[*+off*\]**\[*(len)*\]*

Effect

A specified offset or length is directly appended to either the dobj descriptor of the data object, an <fs> field symbol, or a dereferenced data reference variable dref->\*. Offsets/lengths can be specified for:

-   [Elementary](javascript:call_link\('abenelementary_data_object_glosry.htm'\) "Glossary Entry") [byte-like data objects](javascript:call_link\('abenbyte_like_data_object_glosry.htm'\) "Glossary Entry")

-   [Elementary](javascript:call_link\('abenelementary_data_object_glosry.htm'\) "Glossary Entry") [character-like data objects](javascript:call_link\('abencharlike_data_object_glosry.htm'\) "Glossary Entry")

-   [Flat structures](javascript:call_link\('abenflat_structure_glosry.htm'\) "Glossary Entry") where one of the following prerequisites must be met:

-   The structure contains flat character-like components only.

-   The first fragment of the [structure fragment view](javascript:call_link\('abenunicode_fragment_view_glosry.htm'\) "Glossary Entry") is flat and character-like, and the substring addressed by specifying the offset and length is located within this fragment.

The following restrictions apply:

-   In [write positions](javascript:call_link\('abenwriting_position_glosry.htm'\) "Glossary Entry"), only flat data objects are permitted; it is not possible to write to substrings of strings.

-   Access to substrings of strings is also not possible in the following [reading positions](javascript:call_link\('abenreading_position_glosry.htm'\) "Glossary Entry"):

-   dobj*\[*+off*\]**\[*(len)*\]* specified as a memory area [mem\_area](javascript:call_link\('abapassign_mem_area_static_dobj.htm'\)) of the statement [ASSIGN](javascript:call_link\('abapassign.htm'\)).

-   dobj*\[*+off*\]**\[*(len)*\]* specified as an argument of the statement [GET REFERENCE](javascript:call_link\('abapget_reference.htm'\)) or the reference operator [REF](javascript:call_link\('abenconstructor_expression_ref.htm'\)).

-   dobj*\[*+off*\]**\[*(len)*\]* specified as an actual parameter for input parameters in calls of [methods](javascript:call_link\('abenmethod_calls.htm'\)), [function modules](javascript:call_link\('abapcall_function.htm'\)) , and [subroutines](javascript:call_link\('abapperform.htm'\)) .

-   Offsets/lengths cannot be specified for literals or text symbols.

-   A specified offset/length cannot be appended directly to a table expression [itab\[ ... \]](javascript:call_link\('abentable_expressions.htm'\)), but this is possible after a [chaining](javascript:call_link\('abentable_exp_chaining.htm'\)) whose final place is a suitable structure component after a structure component selector.

-   No offset or length can be specified for an [enumerated object](javascript:call_link\('abenenumerated_object_glosry.htm'\) "Glossary Entry") with an [enumerated type](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry"), regardless of the [base type](javascript:call_link\('abenbase_type_glosry.htm'\) "Glossary Entry").

-   In the case of dynamically [specified operands](javascript:call_link\('abenoperands_specifying.htm'\)) in parentheses, no lengths can be specified.

-   A dereferenced data reference variable dref->\* must be typed in full.

-   For a [writable expression](javascript:call_link\('abenwritable_expression_glosry.htm'\) "Glossary Entry"), offsets/lengths cannot be specified as [memory areas](javascript:call_link\('abapassign_mem_area_writable_exp.htm'\)) in the statement ASSIGN or as arguments of the reference operator [REF](javascript:call_link\('abenconstructor_expression_ref.htm'\)) (table expressions only).

The segment of the data object is used that has the offset specified in off and the length (in characters or bytes) specified in len. A memory area must not be addressed outside the field boundaries, except in the case of the statement [ASSIGN](javascript:call_link\('abapassign.htm'\)). In an offset specified without a length, the entire substring is addressed from off characters; for a length specified without an offset, the first len characters are addressed (different rules apply to the statement [ASSIGN](javascript:call_link\('abapassign.htm'\))).

The operands off and len expect data objects of the type i. These data objects must contain positive integers, with the following exceptions.

-   The length 0 can be specified for [strings](javascript:call_link\('abenstring_glosry.htm'\) "Glossary Entry").

-   A negative offset (but never length 0) can be specified if an <fs> field symbol is specified in the statement [ASSIGN](javascript:call_link\('abapassign_mem_area_static_dobj.htm'\)) for dobj.

-   If off is less than the length of dobj, an asterisk (\*) can be specified for len. The upper limit of dobj then determines the upper limit of the memory area.

If the prerequisites are not met or if the subarea defined by off and len is not completely contained in the data object (except in the case of [ASSIGN](javascript:call_link\('abapassign.htm'\))), a syntax error occurs (if statically identifiable). Otherwise, an exception of the class CX\_SY\_RANGE\_OUT\_OF\_BOUNDS is raised. If off is specified as a numeric literal, this literal cannot be prefixed with a sign.

The offset and length specifications are counted in characters for character-like data objects and in bytes for all other data objects.

A substring specified by an offset or length specification is treated like a data object of the specified length for which the data type depends on the data type of the original data object, the field symbol, or the data reference variable, as shown below:

Original Data Type

Data Type of Substring

c

c

n

n

d

n

t

n

string

string

x

x

xstring

xstring

Structure type

c

If the length of the substring matches the length of the structure in a substring access to a structure exactly, the substring does not have data type c and is handled like the structure itself instead.

Notes

-   For reads on substrings of character-like data objects, built-in [substring functions](javascript:call_link\('abensubstring_functions.htm'\)) that allow searches by specifying both substring and offset/lengths are available. The substring functions can also be used to edit arguments where offsets and lengths cannot be specified, such as data objects with an [enumerated type](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry"). This is because an implicit conversion to string is performed here.

-   It is a good idea to specify offsets with the value 0 explicitly too (that is, dobj+0(len) instead of dobj(len)). This distinguishes a substring access in the source code clearly from other language constructs that also use parentheses, such as dynamic specifications, method calls, or inline declarations.

-   dobj+0(\*), dobj+0, or dobj(\*) are always interpreted as dobj. In this case, dobj can also be a data object where substring access according to the rules above is not possible.

-   No substring access cnt(len), sum(len) can be performed on data objects called cnt and sum unless an offset is specified explicitly. The compiler always interprets this as a [number](javascript:call_link\('abapcnt.htm'\)) or [sum](javascript:call_link\('abapsum.htm'\)) of a field len in the group level processing of an [extract dataset](javascript:call_link\('abenextract_dataset_glosry.htm'\) "Glossary Entry").

-   [Obsolete syntax forms](javascript:call_link\('abentokenization_obsolete.htm'\)) can still occur with substring access (apart from with classes).

-   The statement [MOVE PERCENTAGE](javascript:call_link\('abapmove_percentage.htm'\)) indicates an obsolete form of substring access.

Example

The following structure has both character-like and non-character-like components:

DATA:
  BEGIN OF struc,
    a TYPE c LENGTH 3,    "Length 3 characters
    b TYPE n LENGTH 4,    "Length 4 characters
    c TYPE d,             "Length 8 characters
    d TYPE t,             "Length 6 characters
    e TYPE decfloat16,    "Length 8 bytes
    f TYPE c LENGTH 28,   "Length 28 characters
    g TYPE x LENGTH 2,    "Length 2 bytes
  END OF struc.

The [fragment view](javascript:call_link\('abenunicode_fragment_view_glosry.htm'\) "Glossary Entry") splits the structure into five areas, F1 - F5.

\[ aaa | bbbb | cccccccc | ddd | AAA | eeee | fffffffffffff | gg \]
\[            F1               |  F2 |  F3  |       F4      | F5 \]

Offset/length accesses are possible on the character-like initial fragment F1 only, for example struc(21) or struc+7(14). An access such as struc+57(2), for example, is not permitted.

Executable Example

[Substrings](javascript:call_link\('abendata_process_fields_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Substrings](javascript:call_link\('abendata_process_fields_abexa.htm'\))



**📖 Source**: [abenoffset_length.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenoffset_length.htm)

### abendata_process_fields_abexa.htm

> **📖 Official SAP Documentation**: [abendata_process_fields_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendata_process_fields_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [ABAP Syntax](javascript:call_link\('abenabap_syntax.htm'\)) →  [ABAP Statements](javascript:call_link\('abenabap_statements.htm'\)) →  [Operands](javascript:call_link\('abenoperands.htm'\)) →  [Data Objects in Operand Positions](javascript:call_link\('abenoperands_data_objects.htm'\)) →  [Substring Access](javascript:call_link\('abenoffset_length.htm'\)) → 

Substrings

This example demonstrates how substrings can be accessed.

Source Code

REPORT demo\_data\_process\_fields.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA time TYPE t VALUE '172545'.
    DATA: f1(8)  TYPE c VALUE 'ABCDEFGH',
          f2(20) TYPE c VALUE '12345678901234567890'.
    DATA: f3(8) TYPE c VALUE 'ABCDEFGH',
          f4(8) TYPE c.
    DATA: o     TYPE i VALUE 2,
          l     TYPE i VALUE 4.
    DATA: string(20) TYPE c,
          number(8)  TYPE c VALUE '123456',
          offset     TYPE i VALUE 8,
          length     TYPE i VALUE 12.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( |Example 1|
      )->write( time
      )->write( time+2(2)
      )->write( time+2(4) ).
    CLEAR time+2(4).
    out->write( time ).
    out->next\_section( |Example 2| ).
    f2+6(5) = f1+3(5).
    out->write( f1
      )->write( f2 ).
    out->next\_section( |Example 3| ).
    f4 = f3.
    out->write( f4 ).
    f4 = f3+o(l).
    out->write( f4 ).
    f4+o(l) = f3.
    out->write( f4 ).
    CLEAR f4.
    f4+o(l) = f3.
    out->write( f4 ).
    f4+o(l) = f3+o(l).
    out->write( f4 ).
    out->next\_section( |Example 4| ).
    WRITE number(6) TO string+offset(length) LEFT-JUSTIFIED.
    out->write( string ).
    CLEAR string.
    WRITE number(6) TO string+offset(length) CENTERED.
    out->write( string ).
    CLEAR string.
    WRITE number TO string+offset(length) RIGHT-JUSTIFIED.
    out->display( string ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In the first part, the minutes of a time field are selected by specifying an offset. Then the minutes and seconds are set to their initial values by specifying an offset in the CLEAR statement.

In the second part, the five character sequence 78901 from the field f2 is replaced with DEFGH from f1 by specifying offsets and lengths.

In the third part, assignments are used. First, the content of f1 is assigned to f2 without offsets. This is repeated with offsets and lengths for f1. The next three assignments overwrite the content of f2 with an offset of 2. Note that f2 is padded on the right with blanks, in accordance with the conversion rules for source type c.

In part four, the WRITE TO statement is used. The first six places in the field number are written to the last 12 places of the string field as left-justified, centered, and right-justified places.



**📖 Source**: [abendata_process_fields_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendata_process_fields_abexa.htm)

### abenoffset_length.htm

> **📖 Official SAP Documentation**: [abenoffset_length.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenoffset_length.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [ABAP Syntax](javascript:call_link\('abenabap_syntax.htm'\)) →  [ABAP Statements](javascript:call_link\('abenabap_statements.htm'\)) →  [Operands](javascript:call_link\('abenoperands.htm'\)) →  [Data Objects in Operand Positions](javascript:call_link\('abenoperands_data_objects.htm'\)) → 

Substring Access

In operand positions, subareas of certain data objects can be accessed by specifying an offset/length:

Syntax

dobj*\[*+off*\]**\[*(len)*\]*

<fs>*\[*+off*\]**\[*(len)*\]*

dref->\**\[*+off*\]**\[*(len)*\]*

Effect

A specified offset or length is directly appended to either the dobj descriptor of the data object, an <fs> field symbol, or a dereferenced data reference variable dref->\*. Offsets/lengths can be specified for:

-   [Elementary](javascript:call_link\('abenelementary_data_object_glosry.htm'\) "Glossary Entry") [byte-like data objects](javascript:call_link\('abenbyte_like_data_object_glosry.htm'\) "Glossary Entry")

-   [Elementary](javascript:call_link\('abenelementary_data_object_glosry.htm'\) "Glossary Entry") [character-like data objects](javascript:call_link\('abencharlike_data_object_glosry.htm'\) "Glossary Entry")

-   [Flat structures](javascript:call_link\('abenflat_structure_glosry.htm'\) "Glossary Entry") where one of the following prerequisites must be met:

-   The structure contains flat character-like components only.

-   The first fragment of the [structure fragment view](javascript:call_link\('abenunicode_fragment_view_glosry.htm'\) "Glossary Entry") is flat and character-like, and the substring addressed by specifying the offset and length is located within this fragment.

The following restrictions apply:

-   In [write positions](javascript:call_link\('abenwriting_position_glosry.htm'\) "Glossary Entry"), only flat data objects are permitted; it is not possible to write to substrings of strings.

-   Access to substrings of strings is also not possible in the following [reading positions](javascript:call_link\('abenreading_position_glosry.htm'\) "Glossary Entry"):

-   dobj*\[*+off*\]**\[*(len)*\]* specified as a memory area [mem\_area](javascript:call_link\('abapassign_mem_area_static_dobj.htm'\)) of the statement [ASSIGN](javascript:call_link\('abapassign.htm'\)).

-   dobj*\[*+off*\]**\[*(len)*\]* specified as an argument of the statement [GET REFERENCE](javascript:call_link\('abapget_reference.htm'\)) or the reference operator [REF](javascript:call_link\('abenconstructor_expression_ref.htm'\)).

-   dobj*\[*+off*\]**\[*(len)*\]* specified as an actual parameter for input parameters in calls of [methods](javascript:call_link\('abenmethod_calls.htm'\)), [function modules](javascript:call_link\('abapcall_function.htm'\)) , and [subroutines](javascript:call_link\('abapperform.htm'\)) .

-   Offsets/lengths cannot be specified for literals or text symbols.

-   A specified offset/length cannot be appended directly to a table expression [itab\[ ... \]](javascript:call_link\('abentable_expressions.htm'\)), but this is possible after a [chaining](javascript:call_link\('abentable_exp_chaining.htm'\)) whose final place is a suitable structure component after a structure component selector.

-   No offset or length can be specified for an [enumerated object](javascript:call_link\('abenenumerated_object_glosry.htm'\) "Glossary Entry") with an [enumerated type](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry"), regardless of the [base type](javascript:call_link\('abenbase_type_glosry.htm'\) "Glossary Entry").

-   In the case of dynamically [specified operands](javascript:call_link\('abenoperands_specifying.htm'\)) in parentheses, no lengths can be specified.

-   A dereferenced data reference variable dref->\* must be typed in full.

-   For a [writable expression](javascript:call_link\('abenwritable_expression_glosry.htm'\) "Glossary Entry"), offsets/lengths cannot be specified as [memory areas](javascript:call_link\('abapassign_mem_area_writable_exp.htm'\)) in the statement ASSIGN or as arguments of the reference operator [REF](javascript:call_link\('abenconstructor_expression_ref.htm'\)) (table expressions only).

The segment of the data object is used that has the offset specified in off and the length (in characters or bytes) specified in len. A memory area must not be addressed outside the field boundaries, except in the case of the statement [ASSIGN](javascript:call_link\('abapassign.htm'\)). In an offset specified without a length, the entire substring is addressed from off characters; for a length specified without an offset, the first len characters are addressed (different rules apply to the statement [ASSIGN](javascript:call_link\('abapassign.htm'\))).

The operands off and len expect data objects of the type i. These data objects must contain positive integers, with the following exceptions.

-   The length 0 can be specified for [strings](javascript:call_link\('abenstring_glosry.htm'\) "Glossary Entry").

-   A negative offset (but never length 0) can be specified if an <fs> field symbol is specified in the statement [ASSIGN](javascript:call_link\('abapassign_mem_area_static_dobj.htm'\)) for dobj.

-   If off is less than the length of dobj, an asterisk (\*) can be specified for len. The upper limit of dobj then determines the upper limit of the memory area.

If the prerequisites are not met or if the subarea defined by off and len is not completely contained in the data object (except in the case of [ASSIGN](javascript:call_link\('abapassign.htm'\))), a syntax error occurs (if statically identifiable). Otherwise, an exception of the class CX\_SY\_RANGE\_OUT\_OF\_BOUNDS is raised. If off is specified as a numeric literal, this literal cannot be prefixed with a sign.

The offset and length specifications are counted in characters for character-like data objects and in bytes for all other data objects.

A substring specified by an offset or length specification is treated like a data object of the specified length for which the data type depends on the data type of the original data object, the field symbol, or the data reference variable, as shown below:

Original Data Type

Data Type of Substring

c

c

n

n

d

n

t

n

string

string

x

x

xstring

xstring

Structure type

c

If the length of the substring matches the length of the structure in a substring access to a structure exactly, the substring does not have data type c and is handled like the structure itself instead.

Notes

-   For reads on substrings of character-like data objects, built-in [substring functions](javascript:call_link\('abensubstring_functions.htm'\)) that allow searches by specifying both substring and offset/lengths are available. The substring functions can also be used to edit arguments where offsets and lengths cannot be specified, such as data objects with an [enumerated type](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry"). This is because an implicit conversion to string is performed here.

-   It is a good idea to specify offsets with the value 0 explicitly too (that is, dobj+0(len) instead of dobj(len)). This distinguishes a substring access in the source code clearly from other language constructs that also use parentheses, such as dynamic specifications, method calls, or inline declarations.

-   dobj+0(\*), dobj+0, or dobj(\*) are always interpreted as dobj. In this case, dobj can also be a data object where substring access according to the rules above is not possible.

-   No substring access cnt(len), sum(len) can be performed on data objects called cnt and sum unless an offset is specified explicitly. The compiler always interprets this as a [number](javascript:call_link\('abapcnt.htm'\)) or [sum](javascript:call_link\('abapsum.htm'\)) of a field len in the group level processing of an [extract dataset](javascript:call_link\('abenextract_dataset_glosry.htm'\) "Glossary Entry").

-   [Obsolete syntax forms](javascript:call_link\('abentokenization_obsolete.htm'\)) can still occur with substring access (apart from with classes).

-   The statement [MOVE PERCENTAGE](javascript:call_link\('abapmove_percentage.htm'\)) indicates an obsolete form of substring access.

Example

The following structure has both character-like and non-character-like components:

DATA:
  BEGIN OF struc,
    a TYPE c LENGTH 3,    "Length 3 characters
    b TYPE n LENGTH 4,    "Length 4 characters
    c TYPE d,             "Length 8 characters
    d TYPE t,             "Length 6 characters
    e TYPE decfloat16,    "Length 8 bytes
    f TYPE c LENGTH 28,   "Length 28 characters
    g TYPE x LENGTH 2,    "Length 2 bytes
  END OF struc.

The [fragment view](javascript:call_link\('abenunicode_fragment_view_glosry.htm'\) "Glossary Entry") splits the structure into five areas, F1 - F5.

\[ aaa | bbbb | cccccccc | ddd | AAA | eeee | fffffffffffff | gg \]
\[            F1               |  F2 |  F3  |       F4      | F5 \]

Offset/length accesses are possible on the character-like initial fragment F1 only, for example struc(21) or struc+7(14). An access such as struc+57(2), for example, is not permitted.

Executable Example

[Substrings](javascript:call_link\('abendata_process_fields_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Substrings](javascript:call_link\('abendata_process_fields_abexa.htm'\))


---


## ABAP Keyword Documentation / ABAP − Reference / Program Layout / Modularization Statements / Procedures / Parameter Interface of Procedures

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Layout / Modularization Statements / Procedures / Parameter Interface of Procedures

Included pages: 2



**📖 Source**: [abenoffset_length.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenoffset_length.htm)

### abenformal_parameters_oview.htm

> **📖 Official SAP Documentation**: [abenformal_parameters_oview.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenformal_parameters_oview.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Layout](javascript:call_link\('abenabap_program_layout.htm'\)) →  [Modularization Statements](javascript:call_link\('abenabap_language_modularization.htm'\)) →  [Procedures](javascript:call_link\('abenabap_language_procedures.htm'\)) → 

Parameter Interface of Procedures

The parameter interface of a procedure consists of [formal parameters](javascript:call_link\('abenformal_parameter_glosry.htm'\) "Glossary Entry") and specifies the [exceptions](javascript:call_link\('abenexception_glosry.htm'\) "Glossary Entry") possible in the procedure.

Formal Parameters

Formal parameters are [input parameters](javascript:call_link\('abeninput_parameter_glosry.htm'\) "Glossary Entry"), [output parameters](javascript:call_link\('abenoutput_parameter_glosry.htm'\) "Glossary Entry"), [input/output parameters](javascript:call_link\('abeninput_output_parameter_glosry.htm'\) "Glossary Entry"), or [return values](javascript:call_link\('abenreturn_value_glosry.htm'\) "Glossary Entry"). Several obsolete [table parameters](javascript:call_link\('abentable_parameter_glosry.htm'\) "Glossary Entry") also exist. Formal parameters are either generic or fully [typed](javascript:call_link\('abentyping_glosry.htm'\) "Glossary Entry"). [Pass by reference](javascript:call_link\('abenpass_by_reference_glosry.htm'\) "Glossary Entry") or [pass by value](javascript:call_link\('abenpass_by_value_glosry.htm'\) "Glossary Entry") can be specified for most formal parameters. Pass by value is mandatory for some formal parameters.

Programming Guideline

[Choose the appropriate formal parameter type](javascript:call_link\('abentype_formal_param_proc_guidl.htm'\) "Guideline")

Exceptions

In all procedures ([methods](javascript:call_link\('abenmethod_glosry.htm'\) "Glossary Entry"), [function modules](javascript:call_link\('abenfunction_module_glosry.htm'\) "Glossary Entry")
, and [subroutines](javascript:call_link\('abensubroutine_glosry.htm'\) "Glossary Entry") ) [class-based exceptions](javascript:call_link\('abenclass_based_exception_glosry.htm'\) "Glossary Entry") can be declared using RAISING, which and can then be [propagated from the procedure](javascript:call_link\('abenexceptions_procedures.htm'\)). EXCEPTIONS can also be used in methods and function modules to define non-class-based exceptions, which can then be triggered in the procedure using [RAISE](javascript:call_link\('abapraise_exception.htm'\)) or [MESSAGE ... RAISING](javascript:call_link\('abapmessage_raising.htm'\)).

Pass by Reference or Pass by Value

When deciding whether to use pass by reference or pass by value for a formal parameter, you must compare the performance and robustness of each transfer type.

In ABAP, pass by reference always leads to better performance since no local data object has to be stored and no data transport is necessary when the procedure is called. Therefore, for performance reasons, pass by reference is usually preferable, unless explicit or implicit write access exists to an input parameter in the procedure or you want to ensure that an input/output parameter or an output parameter is returned only if the procedure ends without any errors. In such cases, pass by value is mandatory, to make sure that the assigned [actual parameter](javascript:call_link\('abenactual_parameter_glosry.htm'\) "Glossary Entry") is not modified simultaneously in the caller when writes are made to a formal parameter. For performance reasons, only parameters of 100 bytes or less should be passed in these cases, whenever possible.

Also note the following when using pass by reference:

-   In [subroutines](javascript:call_link\('abensubroutine_glosry.htm'\) "Glossary Entry"), writes can be made to an input parameter defined using USING without a syntax error being produced (as is the case with input parameters of methods or function modules defined using IMPORTING).

-   An output parameter that is passed by reference acts like an input/ output parameter; in other words, if read access to an output parameter exists in the procedure before the value of that parameter is changed, this value is not initial, unlike with pass by value, but is the same as the current value of the actual parameter in the caller.

-   If a procedure is stopped because of an error (that is, if it is stopped for a reason other than reaching its last statement or RETURN, EXIT, or CHECK), all actual parameters that are passed by reference retain the value of the assigned formal parameter that the parameter had when the program was stopped. In pass by value, no values are passed to actual parameters when a procedure terminates.

Procedures and their calls have to be programmed so that these kinds of errors do not occur.

To summarize, pass by reference is always preferable when performance is an issue, while pass by value is more suitable in situations where robustness and data consistency are more important. These factors must be taken into account in each individual case when you decide which pass type to use with which type of parameter.

Programming Guideline

[Choose a suitable pass-by type](javascript:call_link\('abentype_transf_formal_para_guidl.htm'\) "Guideline")

Notes

-   When strings or internal tables of the same type are passed by value, [table sharing](javascript:call_link\('abensharing_glosry.htm'\) "Glossary Entry") comes into force between the data object created locally and the data object passed, as in [assignments](javascript:call_link\('abenassignment_glosry.htm'\) "Glossary Entry"). However, [table sharing](javascript:call_link\('abentable_sharing_glosry.htm'\) "Glossary Entry") only happens if the row type of the internal table permits it. This means that, when you pass strings and internal tables, the performance benefits of pass by reference over pass by value may be negated by sharing (in certain circumstances).

-   Only pass by reference can be specified for the obsolete [table parameters](javascript:call_link\('abentable_parameter_glosry.htm'\) "Glossary Entry").

-   Pass by value is mandatory for the [return value](javascript:call_link\('abenreturn_value_glosry.htm'\) "Glossary Entry") of [functional methods](javascript:call_link\('abenfunctional_method_glosry.htm'\) "Glossary Entry"), the output parameters of [events](javascript:call_link\('abenevent_glosry.htm'\) "Glossary Entry") in ABAP Objects, and all formal parameters of [RFC](javascript:call_link\('abenrfc_glosry.htm'\) "Glossary Entry")\-enabled function modules and [update function modules](javascript:call_link\('abenupdate_function_module_glosry.htm'\) "Glossary Entry") (pass by value is also used implicitly with table parameters).

-   A local data object is generated for formal parameters passed by reference that are not bound to an actual parameter during the call (as for pass by value).

-   There are special rules for defining [literals](javascript:call_link\('abentyping_literals.htm'\)) and [functions and expressions as actual parameters](javascript:call_link\('abentyping_arith_expr.htm'\)).

-   The result of the [typing check](javascript:call_link\('abentyping_check.htm'\)) when passing actual parameters to formal parameters is independent of the pass type. In a [pass by value](javascript:call_link\('abenpass_by_value_glosry.htm'\) "Glossary Entry"), the check for [pass by reference](javascript:call_link\('abenpass_by_reference_glosry.htm'\) "Glossary Entry") is always carried out, even though this is stricter than necessary in individual cases. For example, a special reference variable cannot be passed to a general typed CHANGING parameter, even if pass by value is defined for this parameter.

Example

For a method meth, CHANGING parameter p1 is defined for pass by reference and p2 for pass by value. The values of both parameters are modified before an exception is raised. The actual parameter a1 bound to the parameter using pass by reference contains the modified value when the exception is handled. The actual parameter a2 bound to the parameter using pass by value, on the other hand, keeps its value.

CLASS cx\_exception DEFINITION
                   INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS cls DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS meth CHANGING p1        TYPE i
                                VALUE(p2) TYPE i
                       RAISING  cx\_exception.
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD meth.
    p1 = 333.
    p2 = 444.
    RAISE EXCEPTION TYPE cx\_exception.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(a1) = 111.
  DATA(a2) = 222.
  TRY.
      cls=>meth( CHANGING p1 = a1
                          p2 = a2 ).
    CATCH cx\_exception.
      cl\_demo\_output=>display( |{ a1 }, { a2 }| ).
  ENDTRY.

Continue
![Example](exa.gif "Example") [Pass by Parameter](javascript:call_link\('abenprocedure_param_abexa.htm'\))



**📖 Source**: [abenformal_parameters_oview.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenformal_parameters_oview.htm)

### abenprocedure_param_abexa.htm

> **📖 Official SAP Documentation**: [abenprocedure_param_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenprocedure_param_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Layout](javascript:call_link\('abenabap_program_layout.htm'\)) →  [Modularization Statements](javascript:call_link\('abenabap_language_modularization.htm'\)) →  [Procedures](javascript:call_link\('abenabap_language_procedures.htm'\)) →  [Parameter Interface of Procedures](javascript:call_link\('abenformal_parameters_oview.htm'\)) → 

Pass by Parameter

This example demonstrates the difference between passing a parameter in a procedure by value or by reference.

Source Code

REPORT demo\_procedure\_param.
CLASS demo\_fibb DEFINITION.
  PUBLIC SECTION.
    TYPES: BEGIN OF line,
               x TYPE i,
               y TYPE i,
               range TYPE i,
           END OF line.
    CLASS-DATA: param TYPE STANDARD TABLE OF line,
                res TYPE i.
    CLASS-METHODS: main,
                   fill\_table  CHANGING  g\_param LIKE param,
                   solve\_table IMPORTING g\_param LIKE param,
                   fibb IMPORTING VALUE(l\_line) TYPE line
                        EXPORTING VALUE(r) TYPE i.
ENDCLASS.
CLASS demo\_fibb IMPLEMENTATION.
  METHOD main.
    fill\_table(  CHANGING  g\_param = param ).
    solve\_table( EXPORTING g\_param = param ).
  ENDMETHOD.
  METHOD fill\_table.
    g\_param = VALUE #( FOR j = 1 UNTIL j > 3
                       ( x = j
                         y = j \*\* 2
                         range = 12 / j ) ).
  ENDMETHOD.
  METHOD solve\_table.
    DATA l\_line LIKE LINE OF g\_param.
    LOOP AT g\_param INTO l\_line.
      fibb( EXPORTING l\_line = l\_line IMPORTING r = res ).
      cl\_demo\_output=>write(
      |Fibb( { l\_line-x }, { l\_line-y }, { l\_line-range }) = { res }| ).
    ENDLOOP.
    cl\_demo\_output=>display( ).
  ENDMETHOD.
  METHOD fibb.
    IF l\_line-range = 1.
      IF l\_line-x < l\_line-y.
        r = l\_line-x.
      ELSE.
        r = l\_line-y.
      ENDIF.
    ELSEIF l\_line-range = 2.
      IF l\_line-x < l\_line-y.
        r = l\_line-y.
      ELSE.
        r = l\_line-x.
      ENDIF.
    ELSE.
      l\_line-range = l\_line-range - 2.
      DO l\_line-range TIMES.
        IF l\_line-x < l\_line-y.
          l\_line-x = l\_line-x + l\_line-y.
          r = l\_line-x.
        ELSE.
          l\_line-y = l\_line-x + l\_line-y.
          r = l\_line-y.
        ENDIF.
      ENDDO.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_fibb=>main( ).

Description

The method fibb calculates the sequence term with the number range in a Fibonacci sequence using the start values x and y. As a rule, the next sequence term is always the sum of two previous sequence terms (which is why there are two start values). The method inherits two parameters, a structured parameter l\_line used to pass the input values, and a parameter r of type i used to provide the result. The parameter l\_line is defined as an IMPORTING parameter but still has to be changed in the method, which means that the method definition must contain the keyword VALUE before the parameter. If not, a syntax error occurs. This ensures that a local copy of the parameter is used within the method. The addition VALUE of the output parameter r assigns the result to the static class attribute res only after the method has been processed completely. Otherwise res would be changed in every single step of the algorithm.

The internal table param contains the input values for calculating three different sequence terms of the Fibonacci sequence. The method fill\_table is used to fill param with values and the method solve\_table is used to calculate and display fibb for each line of param.


---


## ABAP Keyword Documentation / ABAP − Reference / Built-In Types, Data Objects, Functions, and Constructors / Built-In Data Types

**Files**: 10 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Built-In Types, Data Objects, Functions, and Constructors / Built-In Functions

Included pages: 3



**📖 Source**: [abenprocedure_param_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenprocedure_param_abexa.htm)

### abenbuilt_in_functions.htm

> **📖 Official SAP Documentation**: [abenbuilt_in_functions.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenbuilt_in_functions.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Built-In Types, Data Objects, Functions, and Constructors](javascript:call_link\('abenbuilt_in.htm'\)) → 

Built-In Functions

ABAP provides a set of built-in functions. A built-in function returns a return value for one or more arguments. Built-in functions can be called by functions in certain operand positions.

Built-in functions can be called functionally in [certain operand positions](javascript:call_link\('abenoperands_expressions.htm'\)). When a built-in function is called in an [operand position](javascript:call_link\('abenexpression_positions.htm'\)), the function is executed before the operand is used and the return value of the built-in function is used as the operand, in accordance with its data type.

-   [Built-In Functions - Syntax](javascript:call_link\('abenbuilt_in_functions_syntax.htm'\))

-   [Built-In Functions - Overview](javascript:call_link\('abenbuilt_in_functions_overview.htm'\))

Continue
[Built-In Functions - Syntax](javascript:call_link\('abenbuilt_in_functions_syntax.htm'\))
[Built-In Functions - Overview](javascript:call_link\('abenbuilt_in_functions_overview.htm'\))



**📖 Source**: [abenbuilt_in_functions.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenbuilt_in_functions.htm)

### abenbuilt_in_functions_syntax.htm

> **📖 Official SAP Documentation**: [abenbuilt_in_functions_syntax.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenbuilt_in_functions_syntax.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Built-In Types, Data Objects, Functions, and Constructors](javascript:call_link\('abenbuilt_in.htm'\)) →  [Built-In Functions](javascript:call_link\('abenbuilt_in_functions.htm'\)) → 

Built-In Functions - Syntax

-   [Functions with an Unnamed Argument](#abenbuilt-in-functions-syntax-1--------functions-with-named-arguments---@ITOC@@ABENBUILT_IN_FUNCTIONS_SYNTAX_2)

-   [Obscuring with Methods](#abenbuilt-in-functions-syntax-3---in-functions-with-named-arguments--there-is-usually-a-main-argument-val-and-additional--possibly-also-optional--arguments--the-following-sections-show-the-general-syntax-for-calling-built-in-functions---functions-with-an-unnamed-argument--syntax------func--arg--------the-syntax-for-functions-with-an-unnamed-argument-is-the-same-as-the-syntax-for-calling-functional-methods-with-an-input-parameter--func-is-the-built-in-function-and-the-argument-arg-is-an-operand-whose-data-type-matches-the-function--the-blanks-after-the-opening-parentheses-and-before-the-closing-parentheses-are-relevant---example--the-built-on-function--line--exists--javascript-call-link---abenline-exists-function-htm-----has-an-unnamed-argument-that-expects-a-table-expression---data-itab-type-table-of-i-with-empty-key------if-line--exists--itab---1-------------endif---functions-with-named-arguments--syntax------func--val---arg-p1---arg1-p2---arg2------------functions-with-one-or-more-named-arguments-are-bound-to-keyword-parameters-in-the-same-way-as-when-functional-methods-are-called-with-multiple-input-parameters--operands-can-be-specified-for-the-arguments-whose-data-type-matches-the-corresponding-parameter--the-blanks-after-the-opening-parentheses-and-before-the-closing-parentheses-are-relevant--if-one-of-these-functions-only-has-one-argument-or-only-the-main-argument-is-to-be-populated--the-syntax-can-be-simplified-as-follows-------func--arg--------example--the-built-in-function--condense--javascript-call-link---abencondense-functions-htm-----has-named-arguments-and-can--for-example--be-called-as-follows---data-str1----condense-------------data-str2----condense--val--------------data-str3----condense--val------------del-------------obscuring-with-methods--within-a-class--a-built-in-function-is-always-obscured-by--methods--javascript-call-link---abenmethod-glosry-htm-----glossary-entry---of-the-class-if-they-have-the-same-name--regardless-of-the-number-and-type-of-arguments-in-the-function--the-function-is-also-obscured-regardless-of-the-number-and-type-of-method-parameters--this-also-takes-place-in-method-calls-for-which-no-selector-----or-----is-specified-in-front-of-the-method-name-------a--static-method--javascript-call-link---abenstatic-method-glosry-htm-----glossary-entry---obscures-a-built-in-function-with-the-same-name-in-all-methods-of-the-associated-class-------an--instance-method--javascript-call-link---abeninstance-method-glosry-htm-----glossary-entry---obscures-a-built-in-function-with-the-same-name-in-the-instance-methods-of-the-associated-class---note--methods-should-never-be-given-the-same-name-as-a-built-in-function---example--the-following-class-returns-a-syntax-error--the-strlen-specified-on-the-right-side-of-the-assignment-indicates-the-method-of-the-class-and-not-the-built-in-function--it-cannot-be-specified-in-this-operand-position-since-it-is-not-a-functional-method-with-return-code---class-demo-definition----public-section------class-methods-main------class-methods-strlen-importing-text-type-string--------------------------exporting-len--type-i--endclass--class-demo-implementation----method-main------data-len----strlen----xxx--------endmethod----method-strlen------------endmethod--endclass----------source-----abenbuilt-in-functions-syntax-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenbuilt-in-functions-syntax-htm-------abenbuilt-in-functions-overview-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------built-in-types--data-objects--functions--and-constructors--javascript-call-link---abenbuilt-in-htm---------built-in-functions--javascript-call-link---abenbuilt-in-functions-htm---------built-in-functions---overview--the-following-tables-show-the-built-in-functions-by-purpose--built-in-functions-are-generally--processing-functions--javascript-call-link---abenprocess-function-glosry-htm-----glossary-entry---or--description-functions--javascript-call-link---abendescription-function-glosry-htm-----glossary-entry---------a-processing-function-performs-general-processing-and-returns-a-return-code-according-to-its-purpose-------a-description-function-determines-a-property-of-an-argument-and-usually-returns-this-property-as-a-numeric-value---other-functions-are-known-as-logical-functions--which-either-evaluate-a-logical-expression--boolean-functions--or-return-a-truth-value--predicate-functions----logical-functions--function--meaning---boolc--javascript-call-link---abenboole-functions-htm-------boolx--javascript-call-link---abenboole-functions-htm-------xsdbool--javascript-call-link---abenboole-functions-htm------boolean-functions---contains--javascript-call-link---abencontains-functions-htm-------contains--any--of--javascript-call-link---abencontains-functions-htm-------contains--any--not--of--javascript-call-link---abencontains-functions-htm------predicate-functions-for-strings---matches--javascript-call-link---abenmatches-functions-htm------predicate-function-for-strings---line--exists--javascript-call-link---abenline-exists-function-htm------predicate-function-for-internal-tables-----more--javascript-call-link---abenlogic-functions-htm------numeric-functions--function--meaning---abs--javascript-call-link---abennumerical-functions-htm-------ceil--javascript-call-link---abennumerical-functions-htm-------floor--javascript-call-link---abennumerical-functions-htm-------frac--javascript-call-link---abennumerical-functions-htm-------sign--javascript-call-link---abennumerical-functions-htm-------trunc--javascript-call-link---abennumerical-functions-htm------general-numeric-functions---ipow--javascript-call-link---abenpower-function-htm------integer-power-function---nmax--javascript-call-link---abennmax-nmin-functions-htm-------nmin--javascript-call-link---abennmax-nmin-functions-htm------numeric-extremum-functions---acos--javascript-call-link---abenfloating-point-functions-htm-------asin--javascript-call-link---abenfloating-point-functions-htm-------atan--javascript-call-link---abenfloating-point-functions-htm-------cos--javascript-call-link---abenfloating-point-functions-htm-------sin--javascript-call-link---abenfloating-point-functions-htm-------tan--javascript-call-link---abenfloating-point-functions-htm-------cosh--javascript-call-link---abenfloating-point-functions-htm-------sinh--javascript-call-link---abenfloating-point-functions-htm-------tanh--javascript-call-link---abenfloating-point-functions-htm-------exp--javascript-call-link---abenfloating-point-functions-htm-------log--javascript-call-link---abenfloating-point-functions-htm-------log10--javascript-call-link---abenfloating-point-functions-htm-------sqrt--javascript-call-link---abenfloating-point-functions-htm------floating-point-functions---round--javascript-call-link---abendec-floating-point-functions-htm-------rescale--javascript-call-link---abendec-floating-point-functions-htm------rounding-functions-----more--javascript-call-link---abenmathematical-functions-htm------string-functions--function--meaning---charlen--javascript-call-link---abenlength-functions-htm-------dbmaxlen--javascript-call-link---abenlength-functions-htm-------numofchar--javascript-call-link---abenlength-functions-htm-------strlen--javascript-call-link---abenlength-functions-htm------length-functions---char--off--javascript-call-link---abenlength-functions-args-htm------length-function---cmax--javascript-call-link---abencmax-cmin-functions-htm-------cmin--javascript-call-link---abencmax-cmin-functions-htm------character-like-extremum-value-functions---count--javascript-call-link---abencount-functions-htm-------count--any--of--javascript-call-link---abencount-functions-htm-------count--any--not--of--javascript-call-link---abencount-functions-htm------search-functions---distance--javascript-call-link---abendistance-functions-htm------similarity-function---condense--javascript-call-link---abencondense-functions-htm------condense-function---concat--lines--of--javascript-call-link---abenconcatenation-functions-htm------concatenation-function---escape--javascript-call-link---abenescape-functions-htm------escape-function---find--javascript-call-link---abensearch-functions-htm-------find--end--javascript-call-link---abensearch-functions-htm-------find--any--of--javascript-call-link---abensearch-functions-htm-------find--any--not--of--javascript-call-link---abensearch-functions-htm------search-functions---insert--javascript-call-link---abeninsert-functions-htm------insert-function---match--javascript-call-link---abenmatch-functions-htm------substring-function---repeat--javascript-call-link---abenrepeat-functions-htm------repeat-function---replace--javascript-call-link---abenreplace-functions-htm------replace-function---reverse--javascript-call-link---abenreverse-functions-htm------reverse-function---segment--javascript-call-link---abensegment-functions-htm------segment-function---shift--left--javascript-call-link---abenshift-functions-htm-------shift--right--javascript-call-link---abenshift-functions-htm------shift-functions---substring--javascript-call-link---abensubstring-functions-htm-------substring--after--javascript-call-link---abensubstring-functions-htm-------substring--from--javascript-call-link---abensubstring-functions-htm-------substring--before--javascript-call-link---abensubstring-functions-htm-------substring--to--javascript-call-link---abensubstring-functions-htm------substring-functions---to--upper--javascript-call-link---abencase-functions-htm-------to--lower--javascript-call-link---abencase-functions-htm-------to--mixed--javascript-call-link---abencase-functions-htm-------from--mixed--javascript-call-link---abencase-functions-htm------case-functions---translate--javascript-call-link---abentranslate-functions-htm------translation-function-----more--javascript-call-link---abenstring-functions-htm------byte-string-functions--function--meaning---xstrlen--javascript-call-link---abendescriptive-functions-binary-htm------length-function---bit-set--javascript-call-link---abenbit-functions-htm------bit-function-----more--javascript-call-link---abenbinary-functions-htm------table-functions--function--meaning---lines--javascript-call-link---abendescriptive-functions-table-htm------row-function---line--index--javascript-call-link---abenline-index-function-htm------index-function-----more--javascript-call-link---abentable-functions-htm----------------abap-keyword-documentation---abap---reference---built-in-types--data-objects--functions--and-constructors---built-in-data-objects----files----6-----difficulty----intermediate----abap-keyword-documentation---abap---reference---built-in-types--data-objects--functions--and-constructors---built-in-functions--included-pages--3---------source-----abenbuilt-in-functions-overview-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenbuilt-in-functions-overview-htm-------abenbuilt-in-functions-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------built-in-types--data-objects--functions--and-constructors--javascript-call-link---abenbuilt-in-htm---------built-in-functions--abap-provides-a-set-of-built-in-functions--a-built-in-function-returns-a-return-value-for-one-or-more-arguments--built-in-functions-can-be-called-by-functions-in-certain-operand-positions---built-in-functions-can-be-called-functionally-in--certain-operand-positions--javascript-call-link---abenoperands-expressions-htm------when-a-built-in-function-is-called-in-an--operand-position--javascript-call-link---abenexpression-positions-htm------the-function-is-executed-before-the-operand-is-used-and-the-return-value-of-the-built-in-function-is-used-as-the-operand--in-accordance-with-its-data-type--------built-in-functions---syntax--javascript-call-link---abenbuilt-in-functions-syntax-htm-----------built-in-functions---overview--javascript-call-link---abenbuilt-in-functions-overview-htm------continue--built-in-functions---syntax--javascript-call-link---abenbuilt-in-functions-syntax-htm------built-in-functions---overview--javascript-call-link---abenbuilt-in-functions-overview-htm-------------source-----abenbuilt-in-functions-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenbuilt-in-functions-htm-------abenbuilt-in-functions-syntax-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------built-in-types--data-objects--functions--and-constructors--javascript-call-link---abenbuilt-in-htm---------built-in-functions--javascript-call-link---abenbuilt-in-functions-htm---------built-in-functions---syntax-------functions-with-an-unnamed-argument---abenbuilt-in-functions-syntax-1--------functions-with-named-arguments---ITOC@@ABENBUILT_IN_FUNCTIONS_SYNTAX_2)

-   [Obscuring with Methods](#abenbuilt-in-functions-syntax-3---in-functions-with-named-arguments--there-is-usually-a-main-argument-val-and-additional--possibly-also-optional--arguments--the-following-sections-show-the-general-syntax-for-calling-built-in-functions---functions-with-an-unnamed-argument--syntax------func--arg--------the-syntax-for-functions-with-an-unnamed-argument-is-the-same-as-the-syntax-for-calling-functional-methods-with-an-input-parameter--func-is-the-built-in-function-and-the-argument-arg-is-an-operand-whose-data-type-matches-the-function--the-blanks-after-the-opening-parentheses-and-before-the-closing-parentheses-are-relevant---example--the-built-on-function--line--exists--javascript-call-link---abenline-exists-function-htm-----has-an-unnamed-argument-that-expects-a-table-expression---data-itab-type-table-of-i-with-empty-key------if-line--exists--itab---1-------------endif---functions-with-named-arguments--syntax------func--val---arg-p1---arg1-p2---arg2------------functions-with-one-or-more-named-arguments-are-bound-to-keyword-parameters-in-the-same-way-as-when-functional-methods-are-called-with-multiple-input-parameters--operands-can-be-specified-for-the-arguments-whose-data-type-matches-the-corresponding-parameter--the-blanks-after-the-opening-parentheses-and-before-the-closing-parentheses-are-relevant--if-one-of-these-functions-only-has-one-argument-or-only-the-main-argument-is-to-be-populated--the-syntax-can-be-simplified-as-follows-------func--arg--------example--the-built-in-function--condense--javascript-call-link---abencondense-functions-htm-----has-named-arguments-and-can--for-example--be-called-as-follows---data-str1----condense-------------data-str2----condense--val--------------data-str3----condense--val------------del-------------obscuring-with-methods--within-a-class--a-built-in-function-is-always-obscured-by--methods--javascript-call-link---abenmethod-glosry-htm-----glossary-entry---of-the-class-if-they-have-the-same-name--regardless-of-the-number-and-type-of-arguments-in-the-function--the-function-is-also-obscured-regardless-of-the-number-and-type-of-method-parameters--this-also-takes-place-in-method-calls-for-which-no-selector-----or-----is-specified-in-front-of-the-method-name-------a--static-method--javascript-call-link---abenstatic-method-glosry-htm-----glossary-entry---obscures-a-built-in-function-with-the-same-name-in-all-methods-of-the-associated-class-------an--instance-method--javascript-call-link---abeninstance-method-glosry-htm-----glossary-entry---obscures-a-built-in-function-with-the-same-name-in-the-instance-methods-of-the-associated-class---note--methods-should-never-be-given-the-same-name-as-a-built-in-function---example--the-following-class-returns-a-syntax-error--the-strlen-specified-on-the-right-side-of-the-assignment-indicates-the-method-of-the-class-and-not-the-built-in-function--it-cannot-be-specified-in-this-operand-position-since-it-is-not-a-functional-method-with-return-code---class-demo-definition----public-section------class-methods-main------class-methods-strlen-importing-text-type-string--------------------------exporting-len--type-i--endclass--class-demo-implementation----method-main------data-len----strlen----xxx--------endmethod----method-strlen------------endmethod--endclass----------source-----abenbuilt-in-functions-syntax-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenbuilt-in-functions-syntax-htm-------abenbuilt-in-functions-overview-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------built-in-types--data-objects--functions--and-constructors--javascript-call-link---abenbuilt-in-htm---------built-in-functions--javascript-call-link---abenbuilt-in-functions-htm---------built-in-functions---overview--the-following-tables-show-the-built-in-functions-by-purpose--built-in-functions-are-generally--processing-functions--javascript-call-link---abenprocess-function-glosry-htm-----glossary-entry---or--description-functions--javascript-call-link---abendescription-function-glosry-htm-----glossary-entry---------a-processing-function-performs-general-processing-and-returns-a-return-code-according-to-its-purpose-------a-description-function-determines-a-property-of-an-argument-and-usually-returns-this-property-as-a-numeric-value---other-functions-are-known-as-logical-functions--which-either-evaluate-a-logical-expression--boolean-functions--or-return-a-truth-value--predicate-functions----logical-functions--function--meaning---boolc--javascript-call-link---abenboole-functions-htm-------boolx--javascript-call-link---abenboole-functions-htm-------xsdbool--javascript-call-link---abenboole-functions-htm------boolean-functions---contains--javascript-call-link---abencontains-functions-htm-------contains--any--of--javascript-call-link---abencontains-functions-htm-------contains--any--not--of--javascript-call-link---abencontains-functions-htm------predicate-functions-for-strings---matches--javascript-call-link---abenmatches-functions-htm------predicate-function-for-strings---line--exists--javascript-call-link---abenline-exists-function-htm------predicate-function-for-internal-tables-----more--javascript-call-link---abenlogic-functions-htm------numeric-functions--function--meaning---abs--javascript-call-link---abennumerical-functions-htm-------ceil--javascript-call-link---abennumerical-functions-htm-------floor--javascript-call-link---abennumerical-functions-htm-------frac--javascript-call-link---abennumerical-functions-htm-------sign--javascript-call-link---abennumerical-functions-htm-------trunc--javascript-call-link---abennumerical-functions-htm------general-numeric-functions---ipow--javascript-call-link---abenpower-function-htm------integer-power-function---nmax--javascript-call-link---abennmax-nmin-functions-htm-------nmin--javascript-call-link---abennmax-nmin-functions-htm------numeric-extremum-functions---acos--javascript-call-link---abenfloating-point-functions-htm-------asin--javascript-call-link---abenfloating-point-functions-htm-------atan--javascript-call-link---abenfloating-point-functions-htm-------cos--javascript-call-link---abenfloating-point-functions-htm-------sin--javascript-call-link---abenfloating-point-functions-htm-------tan--javascript-call-link---abenfloating-point-functions-htm-------cosh--javascript-call-link---abenfloating-point-functions-htm-------sinh--javascript-call-link---abenfloating-point-functions-htm-------tanh--javascript-call-link---abenfloating-point-functions-htm-------exp--javascript-call-link---abenfloating-point-functions-htm-------log--javascript-call-link---abenfloating-point-functions-htm-------log10--javascript-call-link---abenfloating-point-functions-htm-------sqrt--javascript-call-link---abenfloating-point-functions-htm------floating-point-functions---round--javascript-call-link---abendec-floating-point-functions-htm-------rescale--javascript-call-link---abendec-floating-point-functions-htm------rounding-functions-----more--javascript-call-link---abenmathematical-functions-htm------string-functions--function--meaning---charlen--javascript-call-link---abenlength-functions-htm-------dbmaxlen--javascript-call-link---abenlength-functions-htm-------numofchar--javascript-call-link---abenlength-functions-htm-------strlen--javascript-call-link---abenlength-functions-htm------length-functions---char--off--javascript-call-link---abenlength-functions-args-htm------length-function---cmax--javascript-call-link---abencmax-cmin-functions-htm-------cmin--javascript-call-link---abencmax-cmin-functions-htm------character-like-extremum-value-functions---count--javascript-call-link---abencount-functions-htm-------count--any--of--javascript-call-link---abencount-functions-htm-------count--any--not--of--javascript-call-link---abencount-functions-htm------search-functions---distance--javascript-call-link---abendistance-functions-htm------similarity-function---condense--javascript-call-link---abencondense-functions-htm------condense-function---concat--lines--of--javascript-call-link---abenconcatenation-functions-htm------concatenation-function---escape--javascript-call-link---abenescape-functions-htm------escape-function---find--javascript-call-link---abensearch-functions-htm-------find--end--javascript-call-link---abensearch-functions-htm-------find--any--of--javascript-call-link---abensearch-functions-htm-------find--any--not--of--javascript-call-link---abensearch-functions-htm------search-functions---insert--javascript-call-link---abeninsert-functions-htm------insert-function---match--javascript-call-link---abenmatch-functions-htm------substring-function---repeat--javascript-call-link---abenrepeat-functions-htm------repeat-function---replace--javascript-call-link---abenreplace-functions-htm------replace-function---reverse--javascript-call-link---abenreverse-functions-htm------reverse-function---segment--javascript-call-link---abensegment-functions-htm------segment-function---shift--left--javascript-call-link---abenshift-functions-htm-------shift--right--javascript-call-link---abenshift-functions-htm------shift-functions---substring--javascript-call-link---abensubstring-functions-htm-------substring--after--javascript-call-link---abensubstring-functions-htm-------substring--from--javascript-call-link---abensubstring-functions-htm-------substring--before--javascript-call-link---abensubstring-functions-htm-------substring--to--javascript-call-link---abensubstring-functions-htm------substring-functions---to--upper--javascript-call-link---abencase-functions-htm-------to--lower--javascript-call-link---abencase-functions-htm-------to--mixed--javascript-call-link---abencase-functions-htm-------from--mixed--javascript-call-link---abencase-functions-htm------case-functions---translate--javascript-call-link---abentranslate-functions-htm------translation-function-----more--javascript-call-link---abenstring-functions-htm------byte-string-functions--function--meaning---xstrlen--javascript-call-link---abendescriptive-functions-binary-htm------length-function---bit-set--javascript-call-link---abenbit-functions-htm------bit-function-----more--javascript-call-link---abenbinary-functions-htm------table-functions--function--meaning---lines--javascript-call-link---abendescriptive-functions-table-htm------row-function---line--index--javascript-call-link---abenline-index-function-htm------index-function-----more--javascript-call-link---abentable-functions-htm----------------abap-keyword-documentation---abap---reference---built-in-types--data-objects--functions--and-constructors---built-in-functions----files----3-----difficulty----intermediate----abap-keyword-documentation---abap---reference---built-in-types--data-objects--functions--and-constructors---built-in-functions--included-pages--3---------source-----abenbuilt-in-functions-overview-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenbuilt-in-functions-overview-htm-------abenbuilt-in-functions-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------built-in-types--data-objects--functions--and-constructors--javascript-call-link---abenbuilt-in-htm---------built-in-functions--abap-provides-a-set-of-built-in-functions--a-built-in-function-returns-a-return-value-for-one-or-more-arguments--built-in-functions-can-be-called-by-functions-in-certain-operand-positions---built-in-functions-can-be-called-functionally-in--certain-operand-positions--javascript-call-link---abenoperands-expressions-htm------when-a-built-in-function-is-called-in-an--operand-position--javascript-call-link---abenexpression-positions-htm------the-function-is-executed-before-the-operand-is-used-and-the-return-value-of-the-built-in-function-is-used-as-the-operand--in-accordance-with-its-data-type--------built-in-functions---syntax--javascript-call-link---abenbuilt-in-functions-syntax-htm-----------built-in-functions---overview--javascript-call-link---abenbuilt-in-functions-overview-htm------continue--built-in-functions---syntax--javascript-call-link---abenbuilt-in-functions-syntax-htm------built-in-functions---overview--javascript-call-link---abenbuilt-in-functions-overview-htm-------------source-----abenbuilt-in-functions-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenbuilt-in-functions-htm-------abenbuilt-in-functions-syntax-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------built-in-types--data-objects--functions--and-constructors--javascript-call-link---abenbuilt-in-htm---------built-in-functions--javascript-call-link---abenbuilt-in-functions-htm---------built-in-functions---syntax-------functions-with-an-unnamed-argument---abenbuilt-in-functions-syntax-1--------functions-with-named-arguments---ITOC@@ABENBUILT_IN_FUNCTIONS_SYNTAX_2)

-   [Obscuring with Methods](#abenbuilt-in-functions-syntax-3---in-functions-with-named-arguments--there-is-usually-a-main-argument-val-and-additional--possibly-also-optional--arguments--the-following-sections-show-the-general-syntax-for-calling-built-in-functions---functions-with-an-unnamed-argument--syntax------func--arg--------the-syntax-for-functions-with-an-unnamed-argument-is-the-same-as-the-syntax-for-calling-functional-methods-with-an-input-parameter--func-is-the-built-in-function-and-the-argument-arg-is-an-operand-whose-data-type-matches-the-function--the-blanks-after-the-opening-parentheses-and-before-the-closing-parentheses-are-relevant---example--the-built-on-function--line--exists--javascript-call-link---abenline-exists-function-htm-----has-an-unnamed-argument-that-expects-a-table-expression---data-itab-type-table-of-i-with-empty-key------if-line--exists--itab---1-------------endif---functions-with-named-arguments--syntax------func--val---arg-p1---arg1-p2---arg2------------functions-with-one-or-more-named-arguments-are-bound-to-keyword-parameters-in-the-same-way-as-when-functional-methods-are-called-with-multiple-input-parameters--operands-can-be-specified-for-the-arguments-whose-data-type-matches-the-corresponding-parameter--the-blanks-after-the-opening-parentheses-and-before-the-closing-parentheses-are-relevant--if-one-of-these-functions-only-has-one-argument-or-only-the-main-argument-is-to-be-populated--the-syntax-can-be-simplified-as-follows-------func--arg--------example--the-built-in-function--condense--javascript-call-link---abencondense-functions-htm-----has-named-arguments-and-can--for-example--be-called-as-follows---data-str1----condense-------------data-str2----condense--val--------------data-str3----condense--val------------del-------------obscuring-with-methods--within-a-class--a-built-in-function-is-always-obscured-by--methods--javascript-call-link---abenmethod-glosry-htm-----glossary-entry---of-the-class-if-they-have-the-same-name--regardless-of-the-number-and-type-of-arguments-in-the-function--the-function-is-also-obscured-regardless-of-the-number-and-type-of-method-parameters--this-also-takes-place-in-method-calls-for-which-no-selector-----or-----is-specified-in-front-of-the-method-name-------a--static-method--javascript-call-link---abenstatic-method-glosry-htm-----glossary-entry---obscures-a-built-in-function-with-the-same-name-in-all-methods-of-the-associated-class-------an--instance-method--javascript-call-link---abeninstance-method-glosry-htm-----glossary-entry---obscures-a-built-in-function-with-the-same-name-in-the-instance-methods-of-the-associated-class---note--methods-should-never-be-given-the-same-name-as-a-built-in-function---example--the-following-class-returns-a-syntax-error--the-strlen-specified-on-the-right-side-of-the-assignment-indicates-the-method-of-the-class-and-not-the-built-in-function--it-cannot-be-specified-in-this-operand-position-since-it-is-not-a-functional-method-with-return-code---class-demo-definition----public-section------class-methods-main------class-methods-strlen-importing-text-type-string--------------------------exporting-len--type-i--endclass--class-demo-implementation----method-main------data-len----strlen----xxx--------endmethod----method-strlen------------endmethod--endclass----------source-----abenbuilt-in-functions-syntax-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenbuilt-in-functions-syntax-htm-------abenbuilt-in-functions-overview-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------built-in-types--data-objects--functions--and-constructors--javascript-call-link---abenbuilt-in-htm---------built-in-functions--javascript-call-link---abenbuilt-in-functions-htm---------built-in-functions---overview--the-following-tables-show-the-built-in-functions-by-purpose--built-in-functions-are-generally--processing-functions--javascript-call-link---abenprocess-function-glosry-htm-----glossary-entry---or--description-functions--javascript-call-link---abendescription-function-glosry-htm-----glossary-entry---------a-processing-function-performs-general-processing-and-returns-a-return-code-according-to-its-purpose-------a-description-function-determines-a-property-of-an-argument-and-usually-returns-this-property-as-a-numeric-value---other-functions-are-known-as-logical-functions--which-either-evaluate-a-logical-expression--boolean-functions--or-return-a-truth-value--predicate-functions----logical-functions--function--meaning---boolc--javascript-call-link---abenboole-functions-htm-------boolx--javascript-call-link---abenboole-functions-htm-------xsdbool--javascript-call-link---abenboole-functions-htm------boolean-functions---contains--javascript-call-link---abencontains-functions-htm-------contains--any--of--javascript-call-link---abencontains-functions-htm-------contains--any--not--of--javascript-call-link---abencontains-functions-htm------predicate-functions-for-strings---matches--javascript-call-link---abenmatches-functions-htm------predicate-function-for-strings---line--exists--javascript-call-link---abenline-exists-function-htm------predicate-function-for-internal-tables-----more--javascript-call-link---abenlogic-functions-htm------numeric-functions--function--meaning---abs--javascript-call-link---abennumerical-functions-htm-------ceil--javascript-call-link---abennumerical-functions-htm-------floor--javascript-call-link---abennumerical-functions-htm-------frac--javascript-call-link---abennumerical-functions-htm-------sign--javascript-call-link---abennumerical-functions-htm-------trunc--javascript-call-link---abennumerical-functions-htm------general-numeric-functions---ipow--javascript-call-link---abenpower-function-htm------integer-power-function---nmax--javascript-call-link---abennmax-nmin-functions-htm-------nmin--javascript-call-link---abennmax-nmin-functions-htm------numeric-extremum-functions---acos--javascript-call-link---abenfloating-point-functions-htm-------asin--javascript-call-link---abenfloating-point-functions-htm-------atan--javascript-call-link---abenfloating-point-functions-htm-------cos--javascript-call-link---abenfloating-point-functions-htm-------sin--javascript-call-link---abenfloating-point-functions-htm-------tan--javascript-call-link---abenfloating-point-functions-htm-------cosh--javascript-call-link---abenfloating-point-functions-htm-------sinh--javascript-call-link---abenfloating-point-functions-htm-------tanh--javascript-call-link---abenfloating-point-functions-htm-------exp--javascript-call-link---abenfloating-point-functions-htm-------log--javascript-call-link---abenfloating-point-functions-htm-------log10--javascript-call-link---abenfloating-point-functions-htm-------sqrt--javascript-call-link---abenfloating-point-functions-htm------floating-point-functions---round--javascript-call-link---abendec-floating-point-functions-htm-------rescale--javascript-call-link---abendec-floating-point-functions-htm------rounding-functions-----more--javascript-call-link---abenmathematical-functions-htm------string-functions--function--meaning---charlen--javascript-call-link---abenlength-functions-htm-------dbmaxlen--javascript-call-link---abenlength-functions-htm-------numofchar--javascript-call-link---abenlength-functions-htm-------strlen--javascript-call-link---abenlength-functions-htm------length-functions---char--off--javascript-call-link---abenlength-functions-args-htm------length-function---cmax--javascript-call-link---abencmax-cmin-functions-htm-------cmin--javascript-call-link---abencmax-cmin-functions-htm------character-like-extremum-value-functions---count--javascript-call-link---abencount-functions-htm-------count--any--of--javascript-call-link---abencount-functions-htm-------count--any--not--of--javascript-call-link---abencount-functions-htm------search-functions---distance--javascript-call-link---abendistance-functions-htm------similarity-function---condense--javascript-call-link---abencondense-functions-htm------condense-function---concat--lines--of--javascript-call-link---abenconcatenation-functions-htm------concatenation-function---escape--javascript-call-link---abenescape-functions-htm------escape-function---find--javascript-call-link---abensearch-functions-htm-------find--end--javascript-call-link---abensearch-functions-htm-------find--any--of--javascript-call-link---abensearch-functions-htm-------find--any--not--of--javascript-call-link---abensearch-functions-htm------search-functions---insert--javascript-call-link---abeninsert-functions-htm------insert-function---match--javascript-call-link---abenmatch-functions-htm------substring-function---repeat--javascript-call-link---abenrepeat-functions-htm------repeat-function---replace--javascript-call-link---abenreplace-functions-htm------replace-function---reverse--javascript-call-link---abenreverse-functions-htm------reverse-function---segment--javascript-call-link---abensegment-functions-htm------segment-function---shift--left--javascript-call-link---abenshift-functions-htm-------shift--right--javascript-call-link---abenshift-functions-htm------shift-functions---substring--javascript-call-link---abensubstring-functions-htm-------substring--after--javascript-call-link---abensubstring-functions-htm-------substring--from--javascript-call-link---abensubstring-functions-htm-------substring--before--javascript-call-link---abensubstring-functions-htm-------substring--to--javascript-call-link---abensubstring-functions-htm------substring-functions---to--upper--javascript-call-link---abencase-functions-htm-------to--lower--javascript-call-link---abencase-functions-htm-------to--mixed--javascript-call-link---abencase-functions-htm-------from--mixed--javascript-call-link---abencase-functions-htm------case-functions---translate--javascript-call-link---abentranslate-functions-htm------translation-function-----more--javascript-call-link---abenstring-functions-htm------byte-string-functions--function--meaning---xstrlen--javascript-call-link---abendescriptive-functions-binary-htm------length-function---bit-set--javascript-call-link---abenbit-functions-htm------bit-function-----more--javascript-call-link---abenbinary-functions-htm------table-functions--function--meaning---lines--javascript-call-link---abendescriptive-functions-table-htm------row-function---line--index--javascript-call-link---abenline-index-function-htm------index-function-----more--javascript-call-link---abentable-functions-htm----------------abap-keyword-documentation---abap---reference---declarations---declaration-statements---data-types-and-data-objects---types-and-objects---overview---data-objects---references----files----5-----difficulty----beginner----abap-keyword-documentation---abap---reference---declarations---declaration-statements---data-types-and-data-objects---special-declarations--included-pages--2---------source-----abenbuilt-in-functions-overview-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenbuilt-in-functions-overview-htm-------abendeclarations-spcl-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------declarations--javascript-call-link---abendeclarations-htm---------declaration-statements--javascript-call-link---abenabap-declarations-htm---------data-types-and-data-objects--javascript-call-link---abentypes-and-objects-htm---------special-declarations--these-language-elements-should-be-used-only-by-specialists-with-in-depth-knowledge-of-the-corresponding-environment--------infotypes--javascript-call-link---abapinfotypes-htm------continue--infotypes--javascript-call-link---abapinfotypes-htm-------------source-----abendeclarations-spcl-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abendeclarations-spcl-htm-------abapinfotypes-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------declarations--javascript-call-link---abendeclarations-htm---------declaration-statements--javascript-call-link---abenabap-declarations-htm---------data-types-and-data-objects--javascript-call-link---abentypes-and-objects-htm---------special-declarations--javascript-call-link---abendeclarations-spcl-htm---------infotypes--this-statement-should-be-used-by-specialists-only--in-depth-knowledge-of-the-corresponding-environment-is-essential--this-environment-is-not-part-of-abap-and-is-not-documented-here----quick-reference--javascript-call-link---abapinfotypes-shortref-htm------syntax--infotypes-nnnn-----name-name------------------------occurs-n------------------------mode-n---p------------------------as-person-table------------------------valid-from-intlim1-to-intlim2-------extras----1-------name-name----abap-addition-11@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](javascript:call_link\('abeninfo_type_glosry.htm'\) "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](javascript:call_link\('abenlogical_data_base_glosry.htm'\) "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{* 10 *|* n *}*.
  [INCLUDE TYPE](javascript:call_link\('abapinclude_type.htm'\)) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](javascript:call_link\('abenglobal_declaration_sect_glosry.htm'\) "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](javascript:call_link\('abaptypes_itab.htm'\))). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) object.
    
-   The logical database PNP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](javascript:call_link\('abapget-.htm'\)). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](javascript:call_link\('abapprovide_obsolete.htm'\)) of the statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)). If the addition VALID FROM is specified, other [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Types and Objects - Overview / Data Objects / Memory Management of Deep Objects

**Files**: 6 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2



**📖 Source**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)

### abendeclarations_spcl.htm

> **📖 Official SAP Documentation**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))

Continue
[INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))



**📖 Source**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)

### abapinfotypes.htm

> **📖 Official SAP Documentation**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) →  [Special Declarations](javascript:call_link\('abendeclarations_spcl.htm'\)) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](javascript:call_link\('abapinfotypes_shortref.htm'\))

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](javascript:call_link\('abeninfo_type_glosry.htm'\) "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](javascript:call_link\('abenlogical_data_base_glosry.htm'\) "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{* 10 *|* n *}*.
  [INCLUDE TYPE](javascript:call_link\('abapinclude_type.htm'\)) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](javascript:call_link\('abenglobal_declaration_sect_glosry.htm'\) "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](javascript:call_link\('abaptypes_itab.htm'\))). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) object.
    
-   The logical database PNP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](javascript:call_link\('abapget-.htm'\)). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](javascript:call_link\('abapprovide_obsolete.htm'\)) of the statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)). If the addition VALID FROM is specified, other [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Types / TYPES / TYPES - BEGIN OF struct_type

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2



**📖 Source**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)

### abendeclarations_spcl.htm

> **📖 Official SAP Documentation**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))

Continue
[INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))



**📖 Source**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)

### abapinfotypes.htm

> **📖 Official SAP Documentation**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) →  [Special Declarations](javascript:call_link\('abendeclarations_spcl.htm'\)) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](javascript:call_link\('abapinfotypes_shortref.htm'\))

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](javascript:call_link\('abeninfo_type_glosry.htm'\) "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](javascript:call_link\('abenlogical_data_base_glosry.htm'\) "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{* 10 *|* n *}*.
  [INCLUDE TYPE](javascript:call_link\('abapinclude_type.htm'\)) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](javascript:call_link\('abenglobal_declaration_sect_glosry.htm'\) "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](javascript:call_link\('abaptypes_itab.htm'\))). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) object.
    
-   The logical database PNP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](javascript:call_link\('abapget-.htm'\)). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](javascript:call_link\('abapprovide_obsolete.htm'\)) of the statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)). If the addition VALID FROM is specified, other [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Types / TYPES / TYPES - BEGIN OF MESH mesh_type

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2



**📖 Source**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)

### abendeclarations_spcl.htm

> **📖 Official SAP Documentation**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))

Continue
[INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))



**📖 Source**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)

### abapinfotypes.htm

> **📖 Official SAP Documentation**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) →  [Special Declarations](javascript:call_link\('abendeclarations_spcl.htm'\)) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](javascript:call_link\('abapinfotypes_shortref.htm'\))

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](javascript:call_link\('abeninfo_type_glosry.htm'\) "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](javascript:call_link\('abenlogical_data_base_glosry.htm'\) "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{* 10 *|* n *}*.
  [INCLUDE TYPE](javascript:call_link\('abapinclude_type.htm'\)) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](javascript:call_link\('abenglobal_declaration_sect_glosry.htm'\) "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](javascript:call_link\('abaptypes_itab.htm'\))). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) object.
    
-   The logical database PNP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](javascript:call_link\('abapget-.htm'\)). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](javascript:call_link\('abapprovide_obsolete.htm'\)) of the statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)). If the addition VALID FROM is specified, other [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Types / TYPES / TYPES - TABLE OF

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2



**📖 Source**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)

### abendeclarations_spcl.htm

> **📖 Official SAP Documentation**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))

Continue
[INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))



**📖 Source**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)

### abapinfotypes.htm

> **📖 Official SAP Documentation**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) →  [Special Declarations](javascript:call_link\('abendeclarations_spcl.htm'\)) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](javascript:call_link\('abapinfotypes_shortref.htm'\))

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](javascript:call_link\('abeninfo_type_glosry.htm'\) "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](javascript:call_link\('abenlogical_data_base_glosry.htm'\) "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{* 10 *|* n *}*.
  [INCLUDE TYPE](javascript:call_link\('abapinclude_type.htm'\)) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](javascript:call_link\('abenglobal_declaration_sect_glosry.htm'\) "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](javascript:call_link\('abaptypes_itab.htm'\))). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) object.
    
-   The logical database PNP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](javascript:call_link\('abapget-.htm'\)). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](javascript:call_link\('abapprovide_obsolete.htm'\)) of the statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)). If the addition VALID FROM is specified, other [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Types / TYPES / TYPES - LOB HANDLE

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2



**📖 Source**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)

### abendeclarations_spcl.htm

> **📖 Official SAP Documentation**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))

Continue
[INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))



**📖 Source**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)

### abapinfotypes.htm

> **📖 Official SAP Documentation**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) →  [Special Declarations](javascript:call_link\('abendeclarations_spcl.htm'\)) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](javascript:call_link\('abapinfotypes_shortref.htm'\))

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](javascript:call_link\('abeninfo_type_glosry.htm'\) "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](javascript:call_link\('abenlogical_data_base_glosry.htm'\) "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{* 10 *|* n *}*.
  [INCLUDE TYPE](javascript:call_link\('abapinclude_type.htm'\)) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](javascript:call_link\('abenglobal_declaration_sect_glosry.htm'\) "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](javascript:call_link\('abaptypes_itab.htm'\))). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) object.
    
-   The logical database PNP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](javascript:call_link\('abapget-.htm'\)). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](javascript:call_link\('abapprovide_obsolete.htm'\)) of the statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)). If the addition VALID FROM is specified, other [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Objects / Literals

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2



**📖 Source**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)

### abendeclarations_spcl.htm

> **📖 Official SAP Documentation**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))

Continue
[INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))



**📖 Source**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)

### abapinfotypes.htm

> **📖 Official SAP Documentation**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) →  [Special Declarations](javascript:call_link\('abendeclarations_spcl.htm'\)) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](javascript:call_link\('abapinfotypes_shortref.htm'\))

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](javascript:call_link\('abeninfo_type_glosry.htm'\) "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](javascript:call_link\('abenlogical_data_base_glosry.htm'\) "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{* 10 *|* n *}*.
  [INCLUDE TYPE](javascript:call_link\('abapinclude_type.htm'\)) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](javascript:call_link\('abenglobal_declaration_sect_glosry.htm'\) "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](javascript:call_link\('abaptypes_itab.htm'\))). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) object.
    
-   The logical database PNP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](javascript:call_link\('abapget-.htm'\)). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](javascript:call_link\('abapprovide_obsolete.htm'\)) of the statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)). If the addition VALID FROM is specified, other [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Objects / DATA / DATA - BEGIN OF struc

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2



**📖 Source**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)

### abendeclarations_spcl.htm

> **📖 Official SAP Documentation**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))

Continue
[INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))



**📖 Source**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)

### abapinfotypes.htm

> **📖 Official SAP Documentation**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) →  [Special Declarations](javascript:call_link\('abendeclarations_spcl.htm'\)) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](javascript:call_link\('abapinfotypes_shortref.htm'\))

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](javascript:call_link\('abeninfo_type_glosry.htm'\) "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](javascript:call_link\('abenlogical_data_base_glosry.htm'\) "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{* 10 *|* n *}*.
  [INCLUDE TYPE](javascript:call_link\('abapinclude_type.htm'\)) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](javascript:call_link\('abenglobal_declaration_sect_glosry.htm'\) "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](javascript:call_link\('abaptypes_itab.htm'\))). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) object.
    
-   The logical database PNP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](javascript:call_link\('abapget-.htm'\)). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](javascript:call_link\('abapprovide_obsolete.htm'\)) of the statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)). If the addition VALID FROM is specified, other [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Objects / DATA / DATA - TABLE OF

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2



**📖 Source**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)

### abendeclarations_spcl.htm

> **📖 Official SAP Documentation**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))

Continue
[INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))



**📖 Source**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)

### abapinfotypes.htm

> **📖 Official SAP Documentation**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) →  [Special Declarations](javascript:call_link\('abendeclarations_spcl.htm'\)) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](javascript:call_link\('abapinfotypes_shortref.htm'\))

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](javascript:call_link\('abeninfo_type_glosry.htm'\) "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](javascript:call_link\('abenlogical_data_base_glosry.htm'\) "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{* 10 *|* n *}*.
  [INCLUDE TYPE](javascript:call_link\('abapinclude_type.htm'\)) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](javascript:call_link\('abenglobal_declaration_sect_glosry.htm'\) "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](javascript:call_link\('abaptypes_itab.htm'\))). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) object.
    
-   The logical database PNP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](javascript:call_link\('abapget-.htm'\)). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](javascript:call_link\('abapprovide_obsolete.htm'\)) of the statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)). If the addition VALID FROM is specified, other [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2



**📖 Source**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)

### abendeclarations_spcl.htm

> **📖 Official SAP Documentation**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))

Continue
[INFOTYPES](javascript:call_link\('abapinfotypes.htm'\))



**📖 Source**: [abendeclarations_spcl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclarations_spcl.htm)

### abapinfotypes.htm

> **📖 Official SAP Documentation**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_and_objects.htm'\)) →  [Special Declarations](javascript:call_link\('abendeclarations_spcl.htm'\)) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](javascript:call_link\('abapinfotypes_shortref.htm'\))

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](javascript:call_link\('abeninfo_type_glosry.htm'\) "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](javascript:call_link\('abenlogical_data_base_glosry.htm'\) "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{* 10 *|* n *}*.
  [INCLUDE TYPE](javascript:call_link\('abapinclude_type.htm'\)) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](javascript:call_link\('abapdata_begin_of_occurs.htm'\)) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](javascript:call_link\('abenglobal_declaration_sect_glosry.htm'\) "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](javascript:call_link\('abaptypes_itab.htm'\))). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) object.
    
-   The logical database PNP fills the internal table for the event [GET](javascript:call_link\('abapget-.htm'\)) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](javascript:call_link\('abapget-.htm'\)) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](javascript:call_link\('abapget-.htm'\)). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](javascript:call_link\('abapprovide_obsolete.htm'\)) of the statement [PROVIDE](javascript:call_link\('abapprovide.htm'\)). If the addition VALID FROM is specified, other [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Classes / Components of classes / Methods of Classes

**Files**: 4 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapinfotypes.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinfotypes.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Classes / Components of classes / Constructors of Classes

**Files**: 2 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Inheritance

**Files**: 11 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Interfaces

**Files**: 2 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Objects

**Files**: 4 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Statements in ABAP Objects

**Files**: 6 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Examples for ABAP Objects

**Files**: 8 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / CLASS

**Files**: 12 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / INTERFACE

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Data Types and Attributes

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Methods / METHODS

**Files**: 9 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Methods / CLASS-METHODS

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Events

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing or Binding Interfaces

Included pages: 6



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abeninterfaces.htm

> **📖 Official SAP Documentation**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) → 

Implementing or Binding Interfaces

Interfaces can be implemented by classes or bound by other interfaces using the following statement:

-   [INTERFACES](javascript:call_link\('abapinterfaces.htm'\))

Aliases can be defined for interface components using the following statement:

-   [ALIASES](javascript:call_link\('abapaliases.htm'\))

Continue
[INTERFACES](javascript:call_link\('abapinterfaces.htm'\))
[ALIASES](javascript:call_link\('abapaliases.htm'\))



**📖 Source**: [abeninterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterfaces.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapinterfaces_class.htm

> **📖 Official SAP Documentation**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - implementation

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](javascript:call_link\('abapmethods_default.htm'\)).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\)).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](javascript:call_link\('abapmethods_abstract_final.htm'\)) and [FINAL](javascript:call_link\('abapmethods_abstract_final.htm'\)) of the statement [METHODS](javascript:call_link\('abapmethods.htm'\)). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](javascript:call_link\('abapmethods_abstract_final.htm'\)) or [final](javascript:call_link\('abapmethods_abstract_final.htm'\)).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](javascript:call_link\('abapdata.htm'\)) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](javascript:call_link\('abapconstants.htm'\)) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).



**📖 Source**: [abapinterfaces_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_class.htm)

### abapinterfaces_ifac.htm

> **📖 Official SAP Documentation**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) →  [INTERFACES](javascript:call_link\('abapinterfaces.htm'\)) → 

INTERFACES - integration

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access a component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).



**📖 Source**: [abapinterfaces_ifac.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces_ifac.htm)

### abapinterfaces.htm

> **📖 Official SAP Documentation**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

INTERFACES

[Quick Reference](javascript:call_link\('abapinterfaces_shortref.htm'\))

Syntax Forms

[Implementing Interfaces in Classes](javascript:call_link\('abapinterfaces_class.htm'\))
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](javascript:call_link\('abapinterfaces_partially.htm'\))*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Binding Interfaces into Interfaces](javascript:call_link\('abapinterfaces_ifac.htm'\))
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or binds interfaces into other interfaces. It can be used in the [public](javascript:call_link\('abenpublic_glosry.htm'\) "Glossary Entry") [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry") of the [declaration part](javascript:call_link\('abapclass_definition.htm'\)) of classes and in [interface declarations](javascript:call_link\('abapinterface_definition.htm'\)).

Continue
[INTERFACES - implementation](javascript:call_link\('abapinterfaces_class.htm'\))
[INTERFACES - integration](javascript:call_link\('abapinterfaces_ifac.htm'\))



**📖 Source**: [abapinterfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapinterfaces.htm)

### abapaliases.htm

> **📖 Official SAP Documentation**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Declarations](javascript:call_link\('abendeclarations.htm'\)) →  [Declaration Statements](javascript:call_link\('abenabap_declarations.htm'\)) →  [Classes and Interfaces](javascript:call_link\('abenclasses_and_interfaces.htm'\)) →  [Components in Classes and Interfaces](javascript:call_link\('abenclass_ifac_components.htm'\)) →  [Implementing or Binding Interfaces](javascript:call_link\('abeninterfaces.htm'\)) → 

ALIASES

[Quick Reference](javascript:call_link\('abapaliases_shortref.htm'\))

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](javascript:call_link\('abennaming_conventions.htm'\)) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](javascript:call_link\('abenvisibility_section_glosry.htm'\) "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](javascript:call_link\('abenredefinition_glosry.htm'\) "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](javascript:call_link\('abapmethods.htm'\)) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA dref

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA dref

Included pages: 2



**📖 Source**: [abapaliases.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapaliases.htm)

### abapcreate_data_implicit.htm

> **📖 Official SAP Documentation**: [abapcreate_data_implicit.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_implicit.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) → 

CREATE DATA dref

[Quick Reference](javascript:call_link\('abapcreate_data_shortref.htm'\))

Syntax

CREATE DATA dref *\[*[area\_handle](javascript:call_link\('abapcreate_data_area_handle.htm'\))*\]*.

Effect

Creates an anonymous data object with an implicit type. If none of the additions TYPE or LIKE is specified, data reference variable dref must be fully typed. The data object is then created with the static data type of the data reference variable.

Note

When the character # is used in an operand position with the operand type of a data reference variable, the [instance operator](javascript:call_link\('abeninstance_operator_glosry.htm'\) "Glossary Entry") [NEW](javascript:call_link\('abenconstructor_expression_new.htm'\)) works like the statement CREATE DATA dref.

Example

Creates an anonymous data object of the type SCARR from ABAP Dictionary. The type is implicitly determined using the static data type of the data reference variable.

DATA dref TYPE REF TO scarr.
CREATE DATA dref.
SELECT SINGLE \*
       FROM scarr
       WHERE  carrid = 'LH'
       INTO @dref->\*.
cl\_demo\_output=>display( |{ dref->carrid }, { dref->carrname }| ).

Executable Example

[Creating Data Objects with Implicit Type](javascript:call_link\('abencreate_data_implicit_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Creating Data Objects with Implicit Type](javascript:call_link\('abencreate_data_implicit_abexa.htm'\))



**📖 Source**: [abapcreate_data_implicit.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_implicit.htm)

### abencreate_data_implicit_abexa.htm

> **📖 Official SAP Documentation**: [abencreate_data_implicit_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_data_implicit_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) →  [CREATE DATA dref](javascript:call_link\('abapcreate_data_implicit.htm'\)) → 

Creating Data Objects with Implicit Type

This example demonstrates how data objects are created with an implicit type.

Source Code

REPORT demo\_create\_data\_implicit.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES t\_itab TYPE TABLE OF i WITH NON-UNIQUE KEY table\_line.
    DATA: tab\_ref TYPE REF TO t\_itab,
          i\_ref   TYPE REF TO i.
    IF tab\_ref IS INITIAL.
      CREATE DATA tab\_ref.
    ENDIF.
    tab\_ref->\* = VALUE #( FOR j = 1 UNTIL j > 10 ( j ) ).
    IF tab\_ref IS NOT INITIAL.
      IF i\_ref IS INITIAL.
        CREATE DATA i\_ref.
      ENDIF.
      LOOP AT tab\_ref->\* INTO i\_ref->\*.
        cl\_demo\_output=>write( |{ i\_ref->\* }| ).
      ENDLOOP.
    ENDIF.
    cl\_demo\_output=>display( ).
    CLEAR: tab\_ref, i\_ref.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Creates an internal table and a data object of type i. The data types of the objects in question are the static types of the reference variables tab\_ref and i\_ref. The data objects are created directly before they are used and are then initialized by the reference variables and passed to the [garbage collector](javascript:call_link\('abengarbage_collector_glosry.htm'\) "Glossary Entry"). The data objects are accessed by dereferencing the data references.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TYPE abap_type

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TYPE abap_type

Included pages: 2



**📖 Source**: [abencreate_data_implicit_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_data_implicit_abexa.htm)

### abapcreate_data_built_in.htm

> **📖 Official SAP Documentation**: [abapcreate_data_built_in.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_built_in.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) → 

CREATE DATA - TYPE abap\_type

[Quick Reference](javascript:call_link\('abapcreate_data_shortref.htm'\))

Syntax

CREATE DATA dref *\[*[area\_handle](javascript:call_link\('abapcreate_data_area_handle.htm'\))*\]*
                 TYPE *{*abap\_type*|*(name)*}*
                      *\[*LENGTH len*\]* *\[*DECIMALS dec*\]*.

Effect

Creates a data object with an explicitly specified data type. For the data type, all [built-in data types](javascript:call_link\('abenpredefined_data_type_glosry.htm'\) "Glossary Entry") (apart from b and s) can be used that are more specific than the static type of dref or are identical to it. The name of the type can be specified as follows:

-   abap\_type
    

Specified directly and statically as abap\_type.

-   (name)
    

Specified as the content of a character-like data object name (not case-sensitive). The following can be specified for name:

-   Literal or constant
    If the data object name is specified as a character literal or as a constant, it can be evaluated statically and the specified type is identified as the used object.

-   Variable
    If the data object name is specified as a variable, it is specified only dynamically and the content is not evaluated statically.

When the statement is executed, name is not evaluated until runtime (in both cases).

In the ABAP types c, n, p, and x, the length of the data type dtype can be determined by specifying a numeric data object len after the addition LENGTH, which, when the statement is executed, contains a value within the [length range](javascript:call_link\('abenbuilt_in_types_complete.htm'\)) defined for the type in question. If the addition LENGTH is not specified, the standard length from the table is used. For all other ABAP types, the length is determined by the value in the table and the addition LENGTH cannot be specified.

In the ABAP type p, the number of [decimal places](javascript:call_link\('abenfractional_portion_glosry.htm'\) "Glossary Entry") is determined by specifying a numeric data object dec after the addition DECIMALS. If DECIMALS is specified, the same applies as in the statement [TYPES](javascript:call_link\('abaptypes_simple.htm'\)). If the addition DECIMALS is not specified, no decimal places are created. The decimal separator is ignored in operations with packed numbers if the [program attribute](javascript:call_link\('abenprogram_attribute_glosry.htm'\) "Glossary Entry") fixed point arithmetic is not set. If it is not set, the addition DECIMALS is applied only to dynpros and in the statement [WRITE *\[*TO*\]*](javascript:call_link\('abapwrite_to.htm'\)). For all other ABAP types and if name is specified dynamically, the addition DECIMALS is not permitted.

Note

When a data type abap\_type is used, the [instance operator](javascript:call_link\('abeninstance_operator_glosry.htm'\) "Glossary Entry") [NEW](javascript:call_link\('abenconstructor_expression_new.htm'\)) acts like the statement CREATE DATA dref TYPE abap\_type and can be used in [general expression positions](javascript:call_link\('abengeneral_expr_position_glosry.htm'\) "Glossary Entry"). The content of name cannot be specified dynamically here.

Example

Creation of an anonymous data object of packed number type with length specification and decimals. As the static data type of the data reference variable is generic, data referencing is only possible by assignment to a field symbol.

DATA dref TYPE REF TO data.
CREATE DATA dref TYPE p LENGTH 8 DECIMALS 3.
ASSIGN dref->\* TO FIELD-SYMBOL(<fs>).
<fs> = 1 / 3.
cl\_demo\_output=>display( <fs> ).

Executable Example

[Creating Elementary Data Objects](javascript:call_link\('abencreate_simple_data_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Creating Elementary Data Objects](javascript:call_link\('abencreate_simple_data_abexa.htm'\))



**📖 Source**: [abapcreate_data_built_in.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_built_in.htm)

### abencreate_simple_data_abexa.htm

> **📖 Official SAP Documentation**: [abencreate_simple_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_simple_data_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) →  [CREATE DATA - TYPE abap\_type](javascript:call_link\('abapcreate_data_built_in.htm'\)) → 

Creating Elementary Data Objects

This example demonstrates how elementary data objects are created.

Source Code

REPORT demo\_create\_simple\_data.
CLASS create\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS create\_data IMPORTING
                                VALUE(typ) TYPE c
                                VALUE(len) TYPE i
                                VALUE(dec) TYPE i
                              RETURNING
                                VALUE(dref) TYPE REF TO data
                              RAISING cx\_sy\_create\_data\_error.
ENDCLASS.
CLASS create\_demo IMPLEMENTATION.
  METHOD main.
    DATA dref TYPE REF TO data.
    FIELD-SYMBOLS <fs> TYPE any.
    DATA: type     LENGTH 10 TYPE c,
          length   TYPE i,
          decimals TYPE i.
    cl\_demo\_input=>add\_field( EXPORTING text  = \`Builtin ABAP Type\`
                              CHANGING  field = type ).
    cl\_demo\_input=>add\_field( EXPORTING text  = \`Length\`
                              CHANGING  field = length ).
    cl\_demo\_input=>request(   EXPORTING text  = \`Decimals\`
                              CHANGING  field = decimals ).
    TRY.
        IF to\_lower( type ) = 'p' AND decimals > 2 \* length - 1.
          "Would lead to undefined state for packed number
          RAISE EXCEPTION TYPE cx\_sy\_create\_data\_error.
        ENDIF.
        dref = create\_data( typ = type
                            len = length
                            dec = decimals ).
        ASSIGN dref->\* TO <fs>.
        DESCRIBE FIELD <fs> TYPE type
                            LENGTH length IN BYTE MODE
                            DECIMALS decimals.
        cl\_demo\_output=>display( |{ type } { length } { decimals }| ).
      CATCH cx\_sy\_create\_data\_error.
        cl\_demo\_output=>display( |Error creating { type } {
                                                   length } {
                                                   decimals }| ).
    ENDTRY.
  ENDMETHOD.
  METHOD create\_data.
    TRANSLATE typ TO LOWER CASE.
    CASE typ.
      WHEN 'd' OR 'decfloat16' OR 'decfloat34' OR 'f' OR 'i'
               OR 'string' OR 't' OR 'xstring'.
        CREATE DATA dref TYPE (typ).
      WHEN 'c' OR 'n' OR 'x'.
        CREATE DATA dref TYPE (typ) LENGTH len.
      WHEN 'p'.
        CREATE DATA dref TYPE p LENGTH len DECIMALS dec.
      WHEN OTHERS.
        RAISE EXCEPTION TYPE cx\_sy\_create\_data\_error.
    ENDCASE.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  create\_demo=>main( ).

Description

The method create\_data creates all elementary data objects that are possible using built-in ABAP types, depending on the input parameters passed.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TYPE, LIKE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TYPE, LIKE

Included pages: 2



**📖 Source**: [abencreate_simple_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_simple_data_abexa.htm)

### abapcreate_data_existing.htm

> **📖 Official SAP Documentation**: [abapcreate_data_existing.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_existing.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) → 

CREATE DATA - TYPE, LIKE

[Quick Reference](javascript:call_link\('abapcreate_data_shortref.htm'\))

Syntax

CREATE DATA dref *\[*[area\_handle](javascript:call_link\('abapcreate_data_area_handle.htm'\))*\]*
                 *{* *{*TYPE *\[*LINE OF*\]* *{*type*|*(name)*}**}*
                 *|* *{*LIKE *\[*LINE OF*\]* dobj*}* *}*.

Effect

The type of the generated data object is defined by the specified type or data object.

-   type can be any data type from ABAP Dictionary, in particular the structure of a database table , a [classic view](javascript:call_link\('abenclassical_view_glosry.htm'\) "Glossary Entry"), or a [CDS](javascript:call_link\('abencds_entity_glosry.htm'\) "Glossary Entry") entity, a public data type of a global class, or any data type of the same program already defined defined using TYPES and that is either more specific than or identical to the static type of dref. Alternatively, a character-like data object name can be specified in parentheses that contains the name of the existing data type when the statement is executed. This is not case-sensitive. The name in name can also be an [absolute type name](javascript:call_link\('abenabsolute_typename_glosry.htm'\) "Glossary Entry"). If a standard table type with a generic primary table key is specified after TYPE, a new [bound](javascript:call_link\('abenbound_data_type_glosry.htm'\) "Glossary Entry") table type with standard key is created and used.
    
-   A data object that is [visible](javascript:call_link\('abenlifetime_and_visibility.htm'\)) at this point can be [specified](javascript:call_link\('abendata_objects_usage_reading.htm'\)) for dobj. The generated data object inherits the current data type. If dobj is specified as a formal parameter or field symbol, it can be fully or partially generic. When the statement CREATE DATA is executed, a data object must be bound to a generically typed field symbol or parameter and the type of the data object is used. In the case of a completely typed field symbol or parameter, the declared type is used. A data object does not have to be connected.
    

The optional addition LINE OF can be used if type or the name in name is a table type, or if dobj is an internal table. As a result, the generated data object inherits the attributes of the row type of the internal table.

Notes

-   LIKE can be used to reference the public attributes of global classes.
    
-   If a type of another program is specified using an [absolute type name](javascript:call_link\('abenabsolute_typename_glosry.htm'\) "Glossary Entry") in name, this program is loaded into a new [additional program group](javascript:call_link\('abenadditional_prog_group_glosry.htm'\) "Glossary Entry") or into the current [program group](javascript:call_link\('abenprogram_group_glosry.htm'\) "Glossary Entry"), depending on the program type (if not already loaded).
    
-   When an anonymous data object is created with an [enumerated type](javascript:call_link\('abaptypes_enum.htm'\)), the same rules apply for this object as for every other data object of this type.
    
-   When a data type type is used, the [instance operator](javascript:call_link\('abeninstance_operator_glosry.htm'\) "Glossary Entry") [NEW](javascript:call_link\('abenconstructor_expression_new.htm'\)) acts like the statement CREATE DATA dref TYPE type and can be used in [general expression positions](javascript:call_link\('abengeneral_expr_position_glosry.htm'\) "Glossary Entry"). The content of name cannot be specified dynamically here.
    

Example

Creates an anonymous data object of type SCARR. The static data type of the data reference variable is generic. If can only be dereferenced and used on operand positions by means of assignment to a field symbol.

DATA dref TYPE REF TO data.
CREATE DATA dref TYPE scarr.
ASSIGN dref->\* TO FIELD-SYMBOL(<fs>).
SELECT SINGLE \*
       FROM scarr
       WHERE carrid = 'LH'
       INTO @<fs>.
ASSIGN COMPONENT 'CARRID'   OF STRUCTURE <fs> TO FIELD-SYMBOL(<fs1>).
ASSIGN COMPONENT 'CARRNAME' OF STRUCTURE <fs> TO FIELD-SYMBOL(<fs2>).
cl\_demo\_output=>display( |{ <fs1> }, { <fs2> }| ).

Executable Example

[Creating Structured Data Objects](javascript:call_link\('abencreate_structured_data_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Creating Structured Data Objects](javascript:call_link\('abencreate_structured_data_abexa.htm'\))



**📖 Source**: [abapcreate_data_existing.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_existing.htm)

### abencreate_structured_data_abexa.htm

> **📖 Official SAP Documentation**: [abencreate_structured_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_structured_data_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) →  [CREATE DATA - TYPE, LIKE](javascript:call_link\('abapcreate_data_existing.htm'\)) → 

Creating Structured Data Objects

This example demonstrates how structured data objects are created.

Source Code

REPORT demo\_create\_structured\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA dref TYPE REF TO data.
    DATA: dbtab TYPE tabname VALUE 'SPFLI',
          rows  TYPE i VALUE 100.
    FIELD-SYMBOLS <wa> TYPE any.
    cl\_demo\_input=>new(
      )->add\_field( CHANGING field = dbtab
      )->add\_field( CHANGING field = rows )->request( ).
    DATA(out) = cl\_demo\_output=>new( ).
    dbtab = to\_upper( dbtab ).
    TRY.
        dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                  val = dbtab
                  packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        out->display( 'Database table not found' ).
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        out->display(
          'Only tables from the flight data model are allowed' ).
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        CREATE DATA dref TYPE (dbtab).
        ASSIGN dref->\* TO <wa>.
        SELECT \*
               FROM (dbtab) UP TO @rows ROWS
               INTO @<wa>.
          out->write( <wa> ).
        ENDSELECT.
        out->display( ).
      CATCH cx\_sy\_create\_data\_error.
        out->display( 'Error in data creation' ).
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Creates a work area that is compatible with a database table and reads the first few rows (rows) of the database table into this work area using a [SELECT](javascript:call_link\('abapselect.htm'\)) loop. Since the data reference dref is typed dynamically, the work area can only be read using the field symbol <wa>.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG checks whether the database table specified exists and can be used.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - HANDLE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - HANDLE

Included pages: 2



**📖 Source**: [abencreate_structured_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_structured_data_abexa.htm)

### abapcreate_data_handle.htm

> **📖 Official SAP Documentation**: [abapcreate_data_handle.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_handle.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) → 

CREATE DATA - HANDLE

[Quick Reference](javascript:call_link\('abapcreate_data_shortref.htm'\))

Syntax

CREATE DATA dref *\[*[area\_handle](javascript:call_link\('abapcreate_data_area_handle.htm'\))*\]*
                 TYPE HANDLE handle.

Effect

The statement CREATE DATA uses the addition HANDLE to create a data object whose data type is described by an [RTTS](javascript:call_link\('abenrun_time_type_services_glosry.htm'\) "Glossary Entry") [type description object](javascript:call_link\('abentype_object_glosry.htm'\) "Glossary Entry"). handle expects a reference variable of the static type of class CL\_ABAP\_DATADESCR or its subclasses that points to a type description object. The type description object may have been created by applying the RTTS methods to existing data objects or by using the dynamic definition of a new data type.

The type description object must describe a non-generic type. Only type description objects for the generic ABAP types c, n, p, and x create a new [bound data type](javascript:call_link\('abenbound_data_type_glosry.htm'\) "Glossary Entry") and use it with the [standard values](javascript:call_link\('abenbuilt_in_types_complete.htm'\)). Similarly, a type description object for a standard table with a generic table type creates a new bound table type and uses it with a standard key.

Notes

The following are important methods for the dynamic definition of data types:

-   GET\_C, GET\_D, GET\_F ... of the class CL\_ABAP\_ELEMDESCR for type description objects of elementary data types. These methods create either a new type description object in accordance with the input parameters or reuse an existing type object.

-   GET of the classes CL\_ABAP\_STRUCTDESCR, CL\_ABAP\_TABLEDESCR, and CL\_ABAP\_REFDESCR plus GET\_BY\_NAME of the class CL\_ABAP\_REFDESCR for type description objects of structures, internal tables, and reference variables. These methods return the type description object that was specified using the input parameters. A new type description object is created or an existing one is used again.

-   CREATE of the classes CL\_ABAP\_STRUCTDESCR, CL\_ABAP\_TABLEDESCR, and CL\_ABAP\_REFDESCR for creating type description objects for structures, internal tables, and reference variables. These methods return the type description object that was specified using the input parameters. A new type description object is always created.

-   It is advisable to use the GET methods instead of CREATE to avoid creating multiple type description objects for a single type.
    

Example

Creates an anonymous data object using a type description object for a dictionary structure provided by [RTTI](javascript:call_link\('abenrun_time_type_identific_glosry.htm'\) "Glossary Entry").

DATA dref TYPE REF TO data.
DATA(type) = CAST cl\_abap\_datadescr(
  cl\_abap\_typedescr=>describe\_by\_name( 'SCARR' ) ).
CREATE DATA dref TYPE HANDLE type.

Executable Example

[Creating a Structure Using RTTC](javascript:call_link\('abencreate_data_via_rttc_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Creating a Structure Using RTTC](javascript:call_link\('abencreate_data_via_rttc_abexa.htm'\))



**📖 Source**: [abapcreate_data_handle.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_handle.htm)

### abencreate_data_via_rttc_abexa.htm

> **📖 Official SAP Documentation**: [abencreate_data_via_rttc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_data_via_rttc_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) →  [CREATE DATA - HANDLE](javascript:call_link\('abapcreate_data_handle.htm'\)) → 

Creating a Structure Using RTTC

This example demonstrates how a structure is created using [RTTC](javascript:call_link\('abenrun_time_type_creation_glosry.htm'\) "Glossary Entry").

Source Code

REPORT demo\_create\_data\_via\_handle.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: struct\_type TYPE REF TO cl\_abap\_structdescr,
          dref        TYPE REF TO data,
          oref        TYPE REF TO cx\_sy\_struct\_creation.
    DATA column1 TYPE c LENGTH 30.
    DATA column2 TYPE c LENGTH 30.
    FIELD-SYMBOLS: <struc>  TYPE any,
                   <comp1>  TYPE any,
                   <comp2>  TYPE any.
    cl\_demo\_input=>add\_field( CHANGING field = column1 ).
    cl\_demo\_input=>add\_field( CHANGING field = column2 ).
    cl\_demo\_input=>request( ).
    column1 = to\_upper( column1 ).
    column2 = to\_upper( column2 ).
    TRY.
        struct\_type = cl\_abap\_structdescr=>get(
          VALUE #(
            ( name = column1 type = cl\_abap\_elemdescr=>get\_c( 40 ) )
            ( name = column2 type = cl\_abap\_elemdescr=>get\_i( )    )
                 )
                                               ).
        CREATE DATA dref TYPE HANDLE struct\_type.
      CATCH cx\_sy\_struct\_creation INTO oref.
        cl\_demo\_output=>display( oref->get\_text( ) ).
        RETURN.
    ENDTRY.
    ASSIGN dref->\* TO <struc>.
    ASSIGN COMPONENT column1 OF STRUCTURE <struc> TO <comp1>.
    <comp1> = 'Amount'.
    ASSIGN dref->\* TO <struc>.
    ASSIGN COMPONENT column2 OF STRUCTURE <struc> TO <comp2>.
    <comp2> = 11.
    cl\_demo\_output=>display( |{ column1 WIDTH = 32 } { <comp1> }\\n| &
                             |{ column2 WIDTH = 32 } { <comp2> }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Dynamic definition of a structure with two components using the GET method of the CL\_ABAP\_STRUCTDESCR class. The description of the components of the structure is provided in the internal table comp\_tab. If no type description object exists for this structure yet, it is created by the GET method.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG checks whether the database table specified exists and can be used.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - REF TO

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - REF TO

Included pages: 2



**📖 Source**: [abencreate_data_via_rttc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_data_via_rttc_abexa.htm)

### abapcreate_data_reference.htm

> **📖 Official SAP Documentation**: [abapcreate_data_reference.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_reference.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) → 

CREATE DATA - REF TO

[Quick Reference](javascript:call_link\('abapcreate_data_shortref.htm'\))

Syntax

CREATE DATA dref *\[*[area\_handle](javascript:call_link\('abapcreate_data_area_handle.htm'\))*\]*
                 TYPE REF TO *{*type*|*(name)*}*.

Effect

The addition TYPE REF TO is used by the statement CREATE DATA to create a reference variable. The static type of the reference variable can be specified either directly as type or dynamically in name.

When type is specified, the same rules apply as to the definition of reference types using the statement [TYPES](javascript:call_link\('abaptypes.htm'\)). For data reference variables, either the generic type data or a fully specified data type can be specified. For object reference variables, either a class or an interface can be specified.

For name, a character-like field can be specified that has to contain the name of a class, an interface, or a data type when the statement is executed. The name of the reference type in name can also be specified as an [absolute type name](javascript:call_link\('abenabsolute_typename_glosry.htm'\) "Glossary Entry").

Note

Object types in name can also be specified dynamically in lowercase letters.

Example

Creation of an anonymous data object as reference variable of the static type of a class. The dereferenced reference variable can be used to create an object of the class and for access to its components.

CLASS cls DEFINITION.
  PUBLIC SECTION.
    DATA attr TYPE string VALUE \`Oh my ...\`.
ENDCLASS.
TYPES reftype TYPE REF TO cls.
DATA dref TYPE REF TO reftype.
CREATE DATA dref TYPE REF TO cls.
CREATE OBJECT dref->\*.
cl\_demo\_output=>display( dref->\*->attr ).

Executable Example

[Creating Reference Variables](javascript:call_link\('abencreate_reference_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Creating Reference Variables](javascript:call_link\('abencreate_reference_abexa.htm'\))



**📖 Source**: [abapcreate_data_reference.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_reference.htm)

### abencreate_reference_abexa.htm

> **📖 Official SAP Documentation**: [abencreate_reference_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_reference_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) →  [CREATE DATA - REF TO](javascript:call_link\('abapcreate_data_reference.htm'\)) → 

Creating Reference Variables

This example demonstrates how reference variables are created.

Source Code

REPORT demo\_create\_reference.
INTERFACE intf.
  CONSTANTS attr TYPE string VALUE \`Interface constant\`.
ENDINTERFACE.
CLASS cls DEFINITION.
  PUBLIC SECTION.
    INTERFACES intf.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA intf\_name TYPE string.
    DATA cls\_name  TYPE string.
    DATA dref TYPE REF TO data.
    FIELD-SYMBOLS <ref>  TYPE any.
    FIELD-SYMBOLS <attr> TYPE any.
    intf\_name = '\\PROGRAM=DEMO\_CREATE\_REFERENCE\\INTERFACE=INTF'.
    CREATE DATA dref TYPE REF TO (intf\_name).
    ASSIGN dref->\* TO <ref>.
    cls\_name = '\\PROGRAM=DEMO\_CREATE\_REFERENCE\\CLASS=CLS'.
    CREATE OBJECT <ref> TYPE (cls\_name).
    ASSIGN ('<REF>->ATTR') TO <attr>.
    cl\_demo\_output=>display\_data( <attr> ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Creates an interface reference variable dynamically. The [absolute type name](javascript:call_link\('abenabsolute_typename_glosry.htm'\) "Glossary Entry") is used for the name of the local interface.

The reference variable is assigned to a field symbol <ref> using dereferencing. According to the [general typing rules](javascript:call_link\('abentyping_check_general.htm'\)), the field symbol must either be typed in full generically or typed with reference to the interface intf.

The dynamically created reference variable is used to create and address an object of a class. Since this field symbol is fully generic, only the display variant of the [dynamic ASSIGN](javascript:call_link\('abapassign_mem_area_dynamic_dobj.htm'\)) (and not a special [dynamic access](javascript:call_link\('abapassign_mem_area_dynamic_access.htm'\))) can be used to access the interface attribute.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TABLE OF

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TABLE OF

Included pages: 2



**📖 Source**: [abencreate_reference_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_reference_abexa.htm)

### abapcreate_data_itab.htm

> **📖 Official SAP Documentation**: [abapcreate_data_itab.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_itab.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) → 

CREATE DATA - TABLE OF

[Quick Reference](javascript:call_link\('abapcreate_data_shortref.htm'\))

Syntax

CREATE DATA dref *\[*[area\_handle](javascript:call_link\('abapcreate_data_area_handle.htm'\))*\]*
                 *{* *{*TYPE *\[*STANDARD*\]**|*SORTED*|*HASHED TABLE OF *\[*REF TO*\]* *{*type*|*(name)*}**}*
                 *|* *{*LIKE *\[*STANDARD*\]**|*SORTED*|*HASHED TABLE OF dobj*}* *}*
                 *\[* WITH *{* *{**\[*UNIQUE*|*NON-UNIQUE*\]*
                           *{*KEY *{*comp1 comp2 ...*}**|*(keytab)*}**|**{*DEFAULT KEY*}**}**}*
                        *|* *{*EMPTY KEY*}*  *\]*
                 *\[*INITIAL SIZE n*\]*.

Effect

The statement CREATE DATA uses the addition tabkind OF to create an internal table. The meaning of the additions is the same as when declaring internal tables using the statement [DATA](javascript:call_link\('abapdata_itab.htm'\)), but with special rules for [CREATE DATA](javascript:call_link\('abapcreate_data_existing.htm'\)) if dobj is specified after LIKE. The explicit definition of the primary table key is only optional if a [standard table](javascript:call_link\('abenstandard_table_glosry.htm'\) "Glossary Entry") is being created.

Whereas the content of DATA is specified statically, the following can be specified dynamically for CREATE DATA:

-   The row type after TYPE or the static type of a row flagged as a reference variable after TYPE REF TO can have a character-like data object called name. In this case, the same rules apply as in the other variants of CREATE DATA.
    
-   The definition of the primary table key can specify a parenthesized internal table keytab instead of a static component comp1 comp2 ...:
    ... WITH *\[*UNIQUE*|*NON-UNIQUE*\]* KEY (keytab) ...
    The table keytab must have a character-like data type and must contain the name of a valid component in each row or the identifier table\_line for the primary table key in a single row.
    
-   A numeric data object can be specified for n after INITIAL SIZE.
    

Notes

-   The definition of the table key is subject to the following conditions that do not apply to DATA:
    

-   No [secondary table keys](javascript:call_link\('abensecondary_table_key_glosry.htm'\) "Glossary Entry") can be defined in the statement CREATE DATA.

-   The name [primary\_key](javascript:call_link\('abapdata_primary_key.htm'\)) and the addition [COMPONENTS](javascript:call_link\('abapdata_primary_key.htm'\)) cannot be specified explicitly in the definition of the primary key.

[Runtime type creation](javascript:call_link\('abenrun_time_type_creation_glosry.htm'\) "Glossary Entry") should be used instead to create dynamic table types with secondary keys. The same applies when creating an [empty table key](javascript:call_link\('abenitab_empty_key.htm'\)) dynamically, since the internal table keytab can only be used to define non-empty keys.

-   CREATE DATA cannot be used to create internal tables with [header lines](javascript:call_link\('abenheader_line_glosry.htm'\) "Glossary Entry").
    

Example

Creates and uses an anonymous hash table. The type of the data reference variable is generic, which means it can only be dereferenced in the case of assignment to a field symbol.

DATA dref TYPE REF TO data.
FIELD-SYMBOLS <fs> TYPE ANY TABLE.
CREATE DATA dref TYPE HASHED TABLE OF scarr
                 WITH UNIQUE KEY carrid.
ASSIGN dref->\* TO <fs>.
SELECT \*
       FROM scarr
       INTO TABLE @<fs>.
cl\_demo\_output=>display( <fs> ).

Executable Example

[Creating Tabular Data Objects](javascript:call_link\('abencreate_tabular_data_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Creating Tabular Data Objects](javascript:call_link\('abencreate_tabular_data_abexa.htm'\))



**📖 Source**: [abapcreate_data_itab.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_itab.htm)

### abencreate_tabular_data_abexa.htm

> **📖 Official SAP Documentation**: [abencreate_tabular_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_tabular_data_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) →  [CREATE DATA - TABLE OF](javascript:call_link\('abapcreate_data_itab.htm'\)) → 

Creating Tabular Data Objects

The example demonstrates the creation of tabular data objects

Source Code

REPORT demo\_create\_tabular\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA dref TYPE REF TO data.
    DATA: dbtab TYPE tabname VALUE 'SPFLI',
          rows  TYPE i VALUE 100.
    FIELD-SYMBOLS <table> TYPE ANY TABLE.
    cl\_demo\_input=>new(
      )->add\_field( CHANGING field = dbtab
      )->add\_field( CHANGING field = rows )->request( ).
    DATA(out) = cl\_demo\_output=>new( ).
    dbtab = to\_upper( dbtab ).
    TRY.
        cl\_abap\_dyn\_prg=>check\_table\_name\_str(
          val = dbtab
          packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        out->display( 'Database table not found' ).
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        out->display(
          'Only tables from the flight data model are allowed' ).
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        CREATE DATA dref TYPE STANDARD TABLE OF (dbtab)
                              WITH NON-UNIQUE DEFAULT KEY.
        ASSIGN dref->\* TO <table>.
        SELECT \*
               FROM (dbtab) UP TO @rows ROWS
               INTO TABLE @<table>.
        out->display( <table> ).
      CATCH cx\_sy\_create\_data\_error.
        out->display( 'Error in data creation' ).
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Creating an internal table that matches any database table and reading the first rows (rows) of the database into the internal table. Since the dref data reference is dynamically typed, access to the internal table can only take place using the <tab> field symbol.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG checks whether the database table specified exists and can be used.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - AREA HANDLE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - AREA HANDLE

Included pages: 2



**📖 Source**: [abencreate_tabular_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_tabular_data_abexa.htm)

### abapcreate_data_area_handle.htm

> **📖 Official SAP Documentation**: [abapcreate_data_area_handle.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_area_handle.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) → 

CREATE DATA - AREA HANDLE

[Quick Reference](javascript:call_link\('abapcreate_data_shortref.htm'\))

Syntax

CREATE DATA dref AREA HANDLE handle ...

Effect

This statement creates an anonymous data object as a [shared object](javascript:call_link\('abenshared_object_glosry.htm'\) "Glossary Entry") in the [area instance version](javascript:call_link\('abenarea_instance_version_glosry.htm'\) "Glossary Entry") of the [shared memory](javascript:call_link\('abenshared_memory_glosry.htm'\) "Glossary Entry") to which the [area handle](javascript:call_link\('abenarea_handle_glosry.htm'\) "Glossary Entry") referenced by handle is bound.

handle expects an object reference variable whose static type is [CL\_ABAP\_MEMORY\_AREA](javascript:call_link\('abenshm_cl_abap_memory_area.htm'\)) or one of its subclasses ([area class](javascript:call_link\('abenarea_class_glosry.htm'\) "Glossary Entry")). When the statement is executed, handle must point to an [area handle](javascript:call_link\('abenarea_handle_glosry.htm'\) "Glossary Entry") and the area handle must be associated with an area instance version with a change lock. A reference like this can be created in one of the following ways:

-   By inheriting the return value of the methods [ATTACH\_FOR\_WRITE](javascript:call_link\('abenshm_area_class.htm'\)) or [ATTACH\_FOR\_UPDATE](javascript:call_link\('abenshm_area_class.htm'\)) of an area class created using transaction SHMA.
    
-   By inheriting the return value of the method [GET\_HANDLE\_BY\_...](javascript:call_link\('abenshm_cl_abap_memory_area.htm'\)) of any area class.
    
-   By inheriting the return value of the method [GET\_IMODE\_HANDLE](javascript:call_link\('abenshm_cl_imode_area.htm'\)) of the predefined class CL\_IMODE\_AREA.
    

The latter is a reference to an area handle for the current [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") and the statement CREATE DATA operates as if the addition AREA HANDLE is not specified.

Restrictions

The creation of anonymous data objects as shared objects is subject to the following restrictions for data references in the shared objects memory: the storage of data references in closed [area instance versions](javascript:call_link\('abenarea_instance_version_glosry.htm'\) "Glossary Entry") of the shared objects memory is restricted to those [dynamic types](javascript:call_link\('abendynamic_type_glosry.htm'\) "Glossary Entry") that are known when loading a program into an internal session.

Therefore, the following data types cannot be used to create anonymous data objects in the shared object memory, if these are to be preserved in a closed area instance version:

1.  All data types created in a temporary subroutine pool created using [GENERATE SUBROUTINE POOL](javascript:call_link\('abapgenerate_shortref.htm'\)).
    
2.  Data types created dynamically at runtime using methods of the [RTTC](javascript:call_link\('abenrun_time_type_creation_glosry.htm'\) "Glossary Entry").
    
3.  Bound data types of anonymous data objects created at program runtime and to which a dynamic length was assigned when they were created with CREATE DATA.
    
4.  Bound data types of anonymous data objects created at program runtime and to which a dynamic type requiring length definition was assigned when the data objects were created using CREATE DATA.
    

Points 3 and 4 include the statement CREATE DATA with the addition AREA HANDLE itself. Exceptions to the restrictions listed under points 2 to 4 are:

-   The restrictions are not valid for data type p.
    
-   The restrictions are not valid for data types c, n, and x as long as the memory requirements do not exceed 100 bytes.
    

If a data reference variable that is stored in the shared objects memory refers to an anonymous data object of a dynamic type that is subject to the restrictions, the exception of the class CX\_SHM\_EXTERNAL\_TYPE is raised when the DETACH\_COMMIT method is executed.

The following can be used without restriction:

-   All visible data types of global interfaces and classes.
    
-   Data elements, structures, and database tables and table types from ABAP Dictionary.
    
-   Data types from type groups.
    
-   Bound data types of anonymous data objects created at program runtime to which a static type with a static length was assigned when they were created using CREATE DATA.
    
-   Bound data types of anonymous data objects created at program runtime to which a fully specified dynamic type was assigned when they were created using CREATE DATA.
    
-   All data types that were created statically in the same program using declarative statements. It should be noted, however, that it is no longer possible to access existing area instances once the creating program is changed.
    

The additions [REF TO](javascript:call_link\('abapcreate_data_reference.htm'\)) and [TABLE OF](javascript:call_link\('abapcreate_data_itab.htm'\)) can be used as long as the specified types meet the above requirements. This also applies to the addition [HANDLE](javascript:call_link\('abapcreate_data_handle.htm'\)), which means the type description object must have been created with methods of the [RTTI](javascript:call_link\('abenrun_time_type_identific_glosry.htm'\) "Glossary Entry") from allowed types.

Notes

-   The only shared object that can be addressed from an ABAP program directly after a binding is made to an area instance version is the instance of the [area root class](javascript:call_link\('abenroot_data_class_glosry.htm'\) "Glossary Entry"). All other objects have to be referenced in this instance. In particular, there is no direct access to anonymous data objects possible. Instead, the instance of the area root class must contain references to these anonymous data objects, which can also be indirect.
    
-   It is best to use only global data types with AREA HANDLE. As an occasional replacement for the direct reference to data elements and table types from ABAP Dictionary, the respective types can be created in global interfaces, classes, or even type groups.
    

Example

Creates an anonymous structure in an area instance version of area CL\_DEMO\_AREA.

DATA: root   TYPE REF TO cl\_demo\_root,
      handle TYPE REF TO cl\_demo\_area.
...
handle = cl\_demo\_area=>attach\_for\_write( ).
CREATE OBJECT root AREA HANDLE handle.
handle->set\_root( root ).
CREATE DATA root->dref AREA HANDLE handle TYPE scarr.
...

Executable Example

[Creating a Data Object as a Shared Object](javascript:call_link\('abencreate_shared_data_objct_abexa.htm'\))

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Handleable Exceptions

CX\_SHM\_WRONG\_HANDLE

-   Cause: The area handle does not hold any change locks.
    

CX\_SHM\_ALREADY\_DETACHED

-   Cause: The area handle is not bound to an area instance version.
    

CX\_SHM\_OUT\_OF\_MEMORY

-   Cause: There is not enough memory.
    

Continue
![Example](exa.gif "Example") [Creating a Data Object as a Shared Object](javascript:call_link\('abencreate_shared_data_objct_abexa.htm'\))



**📖 Source**: [abapcreate_data_area_handle.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_data_area_handle.htm)

### abencreate_shared_data_objct_abexa.htm

> **📖 Official SAP Documentation**: [abencreate_shared_data_objct_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_shared_data_objct_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)) →  [CREATE DATA - AREA HANDLE](javascript:call_link\('abapcreate_data_area_handle.htm'\)) → 

Creating a Data Object as a Shared Object

This example demonstrates how a data object is created in an [area instance version](javascript:call_link\('abenarea_instance_version_glosry.htm'\) "Glossary Entry").

Source Code

REPORT demo\_create\_shared\_data\_object.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: handle TYPE REF TO cl\_demo\_area,
          root   TYPE REF TO cl\_demo\_root,
          exc    TYPE REF TO cx\_shm\_attach\_error.
    FIELD-SYMBOLS <fs> TYPE any.
    DATA(out) = cl\_demo\_output=>new( ).
    TRY.
        handle = cl\_demo\_area=>attach\_for\_write( ).
        CREATE OBJECT root AREA HANDLE handle.
        handle->set\_root( root ).
        CREATE DATA root->dref AREA HANDLE handle TYPE string.
        ASSIGN root->dref->\* TO <fs>.
        <fs> = \`String in shared memory\`.
        handle->detach\_commit( ).
      CATCH cx\_shm\_attach\_error INTO exc.
        out->display( exc->get\_text( ) ).
        LEAVE PROGRAM.
      CATCH cx\_shm\_external\_type.
        out->display( 'Type cannot be used' ).
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        handle = cl\_demo\_area=>attach\_for\_read( ).
        ASSIGN handle->root->dref->\* TO <fs>.
        out->display( <fs> ).
        handle->detach( ).
      CATCH cx\_shm\_attach\_error INTO exc.
        out->display( exc->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The addition AREA HANDLE is used to create an anonymous data object of type string as a [shared object](javascript:call_link\('abenshared_object_glosry.htm'\) "Glossary Entry") in an [area instance version](javascript:call_link\('abenarea_instance_version_glosry.htm'\) "Glossary Entry") of the area CL\_DEMO\_AREA. The generically typed attribute dref of the [area root class](javascript:call_link\('abenroot_data_class_glosry.htm'\) "Glossary Entry") CL\_DEMO\_ROOT is used as a reference variable. A field symbol is used to dereference the data reference and assign a value to the anonymous data object.

Once the method DETACH\_COMMIT completes the write, a read is performed to demonstrate how the objects in the shared memory are accessed. An access of this type can also be made in another program, as long as the area instance version exists in the shared memory.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE OBJECT

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE OBJECT

Included pages: 8



**📖 Source**: [abencreate_shared_data_objct_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_shared_data_objct_abexa.htm)

### abapcreate_object.htm

> **📖 Official SAP Documentation**: [abapcreate_object.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) → 

CREATE OBJECT

[Quick Reference](javascript:call_link\('abapcreate_object_shortref.htm'\))

Syntax Forms

[Defining a Class Implicitly](javascript:call_link\('abapcreate_object_implicit.htm'\))
1\. CREATE OBJECT oref *\[* [area\_handle](javascript:call_link\('abapcreate_object_area_handle.htm'\))*\]* *\[* [parameter\_list](javascript:call_link\('abapcreate_object_parameters.htm'\))*\]*.
[Defining a Class Explicitly](javascript:call_link\('abapcreate_object_explicit.htm'\))
2\. CREATE OBJECT oref *\[* [area\_handle](javascript:call_link\('abapcreate_object_area_handle.htm'\))*\]*
                     TYPE *{* class  *\[*[parameter\_list](javascript:call_link\('abapcreate_object_parameters.htm'\))*\]* *}*
                        *|* *{* (name) *\[* [parameter\_list](javascript:call_link\('abapcreate_object_parameters.htm'\))*|* [parameter\_tables](javascript:call_link\('abapcreate_object_para_tables.htm'\))*\]* *}*.

Effect

The statement CREATE OBJECT creates an instance of a class or object and assigns the object reference to the reference variable oref. The instance constructor of the class is called directly after the object is created.

By default, the object is created in the [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") (or [heap](javascript:call_link\('abenheap_glosry.htm'\) "Glossary Entry")) of the current program and remains there for as long as it is required. If no more [heap references](javascript:call_link\('abenheap_reference_glosry.htm'\) "Glossary Entry") point to the object, the following applies:

-   No more object references point to the object.
    
-   no data reference can no field symbol points to an instance attribute or to a part of an instance attribute,
    

Also, if no more methods of the object are registered as event handlers, the object is deleted by the [garbage collector](javascript:call_link\('abengarbage_collector_glosry.htm'\) "Glossary Entry"). The addition [area\_handle](javascript:call_link\('abapcreate_object_area_handle.htm'\)) can be used to create the object as a [shared object](javascript:call_link\('abenshared_object_glosry.htm'\) "Glossary Entry").

The reference variable oref must be declared as an object reference variable. Instance components of an object created using CREATE OBJECT can only be accessed using object reference variables (see [Data Objects in Operand Positions](javascript:call_link\('abenoperands_data_objects.htm'\))).

The addition TYPE can be used to specify the class of the new object. The static type of the object reference variables must be more general than or identical to the class of the new object (in accordance with the rules for [Assignments Between Object Reference Variables](javascript:call_link\('abenconversion_references_objects.htm'\))).

Instances of a class can be created only where permitted by the addition CREATE of the statement [CLASS DEFINITION](javascript:call_link\('abapclass.htm'\)). The class can be a local class of the same ABAP program or a global class from the class library permitted by the package check.

The additions [parameter\_list](javascript:call_link\('abapcreate_object_parameters.htm'\)) and [parameter\_tables](javascript:call_link\('abapcreate_object_para_tables.htm'\)) must be used to fill the non-optional input parameters of the first explicitly implemented instance constructor in the path of the inheritance tree between the instantiated class and the root class object. These additions can also be used to assign return values to the non-class-based exceptions of the instance constructor.

If a handleable exception is raised for the object in the runtime environment, the object is not created and the object reference variable oref is initialized. If a handleable exception is raised when the object is created in the instance constructor of the class, the object is deleted and the object reference variable oref is initialized.

Return Value
If the CREATE OBJECT statement is executed successfully, sy-subrc is set to 0. Values other than 0 can occur when specifying EXCEPTIONS in parameter\_spec when non-class-based exceptions of the instance constructor are handled.

Notes

-   If the reference variable oref specified after CREATE OBJECT is passed simultaneously to the instance constructor, it points to the new object when this constructor is executed. To pass a reference to an existing object to the instance constructor, a different reference variable needs to be used.
    
-   The statement CREATE OBJECT creates a [heap reference](javascript:call_link\('abenheap_reference_glosry.htm'\) "Glossary Entry"). All references that point to the object or its parts are also heap references and keep the object alive. The same applies to field symbols that point to instance attributes or to their parts.
    
-   When a class is used, the [instance operator](javascript:call_link\('abeninstance_operator_glosry.htm'\) "Glossary Entry") [NEW](javascript:call_link\('abenconstructor_expression_new.htm'\)) acts like the statement CREATE OBJECT oref TYPE class and can be used in [general expression positions](javascript:call_link\('abengeneral_expr_position_glosry.htm'\) "Glossary Entry").
    
-   The return code sy-subrc is set to 0 if the statement is successful because the instance constructor is called. sy-subrc is set each time a [method is called](javascript:call_link\('abapcall_method_static_short.htm'\)).
    

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Handleable Exceptions

CX\_SY\_CREATE\_OBJECT\_ERROR

-   Cause: An attempt was made to instantiate an abstract class.
    Runtime error: CREATE\_OBJECT\_CLASS\_ABSTRACT
    
-   Cause: The class specified in the addition TYPE does not exist.
    Runtime error: CREATE\_OBJECT\_CLASS\_NOT\_FOUND
    
-   Cause: The class specified dynamically in TYPE does not match the type of the reference variable.
    Runtime error: MOVE\_OREF\_NOT\_CONVERTIBLE
    
-   Cause: An attempt was made to instantiate a private class externally.
    Runtime error: CREATE\_OBJECT\_CREATE\_PRIVATE
    
-   Cause: An attempt was made to instantiate a protected class externally.
    Runtime error: CREATE\_OBJECT\_CREATE\_PROTECTED
    

Non-Handleable Exceptions

-   Cause: A reference must be specified as the target variable.
    Runtime error: CREATE\_OBJECT\_NO\_REFTYPE:
    

Continue
[CREATE OBJECT oref](javascript:call_link\('abapcreate_object_implicit.htm'\))
[CREATE OBJECT - TYPE](javascript:call_link\('abapcreate_object_explicit.htm'\))
[CREATE OBJECT - AREA HANDLE](javascript:call_link\('abapcreate_object_area_handle.htm'\))
[CREATE OBJECT - parameter\_list](javascript:call_link\('abapcreate_object_parameters.htm'\))
[CREATE OBJECT - parameter\_tables](javascript:call_link\('abapcreate_object_para_tables.htm'\))



**📖 Source**: [abapcreate_object.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object.htm)

### abapcreate_object_implicit.htm

> **📖 Official SAP Documentation**: [abapcreate_object_implicit.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_implicit.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE OBJECT](javascript:call_link\('abapcreate_object.htm'\)) → 

CREATE OBJECT oref

[Quick Reference](javascript:call_link\('abapcreate_object_shortref.htm'\))

Syntax

CREATE OBJECT oref *\[* [area\_handle](javascript:call_link\('abapcreate_object_area_handle.htm'\))*\]* *\[* [parameter\_list](javascript:call_link\('abapcreate_object_parameters.htm'\))*\]*.

Effect

If the addition TYPE is not specified, the object reference variable oref must be a class reference variable. An instance of the class is created that is the static type of the object reference variable. The static type of the class reference variable cannot be an [abstract](javascript:call_link\('abenabstract_glosry.htm'\) "Glossary Entry") class, and in particular must not be the root class object.

Note

When the character # is used in an operand position with the operand type of a class reference variable, the [instance operator](javascript:call_link\('abeninstance_operator_glosry.htm'\) "Glossary Entry") [NEW](javascript:call_link\('abenconstructor_expression_new.htm'\)) works like the statement CREATE DATA dref.

Example

Creates an instance of a class cls using an implicit reference to the static type of the reference variables.

CLASS cls DEFINITION.
  PUBLIC SECTION.
    DATA attr type string VALUE 'Object'.
ENDCLASS.
DATA oref TYPE REF TO cls.
CREATE OBJECT oref.
cl\_demo\_output=>display( oref->attr ).



**📖 Source**: [abapcreate_object_implicit.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_implicit.htm)

### abapcreate_object_explicit.htm

> **📖 Official SAP Documentation**: [abapcreate_object_explicit.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_explicit.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE OBJECT](javascript:call_link\('abapcreate_object.htm'\)) → 

CREATE OBJECT - TYPE

[Quick Reference](javascript:call_link\('abapcreate_object_shortref.htm'\))

Syntax

CREATE OBJECT oref *\[*[area\_handle](javascript:call_link\('abapcreate_object_area_handle.htm'\))*\]*
                   TYPE *{* class  *\[*[parameter\_list](javascript:call_link\('abapcreate_object_parameters.htm'\))*\]* *}*
                      *|* *{* (name) *\[* [parameter\_list](javascript:call_link\('abapcreate_object_parameters.htm'\))*|* [parameter\_tables](javascript:call_link\('abapcreate_object_para_tables.htm'\))*\]* *}*.

Effect

Creates an instance of an explicitly specified class. A [concrete](javascript:call_link\('abenconcrete_glosry.htm'\) "Glossary Entry") class that is more specific than or identical to the static type of the object reference variable oref can be specified. The reference variable oref can be a class reference variable or an interface reference variable. The name of the class can be specified as follows:

-   class
    

Specified directly and statically as class.

-   (name)
    

Specified as the content of a character-like data object name. The data object name must contain the name of the class in uppercase letters when the statement is executed. The class name in name can also be an [absolute type name](javascript:call_link\('abenabsolute_typename_glosry.htm'\) "Glossary Entry"). The following can be specified for name:

-   Literal or constant
    If the data object name is specified as a character literal or as a constant, it can be evaluated statically and the specified class is identified as the used object.

-   Variable
    If the data object name is specified as a variable, it is specified only dynamically and the content is not evaluated statically.

When the statement is executed, name is not evaluated until runtime (in both cases).

The class must be usable at the current location:

-   The addition [CREATE](javascript:call_link\('abapclass_options.htm'\)) of the class definition must permit objects to be created.
    
-   The package check must permit an object of a global class to be created.
    

Notes

-   If the class is specified dynamically, the parameters can either be specified statically in [parameter\_list](javascript:call_link\('abapcreate_object_parameters.htm'\)) or dynamically in [parameter\_tables](javascript:call_link\('abapcreate_object_para_tables.htm'\)).
    
-   When a class is used, the [instance operator](javascript:call_link\('abeninstance_operator_glosry.htm'\) "Glossary Entry") [NEW](javascript:call_link\('abenconstructor_expression_new.htm'\)) acts like the statement CREATE OBJECT oref TYPE class and can be used in [general expression positions](javascript:call_link\('abengeneral_expr_position_glosry.htm'\) "Glossary Entry"). The content of name cannot be specified dynamically here.
    

Security Note

Dynamically created objects can present a serious security risk if used in the wrong way. Names of classes that are passed to a program from the outside must be checked thoroughly before being used in dynamic statements. The system class CL\_ABAP\_DYN\_PRG, for example, can be used to do this. See [Dynamic Calls](javascript:call_link\('abendyn_call_scrty.htm'\)).

Example

Creates an instance of a class cls using an explicit reference to the class. The static type of the reference variable is the root class object and is therefore more general than any other class. Components must be accessed dynamically or a cast must be performed (as shown here).

CLASS cls DEFINITION.
  PUBLIC SECTION.
    DATA attr TYPE string VALUE 'Object'.
ENDCLASS.
DATA oref TYPE REF TO object.
CREATE OBJECT oref TYPE cls.
cl\_demo\_output=>display( CAST cls( oref ) ).



**📖 Source**: [abapcreate_object_explicit.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_explicit.htm)

### abapcreate_object_area_handle.htm

> **📖 Official SAP Documentation**: [abapcreate_object_area_handle.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_area_handle.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE OBJECT](javascript:call_link\('abapcreate_object.htm'\)) → 

CREATE OBJECT - AREA HANDLE

[Quick Reference](javascript:call_link\('abapcreate_object_shortref.htm'\))

Syntax

CREATE OBJECT oref AREA HANDLE handle ...

Effect

This statement creates an object as a [shared object](javascript:call_link\('abenshared_object_glosry.htm'\) "Glossary Entry") in the [area instance version](javascript:call_link\('abenarea_instance_version_glosry.htm'\) "Glossary Entry") of the [shared memory](javascript:call_link\('abenshared_memory_glosry.htm'\) "Glossary Entry"), which is bound to the [area handle](javascript:call_link\('abenarea_handle_glosry.htm'\) "Glossary Entry") referenced by handle. The implicitly or explicitly specified class must be defined as a [shared-memory-enabled class](javascript:call_link\('abendata_class_glosry.htm'\) "Glossary Entry") using the addition [SHARED MEMORY ENABLED](javascript:call_link\('abapclass_options.htm'\)) of the statement [CLASS](javascript:call_link\('abapclass_definition.htm'\)).

handle expects an object reference variable whose static type is [CL\_ABAP\_MEMORY\_AREA](javascript:call_link\('abenshm_cl_abap_memory_area.htm'\)) or one of its subclasses ([area class](javascript:call_link\('abenarea_class_glosry.htm'\) "Glossary Entry")). When the statement is executed, handle must point to an [area handle](javascript:call_link\('abenarea_handle_glosry.htm'\) "Glossary Entry") and the area handle must be associated with an area instance version with a change lock. A reference like this can be created in one of the following ways:

-   By inheriting the return value of the methods [ATTACH\_FOR\_WRITE](javascript:call_link\('abenshm_area_class.htm'\)) or [ATTACH\_FOR\_UPDATE](javascript:call_link\('abenshm_area_class.htm'\)) of an area class created using transaction SHMA.
    
-   By inheriting the return value of the method [GET\_HANDLE\_BY\_...](javascript:call_link\('abenshm_cl_abap_memory_area.htm'\)) of any area class.
    
-   By inheriting the return value of the method [GET\_IMODE\_HANDLE](javascript:call_link\('abenshm_cl_imode_area.htm'\)) of the predefined class CL\_IMODE\_AREA.
    

The latter is a reference to an area handle for the current [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") and the statement CREATE OBJECT operates as if the addition AREA HANDLE were not specified.

Notes

-   The only shared object that can be addressed from an ABAP program directly after a binding is made to an area instance version is the instance of the [area root class](javascript:call_link\('abenroot_data_class_glosry.htm'\) "Glossary Entry"). All other objects have to be referenced in this instance.
    
-   The static attributes of a shared object are not created in the shared memory. Instead, they are created when the shared-memory-enabled class is loaded to the internal session of a program, as for every class. They can thus occur more than once and independently of one another in different programs.
    

Example

Creation of a shared object in an area instance version of area CL\_DEMO\_AREA.

CLASS cls DEFINITION
          SHARED MEMORY ENABLED.
  ...
ENDCLASS.
DATA: root   TYPE REF TO cl\_demo\_root,
      handle TYPE REF TO cl\_demo\_area.
...
handle = cl\_demo\_area=>attach\_for\_write( ).
CREATE OBJECT root AREA HANDLE handle.
handle->set\_root( root ).
CREATE OBJECT root->oref AREA HANDLE handle TYPE cls.
...

Executable Example

[Creating an Instance of a Class as a Shared Object](javascript:call_link\('abencreate_shared_object_abexa.htm'\))

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Handleable Exceptions

CX\_SHM\_WRONG\_HANDLE

-   Cause: The area handle does not hold any change locks.
    

CX\_SHM\_ALREADY\_DETACHED

-   Cause: The area handle is not bound to an area instance version.
    

CX\_SHM\_OUT\_OF\_MEMORY

-   Cause: There is not enough memory.
    

CX\_SHM\_OBJECT\_NOT\_SERIALIZABLE

-   Cause: In an area instance displaceable using backup and recovery, an attempt was made to create an object that cannot be serialized.
    

Continue
![Example](exa.gif "Example") [Creating an Instance of a Class as a Shared Object](javascript:call_link\('abencreate_shared_object_abexa.htm'\))



**📖 Source**: [abapcreate_object_area_handle.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_area_handle.htm)

### abencreate_shared_object_abexa.htm

> **📖 Official SAP Documentation**: [abencreate_shared_object_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_shared_object_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE OBJECT](javascript:call_link\('abapcreate_object.htm'\)) →  [CREATE OBJECT - AREA HANDLE](javascript:call_link\('abapcreate_object_area_handle.htm'\)) → 

Creating an Instance of a Class as a Shared Object

This example demonstrates how an object is created in an [area instance version](javascript:call_link\('abenarea_instance_version_glosry.htm'\) "Glossary Entry").

Source Code

REPORT demo\_create\_shared\_object.
CLASS class DEFINITION
            SHARED MEMORY ENABLED.
  PUBLIC SECTION.
    DATA attr TYPE string.
    METHODS set\_attr IMPORTING text TYPE string.
ENDCLASS.
CLASS class IMPLEMENTATION.
  METHOD set\_attr.
    attr = text.
  ENDMETHOD.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: handle TYPE REF TO cl\_demo\_area,
          root   TYPE REF TO cl\_demo\_root,
          exc    TYPE REF TO cx\_shm\_attach\_error,
          oref   TYPE REF TO class.
    TRY.
        handle = cl\_demo\_area=>attach\_for\_write( ).
        CREATE OBJECT root AREA HANDLE handle.
        handle->set\_root( root ).
        CREATE OBJECT root->oref AREA HANDLE handle TYPE class.
        oref ?= root->oref.
        oref->set\_attr( \`String in shared memory\` ).
        CLEAR oref.
        handle->detach\_commit( ).
      CATCH cx\_shm\_attach\_error INTO exc.
        cl\_demo\_output=>display\_text( exc->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        handle = cl\_demo\_area=>attach\_for\_read( ).
        oref ?= handle->root->oref.
        cl\_demo\_output=>display\_data( oref->attr ).
        CLEAR oref.
        handle->detach( ).
      CATCH cx\_shm\_attach\_error INTO exc.
        cl\_demo\_output=>display\_text( exc->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The addition AREA HANDLE is used to create an instance of the local class class as a [shared object](javascript:call_link\('abenshared_object_glosry.htm'\) "Glossary Entry") in an [area instance version](javascript:call_link\('abenarea_instance_version_glosry.htm'\) "Glossary Entry") of the area CL\_DEMO\_AREA. The generically typed attribute oref of the [area root class](javascript:call_link\('abenroot_data_class_glosry.htm'\) "Glossary Entry") CL\_DEMO\_ROOT is used a a reference variable. The attribute attr of the object is given a value by calling its method set\_attr.

Once the method DETACH\_COMMIT completes the write, a read is performed to demonstrate how the objects in the shared memory are accessed. An access of this type can also be made in another program, as long as the area instance version exists in the shared memory.



**📖 Source**: [abencreate_shared_object_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencreate_shared_object_abexa.htm)

### abapcreate_object_area_handle.htm

> **📖 Official SAP Documentation**: [abapcreate_object_area_handle.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_area_handle.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE OBJECT](javascript:call_link\('abapcreate_object.htm'\)) → 

CREATE OBJECT - AREA HANDLE

[Quick Reference](javascript:call_link\('abapcreate_object_shortref.htm'\))

Syntax

CREATE OBJECT oref AREA HANDLE handle ...

Effect

This statement creates an object as a [shared object](javascript:call_link\('abenshared_object_glosry.htm'\) "Glossary Entry") in the [area instance version](javascript:call_link\('abenarea_instance_version_glosry.htm'\) "Glossary Entry") of the [shared memory](javascript:call_link\('abenshared_memory_glosry.htm'\) "Glossary Entry"), which is bound to the [area handle](javascript:call_link\('abenarea_handle_glosry.htm'\) "Glossary Entry") referenced by handle. The implicitly or explicitly specified class must be defined as a [shared-memory-enabled class](javascript:call_link\('abendata_class_glosry.htm'\) "Glossary Entry") using the addition [SHARED MEMORY ENABLED](javascript:call_link\('abapclass_options.htm'\)) of the statement [CLASS](javascript:call_link\('abapclass_definition.htm'\)).

handle expects an object reference variable whose static type is [CL\_ABAP\_MEMORY\_AREA](javascript:call_link\('abenshm_cl_abap_memory_area.htm'\)) or one of its subclasses ([area class](javascript:call_link\('abenarea_class_glosry.htm'\) "Glossary Entry")). When the statement is executed, handle must point to an [area handle](javascript:call_link\('abenarea_handle_glosry.htm'\) "Glossary Entry") and the area handle must be associated with an area instance version with a change lock. A reference like this can be created in one of the following ways:

-   By inheriting the return value of the methods [ATTACH\_FOR\_WRITE](javascript:call_link\('abenshm_area_class.htm'\)) or [ATTACH\_FOR\_UPDATE](javascript:call_link\('abenshm_area_class.htm'\)) of an area class created using transaction SHMA.
    
-   By inheriting the return value of the method [GET\_HANDLE\_BY\_...](javascript:call_link\('abenshm_cl_abap_memory_area.htm'\)) of any area class.
    
-   By inheriting the return value of the method [GET\_IMODE\_HANDLE](javascript:call_link\('abenshm_cl_imode_area.htm'\)) of the predefined class CL\_IMODE\_AREA.
    

The latter is a reference to an area handle for the current [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") and the statement CREATE OBJECT operates as if the addition AREA HANDLE were not specified.

Notes

-   The only shared object that can be addressed from an ABAP program directly after a binding is made to an area instance version is the instance of the [area root class](javascript:call_link\('abenroot_data_class_glosry.htm'\) "Glossary Entry"). All other objects have to be referenced in this instance.
    
-   The static attributes of a shared object are not created in the shared memory. Instead, they are created when the shared-memory-enabled class is loaded to the internal session of a program, as for every class. They can thus occur more than once and independently of one another in different programs.
    

Example

Creation of a shared object in an area instance version of area CL\_DEMO\_AREA.

CLASS cls DEFINITION
          SHARED MEMORY ENABLED.
  ...
ENDCLASS.
DATA: root   TYPE REF TO cl\_demo\_root,
      handle TYPE REF TO cl\_demo\_area.
...
handle = cl\_demo\_area=>attach\_for\_write( ).
CREATE OBJECT root AREA HANDLE handle.
handle->set\_root( root ).
CREATE OBJECT root->oref AREA HANDLE handle TYPE cls.
...

Executable Example

[Creating an Instance of a Class as a Shared Object](javascript:call_link\('abencreate_shared_object_abexa.htm'\))

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Handleable Exceptions

CX\_SHM\_WRONG\_HANDLE

-   Cause: The area handle does not hold any change locks.
    

CX\_SHM\_ALREADY\_DETACHED

-   Cause: The area handle is not bound to an area instance version.
    

CX\_SHM\_OUT\_OF\_MEMORY

-   Cause: There is not enough memory.
    

CX\_SHM\_OBJECT\_NOT\_SERIALIZABLE

-   Cause: In an area instance displaceable using backup and recovery, an attempt was made to create an object that cannot be serialized.
    

Continue
![Example](exa.gif "Example") [Creating an Instance of a Class as a Shared Object](javascript:call_link\('abencreate_shared_object_abexa.htm'\))



**📖 Source**: [abapcreate_object_area_handle.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_area_handle.htm)

### abapcreate_object_parameters.htm

> **📖 Official SAP Documentation**: [abapcreate_object_parameters.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_parameters.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE OBJECT](javascript:call_link\('abapcreate_object.htm'\)) → 

CREATE OBJECT - parameter\_list

[Quick Reference](javascript:call_link\('abapcreate_object_shortref.htm'\))

Syntax

... *\[*EXPORTING  p1 = a1 p2 = a2 ...*\]*
    *\[*EXCEPTIONS exc1 = n1 exc2 = n2 ... *\[*OTHERS = n\_others*\]**\]*.

Effect

The additions EXPORTING and EXCEPTIONS are used to pass actual parameters to the instance constructor statically or to assign return values to non-class-based exceptions.

-   When using the addition EXPORTING, the non-optional input parameters p1 p2 ... of the instance constructor of the instantiated class must be specified using the type-friendly actual parameters a1 a2 ... (the other input parameters are optional). As in regular method calls, a1, a2, ... are [general expression positions](javascript:call_link\('abengeneral_expr_position_glosry.htm'\) "Glossary Entry"). In other words, functions and expressions can be passed as actual parameters, alongside data objects. [Special rules](javascript:call_link\('abentyping_arith_expr.htm'\)) apply in this case. If a subclass does not have an instance constructor implemented explicitly, the interface of the instance constructor from the next-highest superclass that explicitly implements the instance constructor is used.
    
-   The addition EXCEPTIONS can be used to assign return values to [non-class-based exceptions](javascript:call_link\('abenexceptions_non_class.htm'\)) exc1 exc2...
    

The syntax and semantics are the same as in the parameter list for [static method calls](javascript:call_link\('abenmethod_calls_static.htm'\)).

Example

Creates a Control Framework (CFW) dialog box and passes input parameters to the instance constructor of the global class CL\_GUI\_DIALOGBOX\_CONTAINER. The class is defined implicitly using the static type of the reference variable dialog\_box.

DATA dialog\_box TYPE REF TO cl\_gui\_dialogbox\_container.
CREATE OBJECT dialog\_box
       EXPORTING parent = cl\_gui\_container=>desktop
                 width  = 1000
                 height = 350.



**📖 Source**: [abapcreate_object_parameters.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_parameters.htm)

### abapcreate_object_para_tables.htm

> **📖 Official SAP Documentation**: [abapcreate_object_para_tables.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_para_tables.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [CREATE OBJECT](javascript:call_link\('abapcreate_object.htm'\)) → 

CREATE OBJECT - parameter\_tables

[Quick Reference](javascript:call_link\('abapcreate_object_shortref.htm'\))

Syntax

... *\[*PARAMETER-TABLE ptab*\]*
    *\[*EXCEPTION-TABLE etab*\]*.

Effect

The additions PARAMETER-TABLE and EXCEPTION-TABLE pass actual parameters dynamically to the instance constructor or assign return values to the non-class-based exceptions.

These additions can be used only if the instantiated class is specified dynamically in name. Using the special internal tables ptab and etab, they assign actual parameters to the input parameters of the instance constructor or return values to the non-class-based exceptions.

The syntax and semantics are the same as those that apply to dynamic method calls using the statement [CALL METHOD](javascript:call_link\('abapcall_method_dynamic.htm'\)). The internal tables ptab and etab in particular must be defined with reference to the tables ABAP\_PARMBIND\_TAB and ABAP\_EXCPBIND\_TAB from the [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") ABAP.

Example

Creates a [Control Framework](javascript:call_link\('abencontrol_framework_glosry.htm'\) "Glossary Entry") (CFW) dialog box dynamically and passes input parameters dynamically to the instance constructor of the global class CL\_GUI\_DIALOGBOX\_CONTAINER. The class is defined explicitly using the addition [TYPE](javascript:call_link\('abapcreate_object_explicit.htm'\)).

DATA: container TYPE REF TO cl\_gui\_container,
      exc\_ref TYPE REF TO cx\_root.
DATA: class TYPE string VALUE \`CL\_GUI\_DIALOGBOX\_CONTAINER\`,
      ptab TYPE abap\_parmbind\_tab.
ptab = VALUE #( ( name  = 'PARENT'
                  kind  = cl\_abap\_objectdescr=>exporting
                  value = REF #( cl\_gui\_container=>desktop ) )
                ( name  = 'WIDTH'
                  kind  = cl\_abap\_objectdescr=>exporting
                  value = REF #( 1000 ) )
                ( name  = 'HEIGHT'
                  kind  = cl\_abap\_objectdescr=>exporting
                  value = REF #( 300 ) ) ).
TRY.
    CREATE OBJECT container TYPE (class)
      PARAMETER-TABLE ptab.
  CATCH cx\_sy\_create\_object\_error INTO exc\_ref.
    MESSAGE exc\_ref->get\_text( ) TYPE 'I'.
ENDTRY.

Example

The following program extract creates an object of a class SOME\_CLASS dynamically whose instance constructor expects a reference variable of the static type ANY\_CLASS. The syntax of the program is correct, but the object is created only in systems in which the classes exist.

CONSTANTS:
  anycls  TYPE string VALUE \`ANY\_CLASS\`,
  somecls TYPE string VALUE \`SOME\_CLASS\`,
  param   TYPE string VALUE \`PARA\`.
DATA dref TYPE REF TO data.
TRY.
    CREATE DATA dref TYPE REF TO (anycls).
    ASSIGN dref->\* TO FIELD-SYMBOL(<fs>).
    CREATE OBJECT <fs> TYPE (anycls).
  CATCH cx\_sy\_create\_data\_error
        cx\_sy\_create\_object\_error.
    ...
ENDTRY.
IF <fs> IS ASSIGNED.
  DATA(ptab) = VALUE abap\_parmbind\_tab(
    ( name = param
      kind  = cl\_abap\_objectdescr=>exporting
      value =  REF #( <fs> ) ) ).
ENDIF.
DATA oref TYPE REF TO object.
TRY.
    CREATE OBJECT oref TYPE (somecls) PARAMETER-TABLE ptab.
  CATCH cx\_sy\_create\_object\_error
        cx\_sy\_dyn\_call\_parameter\_error INTO DATA(exc).
    ...
ENDTRY.

This program can be executed in systems in which classes are declared as follows without raising exceptions.

CLASS any\_class DEFINITION.
  ...
ENDCLASS.
CLASS some\_class DEFINITION.
  PUBLIC SECTION.
    METHODS constructor IMPORTING para TYPE REF TO any\_class.
    ...
ENDCLASS.
CLASS some\_class IMPLEMENTATION.
  METHOD constructor.
    ...
  ENDMETHOD.
  ...
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / NEW - Instance Operator

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / NEW - Instance Operator

Included pages: 8



**📖 Source**: [abapcreate_object_para_tables.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_para_tables.htm)

### abenconstructor_expression_new.htm

> **📖 Official SAP Documentation**: [abenconstructor_expression_new.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconstructor_expression_new.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) → 

NEW - Instance Operator

Syntax

... NEW type( ... ) ...

Effect

A [constructor expression](javascript:call_link\('abenconstructor_expressions.htm'\)) with the instance operator NEW creates an [anonymous data object](javascript:call_link\('abenanonymous_data_object_glosry.htm'\) "Glossary Entry") or an [instance](javascript:call_link\('abeninstance_glosry.htm'\) "Glossary Entry") of a class and assigns values to the new object. The result is a reference variable that points to the new object. The following can be specified for type:

-   A non-generic data type dtype.
    The operator NEW works in the same way as the statement [CREATE DATA dref TYPE dtype](javascript:call_link\('abapcreate_data_existing.htm'\)), where dref stands for the result that points to the new anonymous data object. The result is a data reference variable of the [static type](javascript:call_link\('abenstatic_type_glosry.htm'\) "Glossary Entry") dtype. A constructor expression of this type cannot be extended using a [component selector](javascript:call_link\('abencomponent_selector_glosry.htm'\) "Glossary Entry").

-   A class class.
    The operator NEW works in the same way as the statement [CREATE OBJECT oref TYPE class](javascript:call_link\('abapcreate_object_explicit.htm'\)), where oref stands for the result that points to the new object. The result is an object reference variable of the [static type](javascript:call_link\('abenstatic_type_glosry.htm'\) "Glossary Entry") class. Using an object component selector \->, a constructor expression of this type can be extended in both [general expression positions](javascript:call_link\('abengeneral_expression_positions.htm'\)) and [functional positions](javascript:call_link\('abenfunctional_positions.htm'\)) (like an object reference variable) and can be used in the same operand positions. The following is also possible:

-   [Standalone method calls](javascript:call_link\('abapcall_method_static_short.htm'\)) (including [chained method calls](javascript:call_link\('abenchained_method_call_glosry.htm'\) "Glossary Entry")) can be introduced.

-   A single expression that points to an attribute of the class using exactly one follow-on object component selector can also be used as the target field of assignments.

-   The # character.
    If the data type required in an operand position is unique and known completely, the # character can be used instead of an explicitly specified type type and the [operand type](javascript:call_link\('abenoperand_type_glosry.htm'\) "Glossary Entry") is used. If the operand type is not known in full, the # character cannot be used, with the following exception: The operand can be evaluated after BASE when a [structure](javascript:call_link\('abennew_constructor_params_struct.htm'\)) or an [internal table](javascript:call_link\('abennew_constructor_params_itab.htm'\)) is constructed.

The same descriptions apply as to the CREATE statements. Once an object is created, it is provided with values using the parameters in parentheses. The syntax used in parameter passing depends on the type used. There are specialized categories of parameter passing for complex types.

-   [Initial value for all types](javascript:call_link\('abennew_constructor_params_initial.htm'\))

-   [Initial value for all data types](javascript:call_link\('abennew_constructor_params_single.htm'\))

-   [Structures](javascript:call_link\('abennew_constructor_params_struct.htm'\))

-   [Internal tables](javascript:call_link\('abennew_constructor_params_itab.htm'\))

-   [Classes](javascript:call_link\('abennew_constructor_params_class.htm'\))

When a constructor expression is [assigned](javascript:call_link\('abenequals_operator.htm'\)) to a reference variable using NEW, the information in the parentheses is evaluated before the new object is bound to the target variable.

Return Value
If an instance of a [class](javascript:call_link\('abennew_constructor_params_class.htm'\)) is created successfully, the instance operator NEW sets sy-subrc to 0. Non-class-based exceptions of the instance constructor cannot be handled, which means that sy-subrc is never set to a value other than 0. The return code sy-subrc is not set when anonymous data objects are created.

Notes

-   To create the values for a new data object, the instance operator NEW uses mainly the same syntax as the value operator [VALUE](javascript:call_link\('abenconstructor_expression_value.htm'\)).

-   The instance operator NEW always creates a new temporary reference variable that points to the new object. The reference variable is used as the operand of a statement and then deleted. It is deleted when the current statement is closed or after the analysis of a relational expression once the truth value is determined. The new object is passed to the garbage collector if it is not passed to a [heap reference](javascript:call_link\('abenheap_reference_glosry.htm'\) "Glossary Entry") or a field symbol after the temporary reference variable is deleted.

-   [Assignments](javascript:call_link\('abenequals_operator.htm'\)) to a reference variable also always create a temporary reference variable that is only assigned to the target variable afterwards. This means that the object pointed to by the target variable before the assignment can be addressed using it throughout the entire expression. This is the difference between NEW and the value operator [VALUE](javascript:call_link\('abenconstructor_expression_value.htm'\)).

Example

Creates an anonymous data object of the type i with the value 555 and an instance of a local class cls (derived implicitly from the static type of oref). In this case, the last statement could be written just as explicitly as oref = NEW cls( ) or it could be written as DATA(oref) = NEW cls( ), using an inline declaration instead of the preceding DATA statement.

CLASS cls DEFINITION.
  ...
ENDCLASS.
DATA: dref TYPE REF TO data,
      oref TYPE REF TO cls.
dref = NEW i( 555 ).
oref = NEW #( ).

Continue
[NEW - Initial Value for All Types](javascript:call_link\('abennew_constructor_params_initial.htm'\))
[NEW - Single Value for All Data Types](javascript:call_link\('abennew_constructor_params_single.htm'\))
[NEW - Structures](javascript:call_link\('abennew_constructor_params_struct.htm'\))
[NEW - Internal Tables](javascript:call_link\('abennew_constructor_params_itab.htm'\))
[NEW - Classes](javascript:call_link\('abennew_constructor_params_class.htm'\))



**📖 Source**: [abenconstructor_expression_new.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconstructor_expression_new.htm)

### abennew_constructor_params_initial.htm

> **📖 Official SAP Documentation**: [abennew_constructor_params_initial.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_initial.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [NEW - Instance Operator](javascript:call_link\('abenconstructor_expression_new.htm'\)) → 

NEW - Initial Value for All Types

Syntax

... NEW dtype*|*class*|*#( ) ...

Effect

If no parameters are specified,

-   an anonymous data object retains its type-specific initial value,

-   no values are passed to the instance constructor of an object.

This is possible for every non-generic data type dtype. The instance constructor of a class class can either have only optional input parameters or no input parameters at all. The # symbol can stand for appropriate types.

Note

If dtype or # stand for an [enumerated type](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry"), its initial value is generated according to its [base type](javascript:call_link\('abenbase_type_glosry.htm'\) "Glossary Entry").

Example

After the following program section is executed, dref points to an empty internal table with the row type T100. Both constructor expressions have the same function.

TYPES t\_itab TYPE TABLE OF t100 WITH EMPTY KEY.
DATA dref TYPE REF TO t\_itab.
dref = NEW #( ).
dref = NEW t\_itab( ).



**📖 Source**: [abennew_constructor_params_initial.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_initial.htm)

### abennew_constructor_params_single.htm

> **📖 Official SAP Documentation**: [abennew_constructor_params_single.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_single.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [NEW - Instance Operator](javascript:call_link\('abenconstructor_expression_new.htm'\)) → 

NEW - Single Value for All Data Types

Syntax

... NEW dtype*|*#( *\[*[let\_exp](javascript:call_link\('abaplet.htm'\))*\]* dobj ) ...

Effect

If dtype is a non-generic elementary data type, a structured type, a table type, or a reference type (or # stands a type like this), a single data object dobj can be specified as a unnamed argument (the data object either has the type dtype or is convertible to this type). dobj is a [general expression position](javascript:call_link\('abengeneral_expr_position_glosry.htm'\) "Glossary Entry"). The value of dobj is assigned to the new anonymous data object. The assignment is made in accordance with the applicable [assignment rules](javascript:call_link\('abenconversion_rules.htm'\)). An optional LET expression [let\_exp](javascript:call_link\('abaplet.htm'\)) can be specified before the data object to define local helper fields.

Notes

-   An expression specified for dobj can, more specifically, itself be a constructor expression or contain a constructor expression.

-   When a constructor expression is assigned to a reference variable using NEW, the original reference is made available in the entire expression in the target variable. The target variable is not overwritten until the expression is closed.

Example

Constructs an anonymous data object of the type string, whose value is determined using a string expression.

DATA input TYPE c LENGTH 10 VALUE 'World'.
cl\_demo\_input=>request( CHANGING field = input ).
DATA dref TYPE REF TO string.
dref =  NEW string( \`Hello \` && input && \`!\` ).
cl\_demo\_output=>display( dref->\* ).

Example

For each row read, a structured anonymous data object is created in a SELECT loop. The content of the row is assigned to this data object. The object is created in the general expression position of the statement APPEND and the new data reference is appended directly to an internal table with the appropriate row type. The result is a table that references all new anonymous data objects.

DATA dref\_tab LIKE TABLE OF REF TO t100 WITH EMPTY KEY.
DATA wa TYPE t100.
SELECT \*
       FROM t100
       WHERE sprsl = @sy-langu
       INTO @wa.
  APPEND NEW #( wa ) TO dref\_tab.
ENDSELECT.



**📖 Source**: [abennew_constructor_params_single.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_single.htm)

### abennew_constructor_params_struct.htm

> **📖 Official SAP Documentation**: [abennew_constructor_params_struct.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_struct.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [NEW - Instance Operator](javascript:call_link\('abenconstructor_expression_new.htm'\)) → 

NEW - Structures

Syntax

... NEW dtype*|*#( *\[*[let\_exp](javascript:call_link\('abaplet.htm'\))*\]*
                 *\[*BASE dobj*\]*
                 comp1 = dobj1 comp2 = dobj2 ... ) ...

Effect

If dtype is a structured data type or # stands for a type like this, the individual components can be specified as named arguments comp1, comp2, ... Each component of the new anonymous data object can be assigned a data object with the same data type as the component (or whose data type can be converted to this data type). This assignment is made for all data types in accordance with the appropriate [assignment rules](javascript:call_link\('abenconversion_rules.htm'\)).

An addition BASE can be specified in front of the individual component assignments, followed by a data object dobj. dobj is a [functional operand position](javascript:call_link\('abenfunctional_position_glosry.htm'\) "Glossary Entry"). The type of dobj must be convertible to the type of the anonymous data object. If BASE is specified, the content of dobj is assigned to the anonymous data object before the individual components are assigned. If the character # is specified for the type of the anonymous data object and the type is not known from the operand position of the VALUE expression, the type of dobj is used for this expression (if known and structured).

dobj1, dobj2, ... are [general expression positions](javascript:call_link\('abengeneral_expr_position_glosry.htm'\) "Glossary Entry"). An optional LET expression [let\_exp](javascript:call_link\('abaplet.htm'\)) can be specified in front of the assignments to define local helper fields that can be used on the right side of the assignments.

If a component is itself structured, either a suitable data object can be assigned to the entire substructure or its components can be specified using the structure component selector (\-). Non-specified components are ignored and keep their type-specific initial value or the value assigned using BASE. It is not possible to assign multiple values to a component, regardless of how the component is addressed. If the addition BASE is used, at least one component must be specified.

Notes

-   The assignments can be specified in any order within the parentheses.

-   If a component with a complex data type is constructed in an argument position, the value operator [VALUE](javascript:call_link\('abenconstructor_expression_value.htm'\)) can be used. This affects tabular components, for example. This is also possible for structured components but is not necessary since the subcomponents can be addressed using the structure component selector.

-   When a constructor expression is assigned to a reference variable using NEW, the original reference is made available in the entire expression in the target variable. The target variable is not overwritten until the expression is closed. In the case of the value operator [VALUE](javascript:call_link\('abenvalue_constructor_params_struc.htm'\)), however, the target variable can only be assigned to a helper variable using LET and is then no longer available.

Example

Constructs an anonymous data object with a nested structure type and tabular components. The subcomponents of col2 are addressed directly using the structure component selector. [VALUE](javascript:call_link\('abenconstructor_expression_value.htm'\)) must be used to construct the tabular component col3. This is because the [syntax](javascript:call_link\('abennew_constructor_params_itab.htm'\)) used to construct internal tables cannot be specified directly as an argument.

TYPES: t\_itab TYPE TABLE OF i WITH EMPTY KEY,
       BEGIN OF t\_struct,
         col1 TYPE i,
         BEGIN OF col2,
           col1 TYPE i,
           col2 TYPE t\_itab,
         END OF col2,
         col3 TYPE t\_itab,
       END OF t\_struct.
DATA itab TYPE t\_itab.
DATA dref TYPE REF TO data.
dref = NEW t\_struct( col1 = 1
                     col2-col1 = 2
                     col2-col2 = itab
                     col3 = VALUE #( ( 1 )
                                     ( 2 )
                                     ( 3 ) ) ).

Example

Uses BASE. The type of the return value of base1 is applied in the construction of ref1. This is not possible in the construction of ref2, since base2 is not structured. In both results, col1 and col3 have the values xx or zz assigned using BASE, whereas col2 has the directly assigned value BB.

TYPES:
  BEGIN OF struct,
    col1 TYPE c LENGTH 2,
    col2 TYPE c LENGTH 2,
    col3 TYPE c LENGTH 2,
  END OF struct.
DATA(base1)   = VALUE struct( col1 = 'xx' col2 = 'yy' col3 = 'zz' ).
DATA(ref1)  = NEW #( BASE base1 col2 = 'BB' ).
DATA(base2)   = \`xxyyzz\`.
DATA(ref2)  = NEW struct( BASE base2 col2 = 'BB' ).
cl\_demo\_output=>write(   ref1->\* ).
cl\_demo\_output=>display( ref2->\* ).

Example

See also the examples for the value operator [VALUE](javascript:call_link\('abenvalue_constructor_params_struc.htm'\)).



**📖 Source**: [abennew_constructor_params_struct.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_struct.htm)

### abennew_constructor_params_itab.htm

> **📖 Official SAP Documentation**: [abennew_constructor_params_itab.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_itab.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [NEW - Instance Operator](javascript:call_link\('abenconstructor_expression_new.htm'\)) → 

NEW - Internal Tables

Syntax

... NEW dtype*|*#( *\[*[let\_exp](javascript:call_link\('abaplet.htm'\))*\]*
                 *\[*BASE itab*\]*
                 *\[*[FOR for\_exp1](javascript:call_link\('abenfor.htm'\))
                  [FOR for\_exp2](javascript:call_link\('abenfor.htm'\))
                  ... *\]*
                 ( [line\_spec1](javascript:call_link\('abennew_constructor_params_lspc.htm'\)) )
                 ( [line\_spec2](javascript:call_link\('abennew_constructor_params_lspc.htm'\)) )
                   ... ) ...

Extras:

[1\. ... BASE itab](#!ABAP_ADDITION_1@1@)
[2\. ... FOR for\_exp](#!ABAP_ADDITION_2@2@)

Effect

If dtype is a tabular data type or # stands for a type like this, the table rows of the constructed table are created as follows:

-   Firstly, an optional LET expression [let\_exp](javascript:call_link\('abaplet.htm'\)) can be specified to define local helper fields whose values can be used to construct the table rows.

-   An optional start value for the content can then be specified for the content of the internal table after BASE (see below).

-   One or more optional consecutive [iteration expressions](javascript:call_link\('abeniteration_expression_glosry.htm'\) "Glossary Entry") can then be specified using [FOR](javascript:call_link\('abenfor.htm'\)) (see below).

-   The table rows are then constructed in one or more sets of internal parentheses by specifying [line\_spec](javascript:call_link\('abennew_constructor_params_lspc.htm'\)). Each set of inner parentheses constructs one or more rows in accordance with the information in line\_spec and inserts them into the new internal table in accordance with the rules for the statement [INSERT](javascript:call_link\('abapinsert_itab.htm'\)) ... [INTO TABLE](javascript:call_link\('abapinsert_itab_position.htm'\)). The object is inserted in the order of the parentheses.

The constructed rows must meet the requirements of the statement [INSERT](javascript:call_link\('abapinsert_itab.htm'\)) for inserting work areas using table keys and therefore be compatible with the row type. There is one exception to this: when constructing a [standard table](javascript:call_link\('abenstandard_table_glosry.htm'\) "Glossary Entry") (where the rows are only appended anyway), the value can be shorter than the row length (for row types c and x), in which case it is padded on the right with blanks or hexadecimal 0.

Notes

-   When a constructor expression is assigned to a reference variable using NEW, the original reference is made available in the entire expression in the target variable. The target variable is not overwritten until the expression is closed. In the case of the value operator [VALUE](javascript:call_link\('abenvalue_constructor_params_itab.htm'\)), however, the target variable can only be assigned to a helper variable using LET and is then no longer available.

-   The operand type for [line\_spec](javascript:call_link\('abennew_constructor_params_lspc.htm'\)) in the inner parentheses is the row type of the table type specified using dtype or #, which means it is always uniquely identifiable. Constructor expressions in this place can therefore always derive the required data type using #.
    

Example

Constructs an anonymous internal table with a structured row type with substructures and tabular components.

TYPES: BEGIN OF t\_struct1,
         col1 TYPE i,
         col2 TYPE i,
       END OF t\_struct1,
       BEGIN OF t\_struct2,
         col1 TYPE i,
         col2 TYPE t\_struct1,
         col3 TYPE TABLE OF t\_struct1 WITH EMPTY KEY,
       END OF t\_struct2,
       t\_itab TYPE TABLE OF t\_struct2 WITH EMPTY KEY.
DATA dref TYPE REF TO data.
dref = NEW t\_itab( ( col1 = 1
                     col2-col1 = 1
                     col2-col2 = 2
                     col3 = VALUE #( ( col1 = 1 col2 = 2 )
                                     ( col1 = 3 col2 = 4 ) ) )
                   ( col1 = 2
                     col2-col1 = 2
                     col2-col2 = 4
                     col3 = VALUE #( ( col1 = 2 col2 = 4 )
                                     ( col1 = 6 col2 = 8 ) ) ) ).

Examples

See also the examples for the value operator [VALUE](javascript:call_link\('abenvalue_constructor_params_itab.htm'\)).

Addition 1

... BASE itab

Effect

An addition, BASE, followed by an internal table, itab, can be specified in front of the inserted rows. This is a [functional operand position](javascript:call_link\('abenfunctional_position_glosry.htm'\) "Glossary Entry"). The row type of itab must be convertible to the row type of the return value. If BASE is specified, the content of itab is assigned to the return value before the individual rows are inserted. If the character # is specified for the type of the return value and the type cannot be determined from the operand position of the constructor expression, the type of itab is used for this expression (if known).

Example

Constructs three anonymous internal tables with an elementary row type. The first table is filled with three rows. The second row is initial. The second and third tables are filled with the rows of the first table and three further rows. Using BASE and [LINES OF](javascript:call_link\('abennew_constructor_params_lspc.htm'\)) here has the same effect.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
DATA(dref1) = NEW t\_itab( ( 1 ) (  ) ( 3 ) ).
DATA(dref2) = NEW t\_itab( BASE dref1->\*
                          (   ) ( 5 ) (  ) ).
DATA(dref3) = NEW t\_itab( ( LINES OF dref1->\* )
                          (   ) ( 5 ) (  ) ).
cl\_demo\_output=>write(   dref1->\* ).
cl\_demo\_output=>write(   dref2->\* ).
cl\_demo\_output=>display( dref3->\* ).

Addition 2

... FOR for\_exp

Effect

If one or more [iteration expressions](javascript:call_link\('abeniteration_expression_glosry.htm'\) "Glossary Entry") are specified consecutively using [FOR](javascript:call_link\('abenfor.htm'\)), this means that the rows constructed in [line\_spec](javascript:call_link\('abennew_constructor_params_lspc.htm'\)) for every iteration of the last FOR expression are inserted into the target table. When constructing table rows in [line\_spec](javascript:call_link\('abennew_constructor_params_lspc.htm'\)), the visible local work areas and field symbols of the iteration expressions can be used to construct table rows.

-   If [conditional iterations](javascript:call_link\('abenfor_conditional.htm'\)) are used, the new table rows are created in freely defined iteration steps.

-   If [table iterations](javascript:call_link\('abenfor_itab.htm'\)) are used, the rows of existing internal tables are evaluated. These are known as [table comprehensions](javascript:call_link\('abentable_comprehension_glosry.htm'\) "Glossary Entry"), since in this case new table rows can be constructed from the rows of existing internal tables.

Notes

-   The term "table comprehension" is derived from similar concepts used in many other languages, where it is also known as "list comprehension".

-   [Table filtering](javascript:call_link\('abentable_filtering_glosry.htm'\) "Glossary Entry") can be implemented more efficiently using the [filter operator](javascript:call_link\('abenfilter_operator_glosry.htm'\) "Glossary Entry") [FILTER](javascript:call_link\('abenconstructor_expression_filter.htm'\)).

-   Conditional iterations and table comprehensions are also possible with [FOR expressions](javascript:call_link\('abenmesh_for.htm'\)) for [mesh paths](javascript:call_link\('abenmesh_path_glosry.htm'\) "Glossary Entry").
    

Example

Constructs an anonymous internal table with an elementary row type and fills it with square numbers using an iteration expression.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
DATA(dref) = NEW t\_itab( FOR i = 1 UNTIL i > 10
                         ( ipow( base = i exp = 2 ) ) ).
cl\_demo\_output=>display( dref->\* ).

Executable Examples

[Examples of Table Comprehensions](javascript:call_link\('abentable_comprehensions_abexas.htm'\))

Continue
[NEW - line\_spec](javascript:call_link\('abennew_constructor_params_lspc.htm'\))



**📖 Source**: [abennew_constructor_params_itab.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_itab.htm)

### abennew_constructor_params_lspc.htm

> **📖 Official SAP Documentation**: [abennew_constructor_params_lspc.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_lspc.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [NEW - Instance Operator](javascript:call_link\('abenconstructor_expression_new.htm'\)) →  [NEW - Internal Tables](javascript:call_link\('abennew_constructor_params_itab.htm'\)) → 

NEW - line\_spec

Syntax

... line
  *|* *{*LINES OF jtab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]**}* ...

Alternatives:

[1\. ... line](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LINES OF jtab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]*](#!ABAP_ALTERNATIVE_2@2@)

Effect

Specifies one or more rows to be inserted when constructing an internal table with the instance operator [NEW](javascript:call_link\('abennew_constructor_params_itab.htm'\)).

Alternative 1

... line

Effect

Specifies a row. line can be specified in exactly the same way as in the parentheses of an expression [NEW line\_type( ... )](javascript:call_link\('abenconstructor_expression_new.htm'\)). Here, line\_type is the row type of the internal table and a corresponding row is constructed. The following special features apply here:

-   If a data object is specified for line, this object must be compatible with the row type.

-   If an expression (built-in function, functional method, calculation expression, constructor expression, or table expression) is specified for line, the result of the expression must be convertible to the row type.

-   The syntax does not permit further parentheses for constructing tabular row types to be nested directly in line.

Short Form for Structured Row Types

If the row type of the internal table is a structured type, the following short form can be used:

NEW dtype*|*#( *\[*let\_exp*\]*
             *\[*BASE itab*\]*
             col1 = dobj11 ... ( col2 = dobj12 col3 = dobj13 ... )
                               ( col2 = dobj22 col3 = dobj23 ... )
                               ...
             col1 = dobj31 col2 = dobj32 ... ( col3 = dobj33 ... )
                                             ( col3 = dobj43 ... )
             ... ).

This has the same semantics as the following form:

NEW dtype*|*#( *\[*let\_exp*\]*
             *\[*BASE itab*\]*
             ( col1 = dobj11 ... col2 = dobj12 col3 = dobj13 ... )
             ( col1 = dobj11 ... col2 = dobj22 col3 = dobj23 ... )
             ...
             ( col1 = dobj31 col2 = dobj32 ... col3 = dobj33 ... )
             ( col1 = dobj31 col2 = dobj32 ... col3 = dobj43 ... )
             ... ).

Values can be assigned to individual structure components outside of the inner parentheses. An assignment of this type applies to all following inner parentheses until the next assignment is made to the component in question. Assignments outside of the inner parentheses must be followed by at least one inner parenthesis. A component cannot be assigned a value more than once in the [construction of a structure](javascript:call_link\('abennew_constructor_params_struct.htm'\)), which means that a component assigned a value outside of the inner parentheses can no longer be specified in an inner parenthesis. A component can be specified again outside the inner parentheses and any components previously specified in an inner parenthesis can also be listed outside the parenthesis.

Notes

-   The restriction that the content of tabular row types cannot be constructed directly in line applies for reasons of legibility (for humans and for machines) and is not a functional restriction. The expression [VALUE line\_type( ... )](javascript:call_link\('abenconstructor_expression_value.htm'\)) can be specified for line to construct the content of a tabular row, where line\_type is the tabular row type.

-   Specifying [CONV line\_type( ... )](javascript:call_link\('abenconstructor_expression_conv.htm'\)) for the inserted values is also a way of meeting the compatibility requirements made by the row type.

-   The short form for structured row types enables columns of internal tables that are to be given an identical value in blocks to be filled more easily.
    

Example

Constructs an anonymous internal table with a structured row type (with a short form for the first column):

TYPES:
  BEGIN OF t\_line,
    col1 TYPE i,
    col2 TYPE i,
  END OF t\_line,
  t\_itab TYPE TABLE OF t\_line WITH EMPTY KEY.
DATA(dref) = NEW t\_itab( col1 = 1 ( col2 = 11 )
                                  ( col2 = 12 )
                                  ( col2 = 13 )
                         col1 = 2 ( col2 = 21 )
                                  ( col2 = 22 )
                                  ( col2 = 23 ) ).
cl\_demo\_output=>display( dref->\* ).

Alternative 2

... LINES OF jtab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]*

Effect

Specifies multiple rows. The rows are taken from the internal table jtab and inserted into the target table as a block. The same applies to jtab and the additions FROM, TO, and USING KEY as to the addition [LINES OF](javascript:call_link\('abapinsert_itab_linespec.htm'\)) of the statement [INSERT](javascript:call_link\('abapinsert_itab.htm'\)) and the block is inserted in accordance with these rules. jtab is a [functional operand position](javascript:call_link\('abenfunctional_position_glosry.htm'\) "Glossary Entry").

Notes

-   The rows from jtab are inserted into the target table using the table key only, which means that jtab must be compatible with the target type.

-   If there is a conflict with an existing unique table key, a non-handleable exception is always raised when inserting multiple rows from an internal table using the statement [INSERT](javascript:call_link\('abapinsert_itab.htm'\)).

-   When standard tables are created, the rows of the table jtab are appended to the target table in the same way as with the statement [APPEND LINES OF](javascript:call_link\('abapappend_linespec.htm'\)).

Example

Constructs an internal table itab containing the first three rows and last three rows of the previously constructed table alpha.

DATA:
  alpha TYPE TABLE OF string WITH EMPTY KEY,
  itab  LIKE REF TO alpha.
alpha = VALUE #(  FOR j = 0 UNTIL j >= strlen( sy-abcde )
                  ( substring( val = sy-abcde
                               off = j
                               len = 1  ) ) ).
itab = NEW #( ( LINES OF alpha FROM 1 to 3 )
              ( \`-\` )
              ( LINES OF alpha FROM lines( alpha ) - 2
                               TO   lines( alpha ) ) ).
cl\_demo\_output=>display( itab->\* ).

This translation does not reflect the current version of the documentation.



**📖 Source**: [abennew_constructor_params_lspc.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_lspc.htm)

### abennew_constructor_params_itab.htm

> **📖 Official SAP Documentation**: [abennew_constructor_params_itab.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_itab.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [NEW - Instance Operator](javascript:call_link\('abenconstructor_expression_new.htm'\)) → 

NEW - Internal Tables

Syntax

... NEW dtype*|*#( *\[*[let\_exp](javascript:call_link\('abaplet.htm'\))*\]*
                 *\[*BASE itab*\]*
                 *\[*[FOR for\_exp1](javascript:call_link\('abenfor.htm'\))
                  [FOR for\_exp2](javascript:call_link\('abenfor.htm'\))
                  ... *\]*
                 ( [line\_spec1](javascript:call_link\('abennew_constructor_params_lspc.htm'\)) )
                 ( [line\_spec2](javascript:call_link\('abennew_constructor_params_lspc.htm'\)) )
                   ... ) ...

Extras:

[1\. ... BASE itab](#!ABAP_ADDITION_1@1@)
[2\. ... FOR for\_exp](#!ABAP_ADDITION_2@2@)

Effect

If dtype is a tabular data type or # stands for a type like this, the table rows of the constructed table are created as follows:

-   Firstly, an optional LET expression [let\_exp](javascript:call_link\('abaplet.htm'\)) can be specified to define local helper fields whose values can be used to construct the table rows.

-   An optional start value for the content can then be specified for the content of the internal table after BASE (see below).

-   One or more optional consecutive [iteration expressions](javascript:call_link\('abeniteration_expression_glosry.htm'\) "Glossary Entry") can then be specified using [FOR](javascript:call_link\('abenfor.htm'\)) (see below).

-   The table rows are then constructed in one or more sets of internal parentheses by specifying [line\_spec](javascript:call_link\('abennew_constructor_params_lspc.htm'\)). Each set of inner parentheses constructs one or more rows in accordance with the information in line\_spec and inserts them into the new internal table in accordance with the rules for the statement [INSERT](javascript:call_link\('abapinsert_itab.htm'\)) ... [INTO TABLE](javascript:call_link\('abapinsert_itab_position.htm'\)). The object is inserted in the order of the parentheses.

The constructed rows must meet the requirements of the statement [INSERT](javascript:call_link\('abapinsert_itab.htm'\)) for inserting work areas using table keys and therefore be compatible with the row type. There is one exception to this: when constructing a [standard table](javascript:call_link\('abenstandard_table_glosry.htm'\) "Glossary Entry") (where the rows are only appended anyway), the value can be shorter than the row length (for row types c and x), in which case it is padded on the right with blanks or hexadecimal 0.

Notes

-   When a constructor expression is assigned to a reference variable using NEW, the original reference is made available in the entire expression in the target variable. The target variable is not overwritten until the expression is closed. In the case of the value operator [VALUE](javascript:call_link\('abenvalue_constructor_params_itab.htm'\)), however, the target variable can only be assigned to a helper variable using LET and is then no longer available.

-   The operand type for [line\_spec](javascript:call_link\('abennew_constructor_params_lspc.htm'\)) in the inner parentheses is the row type of the table type specified using dtype or #, which means it is always uniquely identifiable. Constructor expressions in this place can therefore always derive the required data type using #.
    

Example

Constructs an anonymous internal table with a structured row type with substructures and tabular components.

TYPES: BEGIN OF t\_struct1,
         col1 TYPE i,
         col2 TYPE i,
       END OF t\_struct1,
       BEGIN OF t\_struct2,
         col1 TYPE i,
         col2 TYPE t\_struct1,
         col3 TYPE TABLE OF t\_struct1 WITH EMPTY KEY,
       END OF t\_struct2,
       t\_itab TYPE TABLE OF t\_struct2 WITH EMPTY KEY.
DATA dref TYPE REF TO data.
dref = NEW t\_itab( ( col1 = 1
                     col2-col1 = 1
                     col2-col2 = 2
                     col3 = VALUE #( ( col1 = 1 col2 = 2 )
                                     ( col1 = 3 col2 = 4 ) ) )
                   ( col1 = 2
                     col2-col1 = 2
                     col2-col2 = 4
                     col3 = VALUE #( ( col1 = 2 col2 = 4 )
                                     ( col1 = 6 col2 = 8 ) ) ) ).

Examples

See also the examples for the value operator [VALUE](javascript:call_link\('abenvalue_constructor_params_itab.htm'\)).

Addition 1

... BASE itab

Effect

An addition, BASE, followed by an internal table, itab, can be specified in front of the inserted rows. This is a [functional operand position](javascript:call_link\('abenfunctional_position_glosry.htm'\) "Glossary Entry"). The row type of itab must be convertible to the row type of the return value. If BASE is specified, the content of itab is assigned to the return value before the individual rows are inserted. If the character # is specified for the type of the return value and the type cannot be determined from the operand position of the constructor expression, the type of itab is used for this expression (if known).

Example

Constructs three anonymous internal tables with an elementary row type. The first table is filled with three rows. The second row is initial. The second and third tables are filled with the rows of the first table and three further rows. Using BASE and [LINES OF](javascript:call_link\('abennew_constructor_params_lspc.htm'\)) here has the same effect.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
DATA(dref1) = NEW t\_itab( ( 1 ) (  ) ( 3 ) ).
DATA(dref2) = NEW t\_itab( BASE dref1->\*
                          (   ) ( 5 ) (  ) ).
DATA(dref3) = NEW t\_itab( ( LINES OF dref1->\* )
                          (   ) ( 5 ) (  ) ).
cl\_demo\_output=>write(   dref1->\* ).
cl\_demo\_output=>write(   dref2->\* ).
cl\_demo\_output=>display( dref3->\* ).

Addition 2

... FOR for\_exp

Effect

If one or more [iteration expressions](javascript:call_link\('abeniteration_expression_glosry.htm'\) "Glossary Entry") are specified consecutively using [FOR](javascript:call_link\('abenfor.htm'\)), this means that the rows constructed in [line\_spec](javascript:call_link\('abennew_constructor_params_lspc.htm'\)) for every iteration of the last FOR expression are inserted into the target table. When constructing table rows in [line\_spec](javascript:call_link\('abennew_constructor_params_lspc.htm'\)), the visible local work areas and field symbols of the iteration expressions can be used to construct table rows.

-   If [conditional iterations](javascript:call_link\('abenfor_conditional.htm'\)) are used, the new table rows are created in freely defined iteration steps.

-   If [table iterations](javascript:call_link\('abenfor_itab.htm'\)) are used, the rows of existing internal tables are evaluated. These are known as [table comprehensions](javascript:call_link\('abentable_comprehension_glosry.htm'\) "Glossary Entry"), since in this case new table rows can be constructed from the rows of existing internal tables.

Notes

-   The term "table comprehension" is derived from similar concepts used in many other languages, where it is also known as "list comprehension".

-   [Table filtering](javascript:call_link\('abentable_filtering_glosry.htm'\) "Glossary Entry") can be implemented more efficiently using the [filter operator](javascript:call_link\('abenfilter_operator_glosry.htm'\) "Glossary Entry") [FILTER](javascript:call_link\('abenconstructor_expression_filter.htm'\)).

-   Conditional iterations and table comprehensions are also possible with [FOR expressions](javascript:call_link\('abenmesh_for.htm'\)) for [mesh paths](javascript:call_link\('abenmesh_path_glosry.htm'\) "Glossary Entry").
    

Example

Constructs an anonymous internal table with an elementary row type and fills it with square numbers using an iteration expression.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
DATA(dref) = NEW t\_itab( FOR i = 1 UNTIL i > 10
                         ( ipow( base = i exp = 2 ) ) ).
cl\_demo\_output=>display( dref->\* ).

Executable Examples

[Examples of Table Comprehensions](javascript:call_link\('abentable_comprehensions_abexas.htm'\))

Continue
[NEW - line\_spec](javascript:call_link\('abennew_constructor_params_lspc.htm'\))



**📖 Source**: [abennew_constructor_params_itab.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_itab.htm)

### abennew_constructor_params_class.htm

> **📖 Official SAP Documentation**: [abennew_constructor_params_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [NEW - Instance Operator](javascript:call_link\('abenconstructor_expression_new.htm'\)) → 

NEW - Classes

Syntax

... NEW class*|*#( *\[*[let\_exp](javascript:call_link\('abaplet.htm'\))*\]* p1 = a1 p2 = a2 .. ) ...

Effect

If a class class is specified or # stands for a class like this, the non-optional input parameters p1 p2 ... of the instance constructor of the instantiated class must be filled using the type-friendly actual parameters a1 a2 ... The optional input parameters do not need to be filled. The description of the statement [CREATE OBJECT](javascript:call_link\('abapcreate_object_parameters.htm'\)) specifies how values are passed by parameter and which classes can be used. [No parameters](javascript:call_link\('abennew_constructor_params_initial.htm'\)) are passed for a class without an explicit instance constructor. An optional LET expression [let\_exp](javascript:call_link\('abaplet.htm'\)) can be specified in front of the parameter to define local helper fields.

Like an object reference variable of the type class, a constructor expression NEW class( ... ) can be specified in front of the [object component selector](javascript:call_link\('abenobject_component_select_glosry.htm'\) "Glossary Entry") \-> and in [chained attribute accesses](javascript:call_link\('abenchained_attribute_acc_glosry.htm'\) "Glossary Entry") and [chained method calls](javascript:call_link\('abenchained_method_call_glosry.htm'\) "Glossary Entry"). A chained method call of this type can be specified as a [standalone statement](javascript:call_link\('abapcall_method_static_chain.htm'\)). This persists the result for the duration of the statement. Even a single expression without a following object component selector can be specified as a standalone statement. In this case, the only constructor executed is the constructor that needs to save a reference to the new object elsewhere (if it needs to be persisted).

In the special case of an attribute access NEW class( ... )->attr, the following applies:

-   It can be specified as a [writable expression](javascript:call_link\('abenwritable_expression_glosry.htm'\) "Glossary Entry") in a [result position](javascript:call_link\('abenresult_position_glosry.htm'\) "Glossary Entry").

-   A [specified offset/length](javascript:call_link\('abenoffset_length_specific_glosry.htm'\) "Glossary Entry") [+off(len)](javascript:call_link\('abenoffset_length.htm'\)) can be appended (if the data type is suitable), except when the chaining uses the statement ASSIGN as a [memory area](javascript:call_link\('abapassign_mem_area_writable_exp.htm'\)).

[Method chainings](javascript:call_link\('abenmethod_chaining_glosry.htm'\) "Glossary Entry") cannot be specified between the constructor expression and the attribute here.

Notes

-   This can be seen as a functional call of the instance constructor. As in [function calls](javascript:call_link\('abapcall_method_functional.htm'\)) of [functional methods](javascript:call_link\('abapmethods_functional.htm'\)), no [non-class-based exceptions](javascript:call_link\('abenexceptions_non_class.htm'\)) can be handled.

-   When the instance constructor is called, the return code sy-subrc is set to 0. Values other than 0 are not possible, since non-class-based exceptions cannot be handled.

Example

Constructs an instance of the class c1 when the method m2 of the class c2 is called. Here, an input parameter of the type in question is expected.

CLASS c1 DEFINITION.
  PUBLIC SECTION.
    METHODS constructor IMPORTING p1 TYPE i p2 TYPE i.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD constructor.
    ...
  ENDMETHOD.
ENDCLASS.
CLASS c2 DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS m2 IMPORTING oref TYPE REF TO c1.
ENDCLASS.
CLASS c2 IMPLEMENTATION.
  METHOD m2.
    ...
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  c2=>m2( NEW #( p1 = 1 p2 = 2 ) ).

Example

Uses a constructor expression with NEW in various positions. The temporary reference variable created using NEW is persisted during each statement.

CLASS c1 DEFINITION.
  PUBLIC SECTION.
    DATA     a1 TYPE i.
    METHODS: m1 RETURNING value(p) TYPE i,
             m2.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD m1.
    ...
  ENDMETHOD.
  METHOD m2.
    ...
  ENDMETHOD.
ENDCLASS.
DATA num TYPE i.
START-OF-SELECTION.
  num = NEW c1( )->a1.
  NEW c1( )->a1 = num.
  num = NEW c1( )->m1( ).
  NEW c1( )->m2( ).
  NEW c1( ).

Example

Displays a time stamp created in a constructor that only exists while the statement is being executed.

CLASS utc DEFINITION.
  PUBLIC SECTION.
    DATA ts TYPE timestamp.
    METHODS constructor.
ENDCLASS.
CLASS utc IMPLEMENTATION.
  METHOD constructor.
    GET TIME STAMP FIELD ts.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display\_text(
    |{ NEW utc( )->ts TIMESTAMP = ISO }| ).

Example

Constructor expression with NEW on the left side of an expression. The temporary reference variable created using NEW exists only while the statement is being executed, however the reference to the object is assigned to the reference variable oref of the class class. This persists the object.

CLASS class DEFINITION.
  PUBLIC SECTION.
    DATA attr TYPE string.
    METHODS constructor.
ENDCLASS.
DATA oref TYPE REF TO class.
CLASS class IMPLEMENTATION.
  METHOD constructor.
    oref = me.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  NEW class( )->attr = 'foo'.
  cl\_demo\_output=>display( oref->attr ).


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / VALUE - Value Operator / VALUE - Initial Value for All Types

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / VALUE - Value Operator / VALUE - Initial Value for All Types

Included pages: 2



**📖 Source**: [abennew_constructor_params_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abennew_constructor_params_class.htm)

### abenvalue_constructor_params_init.htm

> **📖 Official SAP Documentation**: [abenvalue_constructor_params_init.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_constructor_params_init.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [VALUE - Value Operator](javascript:call_link\('abenconstructor_expression_value.htm'\)) → 

VALUE - Initial Value for All Types

Syntax

... VALUE dtype*|*#( ) ...

Effect

If no parameters are specified in the parentheses, the return value is set to its type-specific initial value. This is possible for any non-generic data types dtype. The # character can stand for appropriate operand types known statically. When VALUE #( ) is passed to a generically typed formal parameter, the type is also derived from the generic type of this parameter in the following cases:

-   string for csequence and clike

-   xstring for xsequence

-   decfloat34 for numeric and decfloat

-   p with the length 8 and no decimal places if p is generic

-   The [standard key](javascript:call_link\('abenstandard_key_glosry.htm'\) "Glossary Entry") for a standard table type with generic primary table key

Other generic data types (except for table types) that are explicitly generic with respect to their secondary table keys cannot be made more concrete and produce a syntax error. More specifically, this applies to the types c, n, and x with generic lengths.

Notes

-   VALUE with pass by value is used only to construct certain complex values (structures and internal tables). VALUE without pass by value, on the other hand, is a general method for creating type-dependent initial values in any operand positions.

-   Certain rules apply to derivations of the type in cases where # is specified for actual parameters that can be passed to generically typed formal parameters. These rules prevent syntax errors in programs that call a procedure and where the procedure makes the full typing of a formal parameter type more general by switching to a generic type.

-   If dtype or # stand for an [enumerated type](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry"), its initial value is generated according to its [base type](javascript:call_link\('abenbase_type_glosry.htm'\) "Glossary Entry").

Example

Creates a suitable initial structure for a non-optional input parameter of a method.

CLASS c1 DEFINITION.
  PUBLIC SECTION.
    TYPES: BEGIN OF t\_struct,
             col1 TYPE i,
             col2 TYPE i,
           END OF t\_struct.
    CLASS-METHODS m1 IMPORTING p TYPE t\_struct.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD m1.
    ...
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  c1=>m1( VALUE #( ) ).

Executable Example

[Value Operator, Type Inference](javascript:call_link\('abenvalue_type_inference_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Value Operator, Type Inference](javascript:call_link\('abenvalue_type_inference_abexa.htm'\))



**📖 Source**: [abenvalue_constructor_params_init.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_constructor_params_init.htm)

### abenvalue_type_inference_abexa.htm

> **📖 Official SAP Documentation**: [abenvalue_type_inference_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_type_inference_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [VALUE - Value Operator](javascript:call_link\('abenconstructor_expression_value.htm'\)) →  [VALUE - Initial Value for All Types](javascript:call_link\('abenvalue_constructor_params_init.htm'\)) → 

Value Operator, Type Inference

This example demonstrates a type inference for the value operator [VALUE](javascript:call_link\('abenconstructor_expression_value.htm'\)).

Source Code

REPORT demo\_value\_type\_inference.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    TYPES c10 TYPE c LENGTH 10.
    CLASS-METHODS:
      main,
      meth1 IMPORTING p TYPE c10,
      meth2 IMPORTING p TYPE c,
      meth3 IMPORTING p TYPE csequence,
      descr IMPORTING p TYPE any.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    demo=>meth1( p = VALUE #(  ) ).
    cl\_demo\_output=>line( ).
   "demo=>meth2( p = value #(  ) ). "not possible
    cl\_demo\_output=>line( ).
    demo=>meth3( p = VALUE #(  ) ) ##type.
    cl\_demo\_output=>display( ).  ENDMETHOD.
  METHOD meth1.
    descr( p ).
  ENDMETHOD.
  METHOD meth2.
    descr( p ).
  ENDMETHOD.
  METHOD meth3.
    descr( p ).
  ENDMETHOD.
  METHOD descr.
    DATA type   TYPE string.
    DATA length TYPE i.
    DESCRIBE FIELD p TYPE type.
    IF type = 'g'.
      type = 'STRING'.
      length = strlen( p ).
    ELSE.
      DESCRIBE FIELD p LENGTH length IN CHARACTER MODE.
    ENDIF.
    cl\_demo\_output=>write( |{ type } { length }| ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Passes constructor expressions with the value operator [VALUE](javascript:call_link\('abenvalue_constructor_params_init.htm'\)) for initial values to differently typed formal parameters of methods.

-   Fully typed formal parameter

When the method meth1 is called with a fully typed formal parameter, the operand type for # is identified using this parameter and the result of the value operator is an initial field of type c with length 10.

-   Formal parameter typed generically with c

No call is possible here, since there is no inference rule for the generic type c.

-   Formal parameter typed generically with csequence

In accordance with the inference rule for csequence, the result of the value operator is an initial field of type string. This is indicated by a syntax check warning.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / VALUE - Value Operator / VALUE - Internal Tables

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / VALUE - Value Operator / VALUE - Internal Tables

Included pages: 4



**📖 Source**: [abenvalue_type_inference_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_type_inference_abexa.htm)

### abenvalue_constructor_params_itab.htm

> **📖 Official SAP Documentation**: [abenvalue_constructor_params_itab.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_constructor_params_itab.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [VALUE - Value Operator](javascript:call_link\('abenconstructor_expression_value.htm'\)) → 

VALUE - Internal Tables

Syntax

... VALUE dtype*|*#( *\[*[let\_exp](javascript:call_link\('abaplet.htm'\))*\]*
                   *\[*BASE itab*\]*
                   *\[*[FOR for\_exp1](javascript:call_link\('abenfor.htm'\))
                    [FOR for\_exp2](javascript:call_link\('abenfor.htm'\))
                    ... *\]*
                   ( [line\_spec1](javascript:call_link\('abenvalue_constructor_params_lspc.htm'\)) )
                   ( [line\_spec2](javascript:call_link\('abenvalue_constructor_params_lspc.htm'\)) )
                     ... ) ...

Extras:

[1\. ... BASE itab](#!ABAP_ADDITION_1@1@)
[2\. ... FOR for\_exp](#!ABAP_ADDITION_2@2@)

Effect

If dtype is a tabular data type or # stands for a type like this, the table rows of the constructed table are created as follows:

-   Firstly, an optional LET expression [let\_exp](javascript:call_link\('abaplet.htm'\)) can be specified to define local helper fields whose values can be used to construct the table rows.

-   An optional start value for the content can then be specified for the content of the internal table after BASE (see below).

-   One or more optional consecutive [iteration expressions](javascript:call_link\('abeniteration_expression_glosry.htm'\) "Glossary Entry") can then be specified using [FOR](javascript:call_link\('abenfor.htm'\)) (see below).

-   The table rows are then constructed in one or more sets of internal parentheses by specifying [line\_spec](javascript:call_link\('abenvalue_constructor_params_lspc.htm'\)). Each set of inner parentheses constructs one or more rows in accordance with the information in line\_spec and inserts them into the new internal table in accordance with the rules for the statement [INSERT](javascript:call_link\('abapinsert_itab.htm'\)) ... [INTO TABLE](javascript:call_link\('abapinsert_itab_position.htm'\)), with one difference: Any conflicts with an existing unique primary table key raise an exception of the class CX\_SY\_ITAB\_DUPLICATE\_KEY. The object is inserted in the order of the parentheses.

The constructed rows must meet the requirements of the statement [INSERT](javascript:call_link\('abapinsert_itab.htm'\)) for inserting work areas using table keys and therefore be compatible with the row type. There is one exception to this: when constructing a [standard table](javascript:call_link\('abenstandard_table_glosry.htm'\) "Glossary Entry") (where the rows are only appended anyway), the value can be shorter than the row length (for row types c and x), in which case it is padded on the right with blanks or hexadecimal 0.

If the VALUE operator is used as the source of an assignment to an internal table, this table is first initialized after the evaluation of the [LET](javascript:call_link\('abaplet.htm'\)) expression (if available) or is assigned the content of itab. The [line\_spec](javascript:call_link\('abenvalue_constructor_params_lspc.htm'\)) data is then evaluated and inserted directly in the target table.

Notes

-   In assignments of constructor expressions to an internal table, its existing rows cannot be used directly as an argument in [line\_spec](javascript:call_link\('abenvalue_constructor_params_lspc.htm'\)). This is because this table is deleted before line\_spec is evaluated or overwritten by the content of itab. If the entire internal table or rows from the left side are needed on the right side, however, they can be saved in local helper variables using a [LET](javascript:call_link\('abaplet.htm'\)) expression, since this expression is evaluated first.

-   The operand type for [line\_spec](javascript:call_link\('abenvalue_constructor_params_lspc.htm'\)) in the inner parentheses is the row type of the table type specified using dtype or #, which means it is always uniquely identifiable. Constructor expressions in this place can therefore always derive the required data type using #.
    

Example

Constructs an internal table with a structured row type and fills it with two rows. The structures are filled with values component by component.

TYPES: BEGIN OF t\_struct,
         col1 TYPE i,
         col2 TYPE i,
       END OF t\_struct,
       t\_itab TYPE TABLE OF t\_struct WITH EMPTY KEY.
DATA itab TYPE t\_itab.
itab = VALUE #( ( col1 = 1 col2 = 2 )
                ( col1 = 3 col2 = 4 ) ).

Example

Constructs an internal table with a tabular row type and fills it with two rows. The first row is assigned a table that is already filled. The second row is constructed using VALUE.

TYPES: t\_itab1 TYPE TABLE OF i        WITH EMPTY KEY,
       t\_itab2 TYPE TABLE OF t\_itab1 WITH EMPTY KEY.
DATA itab1 TYPE t\_itab1.
DATA itab2 TYPE t\_itab2.
itab1 = VALUE #( ( 1 ) ( 2 ) ( 3 ) ).
itab2 = VALUE #( ( itab1 )
                 ( VALUE t\_itab1( ( 4 ) ( 5 ) ( 6 ) ) ) ).

Examples

See also the examples for the instance operator [NEW](javascript:call_link\('abennew_constructor_params_itab.htm'\)).

Executable Examples

-   [VALUE - Operator for Internal Tables](javascript:call_link\('abenvalue_itab_abexa.htm'\))

-   [VALUE Operator with LET for Internal Tables](javascript:call_link\('abenvalue_itab_let_abexa.htm'\))
    

Addition 1

... BASE itab

Effect

An addition, BASE, followed by an internal table, itab, can be specified in front of the inserted rows. This is a [functional operand position](javascript:call_link\('abenfunctional_position_glosry.htm'\) "Glossary Entry"). The row type of itab must be convertible to the row type of the return value. If BASE is specified, the content of itab is assigned to the return value before the individual rows are inserted. If the character # is specified for the type of the return value and the type cannot be determined from the operand position of the constructor expression, the type of itab is used for this expression (if known).

Notes

-   If the addition BASE is not specified, the content of tables can only be reconstructed using the value operator and no new content can be added. If the same table is specified after BASE to which the constructor expression is assigned, further rows can be inserted in this table.

-   If the target table is specified as itab after BASE in an assignment to an existing internal table, no assignment takes place before [line\_spec](javascript:call_link\('abenvalue_constructor_params_lspc.htm'\)) is evaluated, and the target table just keeps its value instead.
    

Example

Uses BASE. The table type of base1 or base2 is applied in the construction of tab1 and tab2. This is not possible in the construction of tab3 since the row type of base2 is not structured and hence not suitable for specifying individual components in the parentheses that follow. The type itab2 is specified explicitly for tab3. This is possible since the row type of base2 can be converted into this row type. Sorted tables are constructed, which means that the rows in the results are also sorted.

TYPES:
  itab1 TYPE SORTED TABLE OF string WITH UNIQUE KEY table\_line,
  BEGIN OF struct,
    col1 TYPE c LENGTH 2,
    col2 TYPE c LENGTH 2,
    col3 TYPE c LENGTH 2,
  END OF struct,
  itab2 TYPE SORTED TABLE OF struct WITH UNIQUE KEY col1 col2 col3.
DATA(base1) = VALUE itab1(
                ( \`x1y1z1\` )
                ( \`x2y2z2\` )
                ( \`x3y3z3\` ) ).
DATA(base2) = VALUE itab2(
                ( col1 = 'x1' col2 = 'y1' col3 = 'z1' )
                ( col1 = 'x2' col2 = 'y2' col3 = 'z2' )
                ( col1 = 'x3' col2 = 'y3' col3 = 'z3' ) ).
DATA(tab1) = VALUE #( BASE base1
               ( \`A1B1B1\` )
               ( \`A2B2B2\` ) ).
DATA(tab2)  = VALUE #(
                BASE base2
                ( col1 = 'A1' col2 = 'B1' col3 = 'C1' )
                ( col1 = 'A2' col2 = 'B2' col3 = 'C2' ) ).
DATA(tab3) = VALUE itab2( BASE base1
               ( col1 = 'A1' col2 = 'B1' col3 = 'C1' )
               ( col1 = 'A2' col2 = 'B2' col3 = 'C2' ) ).
cl\_demo\_output=>write(   tab1  ).
cl\_demo\_output=>write(   tab2 ).
cl\_demo\_output=>display( tab3 ).

Example

Uses BASE to append rows to existing rows in an internal table.

TYPES itab TYPE TABLE OF string WITH EMPTY KEY.
DATA(itab) =
  VALUE itab(
    ( \`a\` ) ( \`b\` ) ( \`c\` ) ).
...
itab =
  VALUE #(
    BASE itab
    ( \`d\` ) ( \`e\` ) ( \`f\` ) ).
cl\_demo\_output=>display( itab ).

Example

Uses BASE to append rows to an internal table in a loop. After the output, it possible to see how the same function can be applied using an iteration expression with [FOR](javascript:call_link\('abenfor_conditional.htm'\)).

DATA itab TYPE TABLE OF i WITH EMPTY KEY.
DO 10 TIMES.
  itab = VALUE #( BASE itab ( ipow( base = sy-index exp = 2 ) ) ).
ENDDO.
cl\_demo\_output=>display( itab ).
DATA jtab LIKE itab.
jtab = VALUE #( FOR j = 1 UNTIL j > 10
                ( ipow( base = j exp = 2 ) ) ).
ASSERT jtab = itab.

Addition 2

... FOR for\_exp

Effect

If one or more [iteration expressions](javascript:call_link\('abeniteration_expression_glosry.htm'\) "Glossary Entry") are specified consecutively using [FOR](javascript:call_link\('abenfor.htm'\)), this means that the rows constructed in [line\_spec](javascript:call_link\('abenvalue_constructor_params_lspc.htm'\)) for every iteration of the last FOR expression are inserted into the target table. When constructing table rows in [line\_spec](javascript:call_link\('abenvalue_constructor_params_lspc.htm'\)), the visible local work areas and field symbols of the iteration expressions can be used to construct table rows.

-   If [conditional iterations](javascript:call_link\('abenfor_conditional.htm'\)) are used, the new table rows are created in freely defined iteration steps.

-   If [table iterations](javascript:call_link\('abenfor_itab.htm'\)) are used, the rows of existing internal tables are evaluated. These are known as [table comprehensions](javascript:call_link\('abentable_comprehension_glosry.htm'\) "Glossary Entry"), since in this case new table rows can be constructed from the rows of existing internal tables.

Notes

-   The term "table comprehension" is derived from similar concepts used in many other languages, where it is also known as "list comprehension".

-   [Table filtering](javascript:call_link\('abentable_filtering_glosry.htm'\) "Glossary Entry") can be implemented more efficiently using the [filter operator](javascript:call_link\('abenfilter_operator_glosry.htm'\) "Glossary Entry") [FILTER](javascript:call_link\('abenconstructor_expression_filter.htm'\)).

-   Conditional iterations and table comprehensions are also possible with [FOR expressions](javascript:call_link\('abenmesh_for.htm'\)) for [mesh paths](javascript:call_link\('abenmesh_path_glosry.htm'\) "Glossary Entry").

-   For tasks that can be solved using both table comprehensions and [special assignments](javascript:call_link\('abencorresponding.htm'\)) for components (in particular the component operator [CORRESPONDING](javascript:call_link\('abenconstructor_expr_corresponding.htm'\))), it is best to use assignments (see the [executable example](javascript:call_link\('abencorresponding_vs_for_abexa.htm'\))).

-   If the VALUE operator is used, it should be noted that assignments to internal tables are also initialized (or given the content of itab after BASE) even in the case of table comprehensions after the evaluation of a [LET](javascript:call_link\('abaplet.htm'\)) expressions. The target table is then used directly. The original table can therefore not be used directly in the FOR expressions (unless it is assigned to a helper variable after LET).

Example

Constructs a temporary internal table with an elementary row type and fills it with square numbers using an iteration expression.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
cl\_demo\_output=>display(
  VALUE t\_itab( FOR i = 1 UNTIL i > 10
                ( ipow( base = i exp = 2 ) ) ) ).

Executable Examples

-   [Examples of Table Comprehensions](javascript:call_link\('abentable_comprehensions_abexas.htm'\))

Continue
[VALUE - line\_spec](javascript:call_link\('abenvalue_constructor_params_lspc.htm'\))
![Example](exa.gif "Example") [VALUE - Operator for Internal Tables](javascript:call_link\('abenvalue_itab_abexa.htm'\))
![Example](exa.gif "Example") [VALUE - Operator with LET for Internal Tables](javascript:call_link\('abenvalue_itab_let_abexa.htm'\))



**📖 Source**: [abenvalue_constructor_params_itab.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_constructor_params_itab.htm)

### abenvalue_constructor_params_lspc.htm

> **📖 Official SAP Documentation**: [abenvalue_constructor_params_lspc.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_constructor_params_lspc.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [VALUE - Value Operator](javascript:call_link\('abenconstructor_expression_value.htm'\)) →  [VALUE - Internal Tables](javascript:call_link\('abenvalue_constructor_params_itab.htm'\)) → 

VALUE - line\_spec

Syntax

... line
  *|* *{*LINES OF itab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]**}* ...

Alternatives:

[1\. ... line](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LINES OF jtab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]*](#!ABAP_ALTERNATIVE_2@2@)

Effect

Specifies one or more rows to be inserted when constructing an internal table with the value operator [VALUE](javascript:call_link\('abenvalue_constructor_params_itab.htm'\)).

Note

If rows from the target table or the entire target table are used in line\_spec in an assignment of a constructor expression using the value operator [VALUE](javascript:call_link\('abenvalue_constructor_params_itab.htm'\)) to an internal table, these rows are deleted or overwritten by a start value before both variants of line\_spec are evaluated. The target table must therefore be saved in an auxiliary variable first. A [LET](javascript:call_link\('abaplet.htm'\)) expression can be used to do this.

Alternative 1

... line

Effect

Specifies a row. line can be specified in exactly the same way as in the parentheses of an expression [NEW line\_type( ... )](javascript:call_link\('abenconstructor_expression_new.htm'\)). Here, line\_type is the row type of the internal table and a corresponding row is constructed. The following special features apply here:

-   If a data object is specified for line, this object must be compatible with the row type.

-   If an expression (built-in function, functional method, calculation expression, constructor expression, or table expression) is specified for line, the result of the expression must be convertible to the row type.

-   The syntax does not permit further parentheses for constructing tabular row types to be nested directly in line.

Short Form for Structured Row Types

If the row type of the internal table is a structured type, the following short form can be used:

VALUE dtype*|*#( *\[*let\_exp*\]*
               *\[*BASE itab*\]*
               col1 = dobj11 ... ( col2 = dobj12 col3 = dobj13 ... )
                                 ( col2 = dobj22 col3 = dobj23 ... )
                                 ...
               col1 = dobj31 col2 = dobj32 ... ( col3 = dobj33 ... )
                                               ( col3 = dobj43 ... )
               ... ).

This has the same semantics as the following:

VALUE dtype*|*#( *\[*let\_exp*\]*
               *\[*BASE itab*\]*
               ( col1 = dobj11 ... col2 = dobj12 col3 = dobj13 ... )
               ( col1 = dobj11 ... col2 = dobj22 col3 = dobj23 ... )
               ...
               ( col1 = dobj31 col2 = dobj32 ... col3 = dobj33 ... )
               ( col1 = dobj31 col2 = dobj32 ... col3 = dobj43 ... )
               ... ).

Values can be assigned to individual structure components outside of the inner parentheses. An assignment of this type applies to all following inner parentheses until the next assignment is made to the component in question. Assignments outside of the inner parentheses must be followed by at least one inner parenthesis. A component cannot be assigned a value more than once in the [construction of a structure](javascript:call_link\('abennew_constructor_params_struct.htm'\)), which means that a component assigned a value outside of the inner parentheses can no longer be specified in an inner parenthesis. A component can be specified again outside the inner parentheses and any components previously specified in an inner parenthesis can also be listed outside the parenthesis.

Notes

-   The restriction that the content of tabular row types cannot be constructed directly in line applies for reasons of legibility (for humans and for machines) and is not a functional restriction. The expression [VALUE line\_type( ... )](javascript:call_link\('abenconstructor_expression_value.htm'\)) can be specified for line to construct the content of a tabular row, where line\_type is the tabular row type.

-   Specifying [CONV line\_type( ... )](javascript:call_link\('abenconstructor_expression_conv.htm'\)) for the inserted values is also a way of meeting the compatibility requirements made by the row type.

-   The short form for structured row types enables columns of internal tables that are to be given an identical value in blocks to be filled more easily.

-   As in VALUE, the table rows are constructed in accordance with the rules for the instance operator [NEW](javascript:call_link\('abenconstructor_expression_new.htm'\)), since new table rows are created here too and the restriction for VALUE dictating that no values of elementary data objects can be constructed cannot be applied.
    

Example

Constructs a [ranges table](javascript:call_link\('abenranges_table_glosry.htm'\) "Glossary Entry") and fills it with four rows while using the short form for structured row types.

DATA itab TYPE RANGE OF i.
itab = VALUE #( sign = 'I'  option = 'BT' ( low = 1  high = 10 )
                                          ( low = 21 high = 30 )
                                          ( low = 41 high = 50 )
                            option = 'GE' ( low = 61 )  ).

Alternative 2

... LINES OF jtab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]*

Effect

Specifies multiple rows. The rows are taken from the internal table jtab and inserted into the target table as a block. The same applies to jtab and the additions FROM, TO, and USING KEY as to the addition [LINES OF](javascript:call_link\('abapinsert_itab_linespec.htm'\)) of the statement [INSERT](javascript:call_link\('abapinsert_itab.htm'\)) and the block is inserted in accordance with these rules. jtab is a [functional operand position](javascript:call_link\('abenfunctional_position_glosry.htm'\) "Glossary Entry").

Notes

-   The rows from jtab are inserted into the target table using the table key only, which means that jtab must be compatible with the target type.

-   If there is a conflict with an existing unique table key, a non-handleable exception is always raised when inserting multiple rows from an internal table using the statement [INSERT](javascript:call_link\('abapinsert_itab.htm'\)).

-   When standard tables are created, the rows of the table jtab are appended to the target table in the same way as with the statement [APPEND LINES OF](javascript:call_link\('abapappend_linespec.htm'\)).
    

Example

Constructs an internal table with an elementary row type. jtab is filled with three rows and itab with six rows. The first row inserted in itab is initial and the last three rows are taken from the table jtab filled previously.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
DATA(jtab) = VALUE t\_itab( ( 10 ) ( 20 ) ( 30 ) ).
DATA(itab) = VALUE t\_itab( ( ) ( 1 ) ( 2 ) ( LINES OF jtab ) ).
cl\_demo\_output=>display( itab ).



**📖 Source**: [abenvalue_constructor_params_lspc.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_constructor_params_lspc.htm)

### abenvalue_itab_abexa.htm

> **📖 Official SAP Documentation**: [abenvalue_itab_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_itab_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [VALUE - Value Operator](javascript:call_link\('abenconstructor_expression_value.htm'\)) →  [VALUE - Internal Tables](javascript:call_link\('abenvalue_constructor_params_itab.htm'\)) → 

VALUE - Operator for Internal Tables

This example demonstrates the value operator [VALUE](javascript:call_link\('abenvalue_constructor_params_itab.htm'\)) for internal tables.

Source Code

REPORT demo\_value\_constructor\_itab.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES itab TYPE STANDARD TABLE OF i WITH EMPTY KEY.
    DATA(itab) = VALUE itab( ( 1 ) ( 2 ) ( 3 ) ).
    DATA(itab1) = itab.
    itab1 = VALUE #(  BASE itab1
                     ( 4 )
                     ( 5 ) ).
    cl\_demo\_output=>write( itab1 ).
    DATA(itab2) = itab.
    itab2 = VALUE #( ( LINES OF itab2 )
                      ( 4 )
                      ( 5 ) ).
    cl\_demo\_output=>write( itab2 ).
    DATA(itab3) = itab.
    itab3 = VALUE #( BASE itab3
                     ( LINES OF itab3 )
                     ( 4 )
                     ( 5 ) ).
    cl\_demo\_output=>write( itab3 ).
    DATA(itab4) = itab.
    itab4 = VALUE #( LET x = itab4 IN
                     ( LINES OF x )
                     ( 4 )
                     ( 5 ) ).
    cl\_demo\_output=>write( itab4 ).
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The example shows various effects when using the left side of an assignment in specified rows of the operator VALUE in the construction of internal tables.

-   In the construction of itab1, the left side is used after BASE. Here, the original three rows are passed as a start value before the specified rows are evaluated. Two single rows are then appended to this start value.

-   In the construction of itab2, the left side is initialized before the specified rows are evaluated. This is why no rows are inserted by LINES OF itab2 and the table contains only two single rows.

-   In the construction of itab3, the left side is given its original three rows as a start row using BASE. These rows are then appended again using LINES OF, before the two single rows are appended.

-   In the construction of itab4, the left side is saved in the helper variable x before it is initialized. It is then used in LINES OF. The result is the same as when the left side is used after BASE.



**📖 Source**: [abenvalue_itab_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_itab_abexa.htm)

### abenvalue_itab_let_abexa.htm

> **📖 Official SAP Documentation**: [abenvalue_itab_let_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_itab_let_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [VALUE - Value Operator](javascript:call_link\('abenconstructor_expression_value.htm'\)) →  [VALUE - Internal Tables](javascript:call_link\('abenvalue_constructor_params_itab.htm'\)) → 

VALUE - Operator with LET for Internal Tables

This example demonstrates the value operator [VALUE](javascript:call_link\('abenvalue_constructor_params_itab.htm'\)) for internal tables with a [LET expression](javascript:call_link\('abaplet.htm'\)).

Source Code

REPORT demo\_value\_constr\_itab\_let.
CLASS date DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS get RETURNING VALUE(d) TYPE d.
ENDCLASS.
CLASS date IMPLEMENTATION.
  METHOD get.
    d = sy-datlo.
  ENDMETHOD.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES t\_date\_tab TYPE TABLE OF string  WITH EMPTY KEY.
    cl\_demo\_output=>display(
      VALUE t\_date\_tab(
        LET d = date=>get( ) IN
        ( |{ CONV d( d - 1 ) DATE = ENVIRONMENT }| )
        ( |{         d       DATE = ENVIRONMENT }| )
        ( |{ CONV d( d + 1 ) DATE = ENVIRONMENT }| ) ) ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Constructs an internal table with an elementary row type with type string and fills it with three rows. The result is a table that is given the previous day, today, and the next day (all formatted for the current language environment). Today's date is produced using a method. To make sure that the method is called only once, the return value is assigned to a local helper field in a [LET expression](javascript:call_link\('abaplet.htm'\)).


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Areas

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Classes and Interfaces / Shared Objects - IF_SHM_BUILD_INSTANCE

Included pages: 2



**📖 Source**: [abenvalue_itab_let_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvalue_itab_let_abexa.htm)

### abenshm_if_shm_build_instance.htm

> **📖 Official SAP Documentation**: [abenshm_if_shm_build_instance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_if_shm_build_instance.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [Shared Objects](javascript:call_link\('abenabap_shared_objects.htm'\)) →  [Shared Objects - Classes and Interfaces](javascript:call_link\('abenshm_classes.htm'\)) → 

Shared Objects - IF\_SHM\_BUILD\_INSTANCE

The interface IF\_SHM\_BUILD\_INSTANCE must be included by an [area constructor class](javascript:call_link\('abenshm_area_constructor_class.htm'\)) that implements the optional area constructor of an area.

Static Methods

BUILD

Interface method for implementing the area constructor of an area.

Input Parameters

-   INST\_NAME of type SHM\_INST\_NAME

Name of the area instance version. The name is optional. The default value is the value of the constant CL\_SHM\_AREA=>DEFAULT\_INSTANCE.

-   INVOCATION\_MODE of type i

This parameter can be used to determine the type of call in the area constructor. The default value CL\_SHM\_AREA=>INVOCATION\_MODE\_EXPLICIT is used for the explicit call. CL\_SHM\_AREA=>INVOCATION\_MODE\_AUTO\_BUILD is passed with the automatic call.

Exceptions

-   CX\_SHM\_BUILD\_FAILED

An error occurred when the area constructor was executed.

Note

The method BUILD does not have an input parameter for the client ID. The area is built in the current client when the method is called.

Continue
[Shared Objects - Area Constructor Class](javascript:call_link\('abenshm_area_constructor_class.htm'\))



**📖 Source**: [abenshm_if_shm_build_instance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_if_shm_build_instance.htm)

### abenshm_area_constructor_class.htm

> **📖 Official SAP Documentation**: [abenshm_area_constructor_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_area_constructor_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [Shared Objects](javascript:call_link\('abenabap_shared_objects.htm'\)) →  [Shared Objects - Classes and Interfaces](javascript:call_link\('abenshm_classes.htm'\)) →  [Shared Objects - IF\_SHM\_BUILD\_INSTANCE](javascript:call_link\('abenshm_if_shm_build_instance.htm'\)) → 

Shared Objects - Area Constructor Class

An area constructor class is a global class with a freely definable name that implements the interface [IF\_SHM\_BUILD\_INSTANCE](javascript:call_link\('abenshm_if_shm_build_instance.htm'\)). An area constructor can be implemented in the interface method BUILD.

An area constructor class can be [assigned](javascript:call_link\('abenshm_area_dynamic_properties.htm'\)) to an [area](javascript:call_link\('abenshm_areas.htm'\)) in transaction SHMA. This is always necessary if the area is built automatically by calling the area constructor, that is if the components BUILD\_KIND and REFRESH\_TIME of the structure PROPERTIES of the class [CL\_SHM\_AREA](javascript:call_link\('abenshm_cl_shm_area.htm'\)) are filled accordingly. If an area is not built automatically, an area constructor class can be specified for the explicit area constructor call using the method BUILD of the [area class](javascript:call_link\('abenshm_area_class.htm'\)).

Structure of an Area Constructor

The following structure is recommended for the area constructor implemented in the interface method BUILD:

1.  First, the area constructor has to use the method ATTACH\_FOR\_WRITE to create an area handle with an exclusive lock for the area instance passed in the parameter INST\_NAME. The automatic area constructor is also not able to ensure that the exclusive lock can be set, which means that all exceptions have to be caught and forwarded to the caller of the constructor by raising the interface exception CX\_SHM\_BUILD\_FAILED. This should pass the original exception to the parameter PREVIOUS of the constructor of CX\_SHM\_BUILD\_FAILED.
    
2.  As is the case whenever a new area instance version is created, a root object also has to be defined in the area constructor using the method SET\_ROOT.
    
3.  The area instance version can then be built, which means that objects are stored in the shared memory.
    
4.  The new area handle has to be released again using the method DETACH\_COMMIT.
    
5.  If the area constructor was called automatically, a database commit has to be triggered when a transactional area is built.

In an area constructor, no statements can be used that exit the current [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") (such as SUBMIT, CALL TRANSACTION, CALL SCREEN, MESSAGE for message types "W", "I", "E", and so on).

Example

The following implementation can be used as a template for new implementations.

CLASS area\_constructor IMPLEMENTATION.
  METHOD if\_shm\_build\_instance~build.
    DATA:
      my\_handle TYPE REF TO area
      my\_data   TYPE REF TO area\_root\_class
      my\_except TYPE REF TO cx\_root.
    TRY.
        my\_handle = cl\_my\_area=>attach\_for\_write( inst\_name ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    CREATE OBJECT my\_data AREA HANDLE my\_handle.
    my\_handle->set\_root( my\_data ).
    ... " code to build the area instance
    TRY.
        my\_handle->detach\_commit( ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    IF invocation\_mode = cl\_shm\_area=>invocation\_mode\_auto\_build.
      COMMIT CONNECTION default.
    ENDIF.
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Area Instance Versions

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Classes and Interfaces / Shared Objects - IF_SHM_BUILD_INSTANCE

Included pages: 2



**📖 Source**: [abenshm_area_constructor_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_area_constructor_class.htm)

### abenshm_if_shm_build_instance.htm

> **📖 Official SAP Documentation**: [abenshm_if_shm_build_instance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_if_shm_build_instance.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [Shared Objects](javascript:call_link\('abenabap_shared_objects.htm'\)) →  [Shared Objects - Classes and Interfaces](javascript:call_link\('abenshm_classes.htm'\)) → 

Shared Objects - IF\_SHM\_BUILD\_INSTANCE

The interface IF\_SHM\_BUILD\_INSTANCE must be included by an [area constructor class](javascript:call_link\('abenshm_area_constructor_class.htm'\)) that implements the optional area constructor of an area.

Static Methods

BUILD

Interface method for implementing the area constructor of an area.

Input Parameters

-   INST\_NAME of type SHM\_INST\_NAME

Name of the area instance version. The name is optional. The default value is the value of the constant CL\_SHM\_AREA=>DEFAULT\_INSTANCE.

-   INVOCATION\_MODE of type i

This parameter can be used to determine the type of call in the area constructor. The default value CL\_SHM\_AREA=>INVOCATION\_MODE\_EXPLICIT is used for the explicit call. CL\_SHM\_AREA=>INVOCATION\_MODE\_AUTO\_BUILD is passed with the automatic call.

Exceptions

-   CX\_SHM\_BUILD\_FAILED

An error occurred when the area constructor was executed.

Note

The method BUILD does not have an input parameter for the client ID. The area is built in the current client when the method is called.

Continue
[Shared Objects - Area Constructor Class](javascript:call_link\('abenshm_area_constructor_class.htm'\))



**📖 Source**: [abenshm_if_shm_build_instance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_if_shm_build_instance.htm)

### abenshm_area_constructor_class.htm

> **📖 Official SAP Documentation**: [abenshm_area_constructor_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_area_constructor_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [Shared Objects](javascript:call_link\('abenabap_shared_objects.htm'\)) →  [Shared Objects - Classes and Interfaces](javascript:call_link\('abenshm_classes.htm'\)) →  [Shared Objects - IF\_SHM\_BUILD\_INSTANCE](javascript:call_link\('abenshm_if_shm_build_instance.htm'\)) → 

Shared Objects - Area Constructor Class

An area constructor class is a global class with a freely definable name that implements the interface [IF\_SHM\_BUILD\_INSTANCE](javascript:call_link\('abenshm_if_shm_build_instance.htm'\)). An area constructor can be implemented in the interface method BUILD.

An area constructor class can be [assigned](javascript:call_link\('abenshm_area_dynamic_properties.htm'\)) to an [area](javascript:call_link\('abenshm_areas.htm'\)) in transaction SHMA. This is always necessary if the area is built automatically by calling the area constructor, that is if the components BUILD\_KIND and REFRESH\_TIME of the structure PROPERTIES of the class [CL\_SHM\_AREA](javascript:call_link\('abenshm_cl_shm_area.htm'\)) are filled accordingly. If an area is not built automatically, an area constructor class can be specified for the explicit area constructor call using the method BUILD of the [area class](javascript:call_link\('abenshm_area_class.htm'\)).

Structure of an Area Constructor

The following structure is recommended for the area constructor implemented in the interface method BUILD:

1.  First, the area constructor has to use the method ATTACH\_FOR\_WRITE to create an area handle with an exclusive lock for the area instance passed in the parameter INST\_NAME. The automatic area constructor is also not able to ensure that the exclusive lock can be set, which means that all exceptions have to be caught and forwarded to the caller of the constructor by raising the interface exception CX\_SHM\_BUILD\_FAILED. This should pass the original exception to the parameter PREVIOUS of the constructor of CX\_SHM\_BUILD\_FAILED.
    
2.  As is the case whenever a new area instance version is created, a root object also has to be defined in the area constructor using the method SET\_ROOT.
    
3.  The area instance version can then be built, which means that objects are stored in the shared memory.
    
4.  The new area handle has to be released again using the method DETACH\_COMMIT.
    
5.  If the area constructor was called automatically, a database commit has to be triggered when a transactional area is built.

In an area constructor, no statements can be used that exit the current [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") (such as SUBMIT, CALL TRANSACTION, CALL SCREEN, MESSAGE for message types "W", "I", "E", and so on).

Example

The following implementation can be used as a template for new implementations.

CLASS area\_constructor IMPLEMENTATION.
  METHOD if\_shm\_build\_instance~build.
    DATA:
      my\_handle TYPE REF TO area
      my\_data   TYPE REF TO area\_root\_class
      my\_except TYPE REF TO cx\_root.
    TRY.
        my\_handle = cl\_my\_area=>attach\_for\_write( inst\_name ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    CREATE OBJECT my\_data AREA HANDLE my\_handle.
    my\_handle->set\_root( my\_data ).
    ... " code to build the area instance
    TRY.
        my\_handle->detach\_commit( ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    IF invocation\_mode = cl\_shm\_area=>invocation\_mode\_auto\_build.
      COMMIT CONNECTION default.
    ENDIF.
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Objects

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Classes and Interfaces / Shared Objects - IF_SHM_BUILD_INSTANCE

Included pages: 2



**📖 Source**: [abenshm_area_constructor_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_area_constructor_class.htm)

### abenshm_if_shm_build_instance.htm

> **📖 Official SAP Documentation**: [abenshm_if_shm_build_instance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_if_shm_build_instance.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [Shared Objects](javascript:call_link\('abenabap_shared_objects.htm'\)) →  [Shared Objects - Classes and Interfaces](javascript:call_link\('abenshm_classes.htm'\)) → 

Shared Objects - IF\_SHM\_BUILD\_INSTANCE

The interface IF\_SHM\_BUILD\_INSTANCE must be included by an [area constructor class](javascript:call_link\('abenshm_area_constructor_class.htm'\)) that implements the optional area constructor of an area.

Static Methods

BUILD

Interface method for implementing the area constructor of an area.

Input Parameters

-   INST\_NAME of type SHM\_INST\_NAME

Name of the area instance version. The name is optional. The default value is the value of the constant CL\_SHM\_AREA=>DEFAULT\_INSTANCE.

-   INVOCATION\_MODE of type i

This parameter can be used to determine the type of call in the area constructor. The default value CL\_SHM\_AREA=>INVOCATION\_MODE\_EXPLICIT is used for the explicit call. CL\_SHM\_AREA=>INVOCATION\_MODE\_AUTO\_BUILD is passed with the automatic call.

Exceptions

-   CX\_SHM\_BUILD\_FAILED

An error occurred when the area constructor was executed.

Note

The method BUILD does not have an input parameter for the client ID. The area is built in the current client when the method is called.

Continue
[Shared Objects - Area Constructor Class](javascript:call_link\('abenshm_area_constructor_class.htm'\))



**📖 Source**: [abenshm_if_shm_build_instance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_if_shm_build_instance.htm)

### abenshm_area_constructor_class.htm

> **📖 Official SAP Documentation**: [abenshm_area_constructor_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_area_constructor_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [Shared Objects](javascript:call_link\('abenabap_shared_objects.htm'\)) →  [Shared Objects - Classes and Interfaces](javascript:call_link\('abenshm_classes.htm'\)) →  [Shared Objects - IF\_SHM\_BUILD\_INSTANCE](javascript:call_link\('abenshm_if_shm_build_instance.htm'\)) → 

Shared Objects - Area Constructor Class

An area constructor class is a global class with a freely definable name that implements the interface [IF\_SHM\_BUILD\_INSTANCE](javascript:call_link\('abenshm_if_shm_build_instance.htm'\)). An area constructor can be implemented in the interface method BUILD.

An area constructor class can be [assigned](javascript:call_link\('abenshm_area_dynamic_properties.htm'\)) to an [area](javascript:call_link\('abenshm_areas.htm'\)) in transaction SHMA. This is always necessary if the area is built automatically by calling the area constructor, that is if the components BUILD\_KIND and REFRESH\_TIME of the structure PROPERTIES of the class [CL\_SHM\_AREA](javascript:call_link\('abenshm_cl_shm_area.htm'\)) are filled accordingly. If an area is not built automatically, an area constructor class can be specified for the explicit area constructor call using the method BUILD of the [area class](javascript:call_link\('abenshm_area_class.htm'\)).

Structure of an Area Constructor

The following structure is recommended for the area constructor implemented in the interface method BUILD:

1.  First, the area constructor has to use the method ATTACH\_FOR\_WRITE to create an area handle with an exclusive lock for the area instance passed in the parameter INST\_NAME. The automatic area constructor is also not able to ensure that the exclusive lock can be set, which means that all exceptions have to be caught and forwarded to the caller of the constructor by raising the interface exception CX\_SHM\_BUILD\_FAILED. This should pass the original exception to the parameter PREVIOUS of the constructor of CX\_SHM\_BUILD\_FAILED.
    
2.  As is the case whenever a new area instance version is created, a root object also has to be defined in the area constructor using the method SET\_ROOT.
    
3.  The area instance version can then be built, which means that objects are stored in the shared memory.
    
4.  The new area handle has to be released again using the method DETACH\_COMMIT.
    
5.  If the area constructor was called automatically, a database commit has to be triggered when a transactional area is built.

In an area constructor, no statements can be used that exit the current [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") (such as SUBMIT, CALL TRANSACTION, CALL SCREEN, MESSAGE for message types "W", "I", "E", and so on).

Example

The following implementation can be used as a template for new implementations.

CLASS area\_constructor IMPLEMENTATION.
  METHOD if\_shm\_build\_instance~build.
    DATA:
      my\_handle TYPE REF TO area
      my\_data   TYPE REF TO area\_root\_class
      my\_except TYPE REF TO cx\_root.
    TRY.
        my\_handle = cl\_my\_area=>attach\_for\_write( inst\_name ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    CREATE OBJECT my\_data AREA HANDLE my\_handle.
    my\_handle->set\_root( my\_data ).
    ... " code to build the area instance
    TRY.
        my\_handle->detach\_commit( ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    IF invocation\_mode = cl\_shm\_area=>invocation\_mode\_auto\_build.
      COMMIT CONNECTION default.
    ENDIF.
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Classes and Interfaces / Shared Objects - IF_SHM_BUILD_INSTANCE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Classes and Interfaces / Shared Objects - IF_SHM_BUILD_INSTANCE

Included pages: 2



**📖 Source**: [abenshm_area_constructor_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_area_constructor_class.htm)

### abenshm_if_shm_build_instance.htm

> **📖 Official SAP Documentation**: [abenshm_if_shm_build_instance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_if_shm_build_instance.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [Shared Objects](javascript:call_link\('abenabap_shared_objects.htm'\)) →  [Shared Objects - Classes and Interfaces](javascript:call_link\('abenshm_classes.htm'\)) → 

Shared Objects - IF\_SHM\_BUILD\_INSTANCE

The interface IF\_SHM\_BUILD\_INSTANCE must be included by an [area constructor class](javascript:call_link\('abenshm_area_constructor_class.htm'\)) that implements the optional area constructor of an area.

Static Methods

BUILD

Interface method for implementing the area constructor of an area.

Input Parameters

-   INST\_NAME of type SHM\_INST\_NAME

Name of the area instance version. The name is optional. The default value is the value of the constant CL\_SHM\_AREA=>DEFAULT\_INSTANCE.

-   INVOCATION\_MODE of type i

This parameter can be used to determine the type of call in the area constructor. The default value CL\_SHM\_AREA=>INVOCATION\_MODE\_EXPLICIT is used for the explicit call. CL\_SHM\_AREA=>INVOCATION\_MODE\_AUTO\_BUILD is passed with the automatic call.

Exceptions

-   CX\_SHM\_BUILD\_FAILED

An error occurred when the area constructor was executed.

Note

The method BUILD does not have an input parameter for the client ID. The area is built in the current client when the method is called.

Continue
[Shared Objects - Area Constructor Class](javascript:call_link\('abenshm_area_constructor_class.htm'\))



**📖 Source**: [abenshm_if_shm_build_instance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_if_shm_build_instance.htm)

### abenshm_area_constructor_class.htm

> **📖 Official SAP Documentation**: [abenshm_area_constructor_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_area_constructor_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [Shared Objects](javascript:call_link\('abenabap_shared_objects.htm'\)) →  [Shared Objects - Classes and Interfaces](javascript:call_link\('abenshm_classes.htm'\)) →  [Shared Objects - IF\_SHM\_BUILD\_INSTANCE](javascript:call_link\('abenshm_if_shm_build_instance.htm'\)) → 

Shared Objects - Area Constructor Class

An area constructor class is a global class with a freely definable name that implements the interface [IF\_SHM\_BUILD\_INSTANCE](javascript:call_link\('abenshm_if_shm_build_instance.htm'\)). An area constructor can be implemented in the interface method BUILD.

An area constructor class can be [assigned](javascript:call_link\('abenshm_area_dynamic_properties.htm'\)) to an [area](javascript:call_link\('abenshm_areas.htm'\)) in transaction SHMA. This is always necessary if the area is built automatically by calling the area constructor, that is if the components BUILD\_KIND and REFRESH\_TIME of the structure PROPERTIES of the class [CL\_SHM\_AREA](javascript:call_link\('abenshm_cl_shm_area.htm'\)) are filled accordingly. If an area is not built automatically, an area constructor class can be specified for the explicit area constructor call using the method BUILD of the [area class](javascript:call_link\('abenshm_area_class.htm'\)).

Structure of an Area Constructor

The following structure is recommended for the area constructor implemented in the interface method BUILD:

1.  First, the area constructor has to use the method ATTACH\_FOR\_WRITE to create an area handle with an exclusive lock for the area instance passed in the parameter INST\_NAME. The automatic area constructor is also not able to ensure that the exclusive lock can be set, which means that all exceptions have to be caught and forwarded to the caller of the constructor by raising the interface exception CX\_SHM\_BUILD\_FAILED. This should pass the original exception to the parameter PREVIOUS of the constructor of CX\_SHM\_BUILD\_FAILED.
    
2.  As is the case whenever a new area instance version is created, a root object also has to be defined in the area constructor using the method SET\_ROOT.
    
3.  The area instance version can then be built, which means that objects are stored in the shared memory.
    
4.  The new area handle has to be released again using the method DETACH\_COMMIT.
    
5.  If the area constructor was called automatically, a database commit has to be triggered when a transactional area is built.

In an area constructor, no statements can be used that exit the current [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") (such as SUBMIT, CALL TRANSACTION, CALL SCREEN, MESSAGE for message types "W", "I", "E", and so on).

Example

The following implementation can be used as a template for new implementations.

CLASS area\_constructor IMPLEMENTATION.
  METHOD if\_shm\_build\_instance~build.
    DATA:
      my\_handle TYPE REF TO area
      my\_data   TYPE REF TO area\_root\_class
      my\_except TYPE REF TO cx\_root.
    TRY.
        my\_handle = cl\_my\_area=>attach\_for\_write( inst\_name ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    CREATE OBJECT my\_data AREA HANDLE my\_handle.
    my\_handle->set\_root( my\_data ).
    ... " code to build the area instance
    TRY.
        my\_handle->detach\_commit( ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    IF invocation\_mode = cl\_shm\_area=>invocation\_mode\_auto\_build.
      COMMIT CONNECTION default.
    ENDIF.
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Parameters in the User Memory

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Parameters in the User Memory

Included pages: 3



**📖 Source**: [abenshm_area_constructor_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenshm_area_constructor_class.htm)

### abenmemory.htm

> **📖 Official SAP Documentation**: [abenmemory.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmemory.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) → 

Parameters in the User Memory

-   [SPA/GPA Parameters](#abenmemory-1--------spa-gpa-parameters-and-abap-programs---@ITOC@@ABENMEMORY_2)

-   [Managing SPA/GPA Parameters](#abenmemory-3--------spa-gpa-parameters-and-dynpro-fields---@ITOC@@ABENMEMORY_4)

SPA/GPA Parameters

The [user memory](javascript:call_link\('abenuser_memory_glosry.htm'\) "Glossary Entry") is a user-specific [memory area](javascript:call_link\('abenmemory_organization.htm'\)) of the current [AS Instance](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry"), which is accessed by all [ABAP sessions](javascript:call_link\('abenmain_session_glosry.htm'\) "Glossary Entry") of a user session at once. ABAP programs have access to SPA/GPA parameters stored in the user memory (also called SET/GET parameters).

Each SPA/GPA parameter is identified by an ID of up to 20 characters. SPA/GPA parameters can either be created explicitly using the statement [SET PARAMETER](javascript:call_link\('abapset_parameter.htm'\)), or implicitly in a [PAI](javascript:call_link\('abenpai_glosry.htm'\) "Glossary Entry") event. Once they have been saved in the user memory, they are available to any programs and any sessions throughout the whole duration of a user session. SPA/GPA parameters are usually evaluated by the ABAP runtime environment. In ABAP programs, the parameters can be read using the statement [GET PARAMETER](javascript:call_link\('abapget_parameter.htm'\)).

Example

One example of a program that uses SPA/GPA parameters is user maintenance (transaction SU01). In this transaction, user-specific parameters can be entered on the Parameters tab page, which are then set when the user logs on to [AS ABAP](javascript:call_link\('abensap_nw_abap_glosry.htm'\) "Glossary Entry"), and are evaluated by other programs.

SPA/GPA Parameters and ABAP Programs

The statements [SET PARAMETER](javascript:call_link\('abapset_parameter.htm'\)) and [GET PARAMETER](javascript:call_link\('abapget_parameter.htm'\)) of a program do not directly access the SPA/GPA parameters of the user memory.

-   Instead, as soon as an ABAP program is rolled in to the memory, all SPA/GPA parameters in the user memory are copied to the [program memory](javascript:call_link\('abenroll_area_glosry.htm'\) "Glossary Entry") of the program. The statements [SET PARAMETER](javascript:call_link\('abapset_parameter.htm'\)) and [GET PARAMETER](javascript:call_link\('abapget_parameter.htm'\)) of a program work with the local SPA/GPA parameters of the program memory.

-   As soon as a program is rolled out of the memory, all local SPA/GPA parameters are copied to the cross-session SAP memory, where they replace all SPA/GPA parameters. Any SPA/GPA parameters that do not exist in the program memory do not exist in the user memory afterwards. A roll out is performed for various reasons, such as:

-   When exiting a program.

-   When calling a new program using [SUBMIT](javascript:call_link\('abapsubmit.htm'\)), [CALL TRANSACTION](javascript:call_link\('abapcall_transaction.htm'\)), or [LEAVE TO TRANSACTION](javascript:call_link\('abapleave_to_transaction.htm'\)).

-   During any work process change A work process is changed in the same situations that cause implicit [database commits](javascript:call_link\('abendb_commit.htm'\)).

-   In the statement [COMMIT WORK](javascript:call_link\('abapcommit.htm'\)).

Note

ABAP programs cannot access the user memory directly. Instead, all SPA/GPA parameters have to be imported or exported implicitly at given times, just like a file. This has consequences for programs run in parallel sessions of the same user:

-   If a program sets a SPA/GPA parameter using [SET PARAMETER](javascript:call_link\('abapset_parameter.htm'\)), a program in a parallel ABAP session cannot be started until the setter program has been rolled out if it needs to access the modified parameter.

-   If a program sets a SPA/GPA parameter using [SET PARAMETER](javascript:call_link\('abapset_parameter.htm'\)) while another program in a parallel ABAP session is active, and the latter has been running longer than the setting program, these changes are overwritten when the program that has been running longer is rolled out.

Premature rollouts can be forced by statements such as [WAIT UP TO](javascript:call_link\('abapwait_up_to.htm'\)), but the fact that the state of the user memory is always determined by the program that was last rolled out creates a serious obstacle for cross-session use of SPA/GPA parameters in programs that are running in parallel. This type of programming is therefore not recommended.

Managing SPA/GPA Parameters

The names of SPA/GPA parameters are managed in the database table TPARA. In [Object Navigator](javascript:call_link\('abenobject_navigator_glosry.htm'\) "Glossary Entry") in [ABAP Workbench](javascript:call_link\('abenabap_workbench_glosry.htm'\) "Glossary Entry"), the names of SPA/GPA parameters are created (in uppercase) in the database table TPARA and are associated with packages. The database table TPARA acts as a reservation table for SPA/GPA parameters. If SPA/GPA parameters are used in a program, the name of the parameter must be contained in the PARAMID column in the database table TPARA. Care must be taken to not overwrite SPA/GPA parameters from other applications.

Note

If a name exists in the database table TPARA, this does not automatically mean that the corresponding parameter also exists in the user memory. SPA/GPA parameters are created only during the execution of ABAP programs.

SPA/GPA Parameters and Dynpro Fields

When defining input fields, [dynpro fields](javascript:call_link\('abendynpro_field_glosry.htm'\) "Glossary Entry") can be associated with SPA/GPA parameters by entering the name of an SPA/GPA parameter from the database table TPARA as an attribute PARAMETER ID. If the corresponding parameter GET PARAMETER is set and no other value is assigned to the input field, the input field is filled with the value of the SPA/GPA parameter when the [screen](javascript:call_link\('abenscreen_glosry.htm'\) "Glossary Entry") is sent. If the corresponding attribute SET PARAMETER is set, the content of the input field is assigned to the SPA/GPA parameter at the PAI event. If the parameter does not yet exist in the user memory, it is created implicitly in the PAI event. In [selection screens](javascript:call_link\('abenselection_screen_glosry.htm'\) "Glossary Entry"), this association can be created using the addition MEMORY ID of the statements [PARAMETERS](javascript:call_link\('abapparameters_value.htm'\)) and [SELECT-OPTIONS](javascript:call_link\('abapselect-options_value.htm'\)).

Notes

-   A data transport between a dynpro field and an SPA/GPA parameter in the user memory only takes place if a global data object with the same name as the dynpro field is declared in the corresponding ABAP program.

-   If the PAI event is raised using a function of type "E", no values are assigned to the SPA/GPA parameters associated with the dynpro and no parameters are created in the user memory.

Continue
[SET PARAMETER](javascript:call_link\('abapset_parameter.htm'\))
[GET PARAMETER](javascript:call_link\('abapget_parameter.htm'\))



**📖 Source**: [abenmemory.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmemory.htm)

### abapset_parameter.htm

> **📖 Official SAP Documentation**: [abapset_parameter.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_parameter.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [Parameters in the User Memory](javascript:call_link\('abenmemory.htm'\)) → 

SET PARAMETER

[Quick Reference](javascript:call_link\('abapset_parameter_shortref.htm'\))

Syntax

SET PARAMETER ID pid FIELD dobj.

Effect

This statement sets the content of the [SPA/GPA](javascript:call_link\('abenspa_gpa_parameter_1_glosry.htm'\) "Glossary Entry") parameter specified in pid [user memory](javascript:call_link\('abenuser_memory_glosry.htm'\) "Glossary Entry") to the content of the data object dobj. The ID pid must be a [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like field that contains no more than 20 characters and does not consist solely of blanks. pid is case-sensitive. dobj expects a flat character-like field whose binary content is passed in an unconverted format.

The statement SET PARAMETER does not access the user memory directly. Instead, it accesses a local mapping of the SPA/GPA parameter in the [program memory](javascript:call_link\('abenroll_area_glosry.htm'\) "Glossary Entry"), which is loaded when rolled in and saved in the user memory when rolled out (see [SPA/GPA Parameters and ABAP Programs](javascript:call_link\('abenmemory.htm'\))). If the SPA/GPA parameter specified for the current user in pid does not yet exist in the [user memory](javascript:call_link\('abenuser_memory_glosry.htm'\) "Glossary Entry"), it is created. If the SPA/GPA parameter has already been created for the current user, its value is overwritten.

In a program, SPA/GPA parameters can only be created or assigned values if a name exists for them in the table TPARA. If it is known statically that an ID pid is not in the database table TPARA, the extended program check reports an error.

Notes

-   An SPA/GPA parameter specified in pid must be entered in uppercase to match a name in the database table TPARA.
    
-   The statements SET PARAMETER and GET PARAMETER do not work directly with the SPA/GPA parameters of the user memory, which means that they are only suitable for passing data within a single [ABAP session](javascript:call_link\('abenmain_session_glosry.htm'\) "Glossary Entry") and not for passing data between two main sessions in parallel. This is because programs that run in parallel can change the state of the parameters unpredictably.
    

Example

If the user selects a flight displayed in the basic list, the SPA/GPA parameters CAR and CON are set to the ID of the airline and the number of the connection at the event AT LINE-SELECTION. The names of both parameters are defined in the table TPARA for this purpose. In the initial [dynpro](javascript:call_link\('abendynpro_glosry.htm'\) "Glossary Entry") of the transaction DEMO\_TRANSACTION, two input fields are associated with these SPA/GPA parameters and are displayed with the selected values as [start values](javascript:call_link\('abenstart_value_glosry.htm'\) "Glossary Entry").

DATA: carrier     TYPE spfli-carrid,
      connection  TYPE spfli-connid.
START-OF-SELECTION.
  SELECT carrid, connid
         FROM spfli
         INTO (@carrier, @connection).
    WRITE: / carrier HOTSPOT, connection HOTSPOT.
    HIDE:  carrier, connection.
  ENDSELECT.
AT LINE-SELECTION.
  SET PARAMETER ID: 'CAR' FIELD carrier,
                    'CON' FIELD connection.
  CALL TRANSACTION 'DEMO\_TRANSACTION'.

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Non-Handleable Exceptions

-   Cause:: Key only contains blank characters
    Runtime error: SET\_PARAMETER\_ID\_SPACE
    
-   Cause: Key is longer than 20 characters
    Runtime error: SET\_PARAMETER\_ID\_TOO\_LONG
    
-   Cause: Value is longer than 255 characters
    Runtime error: SET\_PARAMETER\_VALUE\_TOO\_LONG
    
-   Cause: Memory limit of the user memory was reached
    Runtime error: SET\_PARAMETER\_MEMORY\_OVERFLOW



**📖 Source**: [abapset_parameter.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_parameter.htm)

### abapget_parameter.htm

> **📖 Official SAP Documentation**: [abapget_parameter.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_parameter.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Creating Objects and Values](javascript:call_link\('abencreate_objects.htm'\)) →  [Parameters in the User Memory](javascript:call_link\('abenmemory.htm'\)) → 

GET PARAMETER

[Quick Reference](javascript:call_link\('abapget_parameter_shortref.htm'\))

Syntax

GET PARAMETER ID pid FIELD dobj.

Effect

This statement sets the content of the data object dobj to the content of the [SPA/GPA](javascript:call_link\('abenspa_gpa_parameter_1_glosry.htm'\) "Glossary Entry") parameter specified in pid in the [user memory](javascript:call_link\('abenuser_memory_glosry.htm'\) "Glossary Entry"). The ID pid must be a [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like field that contains no more than 20 characters and does not consist solely of blanks. The field is case-sensitive. The binary content of the SPA/GPA parameter is passed to dobj without being converted. The following can be specified for dobj:

-   An existing flat character-like variable.
    
-   An inline declaration [DATA(var)](javascript:call_link\('abendata_inline.htm'\)), where a variable of type XUVALUE is declared.
    

The statement GET PARAMETER does not access the user memory directly. Instead, it accesses a local mapping of the SPA/GPA parameter in the [program memory](javascript:call_link\('abenroll_area_glosry.htm'\) "Glossary Entry"), which is loaded when rolled in and saved in the user memory when rolled out (see [SPA/GPA Parameters and ABAP Programs](javascript:call_link\('abenmemory.htm'\))). If the SPA/GPA parameter specified in pid does not yet exist in the [user memory](javascript:call_link\('abenuser_memory_glosry.htm'\) "Glossary Entry") for the current user, the data object dobj is initialized and sy-subrc is set to 4.

A program can only read those SPA/GPA parameters for which there is a name in the table TPARA. If it is known statically that an ID pid is not in the database table TPARA, the extended program check reports an error.

System Fields

sy-subrc

Meaning

0

The SPA/GPA parameter specified in pid exists for the current user in the user memory and its value was passed to the target field.

4

The SPA/GPA parameter specified in pid does not exist for the current user in the user memory.

Notes

-   An SPA/GPA parameter that is readable using GET PARAMETER can either have been created previously in the user memory using the statement [SET PARAMETER](javascript:call_link\('abapset_parameter.htm'\)) or created automatically in the [PAI](javascript:call_link\('abenpai_glosry.htm'\) "Glossary Entry") event of a [dynpro](javascript:call_link\('abendynpro_glosry.htm'\) "Glossary Entry") or [selection screen](javascript:call_link\('abenselection_screen_glosry.htm'\) "Glossary Entry").
    
-   An SPA/GPA parameter specified in pid must be entered in uppercase to match a name in the database table TPARA.
    
-   The statements SET PARAMETER and GET PARAMETER do not work directly with the SPA/GPA parameters of the user memory, which means that they are only suitable for passing data within a single [ABAP session](javascript:call_link\('abenmain_session_glosry.htm'\) "Glossary Entry") and not for passing data between two main sessions in parallel. This is because programs that run in parallel can change the state of the parameters unpredictably.
    

Example

In this example, the current value of the SPA/GPA parameter RID is read from the user memory to the data object prog. In the dynpros in [ABAP Workbench](javascript:call_link\('abenabap_workbench_glosry.htm'\) "Glossary Entry"), this parameter is associated with the input fields for a program name. When an ABAP Workbench tool in which an ABAP program is processed, is first called, the parameter is created in the event PAI and assigned the name of the program specified there. If, in the same user session, no dynpro is processed that sets the parameter RID and no corresponding SET PARAMETER statement was executed beforehand, RID is not found in the user memory.

DATA: para TYPE tpara-paramid VALUE 'RID',
      prog TYPE sy-repid.
GET PARAMETER ID para FIELD prog.
IF sy-subrc <> 0.
  MESSAGE 'Parameter not found' TYPE 'I'.
ENDIF.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Expressions and Functions for Conditions / log_exp - Logical Expressions / rel_exp - Comparison Expressions / rel_exp - Comparison Rules / rel_exp - Comparing Elementary Data Types / rel_exp - Comparison Type of Elementary Data Objects

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Expressions and Functions for Conditions / Logical Functions

Included pages: 2



**📖 Source**: [abapget_parameter.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_parameter.htm)

### abenlogic_functions.htm

> **📖 Official SAP Documentation**: [abenlogic_functions.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlogic_functions.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Expressions and Functions for Conditions](javascript:call_link\('abenlogical_expr_func.htm'\)) → 

Logical Functions

Logical functions are a type of [built-in function](javascript:call_link\('abenbuilt_in_functions.htm'\)). They are divided into:

-   [Boolean functions](javascript:call_link\('abenboole_functions.htm'\))

-   [Predicate functions](javascript:call_link\('abenpredicate_functions.htm'\))

Note

The program DEMO\_EXPRESSIONS shows examples of how to use logical functions.

Continue
[boolc, boolx, xsdbool - Boolean Functions](javascript:call_link\('abenboole_functions.htm'\))



**📖 Source**: [abenlogic_functions.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlogic_functions.htm)

### abenboole_functions.htm

> **📖 Official SAP Documentation**: [abenboole_functions.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenboole_functions.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Expressions and Functions for Conditions](javascript:call_link\('abenlogical_expr_func.htm'\)) →  [Logical Functions](javascript:call_link\('abenlogic_functions.htm'\)) → 

boolc, boolx, xsdbool - Boolean Functions

Variants:

[1\. ... boolc( log\_exp ) ...](#!ABAP_VARIANT_1@1@)
[2\. ... boolx( bool = log\_exp bit = bit ) ...](#!ABAP_VARIANT_2@2@)
[3\. ... xsdbool( log\_exp ) ...](#!ABAP_VARIANT_3@3@)

Effect

The Boolean functions determine the [truth value](javascript:call_link\('abenlogical_value_glosry.htm'\) "Glossary Entry") of a logical expression [log\_exp](javascript:call_link\('abenlogexp.htm'\)) specified as an argument. For log\_exp, any logical expression can be specified in accordance with the applicable rules. The return value of a Boolean function has a data type determined by the function and expresses the truth value of the logical expression using a value of this type.

Note

These functions can be viewed as a partial replacement for the Boolean data type for truth values not available in ABAP. In particular, xsdbool and (with restrictions) boolc can be used in many operand positions where input parameters of the type abap\_bool of the type group ABAP are expected.

Variant 1

... boolc( log\_exp ) ...

Effect

The function boolc returns a single-character character string of the type string. If the logical expression is true, "X" is returned. If the logical expression is false, a blank is returned. In principle, boolc is one of the [processing functions with character-like results](javascript:call_link\('abenprocess_functions.htm'\)) and can be specified in [general expression positions](javascript:call_link\('abengeneral_expr_position_glosry.htm'\) "Glossary Entry") and in [character-like expression positions](javascript:call_link\('abencharlike_expr_position_glosry.htm'\) "Glossary Entry").

Notes

-   If boolc requires return values other than "X" or " " (for example, "Y" and "N" or "1" and "0"), the result of boolc can be edited directly using the function [translate](javascript:call_link\('abentranslate_functions.htm'\)) or another suitable [processing function](javascript:call_link\('abenprocess_functions.htm'\)).

-   The result of boolc must not be compared with the constants abap\_true and abap\_false in relational expressions, since the comparison converts the latter from c to string and ignores any blanks. Comparisons of this type are not usually necessary. If a comparison of this type is required anyway, the function xsdbool can be used instead of boolc. The result of this function has the same ABAP type as abap\_bool.

-   If the logical expression is false, the result of boolc does not meet the condition [IS INITIAL](javascript:call_link\('abenlogexp_initial.htm'\)), since a blank is returned (not an empty string). If this is the required behavior, the function xsdbool can be used instead of boolc.

-   If boolc is used in inappropriate places (as specified in the points above), a syntax warning is produced (which can be hidden using a pragma).

Example

The value 0, 1, or 2 is assigned to the variable bool\_value, depending on the result of the logical expressions log\_exp1 and log\_exp2.

DATA bool\_value TYPE i.
bool\_value = strlen( condense( val = boolc( log\_exp1 ) ) ) +
             strlen( condense( val = boolc( log\_exp2 ) ) ).

Example

Calls a method, where the input parameter no\_dialog is supplied with the character-like representation of the results of a predicate expression.

PARAMETERS word TYPE c length 30.
DATA result\_tab TYPE cl\_abap\_docu=>search\_results.
cl\_abap\_docu=>start(
  EXPORTING word           = word
            no\_dialog      = boolc( sy-batch IS NOT INITIAL )
  IMPORTING search\_results = result\_tab ).

Variant 2

... boolx( bool = log\_exp bit = bit ) ...

Effect

The function boolx returns a byte chain of the type xstring. If the logical expression is true, the byte chain is filled as if the function [bit-set( bit )](javascript:call_link\('abenbit_functions.htm'\)) were being executed. If the logical expression is false, the byte chain is filled as if the function [bit-set( 0 )](javascript:call_link\('abenbit_functions.htm'\)) were being executed. bit expects a data object of the type i. In principle, boolx is one of the [bit functions](javascript:call_link\('abenbit_functions.htm'\)) and can be used in all positions where a [bit expression](javascript:call_link\('abenbit_expression_glosry.htm'\) "Glossary Entry") is also allowed.

Note

The function boolx can be used for efficient saving of sequences of truth values.

Example

The result of the following [bit expression](javascript:call_link\('abenbit_expression_glosry.htm'\) "Glossary Entry") is hexadecimal 55, the same as the calculated bit string 01010101.

DATA(result) = boolx( bool = 2 > 1 bit = 8 )
        BIT-OR boolx( bool = 2 < 1 bit = 7 )
        BIT-OR boolx( bool = 2 > 1 bit = 6 )
        BIT-OR boolx( bool = 2 < 1 bit = 5 )
        BIT-OR boolx( bool = 2 > 1 bit = 4 )
        BIT-OR boolx( bool = 2 < 1 bit = 3 )
        BIT-OR boolx( bool = 2 > 1 bit = 2 )
        BIT-OR boolx( bool = 2 < 1 bit = 1 ).

The bit expression above can be expressed using the following iteration with the operator [REDUCE](javascript:call_link\('abenconstructor_expression_reduce.htm'\)).

DATA(result) =
  REDUCE xstring( INIT x TYPE xstring
                  FOR j = 4 THEN j - 1 UNTIL j < 1
                  LET b1 = 2 \* j b2 = 2 \* j - 2 IN
                  NEXT x = x BIT-OR boolx( bool = 2 > 1  bit = b1 )
                             BIT-OR boolx( bool = 2 < 1  bit = b2 ) ).

Variant 3

... xsdbool( log\_exp ) ...

Effect

Like boolc, the function xsdbool returns the value "X" for true and a blank for false. The data type of the return value, however, has the type c of the length 1 here.

The return value references the type XSDBOOLEAN from ABAP Dictionary. This type (which references the identically named domain with the type CHAR and length 1) is handled like a real Boolean type in serializations and deserializations to or from [asXML](javascript:call_link\('abenabap_xslt_asxml_schema.htm'\)) and [asJSON](javascript:call_link\('abenabap_asjson_schema.htm'\)) using [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)). The XML or JSON values true and false are assigned to the values "X" and " " of this type.

xsdbool can be specified in [general](javascript:call_link\('abengeneral_expr_position_glosry.htm'\) "Glossary Entry") and [character-like expression positions](javascript:call_link\('abencharlike_expr_position_glosry.htm'\) "Glossary Entry").

Notes

-   The result of xsdbool can be used like a value of the type abap\_bool and compared with the constants abap\_true and abap\_false.

-   If the logical expression is false, the result of boolc meets the condition [IS INITIAL](javascript:call_link\('abenlogexp_initial.htm'\)), since the returned blank is the type-dependent initial value too.

-   The result of xsdbool cannot usually be implemented directly using a [processing function](javascript:call_link\('abenprocess_functions.htm'\)) such as [translate](javascript:call_link\('abentranslate_functions.htm'\)), since the trailing blanks here are ignored in text fields with the type c. The result of a false logical expression would be ignored. The result of the function boolc with the type string is better suited to transformations of this type.

-   The abbreviation xsd stands for [XML schema data](http://www.w3.org/tr/xmlschema-2/) types.

Example

This example sets the type and the value of the variable gui\_flag declared inline using the Boolean function xsdbool. A [predicative method call](javascript:call_link\('abenpredicative_method_call_glosry.htm'\) "Glossary Entry") is specified as the argument of this function. The variable is then serialized to [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") using the predefined [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") [ID](javascript:call_link\('abenabap_xslt_id.htm'\)). This produces the value true or false. After being compared with the identically typed constant abap\_false, the result of the serializations is either read or displayed.

The result would be very different if boolc were used instead of xsdbool. Firstly, the transformations would have a different result (since the values "X" and " " are not transformed to true or false); secondly, the logical expression gui\_flag = abap\_false would always be false (since abap\_false loses its blank when converted to the type string).

DATA(gui\_flag) = xsdbool( cl\_demo\_sap\_gui=>check( ) ).
CALL TRANSFORMATION id SOURCE gui\_flag = gui\_flag
                       RESULT XML DATA(xml).
DATA(writer) =
  cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_json ).
CALL TRANSFORMATION id SOURCE gui\_flag = gui\_flag
                       RESULT XML writer.
DATA(json) = writer->get\_output( ).
cl\_demo\_output=>write\_xml( xml ).
cl\_demo\_output=>write\_json( json ).
IF gui\_flag = abap\_false.
  cl\_demo\_output=>get( ).
ELSE.
  cl\_demo\_output=>display( ).
ENDIF.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Exception Classes

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

Included pages: 4



**📖 Source**: [abenboole_functions.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenboole_functions.htm)

### abenexception_abexas.htm

> **📖 Official SAP Documentation**: [abenexception_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexception_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) → 

Examples of Exceptions

Continue
![Example](exa.gif "Example") [Exceptions, RAISE](javascript:call_link\('abenraise_abexa.htm'\))
![Example](exa.gif "Example") [Exceptions, TRY](javascript:call_link\('abentry_abexa.htm'\))
![Example](exa.gif "Example") [Exceptions, CATCH](javascript:call_link\('abencatch_exception_abexa.htm'\))



**📖 Source**: [abenexception_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexception_abexas.htm)

### abenraise_abexa.htm

> **📖 Official SAP Documentation**: [abenraise_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, RAISE

This example demonstrates the statement RAISE EXCEPTION.

Source Code

REPORT demo\_raise\_exception.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: oref    TYPE REF TO cx\_demo\_constructor,
          text     TYPE string,
          position TYPE i.
    TRY.
        TRY.
            RAISE EXCEPTION TYPE cx\_demo\_constructor
              EXPORTING
                my\_text = sy-repid.
          CATCH cx\_demo\_constructor INTO oref.
            text = oref->get\_text( ).
            oref->get\_source\_position(
              IMPORTING  source\_line  = position ).
            cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
            RAISE EXCEPTION oref.
        ENDTRY.
      CATCH cx\_demo\_constructor INTO oref.
        text = oref->get\_text( ).
        oref->get\_source\_position(
          IMPORTING source\_line  = position ).
        cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
    ENDTRY.
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the two variants of the statement RAISE EXCEPTION. The first statement raises an exception of the class CX\_DEMO\_CONSTRUCTOR in the inner TRY block, creates the relevant object, and passes the program name to the instance constructor. The inner CATCH block handles the exception, provides the exception text, and raises the exception again without creating a new object. The outer CATCH block handles the exception again. The CX\_DEMO\_CONSTRUCTOR class is defined in such a way that the passed program name appears in the exception text. The generated instance constructor takes care of this.

The line number in which the exception was raised is shown to indicate that, when the existing exception object was reused, information relevant to this object was modified.



**📖 Source**: [abenraise_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_abexa.htm)

### abentry_abexa.htm

> **📖 Official SAP Documentation**: [abentry_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentry_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, TRY

This example demonstrates the TRY control structure.

Source Code

REPORT demo\_try.
CLASS try\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2,
                oref   TYPE REF TO cx\_root,
                text   TYPE string.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA number TYPE i.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS calculation
      IMPORTING  p\_number LIKE number
      CHANGING p\_result LIKE result
               p\_text   LIKE text
      RAISING  cx\_sy\_arithmetic\_error.
ENDCLASS.
CLASS try\_demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_input=>request( CHANGING field = number ).
    out = cl\_demo\_output=>new( ).
    TRY.
        IF abs( number ) > 100.
          RAISE EXCEPTION TYPE cx\_demo\_abs\_too\_large.
        ENDIF.
        calculation( EXPORTING p\_number = number
                     CHANGING  p\_result = result
                               p\_text   = text ).
      CATCH cx\_sy\_arithmetic\_error INTO oref.
        text = oref->get\_text( ).
      CATCH cx\_root INTO oref.
        text = oref->get\_text( ).
    ENDTRY.
    IF NOT text IS INITIAL.
      out->write( text ).
    ENDIF.
    out->display( |Final result: { result ALIGN = LEFT }| ).
  ENDMETHOD.
  METHOD calculation.
    DATA l\_oref TYPE REF TO cx\_root.
    TRY.
        p\_result =  1 / p\_number.
        out->write(
          |Result of division: { p\_result ALIGN = LEFT }| ).
        p\_result = sqrt( p\_number ).
        out->write(
          |Result of square root: { p\_result ALIGN = LEFT }| ).
      CATCH cx\_sy\_zerodivide INTO l\_oref.
        p\_text = l\_oref->get\_text( ).
      CLEANUP.
        CLEAR p\_result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  try\_demo=>main( ).

Description

-   If the content of number is greater than 100, the TRY control structure of the [master program](javascript:call_link\('abenframe_program_glosry.htm'\) "Glossary Entry") raises an exception of the class CX\_DEMO\_ABS\_TOO\_LARGE in the TRY block. This exception is handled by the second CATCH block of the same TRY control structure, since the subclass of the most general exception is CX\_ROOT.

-   If the content of number is 0, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ZERODIVIDE. This is handled in the CATCH block of the same TRY control structure.

-   If the content of number is a negative number, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ARG\_OUT\_OF\_DOMAIN. Since there is no handler defined for this exception in this TRY control structure, the exception is propagated from the method. This is made possible by the declaration of the superclass CX\_SY\_ARITHMETIC\_ERROR using RAISING in the method interface. The CLEANUP block of the inner TRY control structure is executed first.

-   Any other exceptions are handled in the final CATCH block of the TRY control structure of the master program. This block catches all possible exceptions by specifying the most general exception class, CX\_ROOT. If, for example, CX\_SY\_ARG\_OUT\_OF\_DOMAIN or one of its superclasses is not declared in the method interface, the exception CX\_SY\_NO\_HANDLER would be raised and would be handled in the final CATCH block.



**📖 Source**: [abentry_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentry_abexa.htm)

### abencatch_exception_abexa.htm

> **📖 Official SAP Documentation**: [abencatch_exception_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencatch_exception_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, CATCH

This example demonstrates how class-based exceptions are caught.

Source Code

REPORT demo\_catch\_exception.
DATA(in) = cl\_demo\_input=>new( ).
DATA: resumable     TYPE abap\_bool VALUE abap\_false,
      before\_unwind TYPE abap\_bool VALUE abap\_false,
      resume        TYPE abap\_bool VALUE abap\_false.
in->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RAISE RESUMABLE'
               CHANGING  field = resumable
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'CATCH BEFORE UNWIND'
               CHANGING  field = before\_unwind
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RESUME'
               CHANGING  field = resume
)->request( ).
CLASS lcx\_exception DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS exc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS: main,
      meth1 RAISING lcx\_exception,
      meth2 RAISING RESUMABLE(lcx\_exception).
ENDCLASS.
FIELD-SYMBOLS <fs> TYPE any.
CLASS exc\_demo IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    DATA exc TYPE REF TO lcx\_exception.
    IF before\_unwind = abap\_false.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH lcx\_exception.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ELSEIF before\_unwind = abap\_true.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH BEFORE UNWIND lcx\_exception INTO exc.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
          IF resume = abap\_true.
            IF exc->is\_resumable = abap\_true.
              RESUME.
            ELSE.
              out->write( 'Resumption not possible' ).
            ENDIF.
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ENDIF.
    out->display( ).
  ENDMETHOD.
  METHOD meth1.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising non-resumable exception' ).
        RAISE EXCEPTION TYPE lcx\_exception.
        out->write( 'Never executed' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
  METHOD meth2.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising resumable exception' ).
        RAISE RESUMABLE EXCEPTION TYPE lcx\_exception.
        out->write( 'Resuming method' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  exc\_demo=>main( ).

Description

The method meth1 raises a non-resumable exception and the method meth2 raises a resumable exception that is handled in the TRY control structures of the method main using CATCH.

-   If handled without BEFORE UNWIND, the CLEANUP block is executed in both cases before handling and the context of the called method does not exist during handling.

-   If handled with BEFORE UNWIND, the context of the called method exists in both cases during handling and the CLEANUP block is executed after handling.

-   When a resumable exception is raised, the statement RESUME can be executed during handling. This statement makes sure that processing in the called method is continued without its CLEANUP block being executed.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / System Response after a Class-Based Exception

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

Included pages: 4



**📖 Source**: [abencatch_exception_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencatch_exception_abexa.htm)

### abenexception_abexas.htm

> **📖 Official SAP Documentation**: [abenexception_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexception_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) → 

Examples of Exceptions

Continue
![Example](exa.gif "Example") [Exceptions, RAISE](javascript:call_link\('abenraise_abexa.htm'\))
![Example](exa.gif "Example") [Exceptions, TRY](javascript:call_link\('abentry_abexa.htm'\))
![Example](exa.gif "Example") [Exceptions, CATCH](javascript:call_link\('abencatch_exception_abexa.htm'\))



**📖 Source**: [abenexception_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexception_abexas.htm)

### abenraise_abexa.htm

> **📖 Official SAP Documentation**: [abenraise_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, RAISE

This example demonstrates the statement RAISE EXCEPTION.

Source Code

REPORT demo\_raise\_exception.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: oref    TYPE REF TO cx\_demo\_constructor,
          text     TYPE string,
          position TYPE i.
    TRY.
        TRY.
            RAISE EXCEPTION TYPE cx\_demo\_constructor
              EXPORTING
                my\_text = sy-repid.
          CATCH cx\_demo\_constructor INTO oref.
            text = oref->get\_text( ).
            oref->get\_source\_position(
              IMPORTING  source\_line  = position ).
            cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
            RAISE EXCEPTION oref.
        ENDTRY.
      CATCH cx\_demo\_constructor INTO oref.
        text = oref->get\_text( ).
        oref->get\_source\_position(
          IMPORTING source\_line  = position ).
        cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
    ENDTRY.
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the two variants of the statement RAISE EXCEPTION. The first statement raises an exception of the class CX\_DEMO\_CONSTRUCTOR in the inner TRY block, creates the relevant object, and passes the program name to the instance constructor. The inner CATCH block handles the exception, provides the exception text, and raises the exception again without creating a new object. The outer CATCH block handles the exception again. The CX\_DEMO\_CONSTRUCTOR class is defined in such a way that the passed program name appears in the exception text. The generated instance constructor takes care of this.

The line number in which the exception was raised is shown to indicate that, when the existing exception object was reused, information relevant to this object was modified.



**📖 Source**: [abenraise_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_abexa.htm)

### abentry_abexa.htm

> **📖 Official SAP Documentation**: [abentry_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentry_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, TRY

This example demonstrates the TRY control structure.

Source Code

REPORT demo\_try.
CLASS try\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2,
                oref   TYPE REF TO cx\_root,
                text   TYPE string.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA number TYPE i.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS calculation
      IMPORTING  p\_number LIKE number
      CHANGING p\_result LIKE result
               p\_text   LIKE text
      RAISING  cx\_sy\_arithmetic\_error.
ENDCLASS.
CLASS try\_demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_input=>request( CHANGING field = number ).
    out = cl\_demo\_output=>new( ).
    TRY.
        IF abs( number ) > 100.
          RAISE EXCEPTION TYPE cx\_demo\_abs\_too\_large.
        ENDIF.
        calculation( EXPORTING p\_number = number
                     CHANGING  p\_result = result
                               p\_text   = text ).
      CATCH cx\_sy\_arithmetic\_error INTO oref.
        text = oref->get\_text( ).
      CATCH cx\_root INTO oref.
        text = oref->get\_text( ).
    ENDTRY.
    IF NOT text IS INITIAL.
      out->write( text ).
    ENDIF.
    out->display( |Final result: { result ALIGN = LEFT }| ).
  ENDMETHOD.
  METHOD calculation.
    DATA l\_oref TYPE REF TO cx\_root.
    TRY.
        p\_result =  1 / p\_number.
        out->write(
          |Result of division: { p\_result ALIGN = LEFT }| ).
        p\_result = sqrt( p\_number ).
        out->write(
          |Result of square root: { p\_result ALIGN = LEFT }| ).
      CATCH cx\_sy\_zerodivide INTO l\_oref.
        p\_text = l\_oref->get\_text( ).
      CLEANUP.
        CLEAR p\_result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  try\_demo=>main( ).

Description

-   If the content of number is greater than 100, the TRY control structure of the [master program](javascript:call_link\('abenframe_program_glosry.htm'\) "Glossary Entry") raises an exception of the class CX\_DEMO\_ABS\_TOO\_LARGE in the TRY block. This exception is handled by the second CATCH block of the same TRY control structure, since the subclass of the most general exception is CX\_ROOT.

-   If the content of number is 0, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ZERODIVIDE. This is handled in the CATCH block of the same TRY control structure.

-   If the content of number is a negative number, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ARG\_OUT\_OF\_DOMAIN. Since there is no handler defined for this exception in this TRY control structure, the exception is propagated from the method. This is made possible by the declaration of the superclass CX\_SY\_ARITHMETIC\_ERROR using RAISING in the method interface. The CLEANUP block of the inner TRY control structure is executed first.

-   Any other exceptions are handled in the final CATCH block of the TRY control structure of the master program. This block catches all possible exceptions by specifying the most general exception class, CX\_ROOT. If, for example, CX\_SY\_ARG\_OUT\_OF\_DOMAIN or one of its superclasses is not declared in the method interface, the exception CX\_SY\_NO\_HANDLER would be raised and would be handled in the final CATCH block.



**📖 Source**: [abentry_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentry_abexa.htm)

### abencatch_exception_abexa.htm

> **📖 Official SAP Documentation**: [abencatch_exception_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencatch_exception_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, CATCH

This example demonstrates how class-based exceptions are caught.

Source Code

REPORT demo\_catch\_exception.
DATA(in) = cl\_demo\_input=>new( ).
DATA: resumable     TYPE abap\_bool VALUE abap\_false,
      before\_unwind TYPE abap\_bool VALUE abap\_false,
      resume        TYPE abap\_bool VALUE abap\_false.
in->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RAISE RESUMABLE'
               CHANGING  field = resumable
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'CATCH BEFORE UNWIND'
               CHANGING  field = before\_unwind
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RESUME'
               CHANGING  field = resume
)->request( ).
CLASS lcx\_exception DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS exc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS: main,
      meth1 RAISING lcx\_exception,
      meth2 RAISING RESUMABLE(lcx\_exception).
ENDCLASS.
FIELD-SYMBOLS <fs> TYPE any.
CLASS exc\_demo IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    DATA exc TYPE REF TO lcx\_exception.
    IF before\_unwind = abap\_false.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH lcx\_exception.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ELSEIF before\_unwind = abap\_true.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH BEFORE UNWIND lcx\_exception INTO exc.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
          IF resume = abap\_true.
            IF exc->is\_resumable = abap\_true.
              RESUME.
            ELSE.
              out->write( 'Resumption not possible' ).
            ENDIF.
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ENDIF.
    out->display( ).
  ENDMETHOD.
  METHOD meth1.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising non-resumable exception' ).
        RAISE EXCEPTION TYPE lcx\_exception.
        out->write( 'Never executed' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
  METHOD meth2.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising resumable exception' ).
        RAISE RESUMABLE EXCEPTION TYPE lcx\_exception.
        out->write( 'Resuming method' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  exc\_demo=>main( ).

Description

The method meth1 raises a non-resumable exception and the method meth2 raises a resumable exception that is handled in the TRY control structures of the method main using CATCH.

-   If handled without BEFORE UNWIND, the CLEANUP block is executed in both cases before handling and the context of the called method does not exist during handling.

-   If handled with BEFORE UNWIND, the context of the called method exists in both cases during handling and the CLEANUP block is executed after handling.

-   When a resumable exception is raised, the statement RESUME can be executed during handling. This statement makes sure that processing in the called method is continued without its CLEANUP block being executed.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / RAISE EXCEPTION

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

Included pages: 4



**📖 Source**: [abencatch_exception_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencatch_exception_abexa.htm)

### abenexception_abexas.htm

> **📖 Official SAP Documentation**: [abenexception_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexception_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) → 

Examples of Exceptions

Continue
![Example](exa.gif "Example") [Exceptions, RAISE](javascript:call_link\('abenraise_abexa.htm'\))
![Example](exa.gif "Example") [Exceptions, TRY](javascript:call_link\('abentry_abexa.htm'\))
![Example](exa.gif "Example") [Exceptions, CATCH](javascript:call_link\('abencatch_exception_abexa.htm'\))



**📖 Source**: [abenexception_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexception_abexas.htm)

### abenraise_abexa.htm

> **📖 Official SAP Documentation**: [abenraise_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, RAISE

This example demonstrates the statement RAISE EXCEPTION.

Source Code

REPORT demo\_raise\_exception.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: oref    TYPE REF TO cx\_demo\_constructor,
          text     TYPE string,
          position TYPE i.
    TRY.
        TRY.
            RAISE EXCEPTION TYPE cx\_demo\_constructor
              EXPORTING
                my\_text = sy-repid.
          CATCH cx\_demo\_constructor INTO oref.
            text = oref->get\_text( ).
            oref->get\_source\_position(
              IMPORTING  source\_line  = position ).
            cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
            RAISE EXCEPTION oref.
        ENDTRY.
      CATCH cx\_demo\_constructor INTO oref.
        text = oref->get\_text( ).
        oref->get\_source\_position(
          IMPORTING source\_line  = position ).
        cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
    ENDTRY.
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the two variants of the statement RAISE EXCEPTION. The first statement raises an exception of the class CX\_DEMO\_CONSTRUCTOR in the inner TRY block, creates the relevant object, and passes the program name to the instance constructor. The inner CATCH block handles the exception, provides the exception text, and raises the exception again without creating a new object. The outer CATCH block handles the exception again. The CX\_DEMO\_CONSTRUCTOR class is defined in such a way that the passed program name appears in the exception text. The generated instance constructor takes care of this.

The line number in which the exception was raised is shown to indicate that, when the existing exception object was reused, information relevant to this object was modified.



**📖 Source**: [abenraise_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_abexa.htm)

### abentry_abexa.htm

> **📖 Official SAP Documentation**: [abentry_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentry_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, TRY

This example demonstrates the TRY control structure.

Source Code

REPORT demo\_try.
CLASS try\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2,
                oref   TYPE REF TO cx\_root,
                text   TYPE string.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA number TYPE i.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS calculation
      IMPORTING  p\_number LIKE number
      CHANGING p\_result LIKE result
               p\_text   LIKE text
      RAISING  cx\_sy\_arithmetic\_error.
ENDCLASS.
CLASS try\_demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_input=>request( CHANGING field = number ).
    out = cl\_demo\_output=>new( ).
    TRY.
        IF abs( number ) > 100.
          RAISE EXCEPTION TYPE cx\_demo\_abs\_too\_large.
        ENDIF.
        calculation( EXPORTING p\_number = number
                     CHANGING  p\_result = result
                               p\_text   = text ).
      CATCH cx\_sy\_arithmetic\_error INTO oref.
        text = oref->get\_text( ).
      CATCH cx\_root INTO oref.
        text = oref->get\_text( ).
    ENDTRY.
    IF NOT text IS INITIAL.
      out->write( text ).
    ENDIF.
    out->display( |Final result: { result ALIGN = LEFT }| ).
  ENDMETHOD.
  METHOD calculation.
    DATA l\_oref TYPE REF TO cx\_root.
    TRY.
        p\_result =  1 / p\_number.
        out->write(
          |Result of division: { p\_result ALIGN = LEFT }| ).
        p\_result = sqrt( p\_number ).
        out->write(
          |Result of square root: { p\_result ALIGN = LEFT }| ).
      CATCH cx\_sy\_zerodivide INTO l\_oref.
        p\_text = l\_oref->get\_text( ).
      CLEANUP.
        CLEAR p\_result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  try\_demo=>main( ).

Description

-   If the content of number is greater than 100, the TRY control structure of the [master program](javascript:call_link\('abenframe_program_glosry.htm'\) "Glossary Entry") raises an exception of the class CX\_DEMO\_ABS\_TOO\_LARGE in the TRY block. This exception is handled by the second CATCH block of the same TRY control structure, since the subclass of the most general exception is CX\_ROOT.

-   If the content of number is 0, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ZERODIVIDE. This is handled in the CATCH block of the same TRY control structure.

-   If the content of number is a negative number, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ARG\_OUT\_OF\_DOMAIN. Since there is no handler defined for this exception in this TRY control structure, the exception is propagated from the method. This is made possible by the declaration of the superclass CX\_SY\_ARITHMETIC\_ERROR using RAISING in the method interface. The CLEANUP block of the inner TRY control structure is executed first.

-   Any other exceptions are handled in the final CATCH block of the TRY control structure of the master program. This block catches all possible exceptions by specifying the most general exception class, CX\_ROOT. If, for example, CX\_SY\_ARG\_OUT\_OF\_DOMAIN or one of its superclasses is not declared in the method interface, the exception CX\_SY\_NO\_HANDLER would be raised and would be handled in the final CATCH block.



**📖 Source**: [abentry_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentry_abexa.htm)

### abencatch_exception_abexa.htm

> **📖 Official SAP Documentation**: [abencatch_exception_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencatch_exception_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, CATCH

This example demonstrates how class-based exceptions are caught.

Source Code

REPORT demo\_catch\_exception.
DATA(in) = cl\_demo\_input=>new( ).
DATA: resumable     TYPE abap\_bool VALUE abap\_false,
      before\_unwind TYPE abap\_bool VALUE abap\_false,
      resume        TYPE abap\_bool VALUE abap\_false.
in->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RAISE RESUMABLE'
               CHANGING  field = resumable
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'CATCH BEFORE UNWIND'
               CHANGING  field = before\_unwind
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RESUME'
               CHANGING  field = resume
)->request( ).
CLASS lcx\_exception DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS exc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS: main,
      meth1 RAISING lcx\_exception,
      meth2 RAISING RESUMABLE(lcx\_exception).
ENDCLASS.
FIELD-SYMBOLS <fs> TYPE any.
CLASS exc\_demo IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    DATA exc TYPE REF TO lcx\_exception.
    IF before\_unwind = abap\_false.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH lcx\_exception.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ELSEIF before\_unwind = abap\_true.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH BEFORE UNWIND lcx\_exception INTO exc.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
          IF resume = abap\_true.
            IF exc->is\_resumable = abap\_true.
              RESUME.
            ELSE.
              out->write( 'Resumption not possible' ).
            ENDIF.
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ENDIF.
    out->display( ).
  ENDMETHOD.
  METHOD meth1.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising non-resumable exception' ).
        RAISE EXCEPTION TYPE lcx\_exception.
        out->write( 'Never executed' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
  METHOD meth2.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising resumable exception' ).
        RAISE RESUMABLE EXCEPTION TYPE lcx\_exception.
        out->write( 'Resuming method' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  exc\_demo=>main( ).

Description

The method meth1 raises a non-resumable exception and the method meth2 raises a resumable exception that is handled in the TRY control structures of the method main using CATCH.

-   If handled without BEFORE UNWIND, the CLEANUP block is executed in both cases before handling and the context of the called method does not exist during handling.

-   If handled with BEFORE UNWIND, the context of the called method exists in both cases during handling and the CLEANUP block is executed after handling.

-   When a resumable exception is raised, the statement RESUME can be executed during handling. This statement makes sure that processing in the called method is continued without its CLEANUP block being executed.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / TRY

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

Included pages: 4



**📖 Source**: [abencatch_exception_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencatch_exception_abexa.htm)

### abenexception_abexas.htm

> **📖 Official SAP Documentation**: [abenexception_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexception_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) → 

Examples of Exceptions

Continue
![Example](exa.gif "Example") [Exceptions, RAISE](javascript:call_link\('abenraise_abexa.htm'\))
![Example](exa.gif "Example") [Exceptions, TRY](javascript:call_link\('abentry_abexa.htm'\))
![Example](exa.gif "Example") [Exceptions, CATCH](javascript:call_link\('abencatch_exception_abexa.htm'\))



**📖 Source**: [abenexception_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexception_abexas.htm)

### abenraise_abexa.htm

> **📖 Official SAP Documentation**: [abenraise_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, RAISE

This example demonstrates the statement RAISE EXCEPTION.

Source Code

REPORT demo\_raise\_exception.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: oref    TYPE REF TO cx\_demo\_constructor,
          text     TYPE string,
          position TYPE i.
    TRY.
        TRY.
            RAISE EXCEPTION TYPE cx\_demo\_constructor
              EXPORTING
                my\_text = sy-repid.
          CATCH cx\_demo\_constructor INTO oref.
            text = oref->get\_text( ).
            oref->get\_source\_position(
              IMPORTING  source\_line  = position ).
            cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
            RAISE EXCEPTION oref.
        ENDTRY.
      CATCH cx\_demo\_constructor INTO oref.
        text = oref->get\_text( ).
        oref->get\_source\_position(
          IMPORTING source\_line  = position ).
        cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
    ENDTRY.
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the two variants of the statement RAISE EXCEPTION. The first statement raises an exception of the class CX\_DEMO\_CONSTRUCTOR in the inner TRY block, creates the relevant object, and passes the program name to the instance constructor. The inner CATCH block handles the exception, provides the exception text, and raises the exception again without creating a new object. The outer CATCH block handles the exception again. The CX\_DEMO\_CONSTRUCTOR class is defined in such a way that the passed program name appears in the exception text. The generated instance constructor takes care of this.

The line number in which the exception was raised is shown to indicate that, when the existing exception object was reused, information relevant to this object was modified.



**📖 Source**: [abenraise_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_abexa.htm)

### abentry_abexa.htm

> **📖 Official SAP Documentation**: [abentry_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentry_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, TRY

This example demonstrates the TRY control structure.

Source Code

REPORT demo\_try.
CLASS try\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2,
                oref   TYPE REF TO cx\_root,
                text   TYPE string.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA number TYPE i.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS calculation
      IMPORTING  p\_number LIKE number
      CHANGING p\_result LIKE result
               p\_text   LIKE text
      RAISING  cx\_sy\_arithmetic\_error.
ENDCLASS.
CLASS try\_demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_input=>request( CHANGING field = number ).
    out = cl\_demo\_output=>new( ).
    TRY.
        IF abs( number ) > 100.
          RAISE EXCEPTION TYPE cx\_demo\_abs\_too\_large.
        ENDIF.
        calculation( EXPORTING p\_number = number
                     CHANGING  p\_result = result
                               p\_text   = text ).
      CATCH cx\_sy\_arithmetic\_error INTO oref.
        text = oref->get\_text( ).
      CATCH cx\_root INTO oref.
        text = oref->get\_text( ).
    ENDTRY.
    IF NOT text IS INITIAL.
      out->write( text ).
    ENDIF.
    out->display( |Final result: { result ALIGN = LEFT }| ).
  ENDMETHOD.
  METHOD calculation.
    DATA l\_oref TYPE REF TO cx\_root.
    TRY.
        p\_result =  1 / p\_number.
        out->write(
          |Result of division: { p\_result ALIGN = LEFT }| ).
        p\_result = sqrt( p\_number ).
        out->write(
          |Result of square root: { p\_result ALIGN = LEFT }| ).
      CATCH cx\_sy\_zerodivide INTO l\_oref.
        p\_text = l\_oref->get\_text( ).
      CLEANUP.
        CLEAR p\_result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  try\_demo=>main( ).

Description

-   If the content of number is greater than 100, the TRY control structure of the [master program](javascript:call_link\('abenframe_program_glosry.htm'\) "Glossary Entry") raises an exception of the class CX\_DEMO\_ABS\_TOO\_LARGE in the TRY block. This exception is handled by the second CATCH block of the same TRY control structure, since the subclass of the most general exception is CX\_ROOT.

-   If the content of number is 0, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ZERODIVIDE. This is handled in the CATCH block of the same TRY control structure.

-   If the content of number is a negative number, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ARG\_OUT\_OF\_DOMAIN. Since there is no handler defined for this exception in this TRY control structure, the exception is propagated from the method. This is made possible by the declaration of the superclass CX\_SY\_ARITHMETIC\_ERROR using RAISING in the method interface. The CLEANUP block of the inner TRY control structure is executed first.

-   Any other exceptions are handled in the final CATCH block of the TRY control structure of the master program. This block catches all possible exceptions by specifying the most general exception class, CX\_ROOT. If, for example, CX\_SY\_ARG\_OUT\_OF\_DOMAIN or one of its superclasses is not declared in the method interface, the exception CX\_SY\_NO\_HANDLER would be raised and would be handled in the final CATCH block.



**📖 Source**: [abentry_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentry_abexa.htm)

### abencatch_exception_abexa.htm

> **📖 Official SAP Documentation**: [abencatch_exception_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencatch_exception_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, CATCH

This example demonstrates how class-based exceptions are caught.

Source Code

REPORT demo\_catch\_exception.
DATA(in) = cl\_demo\_input=>new( ).
DATA: resumable     TYPE abap\_bool VALUE abap\_false,
      before\_unwind TYPE abap\_bool VALUE abap\_false,
      resume        TYPE abap\_bool VALUE abap\_false.
in->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RAISE RESUMABLE'
               CHANGING  field = resumable
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'CATCH BEFORE UNWIND'
               CHANGING  field = before\_unwind
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RESUME'
               CHANGING  field = resume
)->request( ).
CLASS lcx\_exception DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS exc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS: main,
      meth1 RAISING lcx\_exception,
      meth2 RAISING RESUMABLE(lcx\_exception).
ENDCLASS.
FIELD-SYMBOLS <fs> TYPE any.
CLASS exc\_demo IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    DATA exc TYPE REF TO lcx\_exception.
    IF before\_unwind = abap\_false.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH lcx\_exception.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ELSEIF before\_unwind = abap\_true.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH BEFORE UNWIND lcx\_exception INTO exc.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
          IF resume = abap\_true.
            IF exc->is\_resumable = abap\_true.
              RESUME.
            ELSE.
              out->write( 'Resumption not possible' ).
            ENDIF.
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ENDIF.
    out->display( ).
  ENDMETHOD.
  METHOD meth1.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising non-resumable exception' ).
        RAISE EXCEPTION TYPE lcx\_exception.
        out->write( 'Never executed' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
  METHOD meth2.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising resumable exception' ).
        RAISE RESUMABLE EXCEPTION TYPE lcx\_exception.
        out->write( 'Resuming method' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  exc\_demo=>main( ).

Description

The method meth1 raises a non-resumable exception and the method meth2 raises a resumable exception that is handled in the TRY control structures of the method main using CATCH.

-   If handled without BEFORE UNWIND, the CLEANUP block is executed in both cases before handling and the context of the called method does not exist during handling.

-   If handled with BEFORE UNWIND, the context of the called method exists in both cases during handling and the CLEANUP block is executed after handling.

-   When a resumable exception is raised, the statement RESUME can be executed during handling. This statement makes sure that processing in the called method is continued without its CLEANUP block being executed.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

Included pages: 4



**📖 Source**: [abencatch_exception_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencatch_exception_abexa.htm)

### abenexception_abexas.htm

> **📖 Official SAP Documentation**: [abenexception_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexception_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) → 

Examples of Exceptions

Continue
![Example](exa.gif "Example") [Exceptions, RAISE](javascript:call_link\('abenraise_abexa.htm'\))
![Example](exa.gif "Example") [Exceptions, TRY](javascript:call_link\('abentry_abexa.htm'\))
![Example](exa.gif "Example") [Exceptions, CATCH](javascript:call_link\('abencatch_exception_abexa.htm'\))



**📖 Source**: [abenexception_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexception_abexas.htm)

### abenraise_abexa.htm

> **📖 Official SAP Documentation**: [abenraise_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, RAISE

This example demonstrates the statement RAISE EXCEPTION.

Source Code

REPORT demo\_raise\_exception.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: oref    TYPE REF TO cx\_demo\_constructor,
          text     TYPE string,
          position TYPE i.
    TRY.
        TRY.
            RAISE EXCEPTION TYPE cx\_demo\_constructor
              EXPORTING
                my\_text = sy-repid.
          CATCH cx\_demo\_constructor INTO oref.
            text = oref->get\_text( ).
            oref->get\_source\_position(
              IMPORTING  source\_line  = position ).
            cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
            RAISE EXCEPTION oref.
        ENDTRY.
      CATCH cx\_demo\_constructor INTO oref.
        text = oref->get\_text( ).
        oref->get\_source\_position(
          IMPORTING source\_line  = position ).
        cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
    ENDTRY.
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the two variants of the statement RAISE EXCEPTION. The first statement raises an exception of the class CX\_DEMO\_CONSTRUCTOR in the inner TRY block, creates the relevant object, and passes the program name to the instance constructor. The inner CATCH block handles the exception, provides the exception text, and raises the exception again without creating a new object. The outer CATCH block handles the exception again. The CX\_DEMO\_CONSTRUCTOR class is defined in such a way that the passed program name appears in the exception text. The generated instance constructor takes care of this.

The line number in which the exception was raised is shown to indicate that, when the existing exception object was reused, information relevant to this object was modified.



**📖 Source**: [abenraise_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_abexa.htm)

### abentry_abexa.htm

> **📖 Official SAP Documentation**: [abentry_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentry_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, TRY

This example demonstrates the TRY control structure.

Source Code

REPORT demo\_try.
CLASS try\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2,
                oref   TYPE REF TO cx\_root,
                text   TYPE string.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA number TYPE i.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS calculation
      IMPORTING  p\_number LIKE number
      CHANGING p\_result LIKE result
               p\_text   LIKE text
      RAISING  cx\_sy\_arithmetic\_error.
ENDCLASS.
CLASS try\_demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_input=>request( CHANGING field = number ).
    out = cl\_demo\_output=>new( ).
    TRY.
        IF abs( number ) > 100.
          RAISE EXCEPTION TYPE cx\_demo\_abs\_too\_large.
        ENDIF.
        calculation( EXPORTING p\_number = number
                     CHANGING  p\_result = result
                               p\_text   = text ).
      CATCH cx\_sy\_arithmetic\_error INTO oref.
        text = oref->get\_text( ).
      CATCH cx\_root INTO oref.
        text = oref->get\_text( ).
    ENDTRY.
    IF NOT text IS INITIAL.
      out->write( text ).
    ENDIF.
    out->display( |Final result: { result ALIGN = LEFT }| ).
  ENDMETHOD.
  METHOD calculation.
    DATA l\_oref TYPE REF TO cx\_root.
    TRY.
        p\_result =  1 / p\_number.
        out->write(
          |Result of division: { p\_result ALIGN = LEFT }| ).
        p\_result = sqrt( p\_number ).
        out->write(
          |Result of square root: { p\_result ALIGN = LEFT }| ).
      CATCH cx\_sy\_zerodivide INTO l\_oref.
        p\_text = l\_oref->get\_text( ).
      CLEANUP.
        CLEAR p\_result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  try\_demo=>main( ).

Description

-   If the content of number is greater than 100, the TRY control structure of the [master program](javascript:call_link\('abenframe_program_glosry.htm'\) "Glossary Entry") raises an exception of the class CX\_DEMO\_ABS\_TOO\_LARGE in the TRY block. This exception is handled by the second CATCH block of the same TRY control structure, since the subclass of the most general exception is CX\_ROOT.

-   If the content of number is 0, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ZERODIVIDE. This is handled in the CATCH block of the same TRY control structure.

-   If the content of number is a negative number, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ARG\_OUT\_OF\_DOMAIN. Since there is no handler defined for this exception in this TRY control structure, the exception is propagated from the method. This is made possible by the declaration of the superclass CX\_SY\_ARITHMETIC\_ERROR using RAISING in the method interface. The CLEANUP block of the inner TRY control structure is executed first.

-   Any other exceptions are handled in the final CATCH block of the TRY control structure of the master program. This block catches all possible exceptions by specifying the most general exception class, CX\_ROOT. If, for example, CX\_SY\_ARG\_OUT\_OF\_DOMAIN or one of its superclasses is not declared in the method interface, the exception CX\_SY\_NO\_HANDLER would be raised and would be handled in the final CATCH block.



**📖 Source**: [abentry_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentry_abexa.htm)

### abencatch_exception_abexa.htm

> **📖 Official SAP Documentation**: [abencatch_exception_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencatch_exception_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Class-Based Exceptions](javascript:call_link\('abenexceptions.htm'\)) →  [Examples of Exceptions](javascript:call_link\('abenexception_abexas.htm'\)) → 

Exceptions, CATCH

This example demonstrates how class-based exceptions are caught.

Source Code

REPORT demo\_catch\_exception.
DATA(in) = cl\_demo\_input=>new( ).
DATA: resumable     TYPE abap\_bool VALUE abap\_false,
      before\_unwind TYPE abap\_bool VALUE abap\_false,
      resume        TYPE abap\_bool VALUE abap\_false.
in->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RAISE RESUMABLE'
               CHANGING  field = resumable
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'CATCH BEFORE UNWIND'
               CHANGING  field = before\_unwind
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RESUME'
               CHANGING  field = resume
)->request( ).
CLASS lcx\_exception DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS exc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS: main,
      meth1 RAISING lcx\_exception,
      meth2 RAISING RESUMABLE(lcx\_exception).
ENDCLASS.
FIELD-SYMBOLS <fs> TYPE any.
CLASS exc\_demo IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    DATA exc TYPE REF TO lcx\_exception.
    IF before\_unwind = abap\_false.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH lcx\_exception.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ELSEIF before\_unwind = abap\_true.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH BEFORE UNWIND lcx\_exception INTO exc.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
          IF resume = abap\_true.
            IF exc->is\_resumable = abap\_true.
              RESUME.
            ELSE.
              out->write( 'Resumption not possible' ).
            ENDIF.
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ENDIF.
    out->display( ).
  ENDMETHOD.
  METHOD meth1.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising non-resumable exception' ).
        RAISE EXCEPTION TYPE lcx\_exception.
        out->write( 'Never executed' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
  METHOD meth2.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising resumable exception' ).
        RAISE RESUMABLE EXCEPTION TYPE lcx\_exception.
        out->write( 'Resuming method' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  exc\_demo=>main( ).

Description

The method meth1 raises a non-resumable exception and the method meth2 raises a resumable exception that is handled in the TRY control structures of the method main using CATCH.

-   If handled without BEFORE UNWIND, the CLEANUP block is executed in both cases before handling and the context of the called method does not exist during handling.

-   If handled with BEFORE UNWIND, the context of the called method exists in both cases during handling and the CLEANUP block is executed after handling.

-   When a resumable exception is raised, the statement RESUME can be executed during handling. This statement makes sure that processing in the called method is continued without its CLEANUP block being executed.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Exceptions Before Class-Based Exceptions

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Exceptions Before Class-Based Exceptions

Included pages: 5



**📖 Source**: [abencatch_exception_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencatch_exception_abexa.htm)

### abenexceptions_pre_610.htm

> **📖 Official SAP Documentation**: [abenexceptions_pre_610.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexceptions_pre_610.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) → 

Exceptions Before Class-Based Exceptions

Exceptions are [class-based](javascript:call_link\('abenexceptions.htm'\)). Before the introduction of exception classes, there were the following types of exceptions:

-   Exception situations detected by the system (and whose causes could be handled effectively by the program) raised [catchable runtime errors](javascript:call_link\('abensystem-exceptions.htm'\)) that could be handled by the statement [CATCH SYSTEM-EXCEPTIONS](javascript:call_link\('abapcatch_sys.htm'\)). Catchable runtime errors are now obsolete. Each catchable runtime error is assigned an exception class instead, which is handled in a [TRY block](javascript:call_link\('abaptry.htm'\)). Conversely, not all predefined class-based exceptions are assigned to a catchable runtime error. No new catchable runtime errors are created and existing runtime errors that are to be made handleable are no longer transformed to catchable runtime errors. Instead, exception classes are assigned to them.

-   [Self-defined handleable exceptions](javascript:call_link\('abenexceptions_non_class.htm'\)) were allowed only in the interfaces of function modules and methods. These types of exceptions can be raised within the [procedure](javascript:call_link\('abenprocedure_glosry.htm'\) "Glossary Entry") by the statement [RAISE](javascript:call_link\('abapraise_exception.htm'\)) or [MESSAGE RAISING](javascript:call_link\('abapmessage_raising.htm'\)) as soon as an exception situation is detected. The caller of the procedure can use the addition EXCEPTIONS of the statement [CALL FUNCTION](javascript:call_link\('abapcall_function.htm'\)) or [meth( ... )](javascript:call_link\('abapcall_method_static_short.htm'\)) to assign return codes for the system field sy-subrc to the exceptions the caller wants to handle and evaluate them after the call. However, this is not true exception handling in the sense of reacting to an event.

Interaction of the Exception Concepts

The class-based exceptions replace and enhance the previous concepts in full. Class-based exceptions can be raised and handled in all ABAP contexts (programs, processing blocks). In particular, all previously catchable runtime errors can be handled as class-based exceptions, with the previous exception groups being mapped to shared superclasses. For reasons of downward-compatibility, the catchable runtime errors and the non-class-based exceptions defined in the interfaces of methods and function modules have not been abolished, but their use has been restricted as follows:

-   Within a [processing block](javascript:call_link\('abenprocessing_block_glosry.htm'\) "Glossary Entry"), only one kind of exception can be raised.

-   Within a procedure interface, the declaration of class-based exceptions and the definition of non-class-based exceptions exclude one another.

-   Within a processing block, catchable runtime errors cannot be caught using [CATCH SYSTEM-EXCEPTIONS](javascript:call_link\('abapcatch_sys.htm'\)) if class-based exceptions are handled there in [TRY](javascript:call_link\('abaptry.htm'\)) blocks or are raised using [RAISE EXCEPTION](javascript:call_link\('abapraise_exception.htm'\)) or the addition [THROW](javascript:call_link\('abenconditional_expression_result.htm'\)) in a [conditional expression](javascript:call_link\('abenconditional_expressions.htm'\)). Instead, catchable runtime errors must be caught when handling the associated class-based exception.

For reasons of interoperability, class-based exceptions can be handled within a processing block and return codes of function modules and methods evaluated there using non-class-based exceptions.

Continue
[Non-Class-Based Exceptions](javascript:call_link\('abenexceptions_non_class.htm'\))



**📖 Source**: [abenexceptions_pre_610.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexceptions_pre_610.htm)

### abenexceptions_non_class.htm

> **📖 Official SAP Documentation**: [abenexceptions_non_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexceptions_non_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Exceptions Before Class-Based Exceptions](javascript:call_link\('abenexceptions_pre_610.htm'\)) → 

Non-Class-Based Exceptions

Definition

Non-class-based exceptions can be defined in the interfaces of function modules and methods. These exceptions are defined as follows:

-   In methods of local classes, by assigning a name for the exception after the addition [EXCEPTIONS](javascript:call_link\('abapmethods_general.htm'\)) of the statement [*\[*CLASS-*\]*](javascript:call_link\('abapclass-methods.htm'\))[METHODS](javascript:call_link\('abapmethods.htm'\)).

-   In methods of global classes or function modules, by assigning a name for the exception in [Class Builder](javascript:call_link\('abenclass_builder_glosry.htm'\) "Glossary Entry") or [Function Builder](javascript:call_link\('abenfunction_builder_glosry.htm'\) "Glossary Entry"). Here, the radio button for exception classes is not selected.

The statement [RAISE EXCEPTION](javascript:call_link\('abapraise_exception_class.htm'\)) or the addition [THROW](javascript:call_link\('abenconditional_expression_result.htm'\)) in a [conditional expression](javascript:call_link\('abenconditional_expressions.htm'\)) cannot be used to raise class-based exceptions in a method or a function module in whose interface non-class-based exceptions are defined.

Note

Before class-based exceptions were introduced, all exceptions defined in the interface of methods of global classes or function modules were non-class-based.

Raising

Non-class-based exceptions are raised by the following statements:

-   [RAISE](javascript:call_link\('abapraise_exception.htm'\))

-   [MESSAGE ... RAISING](javascript:call_link\('abapmessage_raising.htm'\))

Handling

The handling of non-class-based exceptions is made possible by the addition EXCEPTIONS in [method calls](javascript:call_link\('abenmethod_calls.htm'\)) and [function module calls](javascript:call_link\('abapcall_function.htm'\)). Number values are assigned to the exceptions and are used to fill the system field sy-subrc when the exception is raised. The actual error handling takes place after the call, when sy-subrc is evaluated.

Programming Guideline

[Using Class-Based Exceptions](javascript:call_link\('abenclass_exception_guidl.htm'\) "Guideline")

Notes

-   The exceptions that can be defined in the interfaces of methods and function modules are not real exceptions, since they do not modify the control flow and they just end the processing of the [procedure](javascript:call_link\('abenprocedure_glosry.htm'\) "Glossary Entry") prematurely and set the return code sy-subrc instead.

-   [RFC](javascript:call_link\('abenrfc_glosry.htm'\) "Glossary Entry") currently allows only classic exception handling. Class-based exception handling is only possible in a different release track.

Continue
[RAISE](javascript:call_link\('abapraise_exception.htm'\))
[MESSAGE - RAISING](javascript:call_link\('abapmessage_raising.htm'\))



**📖 Source**: [abenexceptions_non_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexceptions_non_class.htm)

### abapraise_exception.htm

> **📖 Official SAP Documentation**: [abapraise_exception.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapraise_exception.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Exceptions Before Class-Based Exceptions](javascript:call_link\('abenexceptions_pre_610.htm'\)) →  [Non-Class-Based Exceptions](javascript:call_link\('abenexceptions_non_class.htm'\)) → 

RAISE

[Quick Reference](javascript:call_link\('abapraise_shortref.htm'\))

Syntax

RAISE exception.

Effect

This statement raises the [non-class-based exception](javascript:call_link\('abenexceptions_non_class.htm'\)) exception.

-   RAISE can be specified in a method only if the non-class-based exception is defined in the interface of the method.
    
-   Specify RAISE in function modules only if the non-class-based exception is defined in the interface of the function module.
    
-   It is possible to specify RAISE in all other positions, but this is not recommended.
    

After the exception exception is raised, the system proceeds as follows:

-   If the exception is raised in a method or function module whose caller assigns a return value to the exception, the [procedure](javascript:call_link\('abenprocedure_glosry.htm'\) "Glossary Entry") ends immediately, the system returns to the calling position, and the system field sy-subrc is set according to the assignment.
    
-   If the exception is raised in a method or function module whose caller does not assign a return value to the exception, a runtime error is then triggered whose [short dump](javascript:call_link\('abenshort_dump_glosry.htm'\) "Glossary Entry") contains the name of the exception.
    
-   If the exception is raised in a subroutine, the system searches for the first function module in the procedures of the preceding call stack. If it finds a function module of this type and the exception is defined in it, the system acts as though the exception was raised in this function module. Otherwise, a runtime error occurs.
    
-   In all other processing blocks, raising a non class-based exception produces a runtime error that immediately ends the program.
    

This form of the statement RAISE cannot be used in the same [processing block](javascript:call_link\('abenprocessing_block_glosry.htm'\) "Glossary Entry") as the statement [RAISE EXCEPTION](javascript:call_link\('abapraise_exception_class.htm'\)) or the addition [THROW](javascript:call_link\('abenconditional_expression_result.htm'\)) in a [conditional expression](javascript:call_link\('abenconditional_expressions.htm'\)) to raise class-based exceptions.

Notes

-   The statement MESSAGE with the addition [RAISING](javascript:call_link\('abapmessage_raising.htm'\)) also raises a non-class-based exception. In cases in which non-class-based exceptions are still used, this statement is preferred instead of RAISE, because it offers the option of adding a text to the exception.
    
-   If a [procedure](javascript:call_link\('abenprocedure_glosry.htm'\) "Glossary Entry") is exited by raising an exception, the content of the formal parameter for which the [pass by value](javascript:call_link\('abenpass_by_value_glosry.htm'\) "Glossary Entry") is defined is not assigned to the respective actual parameters.
    

Example

Raising a non-class-based exception in a method.

CLASS cls DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS meth EXCEPTIONS exc.
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD meth.
    ...
    RAISE exc.
    ...
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  cls=>meth( EXCEPTIONS exc = 4 ).
  CASE sy-subrc.
    WHEN 4.
      cl\_demo\_output=>display( 'Exception' ).
    WHEN OTHERS.
      ...
  ENDCASE.

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Non-Handleable Exceptions

-   Cause: The raised exception was not handled by the caller.
    Runtime error: RAISE\_EXCEPTION



**📖 Source**: [abapraise_exception.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapraise_exception.htm)

### abapmessage_raising.htm

> **📖 Official SAP Documentation**: [abapmessage_raising.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapmessage_raising.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Exceptions Before Class-Based Exceptions](javascript:call_link\('abenexceptions_pre_610.htm'\)) →  [Non-Class-Based Exceptions](javascript:call_link\('abenexceptions_non_class.htm'\)) → 

MESSAGE - RAISING

[Quick Reference](javascript:call_link\('abapmessage_shortref.htm'\))

Syntax

MESSAGE *{* [msg](javascript:call_link\('abapmessage_msg.htm'\)) *|* [text](javascript:call_link\('abapmessage_text.htm'\)) *}* [*\[*DISPLAY LIKE dtype*\]*](javascript:call_link\('abapmessage.htm'\)) [*\[*WITH dobj1... dobj4*\]*](javascript:call_link\('abapmessage.htm'\))
        RAISING exception.

Effect

The statement [MESSAGE](javascript:call_link\('abapmessage.htm'\)) with the addition RAISING raises a non-class-based exception exception and only sends a message if the exception is not handled. The semantics of [msg](javascript:call_link\('abapmessage_msg.htm'\)), [text](javascript:call_link\('abapmessage_text.htm'\)), and [WITH](javascript:call_link\('abapmessage.htm'\)) is the same as in the statement MESSAGE without the addition RAISING.

This addition only makes sense during the processing of methods and function modules in which the non-class-based exception exception is defined. Furthermore, it cannot be used in the same [processing block](javascript:call_link\('abenprocessing_block_glosry.htm'\) "Glossary Entry") as the statement RAISE EXCEPTION or the addition [THROW](javascript:call_link\('abenconditional_expression_result.htm'\)) in a [conditional expression](javascript:call_link\('abenconditional_expressions.htm'\)) to raise class-based exceptions.

-   If the MESSAGE statement is executed with the addition RAISING during processing of a method or a function module, and the caller of the method or function module assigns a return code to the [exception](javascript:call_link\('abenexceptions_non_class.htm'\)) exception using the addition EXCEPTIONS of the statement CALL, the statement works in the same way as the statement [RAISE](javascript:call_link\('abapraise_exception.htm'\)).
    
-   If no return code is assigned to the exception exception, the addition RAISING is ignored and the message is sent using the statement [MESSAGE](javascript:call_link\('abapmessage.htm'\)) and [processed](javascript:call_link\('abenabap_messages_types.htm'\)) in accordance with its [message type](javascript:call_link\('abenmessage_type_glosry.htm'\) "Glossary Entry").
    

The system fields of the statement MESSAGE are filled in both cases and are available in the calling program after an exception raised using MESSAGE ...RAISING is handled. This is especially true if a function module was called using Remote Function Call ([RFC](javascript:call_link\('abenremote_function_call_glosry.htm'\) "Glossary Entry")).

Notes

-   The statement MESSAGE ... RAISING is primarily a statement for raising exceptions and not for sending messages. An exception of this type should always be handled like an exception raised using RAISE, since the behavior of the message depends strongly on the context and is usually unpredictable when the function module is created.
    
-   Using MESSAGE ... RAISING in cases in which non class-based exceptions must still be used is preferable to using the RAISE statement, because it offers the option of providing additional text information with an exception.
    
-   A return code can be assigned to messages that are sent in function modules without the addition RAISING by using the predefined exception [error\_message](javascript:call_link\('abapcall_function_parameter.htm'\)).
    
-   Messages sent as messages when a function module is called and not caught (despite RAISING) are processed as with [error\_message](javascript:call_link\('abapcall_function_parameter.htm'\)).
    
-   If a [procedure](javascript:call_link\('abenprocedure_glosry.htm'\) "Glossary Entry") is exited by raising an exception, the content of the formal parameter for which the [pass by value](javascript:call_link\('abenpass_by_value_glosry.htm'\) "Glossary Entry") is defined is not assigned to the respective actual parameters.
    

Example

When the message is called for the first time, an [information message](javascript:call_link\('abeninformation_message_glosry.htm'\) "Glossary Entry") is sent. The second time, an exception is raised instead, which is handled by sy-subrc.

     CLASS c1 DEFINITION.
       PUBLIC SECTION.
         CLASS-METHODS m1 EXCEPTIONS exc1.
     ENDCLASS.
     CLASS c1 IMPLEMENTATION.
       METHOD m1.
         MESSAGE 'Message in a Method' TYPE 'I' RAISING exc1.
       ENDMETHOD.
     ENDCLASS.
     ...
       c1=>m1( ).
       c1=>m1( EXCEPTIONS exc1 = 4 ).
     IF sy-subrc = 4.
       ...
     ENDIF.



**📖 Source**: [abapmessage_raising.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapmessage_raising.htm)

### abenexceptions_non_class.htm

> **📖 Official SAP Documentation**: [abenexceptions_non_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexceptions_non_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Program Flow Logic](javascript:call_link\('abenabap_flow_logic.htm'\)) →  [Exception Handling](javascript:call_link\('abenabap_exceptions.htm'\)) →  [Exceptions Before Class-Based Exceptions](javascript:call_link\('abenexceptions_pre_610.htm'\)) → 

Non-Class-Based Exceptions

Definition

Non-class-based exceptions can be defined in the interfaces of function modules and methods. These exceptions are defined as follows:

-   In methods of local classes, by assigning a name for the exception after the addition [EXCEPTIONS](javascript:call_link\('abapmethods_general.htm'\)) of the statement [*\[*CLASS-*\]*](javascript:call_link\('abapclass-methods.htm'\))[METHODS](javascript:call_link\('abapmethods.htm'\)).

-   In methods of global classes or function modules, by assigning a name for the exception in [Class Builder](javascript:call_link\('abenclass_builder_glosry.htm'\) "Glossary Entry") or [Function Builder](javascript:call_link\('abenfunction_builder_glosry.htm'\) "Glossary Entry"). Here, the radio button for exception classes is not selected.

The statement [RAISE EXCEPTION](javascript:call_link\('abapraise_exception_class.htm'\)) or the addition [THROW](javascript:call_link\('abenconditional_expression_result.htm'\)) in a [conditional expression](javascript:call_link\('abenconditional_expressions.htm'\)) cannot be used to raise class-based exceptions in a method or a function module in whose interface non-class-based exceptions are defined.

Note

Before class-based exceptions were introduced, all exceptions defined in the interface of methods of global classes or function modules were non-class-based.

Raising

Non-class-based exceptions are raised by the following statements:

-   [RAISE](javascript:call_link\('abapraise_exception.htm'\))

-   [MESSAGE ... RAISING](javascript:call_link\('abapmessage_raising.htm'\))

Handling

The handling of non-class-based exceptions is made possible by the addition EXCEPTIONS in [method calls](javascript:call_link\('abenmethod_calls.htm'\)) and [function module calls](javascript:call_link\('abapcall_function.htm'\)). Number values are assigned to the exceptions and are used to fill the system field sy-subrc when the exception is raised. The actual error handling takes place after the call, when sy-subrc is evaluated.

Programming Guideline

[Using Class-Based Exceptions](javascript:call_link\('abenclass_exception_guidl.htm'\) "Guideline")

Notes

-   The exceptions that can be defined in the interfaces of methods and function modules are not real exceptions, since they do not modify the control flow and they just end the processing of the [procedure](javascript:call_link\('abenprocedure_glosry.htm'\) "Glossary Entry") prematurely and set the return code sy-subrc instead.

-   [RFC](javascript:call_link\('abenrfc_glosry.htm'\) "Glossary Entry") currently allows only classic exception handling. Class-based exception handling is only possible in a different release track.

Continue
[RAISE](javascript:call_link\('abapraise_exception.htm'\))
[MESSAGE - RAISING](javascript:call_link\('abapmessage_raising.htm'\))


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversion Rules for Elementary Data Objects / Numeric Source Fields

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversions - Performance Notes

Included pages: 2



**📖 Source**: [abenexceptions_non_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenexceptions_non_class.htm)

### abenconversion_perfo.htm

> **📖 Official SAP Documentation**: [abenconversion_perfo.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_perfo.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assignment and Conversion Rules](javascript:call_link\('abenconversion_rules.htm'\)) → 

Conversions - Performance Notes

Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type should be assigned to one another.

Executable Example

[Conversion Costs](javascript:call_link\('abenconversion_costs_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Conversion Costs](javascript:call_link\('abenconversion_costs_abexa.htm'\))



**📖 Source**: [abenconversion_perfo.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_perfo.htm)

### abenconversion_costs_abexa.htm

> **📖 Official SAP Documentation**: [abenconversion_costs_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_costs_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assignment and Conversion Rules](javascript:call_link\('abenconversion_rules.htm'\)) →  [Conversions - Performance Notes](javascript:call_link\('abenconversion_perfo.htm'\)) → 

Conversion Costs

This example demonstrates costs for type conversions in assignments and operand positions.

Source Code

REPORT demo\_conversion\_costs.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: num   TYPE n LENGTH 10,
          int   TYPE i,
          itab  TYPE STANDARD TABLE OF i,
          t1    TYPE i,
          t2    TYPE i,
          toff  TYPE i,
          tn    TYPE i,
          ti    TYPE i,
          msg   TYPE string.
    CONSTANTS n TYPE i VALUE 100000.
    GET RUN TIME FIELD t1.
    DO n TIMES.
    ENDDO.
    GET RUN TIME FIELD t2.
    toff = t2 - t1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      num = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      int = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>write(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).
    itab = VALUE #( ( 1 ) ).
    CLEAR: tn, ti.
    num = '1'.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX num.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    int = 1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX int.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>display(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The program calculates the relationship between the costs of a conversion from type n to i and the costs of a direct memory copy from type i to i. The conversion is much slower than the unconverted copy, which can be seen directly in the assignment. The difference is not so clear in an operand position (here when specifying the index of a READ statement). This is because the conversion costs are not as high as for a table access.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversion Rules for Elementary Data Objects / Character-Like Source Fields

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversions - Performance Notes

Included pages: 2



**📖 Source**: [abenconversion_costs_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_costs_abexa.htm)

### abenconversion_perfo.htm

> **📖 Official SAP Documentation**: [abenconversion_perfo.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_perfo.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assignment and Conversion Rules](javascript:call_link\('abenconversion_rules.htm'\)) → 

Conversions - Performance Notes

Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type should be assigned to one another.

Executable Example

[Conversion Costs](javascript:call_link\('abenconversion_costs_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Conversion Costs](javascript:call_link\('abenconversion_costs_abexa.htm'\))



**📖 Source**: [abenconversion_perfo.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_perfo.htm)

### abenconversion_costs_abexa.htm

> **📖 Official SAP Documentation**: [abenconversion_costs_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_costs_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assignment and Conversion Rules](javascript:call_link\('abenconversion_rules.htm'\)) →  [Conversions - Performance Notes](javascript:call_link\('abenconversion_perfo.htm'\)) → 

Conversion Costs

This example demonstrates costs for type conversions in assignments and operand positions.

Source Code

REPORT demo\_conversion\_costs.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: num   TYPE n LENGTH 10,
          int   TYPE i,
          itab  TYPE STANDARD TABLE OF i,
          t1    TYPE i,
          t2    TYPE i,
          toff  TYPE i,
          tn    TYPE i,
          ti    TYPE i,
          msg   TYPE string.
    CONSTANTS n TYPE i VALUE 100000.
    GET RUN TIME FIELD t1.
    DO n TIMES.
    ENDDO.
    GET RUN TIME FIELD t2.
    toff = t2 - t1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      num = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      int = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>write(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).
    itab = VALUE #( ( 1 ) ).
    CLEAR: tn, ti.
    num = '1'.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX num.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    int = 1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX int.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>display(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The program calculates the relationship between the costs of a conversion from type n to i and the costs of a direct memory copy from type i to i. The conversion is much slower than the unconverted copy, which can be seen directly in the assignment. The difference is not so clear in an operand position (here when specifying the index of a READ statement). This is because the conversion costs are not as high as for a table access.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversion Rules for Elementary Data Objects / Byte-Like Source Fields

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversions - Performance Notes

Included pages: 2



**📖 Source**: [abenconversion_costs_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_costs_abexa.htm)

### abenconversion_perfo.htm

> **📖 Official SAP Documentation**: [abenconversion_perfo.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_perfo.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assignment and Conversion Rules](javascript:call_link\('abenconversion_rules.htm'\)) → 

Conversions - Performance Notes

Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type should be assigned to one another.

Executable Example

[Conversion Costs](javascript:call_link\('abenconversion_costs_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Conversion Costs](javascript:call_link\('abenconversion_costs_abexa.htm'\))



**📖 Source**: [abenconversion_perfo.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_perfo.htm)

### abenconversion_costs_abexa.htm

> **📖 Official SAP Documentation**: [abenconversion_costs_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_costs_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assignment and Conversion Rules](javascript:call_link\('abenconversion_rules.htm'\)) →  [Conversions - Performance Notes](javascript:call_link\('abenconversion_perfo.htm'\)) → 

Conversion Costs

This example demonstrates costs for type conversions in assignments and operand positions.

Source Code

REPORT demo\_conversion\_costs.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: num   TYPE n LENGTH 10,
          int   TYPE i,
          itab  TYPE STANDARD TABLE OF i,
          t1    TYPE i,
          t2    TYPE i,
          toff  TYPE i,
          tn    TYPE i,
          ti    TYPE i,
          msg   TYPE string.
    CONSTANTS n TYPE i VALUE 100000.
    GET RUN TIME FIELD t1.
    DO n TIMES.
    ENDDO.
    GET RUN TIME FIELD t2.
    toff = t2 - t1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      num = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      int = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>write(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).
    itab = VALUE #( ( 1 ) ).
    CLEAR: tn, ti.
    num = '1'.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX num.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    int = 1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX int.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>display(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The program calculates the relationship between the costs of a conversion from type n to i and the costs of a direct memory copy from type i to i. The conversion is much slower than the unconverted copy, which can be seen directly in the assignment. The difference is not so clear in an operand position (here when specifying the index of a READ statement). This is because the conversion costs are not as high as for a table access.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversion Rules for Elementary Data Objects / Date/Time Fields as Source Fields

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversions - Performance Notes

Included pages: 2



**📖 Source**: [abenconversion_costs_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_costs_abexa.htm)

### abenconversion_perfo.htm

> **📖 Official SAP Documentation**: [abenconversion_perfo.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_perfo.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assignment and Conversion Rules](javascript:call_link\('abenconversion_rules.htm'\)) → 

Conversions - Performance Notes

Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type should be assigned to one another.

Executable Example

[Conversion Costs](javascript:call_link\('abenconversion_costs_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Conversion Costs](javascript:call_link\('abenconversion_costs_abexa.htm'\))



**📖 Source**: [abenconversion_perfo.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_perfo.htm)

### abenconversion_costs_abexa.htm

> **📖 Official SAP Documentation**: [abenconversion_costs_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_costs_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assignment and Conversion Rules](javascript:call_link\('abenconversion_rules.htm'\)) →  [Conversions - Performance Notes](javascript:call_link\('abenconversion_perfo.htm'\)) → 

Conversion Costs

This example demonstrates costs for type conversions in assignments and operand positions.

Source Code

REPORT demo\_conversion\_costs.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: num   TYPE n LENGTH 10,
          int   TYPE i,
          itab  TYPE STANDARD TABLE OF i,
          t1    TYPE i,
          t2    TYPE i,
          toff  TYPE i,
          tn    TYPE i,
          ti    TYPE i,
          msg   TYPE string.
    CONSTANTS n TYPE i VALUE 100000.
    GET RUN TIME FIELD t1.
    DO n TIMES.
    ENDDO.
    GET RUN TIME FIELD t2.
    toff = t2 - t1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      num = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      int = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>write(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).
    itab = VALUE #( ( 1 ) ).
    CLEAR: tn, ti.
    num = '1'.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX num.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    int = 1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX int.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>display(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The program calculates the relationship between the costs of a conversion from type n to i and the costs of a direct memory copy from type i to i. The conversion is much slower than the unconverted copy, which can be seen directly in the assignment. The difference is not so clear in an operand position (here when specifying the index of a READ statement). This is because the conversion costs are not as high as for a table access.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assigning Structure Components / CL_ABAP_CORRESPONDING - System Class

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assigning Structure Components / CL_ABAP_CORRESPONDING - System Class

Included pages: 4



**📖 Source**: [abenconversion_costs_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenconversion_costs_abexa.htm)

### abencl_abap_corresponding.htm

> **📖 Official SAP Documentation**: [abencl_abap_corresponding.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_corresponding.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assigning Structure Components](javascript:call_link\('abencorresponding.htm'\)) → 

CL\_ABAP\_CORRESPONDING - System Class

The system class CL\_ABAP\_CORRESPONDING enables assignments of components between structures or between internal tables with dynamically specified mapping rules. Methods are available for simple assignments, assignments of default values, and for using a lookup table.

-   [CL\_ABAP\_CORRESPONDING - Simple Assignment](javascript:call_link\('abencl_abap_corresponding_1.htm'\))

-   [CL\_ABAP\_CORRESPONDING - Assignment of Default Values](javascript:call_link\('abencl_abap_corresponding_3.htm'\))

-   [CL\_ABAP\_CORRESPONDING - Lookup Table](javascript:call_link\('abencl_abap_corresponding_2.htm'\))

Continue
[CL\_ABAP\_CORRESPONDING - Simple Assignment](javascript:call_link\('abencl_abap_corresponding_1.htm'\))
[CL\_ABAP\_CORRESPONDING - Assignment of Values](javascript:call_link\('abencl_abap_corresponding_3.htm'\))
[CL\_ABAP\_CORRESPONDING - Lookup Table](javascript:call_link\('abencl_abap_corresponding_2.htm'\))



**📖 Source**: [abencl_abap_corresponding.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_corresponding.htm)

### abencl_abap_corresponding_1.htm

> **📖 Official SAP Documentation**: [abencl_abap_corresponding_1.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_corresponding_1.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assigning Structure Components](javascript:call_link\('abencorresponding.htm'\)) →  [CL\_ABAP\_CORRESPONDING - System Class](javascript:call_link\('abencl_abap_corresponding.htm'\)) → 

CL\_ABAP\_CORRESPONDING - Simple Assignment

The methods CREATE and EXECUTE of the system class CL\_ABAP\_CORRESPONDING can be used to assigned components between structure or between internal tables with a dynamically specified mapping rule.

The factory method CREATE is used to create a mapping object:

DATA(mapper) = cl\_abap\_corresponding=>create( source                = struct*|*itab
                                              destination           = struct*|*itab
                                              mapping               = mapping\_tab
                                              discarding\_duplicates = flag ).

Structures struct or internal tables itab of the assigned data types must be passed to the parameters source and destination. An internal table of the type CL\_ABAP\_CORRESPONDING=>MAPPING\_TABLE, containing the mapping rule, must be passed to the parameter mapping. If an initial mapping table is passed, only the identically named components are assigned. The mapping table has the following components:

-   LEVEL

Level of the components in the structure or row structure. The value 0 stands for the top level.

-   KIND

Mapping type. The possible values are:

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_COMPONENT (1) (The components specified in this row are mapped to each other.)

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_EXCEPT\_COMPONENT (2) (The component of the source structure specified in this row is excluded from the mapping of identically named components.)

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_EXCEPT\_ALL (3) (All components of the current source structure are excluded from the mapping of identically name components.)

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_DISCARDING\_DUPLICATES (9) (In a source table, duplicate rows are ignored as when using [DISCARDING DUPLICATES](javascript:call_link\('abencorresponding_constr_dupl.htm'\)) in a mapping rule of the component operator. The target table must have a unique table key.)

-   SRCNAME

Component of the source structure.

-   DSTNAME

Component of the target (destination) structure.

The rows of the internal table must be constructed so that they produce a mapping rule in the correct order. Components of the source structure for which no mapping is defined and that were not excluded are assigned to identically named components of the target structure.

The method EXECUTE of a mapping object can be used to perform any number of assignments between structures or internal tables src and dst whose data type matches the source type or target type specified when the object was created:

mapper->execute( EXPORTING source      = src
                 CHANGING  destination = dst ).

The assignment is performed component by component

-   between the components specified in the mapping rule

-   between the remaining identically named components at the same level (if not excluded in the mapping rule).

In assignments between structures, components of the target structure to which no components of the source structure are assigned keep their previous value, like the statement [MOVE-CORRESPONDING](javascript:call_link\('abapmove-corresponding.htm'\)) and like the operator [CORRESPONDING](javascript:call_link\('abencorresponding_constr_arg_type.htm'\)) with the addition BASE. Any nested internal tables are always resolved, as when the addition EXPANDING NESTED TABLES is specified in MOVE-CORRESPONDING or the addition DEEP for the operator CORRESPONDING. In assignments between internal tables, the target table is always initialized first. There is no matching addition for the addition KEEPING TARGET LINES in MOVE-CORRESPONDING or BASE in CORRESPONDING.

If the value "X" was passed to the parameter DISCARDING\_DUPLICATES of the method CREATE, duplicate rows are handled in tabular component assignments in the same way as when using the addition [DISCARDING DUPLICATES](javascript:call_link\('abencorresponding_constr_dupl.htm'\)) in the basic form of the component operator. Here, the target table must have a unique table key.

The source and the target may be the same. It should be noted, however, the target object is used directly (like in the statement [MOVE-CORRESPONDING](javascript:call_link\('abapmove-corresponding.htm'\))) and that no temporary intermediate result is created (unlike with the operator [CORRESPONDING](javascript:call_link\('abencorresponding_constr_arg_type.htm'\))).

Incorrect parameters passed to the methods of the class CL\_ABAP\_CORRESPONDING raised exceptions of the class CX\_CORR\_DYN\_ERROR.

Notes

-   The methods CREATE and EXECUTE of the system class CL\_ABAP\_CORRESPONDING produce an assignment similar to the statement

dst = [CORRESPONDING](javascript:call_link\('abencorresponding_constr_arg_type.htm'\))  #( BASE ( dst ) struct*|*itab [MAPPING ... EXCEPT ...](javascript:call_link\('abencorresponding_constr_mapping.htm'\)) ).

Here, the [mapping rule](javascript:call_link\('abencorresponding_constr_mapping.htm'\)) is specified dynamically, however, as the content of a special internal table.

-   The same restrictions apply as in the operator [CORRESPONDING](javascript:call_link\('abencorresponding_constr_arg_type.htm'\)). Components can only be mapped to each other if they are on the same level. Components in a substructure cannot be assigned to the components at higher levels, nor higher level components to components in a substructure.

-   The class CL\_ABAP\_CORRESPONDING always resolves tabular components, which is the same behavior as the operator [CORRESPONDING](javascript:call_link\('abencorresponding_constr_arg_type.htm'\)) when a mapping rule is specified. In this case, the addition DEEP is also set implicitly.

-   To achieve the same results for standalone in assignments between structures as in the operator [CORRESPONDING](javascript:call_link\('abencorresponding_constr_arg_type.htm'\)) without BASE, an initial structure can be assigned to the parameter destination.

-   In reflexive assignments between components of the same object, it should be noted that (like in [MOVE-CORRESPONDING](javascript:call_link\('abapmove-corresponding.htm'\))) the editing order is not defined and that a call of the method EXECUTE cannot be used to switch the content of two components. See the executable example [Reflexive Component Assignments](javascript:call_link\('abenreflexive_corresponding_abexa.htm'\)).

-   The [pseudo component](javascript:call_link\('abenpseudo_component_glosry.htm'\) "Glossary Entry") table\_line cannot be addressed in the mapping table.

Example

Uses the class CL\_ABAP\_CORRESPONDING for assignments of components to a simple structure. The mapping rule dictates that the components a3 are assigned to b1 and a1 to b3. The component a2 is ignored since there are no identically named components in the target structure and b2 keeps its value. a4 and a5 in the target structure also keep their values, however, even though the source structure contains identically named components. This is because the value of CL\_ABAP\_CORRESPONDING=>MAPPING\_EXCEPT\_ALL is specified for the mapping type for all non-specified components. The executable [example for simple structures](javascript:call_link\('abencl_abap_corr_dyn_abexa.htm'\)) enables interactive input of the component names that are mapped to each other.

DATA:
  BEGIN OF struct1,
    a1 TYPE string VALUE 'a1',
    a2 TYPE string VALUE 'a2',
    a3 TYPE string VALUE 'a3',
    a4 TYPE string VALUE 'a4',
    a5 TYPE string VALUE 'a5',
  END OF struct1,
  BEGIN OF struct2,
    b1 TYPE string VALUE 'b1',
    b2 TYPE string VALUE 'b2',
    b3 TYPE string VALUE 'b3',
    a4 TYPE string VALUE 'b4',
    a5 TYPE string VALUE 'b5',
  END OF struct2.
DATA(mapper) =
  cl\_abap\_corresponding=>create(
    source            = struct1
    destination       = struct2
    mapping           = VALUE cl\_abap\_corresponding=>mapping\_table(
      ( level = 0 kind = 1 srcname = 'a1' dstname = 'b3' )
      ( level = 0 kind = 1 srcname = 'a3' dstname = 'b1' )
      ( level = 0 kind = 3 ) ) ).
mapper->execute( EXPORTING source      = struct1
                 CHANGING  destination = struct2 ).
cl\_demo\_output=>display( struct2 ).

Executable Examples

-   [CL\_ABAP\_CORRESPONDING for Simple Structures](javascript:call_link\('abencl_abap_corr_dyn_abexa.htm'\))

-   [CL\_ABAP\_CORRESPONDING for Nested Structures](javascript:call_link\('abencl_abap_corr_struc_abexa.htm'\))

-   [CL\_ABAP\_CORRESPONDING for Internal Tables](javascript:call_link\('abencl_abap_corr_itab_abexa.htm'\))

-   [CL\_ABAP\_CORRESPONDING for Tabular Components](javascript:call_link\('abencl_abap_corr_deep_abexa.htm'\))



**📖 Source**: [abencl_abap_corresponding_1.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_corresponding_1.htm)

### abencl_abap_corresponding_3.htm

> **📖 Official SAP Documentation**: [abencl_abap_corresponding_3.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_corresponding_3.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assigning Structure Components](javascript:call_link\('abencorresponding.htm'\)) →  [CL\_ABAP\_CORRESPONDING - System Class](javascript:call_link\('abencl_abap_corresponding.htm'\)) → 

CL\_ABAP\_CORRESPONDING - Assignment of Values

The method CREATE\_WITH\_VALUE of the system class CL\_ABAP\_CORRESPONDING has essentially the same function as the method [CREATE](javascript:call_link\('abencl_abap_corresponding_1.htm'\)). Additionally, the values of any data objects can be assigned to the components of the target structure or target table.

The factory method CREATE\_WITH\_VALUE is used to create a mapping object:

DATA(mapper) =
  cl\_abap\_corresponding=>create\_with\_value( source                = struct*|*itab
                                            destination           = struct*|*itab
                                            mapping               = mapping\_tab
                                            discarding\_duplicates = flag ).

For the parameters source and destination, the same applies as to the method [CREATE](javascript:call_link\('abencl_abap_corresponding_1.htm'\)). An internal table of the type CL\_ABAP\_CORRESPONDING=>MAPPING\_TABLE\_VALUE, containing the mapping rule, must be passed to the parameter mapping. This mapping table has the same components, with the same meaning, as a mapping table of type [CL\_ABAP\_CORRESPONDING=>MAPPING\_TABLE](javascript:call_link\('abencl_abap_corresponding_1.htm'\)), with an additional column and further values for the column KIND:

-   VALUE

In this column, a reference to a suitable data object can be specified, whose value is assigned to the component of the target structure that is specified in DSTNAME.

-   KIND

The additional values for the mapping type are:

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_VALUE (16), the value specified in VALUE is always assigned. The column SRCNAME must be initial

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_DEFAULT\_VALUE (32), the value specified in VALUE is only assigned if the component specified in the column SRCNAME is initial. The component name in SRCNAME must exist in the source structure.

A mapping object created with CREATE\_WITH\_VALUE is used like a mapping object created with [CREATE](javascript:call_link\('abencl_abap_corresponding_1.htm'\)) with the method EXECUTE.

Example

The component b2 is given the value xxx and the component b3 is given the value yyy. The components b1 and b4 are given the values of the associated components a1 and a4 of the source structure.

DATA:
  BEGIN OF struct1,
    a1 TYPE string VALUE 'a1',
    a2 TYPE string VALUE 'a2',
    a3 TYPE string VALUE '  ',
    a4 TYPE string VALUE 'a4',
  END OF struct1,
  BEGIN OF struct2,
    b1 TYPE string VALUE 'b1',
    b2 TYPE string VALUE 'b2',
    b3 TYPE string VALUE 'b3',
    b4 TYPE string VALUE 'b4',
  END OF struct2.
DATA(mapper) =
  cl\_abap\_corresponding=>create\_with\_value(
    source            = struct1
    destination       = struct2
    mapping           = VALUE
      cl\_abap\_corresponding=>mapping\_table\_value(
        ( level = 0 kind = 1  srcname = 'a1' dstname = 'b1' )
        ( level = 0 kind = 16                dstname = 'b2'
                                             value = REF #( \`xxx\` ) )
        ( level = 0 kind = 32 srcname = 'a3' dstname = 'b3'
                                             value = REF #( \`yyy\` ) )
        ( level = 0 kind = 32 srcname = 'a4' dstname = 'b4'
                                             value = REF #( \`zzz\` ) )
         ) ).
mapper->execute( EXPORTING source      = struct1
                 CHANGING  destination = struct2 ).
cl\_demo\_output=>display( struct2 ).



**📖 Source**: [abencl_abap_corresponding_3.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_corresponding_3.htm)

### abencl_abap_corresponding_2.htm

> **📖 Official SAP Documentation**: [abencl_abap_corresponding_2.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_corresponding_2.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Assignments](javascript:call_link\('abenvalue_assignments.htm'\)) →  [Assigning Structure Components](javascript:call_link\('abencorresponding.htm'\)) →  [CL\_ABAP\_CORRESPONDING - System Class](javascript:call_link\('abencl_abap_corresponding.htm'\)) → 

CL\_ABAP\_CORRESPONDING - Lookup Table

The methods CREATE\_USING and EXECUTE\_USING of the system class CL\_ABAP\_CORRESPONDING can be used to assign components between internal tables with a dynamically specified mapping rule. The source table is used as a lookup table.

The factory method CREATE\_USING is used to create a mapping object:

DATA(mapper) = cl\_abap\_corresponding=>create\_using( destination = itab
                                                    using       = lookup\_tab
                                                    mapping     = mapping\_tab ).

Internal tables itab and lookup\_table, with the table types to which the assignment applies, must be passed to the parameters destination and using. An internal table of the type CL\_ABAP\_CORRESPONDING=>MAPPING\_TABLE, containing the mapping rule, must be passed to the parameter mapping. The mapping table has the same components as the methods for [simple assignments](javascript:call_link\('abencl_abap_corresponding_1.htm'\)) with the following special semantics:

-   KIND

Mapping type. The additional possible values are:

-   CL\_ABAP\_CORRESPONDING=>USING\_KEY (4), the table key of the lookup table used for the evaluation is specified in the component SRCNAME in this row. The table must contain a row like this.

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_USING\_COMPONENT (5), the name of a column of the lookup table in SRCNAME is associated with the name of a column of the target table in DSTNAME in a row like this. All key fields of the table key used must be covered by a row like this.

The mapping types for [simple assignments](javascript:call_link\('abencl_abap_corresponding_1.htm'\)) can also be used and have the same semantics as described here.

The method EXECUTE\_USING of a mapping object can be used to perform any number of assignments between tables lookup\_src and dst whose data type matches the source type or target type lookup\_tab or itab specified when the object was created:

mapper->execute\_using( EXPORTING using       = lookup\_src
                       CHANGING  destination = dst ).

For each row in dst, a row is found in the lookup table lookup\_src that matches this row in accordance with the relationship defined using the mapping type CL\_ABAP\_CORRESPONDING=>MAPPING\_USING\_COMPONENT in the mapping table. If the key is not unique, the first row found is used. If no row like this is found, the row from dst remains unchanged. If a row like this is found in lookup\_src, it is assigned to the row from dst in accordance with the rules of [MOVE-CORRESPONDING for structures](javascript:call_link\('abapmove-corresponding_structure.htm'\)) using the addition EXPANDING NESTED TABLES, with the following exception. The components used for the search are not assigned by default. The rows in the mapping table with mapping types for [simple assignments](javascript:call_link\('abencl_abap_corresponding_1.htm'\)) can be used to override the default assignment of identically named components and the default exclusion of the components used for the search. It is not possible to specify the same table for dst and lookup\_src; if specified, the runtime error CORRESPONDING\_SELF occurs.

Notes

-   The methods CREATE\_USING and EXECUTE\_USING of the system class CL\_ABAP\_CORRESPONDING produce an assignment similar to the statement

dst = [CORRESPONDING](javascript:call_link\('abencorresponding_constr_using.htm'\)) #( dst FROM lookup\_tab KEY key\_name ... ).

Here, however. the columns used to synchronize the target table and lookup table, plus the [mapping rule](javascript:call_link\('abencorresponding_constr_mapping.htm'\)) are specified dynamically as the content of a special internal table.

-   In the mapping table, the columns of the target table dst are part of the column DSTNAME, regardless of the mapping type, and the columns of the lookup table are part of the column SRCNAME. In the [CORRESPONDING](javascript:call_link\('abencorresponding_constr_using.htm'\)) operator, however, the arrangement of the operands after USING is different from the arrangement after MAPPING.

Example

The example displays the implementation of an example for component operator [CORRESPONDING with lookup table](javascript:call_link\('abencorresponding_constr_using.htm'\)) to class CL\_ABAP\_CORRESPONDING.

TYPES:
  BEGIN OF line,
    value   TYPE i,
    comment TYPE string,
  END OF line,
  itab1 TYPE STANDARD TABLE OF line WITH EMPTY KEY,
  itab2 TYPE HASHED TABLE OF line WITH UNIQUE KEY value.
DATA(itab1) = VALUE itab1( FOR i = 1 UNTIL i >= 10 ( value = i ) ).
DATA(itab2) = VALUE itab2( ( value = 2 comment = \`...\` )
                           ( value = 3 comment = \`...\` )
                           ( value = 5 comment = \`...\` )
                           ( value = 8 comment = \`...\` ) ).
DATA(mapping\_tab) = VALUE cl\_abap\_corresponding=>mapping\_table(
  ( level = 0 kind = 4 srcname = 'PRIMARY\_KEY' )
  ( level = 0 kind = 5 srcname = 'VALUE' dstname = 'VALUE' ) ).
cl\_abap\_corresponding=>create\_using(
     destination       = itab1
     using             = itab2
     mapping               = mapping\_tab
     )->execute\_using( EXPORTING using       = itab2
                       CHANGING  destination = itab1 ).
cl\_demo\_output=>display( itab1 ).

Executable Example

[CL\_ABAP\_CORRESPONDING with Lookup Table](javascript:call_link\('abencl_abap_corr_lookup_abexa.htm'\))


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Numeric Calculations / System Classes for Numbers

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Numeric Calculations / System Classes for Numbers

Included pages: 4



**📖 Source**: [abencl_abap_corresponding_2.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_corresponding_2.htm)

### abencl_abap_math.htm

> **📖 Official SAP Documentation**: [abencl_abap_math.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_math.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Numeric Calculations](javascript:call_link\('abencompute_expressions.htm'\)) → 

System Classes for Numbers

-   [System Class CL\_ABAP\_MATH](javascript:call_link\('abenfloating_point_class.htm'\))

-   [System Class CL\_ABAP\_DECFLOAT](javascript:call_link\('abencl_abap_decfloat_doc.htm'\))

-   [Random Numbers](javascript:call_link\('abenrandom_number_class.htm'\))

Continue
[System Class CL\_ABAP\_MATH](javascript:call_link\('abenfloating_point_class.htm'\))
[System Class CL\_ABAP\_DECFLOAT](javascript:call_link\('abencl_abap_decfloat_doc.htm'\))
[Random Numbers](javascript:call_link\('abenrandom_number_class.htm'\))



**📖 Source**: [abencl_abap_math.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_math.htm)

### abenfloating_point_class.htm

> **📖 Official SAP Documentation**: [abenfloating_point_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenfloating_point_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Numeric Calculations](javascript:call_link\('abencompute_expressions.htm'\)) →  [System Classes for Numbers](javascript:call_link\('abencl_abap_math.htm'\)) → 

System Class CL\_ABAP\_MATH

-   [Constants for Minimum and Maximum Values](#abenfloating-point-class-1--------operations-with-floating-point-numbers---@ITOC@@ABENFLOATING_POINT_CLASS_2)

-   [Rounding Binary Floating Point Numbers](#abenfloating-point-class-3--------operations-with-decimal-floating-point-numbers---@ITOC@@ABENFLOATING_POINT_CLASS_4)

Constants for Minimum and Maximum Values

The class CL\_ABAP\_MATH contains constants with the limits of the value ranges [built-in numeric types](javascript:call_link\('abenbuiltin_types_numeric.htm'\)).

Example

Displays the minimum values and maximum values of numeric types.

cl\_demo\_output=>display(
  |i:          { cl\_abap\_math=>min\_int4 WIDTH = 20
          } to { cl\_abap\_math=>max\_int4 WIDTH = 20 } \\n| &&
  |int8:       { cl\_abap\_math=>min\_int8 WIDTH = 20
          } to { cl\_abap\_math=>max\_int8 WIDTH = 20 } \\n| &&
  |decfloat16: { cl\_abap\_math=>min\_decfloat16 STYLE = SCIENTIFIC
                                              WIDTH = 20
          } to { cl\_abap\_math=>max\_decfloat16 STYLE = SCIENTIFIC
                                              WIDTH = 20 } \\n| &&
  |decfloat34: { cl\_abap\_math=>min\_decfloat34 STYLE = SCIENTIFIC
                                              WIDTH = 20
          } to { cl\_abap\_math=>max\_decfloat34 STYLE = SCIENTIFIC
                                              WIDTH = 20 } \\n| ).

Operations with Floating Point Numbers

The class CL\_ABAP\_MATH contains methods for operations with floating point numbers.

Rounding Binary Floating Point Numbers

The method ROUND\_F\_TO\_15\_DECS rounds a [binary floating point number](javascript:call_link\('abenbinfloat_glosry.htm'\) "Glossary Entry") to 15 places using commercial rounding.

Note

Commercial rounding to 15 digits can also be done using the built-in function [round](javascript:call_link\('abendec_floating_point_functions.htm'\)), the result of which then has the decfloat34 type.

Example

The example shows how rounding errors in the output formatting of binary floating point numbers can be prevented by two-step rounding using the method ROUND\_F\_TO\_15\_DECS. Instead of the method call, the function call round( val = float dec = 15 ) can be used here.

DATA float TYPE f VALUE '1.005'.
cl\_demo\_output=>display(
  |{ float DECIMALS = 2 }\\n| &&
  |{ cl\_abap\_math=>round\_f\_to\_15\_decs( float ) DECIMALS = 2 }\\n| ).

Operations with Decimal Floating Point Numbers

-   The method GET\_SCALE gets the [scaling](javascript:call_link\('abenscale_glosry.htm'\) "Glossary Entry") of a [decimal floating point number](javascript:call_link\('abendecfloat_glosry.htm'\) "Glossary Entry").

-   The method GET\_NUMBER\_OF\_DIGITS gets the [precision](javascript:call_link\('abenprecision_glosry.htm'\) "Glossary Entry") of a [decimal floating point number](javascript:call_link\('abendecfloat_glosry.htm'\) "Glossary Entry").

-   The method NORMALIZE gets a normalized floating point number. This means that the [scaling](javascript:call_link\('abenscale_glosry.htm'\) "Glossary Entry") and [precision](javascript:call_link\('abenprecision_glosry.htm'\) "Glossary Entry") of an input value are changed so that the mantissa has no trailing zeroes.

-   The method GET\_SCALE\_NORMALIZED gets the [scaling](javascript:call_link\('abenscale_glosry.htm'\) "Glossary Entry") of a normalized [decimal floating point number](javascript:call_link\('abendecfloat_glosry.htm'\) "Glossary Entry"). If the input value has decimal places, the return value is the number of decimal places without trailing zeroes.

-   The method GET\_MAX\_DB\_VALUE gets the maximum value of a number of the type DF16\_DEC or DF34\_DEC on the database.

-   The method GET\_DB\_LENGTH\_DECS gets the length and number of decimal places of a number of the type DF16\_DEC or DF34\_DEC on the database.

Note

The [rounding functions](javascript:call_link\('abenrounding_function_glosry.htm'\) "Glossary Entry") round and rescale can be used to round and rescale decimal floating point numbers.

Example

Displays the scaling and precision of a decimal floating point number.

DATA(decf) = CONV decfloat34( '1234.56789' ).
cl\_demo\_output=>display(
|value = { decf
}\\nscale = { cl\_abap\_math=>get\_scale( decf )
}\\nprecision = { cl\_abap\_math=>get\_number\_of\_digits( decf ) }| ).



**📖 Source**: [abenfloating_point_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenfloating_point_class.htm)

### abencl_abap_decfloat_doc.htm

> **📖 Official SAP Documentation**: [abencl_abap_decfloat_doc.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_decfloat_doc.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Numeric Calculations](javascript:call_link\('abencompute_expressions.htm'\)) →  [System Classes for Numbers](javascript:call_link\('abencl_abap_math.htm'\)) → 

System Class CL\_ABAP\_DECFLOAT

The system class CL\_ABAP\_DECFLOAT contains methods for handling [decimal floating point numbers](javascript:call_link\('abendecfloat_glosry.htm'\) "Glossary Entry").

-   The methods READ\_DECFLOAT34 and READ\_DECFLOAT16 convert strings to decimal floating point numbers. The exceptions of these methods are more significant than those of a normal assignment. Furthermore, the methods return a return value that reveals information about the roundings performed.

-   The methods CONVERT\_CURR\_TO\_DECFLOAT and CONVERT\_DECFLOAT\_TO\_CURR convert currency amounts to decimal floating point numbers (and back) as specified by a currency key.



**📖 Source**: [abencl_abap_decfloat_doc.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_decfloat_doc.htm)

### abenrandom_number_class.htm

> **📖 Official SAP Documentation**: [abenrandom_number_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrandom_number_class.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Numeric Calculations](javascript:call_link\('abencompute_expressions.htm'\)) →  [System Classes for Numbers](javascript:call_link\('abencl_abap_math.htm'\)) → 

Random Numbers

The class CL\_ABAP\_RANDOM calls the pseudo random number generator Mersenne Twister for different numeric types.

For the one-dimensional case, the following special classes generate random numbers for the different numeric types:

Example

Creates a pseudo random number of the type i between 1 and 100 (initialized by the system time).

DATA(r) = cl\_abap\_random\_int=>create( seed = CONV i( sy-uzeit )
                                      min  = 1
                                      max  = 100 ).


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Character String and Byte String Processing / System Classes for Character String and Byte String Processing

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Character String and Byte String Processing / System Classes for Character String and Byte String Processing

Included pages: 5



**📖 Source**: [abenrandom_number_class.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrandom_number_class.htm)

### abencl_abap_string_utilities.htm

> **📖 Official SAP Documentation**: [abencl_abap_string_utilities.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_string_utilities.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Character String and Byte String Processing](javascript:call_link\('abenabap_data_string.htm'\)) → 

System Classes for Character String and Byte String Processing

-   [Class for Trailing Blanks](javascript:call_link\('abenstring_util.htm'\))

-   [Class for Compressing Character Strings and Byte Strings](javascript:call_link\('abencl_abap_gzip.htm'\))

-   [Class with Utilities for String Processing](javascript:call_link\('abencl_abap_char_utilities.htm'\))

-   [Methods for Handling Code Pages](javascript:call_link\('abencl_abap_conv_codepage.htm'\))

Continue
[Class for Trailing Blanks](javascript:call_link\('abenstring_util.htm'\))
[Class for Compressing Character Strings and Byte Strings](javascript:call_link\('abencl_abap_gzip.htm'\))
[Class with Utilities for String Processing](javascript:call_link\('abencl_abap_char_utilities.htm'\))
[Methods for Handling Code Pages](javascript:call_link\('abencl_abap_conv_codepage.htm'\))



**📖 Source**: [abencl_abap_string_utilities.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_string_utilities.htm)

### abenstring_util.htm

> **📖 Official SAP Documentation**: [abenstring_util.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenstring_util.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Character String and Byte String Processing](javascript:call_link\('abenabap_data_string.htm'\)) →  [System Classes for Character String and Byte String Processing](javascript:call_link\('abencl_abap_string_utilities.htm'\)) → 

Class for Trailing Blanks

The class CL\_ABAP\_STRING\_UTILITIES contains methods for processing [text strings](javascript:call_link\('abentext_string_glosry.htm'\) "Glossary Entry").

-   C2STR\_PRESERVING\_BLANKS assigns text fields while preserving the trailing blanks.

-   DEL\_TRAILING\_BLANKS deletes the trailing blanks from strings.

Note

Tasks like this can now also be performed using statements and built-in functions.

Example

The program compares the method C2STR\_PRESERVING\_BLANKS with the built-in function [shift\_right](javascript:call_link\('abenshift_functions.htm'\)). The implementation of the method now consists of nothing more than this function.

DATA(str) = \`abc   \`.
DATA(rslt) = str.
cl\_abap\_string\_utilities=>del\_trailing\_blanks( CHANGING str = rslt ).
ASSERT rslt =  shift\_right( str ).



**📖 Source**: [abenstring_util.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenstring_util.htm)

### abencl_abap_gzip.htm

> **📖 Official SAP Documentation**: [abencl_abap_gzip.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_gzip.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Character String and Byte String Processing](javascript:call_link\('abenabap_data_string.htm'\)) →  [System Classes for Character String and Byte String Processing](javascript:call_link\('abencl_abap_string_utilities.htm'\)) → 

Class for Compressing Character Strings and Byte Strings

These classes offer a range of methods that enable text in text fields or text strings, or binary data in byte fields or byte strings to be compressed or decompressed using GZIP.

For more information, see the individual classes and methods.

Example

Compression and decompression of text.

DATA zip TYPE xstring.
cl\_abap\_gzip=>compress\_text(
  EXPORTING text\_in  = \`Hello!\`
  IMPORTING gzip\_out = zip ).
DATA txt TYPE string.
cl\_abap\_gzip=>decompress\_text(
  EXPORTING gzip\_in  = zip
  IMPORTING text\_out = txt ).
ASSERT txt = \`Hello!\`.



**📖 Source**: [abencl_abap_gzip.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_gzip.htm)

### abencl_abap_char_utilities.htm

> **📖 Official SAP Documentation**: [abencl_abap_char_utilities.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_char_utilities.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Character String and Byte String Processing](javascript:call_link\('abenabap_data_string.htm'\)) →  [System Classes for Character String and Byte String Processing](javascript:call_link\('abencl_abap_string_utilities.htm'\)) → 

Class with Utilities for String Processing

The class CL\_ABAP\_CHAR\_UTILITIES provides attributes and methods as utilities for string processing.

The components of this class are all static and public. The attributes are read-only and are initialized in the class constructor. Details about the attributes and methods of this class are described in the class documentation.

Example

The following rows demonstrate that attributes of the class CL\_ABAP\_CHAR\_UTILITIES containing control characters can be replaced by a representation of the [control characters](javascript:call_link\('abenstring_templates_separators.htm'\)) in a [string template](javascript:call_link\('abenstring_template_glosry.htm'\) "Glossary Entry") .

ASSERT cl\_abap\_char\_utilities=>newline        = |\\n|.
ASSERT cl\_abap\_char\_utilities=>horizontal\_tab = |\\t|.
ASSERT cl\_abap\_char\_utilities=>cr\_lf          = |\\r\\n|.



**📖 Source**: [abencl_abap_char_utilities.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_char_utilities.htm)

### abencl_abap_conv_codepage.htm

> **📖 Official SAP Documentation**: [abencl_abap_conv_codepage.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_conv_codepage.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Character String and Byte String Processing](javascript:call_link\('abenabap_data_string.htm'\)) →  [System Classes for Character String and Byte String Processing](javascript:call_link\('abencl_abap_string_utilities.htm'\)) → 

Methods for Handling Code Pages

The methods CONVERT of the interfaces IF\_ABAP\_CONV\_OUT and IF\_ABAP\_CONV\_IN of objects created with the class CL\_ABAP\_CONV\_CODEPAGE make it possible to convert strings to the binary representation of various code pages (and back again).

Example

Converts the content of a string into its UTF-8 representation. The value "UTF-8" is the default value for the parameter CODEPAGE and can be omitted if required. The statement [ASSERT](javascript:call_link\('abapassert.htm'\)) shows that the reverse conversion creates the original text.

DATA(str) = \`Blah blah ...\`.
DATA(xstr) =
  cl\_abap\_conv\_codepage=>create\_out( codepage = \`UTF-8\`
    )->convert( source = str ).
ASSERT
  cl\_abap\_conv\_codepage=>create\_in( codepage = \`UTF-8\`
    )->convert( source = xstr ) = str.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Enumerated Objects

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Enumerated Objects

Included pages: 4



**📖 Source**: [abencl_abap_conv_codepage.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_conv_codepage.htm)

### abenenumerated_types_usage.htm

> **📖 Official SAP Documentation**: [abenenumerated_types_usage.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenenumerated_types_usage.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) → 

Enumerated Objects

This section summarizes the use of [enumerated objects](javascript:call_link\('abenenumerated_object_glosry.htm'\) "Glossary Entry") (data objects with [enumerated types](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry").

-   [Declaration](#abenenumerated-types-usage-1--------processing-of-enumerated-objects---@ITOC@@ABENENUMERATED_TYPES_USAGE_2)

-   [Operand Positions for Enumerated Objects](#abenenumerated-types-usage-3--------value-assignments---@ITOC@@ABENENUMERATED_TYPES_USAGE_4)

-   [Comparisons](#abenenumerated-types-usage-5--------typing-of-formal-parameters-and-field-symbols---@ITOC@@ABENENUMERATED_TYPES_USAGE_6)

-   [Access to the Enumerated Value](#abenenumerated-types-usage-7--------type-descriptions---@ITOC@@ABENENUMERATED_TYPES_USAGE_8)

-   [Data interfaces](#abenenumerated-types-usage-9--------forbidden-uses---@ITOC@@ABENENUMERATED_TYPES_USAGE_10)

Executable Example

[Enumerated Objects, Use](javascript:call_link\('abenenum_usage_abexa.htm'\))

Declaration

An enumerated object is a data object with an [enumerated type](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry") defined by one of the following TYPES statements:

[TYPES BEGIN OF ENUM enum\_type ...](javascript:call_link\('abaptypes_enum.htm'\))
  [TYPES val1 ...](javascript:call_link\('abaptypes_enum.htm'\))
  [TYPES val2 ...](javascript:call_link\('abaptypes_enum.htm'\))
  ...
[TYPES END OF ENUM enum\_type ...](javascript:call_link\('abaptypes_enum.htm'\))

The technical data type of the content of an enumerated object is the [base type](javascript:call_link\('abenbase_type_glosry.htm'\) "Glossary Entry") of the enumerated type. The potential content is defined by the [enumerated values](javascript:call_link\('abenenumerated_value_glosry.htm'\) "Glossary Entry") defined using TYPES val1, TYPES val2, ..., of which at least one value must have the type-dependent initial value. The base type is i by default but it can be a different elementary data type. The following enumerated objects exist:

-   Enumerated variables

An [enumerated variable](javascript:call_link\('abenenumerated_variable_glosry.htm'\) "Glossary Entry") is a variable defined using

[DATA enum\_var TYPE enum\_type ...](javascript:call_link\('abapdata_enum.htm'\))

that can contain only [enumerated values](javascript:call_link\('abenenumerated_value_glosry.htm'\) "Glossary Entry") of the enumerated type. This is ensured by the ABAP runtime environment and the rules for using enumerated types.

-   Enumeration constants

An [enumeration constant](javascript:call_link\('abenenumerated_constant_glosry.htm'\) "Glossary Entry") is used to define a value in the value set of an enumerated type. In the definition of an enumerated type, it is defined using

[TYPES val ...](javascript:call_link\('abaptypes_enum.htm'\))

under the name val. This constant is a constant of the context of its definition and contains the [enumerated value](javascript:call_link\('abenenumerated_value_glosry.htm'\) "Glossary Entry") assigned in the definition. It can be specified in all reading positions in which enumerated objects are possible. Its enumerated value is either determined automatically as a whole number or can be specified explicitly in the definition.

-   Components of enumeration structures

A component of an [enumeration structure](javascript:call_link\('abenenumerated_structure_glosry.htm'\) "Glossary Entry") is a special form of an enumeration constant that exists as a component of a constant structure and not as a single data object. The enumeration structure struc is defined using

[TYPES BEGIN OF ENUM enum\_type STRUCTURE struc ...](javascript:call_link\('abaptypes_enum.htm'\))

. This makes the enumeration constants defined using

[TYPES val ...](javascript:call_link\('abaptypes_enum.htm'\))

into their structure components. Otherwise, the same applies as to regular enumeration constants.

Notes

-   Enumerated objects are mainly used to check permitted values. This usually restricts the actual parameters passed to methods to the enumerated values defined in the class.

-   The base type and the actual enumerated value are almost always ignored when enumerated objects are used. Assignments and comparisons are usually only made between enumerated objects with the same enumerated type.

-   Base types other than i and the actual enumerated values may be significant in transformations between enumerated type or in migrations of predecessor concepts.

-   Enumeration structures can be used to avoid naming conflicts if there are multiple enumerated types in a single namespace. Enumeration structures can be used to enable the use of the same enumeration constant name in multiple enumerated types.

Example

Declares an enumerated type size in a class. The method parameter size has the enumerated type and only enumerated objects of this type can be passed to this parameter. This example show how the enumeration constant demo=>l is passed. This guarantees that only enumerated values of the enumerated type can be passed to the parameter. These values can be evaluated in comparisons with the enumeration constants. In the CASE control structure shown here, the statement block after WHEN OTHERS can be reached only when demo=>xl and demo=>xxl are passed.

CLASS demo DEFINITION.
  PUBLIC SECTION.
    TYPES:
      BEGIN OF ENUM size,
        s, m, l, xl, xxl,
      END OF ENUM size.
    CLASS-METHODS main
      IMPORTING size TYPE size.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    CASE size.
      WHEN s.
        ...
      WHEN m.
        ...
      WHEN l.
        ...
      WHEN OTHERS.
        ...
    ENDCASE.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( demo=>l ).

Processing of Enumerated Objects

Enumerated objects are almost always processed independently of the base type of the enumerated type. Only the enumerated type itself is of relevance for all rules specified here. Assignments of enumerated objects with a numeric base type, for example, cannot be assigned to numeric target fields and cannot be compared with numeric fields. The enumerated vale in the base type can be accessed using the constructor operators [CONV](javascript:call_link\('abenconv_constructor_enum.htm'\)) and [EXACT](javascript:call_link\('abenexact_constructor_enum.htm'\)) only.

Operand Positions for Enumerated Objects

-   Reading positions

Enumerated objects can be used in all [reading positions](javascript:call_link\('abendata_objects_usage_reading.htm'\)) in which the operand type is their enumerated type or in which the operand is converted to one of the character-like types c or string. [Substring access](javascript:call_link\('abenoffset_length.htm'\)) is not possible.

-   Writing positions

Enumerated variables can only be used in [writing positions](javascript:call_link\('abendata_objects_usage_writing.htm'\)) in which the operand type is the enumerated type and only the associated enumerated values can be written. If known statically, an attempt to assign a value other than a valid enumerated value to an enumerated variable produces a syntax error. If not known statically, an exception is raised.

Example

In the first assignment, the enumeration constant xl in a reading position is assigned to the enumerated variable size in a writing position. The string expression in the second half exploits the fact that the enumeration constants are converted implicitly to the type string before the chaining. The result is SMLXLXXL.

TYPES:
  BEGIN OF ENUM size,
    s, m, l, xl, xxl,
  END OF ENUM size.
DATA size TYPE size.
size = xl.
DATA(str) = s && m && l && xl && xxl.

Value Assignments

Only enumerated objects with the same enumerated type can be assigned to an enumerated variable. In the assignment, the target field is given the enumerated value of the source field.

The initial value of the base type is always a valid enumerated value of an enumerated type. Accordingly, an enumerated variable can be set to the initial value of its base type using [CLEAR](javascript:call_link\('abapclear.htm'\)). Assignments of [VALUE enum\_type( )](javascript:call_link\('abenvalue_constructor_params_init.htm'\)) are also possible.

In the reverse case, enumerated objects can only be assigned to compatible enumerated variables, with the following exception: There is a [conversion rule](javascript:call_link\('abenconversion_enumerated.htm'\)) for assignments of enumerated objects to character-like variables of the types c and string. In this case, the target field is assigned the name of the enumeration constant or of the component of the enumeration structure under which the enumerated value of the source field is defined in the enumerated type-

In structures, each component comprises a separate fragment of the [Unicode fragment view](javascript:call_link\('abenunicode_fragment_view.htm'\)) using an enumerated type. In assignments between structures of this type, the fragment views must match. This makes sure that only components with the same enumerated type can be assigned to each other.

Example

In the first assignment, the enumeration constant sz-xl is assigned to the enumerated variable size of its enumerated type. This variable then contains the associated enumerated value 3. In the second assignment, the enumeration constant is assigned to the text string size\_string. This string is given the value XL in accordance with the conversion rule.

TYPES:
  BEGIN OF ENUM size STRUCTURE sz,
    s, m, l, xl, xxl,
  END OF ENUM size STRUCTURE sz.
DATA size TYPE size.
size = sz-xl.
DATA size\_string TYPE string.
size\_string = sz-xl.

Comparisons

In comparisons between enumerated objects, the [comparison rule](javascript:call_link\('abenlogexp_rules_operands_enum.htm'\)) applies that an enumerated object can only be compared with an enumerated object with the same enumerated type. Here, the values of the operands are compared in accordance with their base type.

Each enumerated type has an initial enumerated value, which makes checks with the predicate expression [IS INITIAL](javascript:call_link\('abenlogexp_initial.htm'\)) possible.

Example

The first comparison shows a typical case where an enumerated variable is compared with an enumeration constant. The syntax of the second comparison (in a comment) is not possible. In the third comparison, the enumerated variable is converted explicitly to the type string before the comparison with a text string.

TYPES:
  BEGIN OF ENUM size,
    s, m, l, xl, xxl,
  END OF ENUM size.
DATA size TYPE size.
...
IF size = xl.
ENDIF.
"IF size = \`XL\`. "<--- Syntax error
"ENDIF.
IF CONV string( size ) = \`XL\`.
ENDIF.

Typing of Formal Parameters and Field Symbols

If [formal parameters](javascript:call_link\('abenformal_parameter_glosry.htm'\) "Glossary Entry") of procedures or [field symbols](javascript:call_link\('abenfield_symbol_glosry.htm'\) "Glossary Entry") are [typed](javascript:call_link\('abentyping.htm'\)) with an enumerated type, only enumerated objects with the same enumerated type can be assigned to them. As usual, an exception to this are return values of functional methods that can also be assigned to character-like objects of the types c and string.

Enumerated types are covered by the generic types [any](javascript:call_link\('abenbuilt_in_types_generic.htm'\)), [data](javascript:call_link\('abenbuilt_in_types_generic.htm'\)), and [simple](javascript:call_link\('abenbuilt_in_types_generic.htm'\)). When an enumerated object is passed to generically typed formal parameters or in assignments to generically typed field symbols, these are given the enumerated type. In assignments to field symbols, castings with the [CASTING](javascript:call_link\('abapassign_casting.htm'\)) addition are not possible and an enumerated type cannot be specified after this addition.

When generically typed formal parameters or field symbols are used for enumerated objects, the restriction applies that only statically known operands with the same [enumerated type](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry") are permitted in [reading positions](javascript:call_link\('abenreading_position_glosry.htm'\) "Glossary Entry") in which an [enumerated object](javascript:call_link\('abenenumerated_object_glosry.htm'\) "Glossary Entry") is expected and this is known statically. This affects, for example, the source field of an assignment to an [enumerated variable](javascript:call_link\('abenenumerated_variable_glosry.htm'\) "Glossary Entry") or an operand compared with an enumerated object. In [writing positions](javascript:call_link\('abenwriting_position_glosry.htm'\) "Glossary Entry") for enumerated objects, however, generic formal parameters or field symbols are allowed for enumerated types. If the operand type is not known statically, the check is only made at runtime in reading positions too.

Example

The field symbol fs1 typed generically with simple cannot be assigned to an enumerated variable size known statically or compared with it. An assignment of size to the field symbol and fully generic handling are, however, possible.

TYPES:
  BEGIN OF ENUM size,
    s, m, l, xl, xxl,
  END OF ENUM size.
FIELD-SYMBOLS <fs1> TYPE simple.
FIELD-SYMBOLS <fs2> TYPE simple.
DATA(size) = xl.
ASSIGN size TO <fs1>.
ASSIGN size TO <fs2>.
<fs1> = size.
"size = <fs1>.        "<--- Syntax error
"ASSERT size = <fs1>. "<--- Syntax error
<fs2> = <fs1>.
ASSERT <fs1> = <fs2>.

Access to the Enumerated Value

A special [rule](javascript:call_link\('abenconv_constructor_enum.htm'\)) for the conversion operator [CONV](javascript:call_link\('abenconstructor_expression_conv.htm'\)) applies when accessing the enumerated value of an enumerated object:

[... CONV base\_type( enum\_dobj ) ...](javascript:call_link\('abenconv_constructor_enum.htm'\))

When the base type base\_type of an enumerated object enum\_dobj specified as an argument is specified directly or indirectly, CONV returns its enumerated value.

In the reverse case, a valid enumerated value can be converted to an enumerated object:

[... CONV enum\_type( dobj ) ...](javascript:call_link\('abenconv_constructor_enum.htm'\))

The argument dobj is converted to the base type of the enumerated type enum\_type and CONV returns an enumerated object with this value. Any invalid values raise an exception.

In combinations of these two variants (in which CONV base\_type( enum\_dobj ) is used as an argument dobj of CONV enum\_type( dobj )), there is a short form:

[... CONV enum\_type( enum\_dobj ) ...](javascript:call_link\('abenconv_constructor_enum.htm'\))

If different enumerated types can have the same base type, an enumerated object of an enumerated type can be converted to the corresponding enumerated object of a different enumerated type.

Note

The corresponding [rules](javascript:call_link\('abenexact_constructor_enum.htm'\)) applies to the lossless operator [EXACT](javascript:call_link\('abenconstructor_expression_exact.htm'\)). Here, additional losslessness checks are made.

Example

The inner conversion operator CONV accesses the current enumerated value of the enumerated object size and returns it in the type i. The outer conversion operator CONV converts the result of the addition back to an enumerated type and assigns this enumerated value to the enumerated variable size. The enumerated value in size is raised by one in each iteration. The final result is the value of the enumeration constant xxl.

TYPES:
  BEGIN OF ENUM size,
    s, m, l, xl, xxl,
  END OF ENUM size.
DATA size TYPE size.
DO 4 TIMES.
  size = CONV #( CONV i( size ) + 1 ).
ENDDO.

Type Descriptions

The type returned for an enumerated object by the statement [DESCRIBE FIELD](javascript:call_link\('abapdescribe_field.htm'\)) is k. The length is the length of the enumerated value in the base type in bytes.

In [RTTS](javascript:call_link\('abenrun_time_type_services_glosry.htm'\) "Glossary Entry"), enumerated objects are described by objects of the class CL\_ABAP\_ENUMDESCR. This class can be used for [RTTI](javascript:call_link\('abenrun_time_type_identific_glosry.htm'\) "Glossary Entry") and [RTTC](javascript:call_link\('abenrun_time_type_creation_glosry.htm'\) "Glossary Entry") purposes. Like any enumerated type, an enumerated type created using RTTC is only compatible with itself.

The following attributes exist in a type description of the class CL\_ABAP\_ENUMDESCR:

-   KIND always has the value E for the elementary base type

-   TYPE\_KIND always has the value k (as in the statement DESCRIBE FIELD)

-   BASE\_TYPE\_KIND describes the base type

-   MEMBERS is a table of the enumeration constants and the associated enumerated values

Executable Example

[Enumerated Objects, Type Description](javascript:call_link\('abenenum_description_abexa.htm'\))

Data interfaces

The following data interfaces support enumerated types:

The character-like representation of enumerated objects (namely the result of a c or string) is used for their output and serialization. The output consists of the name (with a maximum of thirty characters) of the enumeration constant of the current enumerated value in uppercase. Deserializations are performed in the reverse direction. The following are supported:

-   [Data clusters](javascript:call_link\('abendata_cluster_glosry.htm'\) "Glossary Entry") with the statements [EXPORT](javascript:call_link\('abapexport_data_cluster.htm'\)) and [IMPORT](javascript:call_link\('abapimport_data_cluster.htm'\)). When an enumerated object is exported, the enumerated value is saved in the base type and flagged as an enumerated value. Both enumerated objects and exported data objects of the base type can be imported to a suitable enumerated object (the value is checked here). No exported enumerated objects, however, can be exported to data objects of the base type.

-   [ABAP file interface](javascript:call_link\('abenfile_interface_glosry.htm'\) "Glossary Entry") with the statements [TRANSFER](javascript:call_link\('abaptransfer.htm'\)) and [READ DATASET](javascript:call_link\('abapread_dataset.htm'\)). In writes to a file and reads from a file, enumerated objects are handled like data objects of its base type. In reads from a file to an enumerated object, the value is checked to see whether it is a valid enumerated value.

-   Serializations and deserializations from and to [XML](javascript:call_link\('abenxml_glosry.htm'\) "Glossary Entry") and [JSON](javascript:call_link\('abenjson_glosry.htm'\) "Glossary Entry"). The formats [asXML](javascript:call_link\('abenabap_xslt_asxml_enum.htm'\)) and [asJSON](javascript:call_link\('abenabap_asjson_abap_types_enum.htm'\)) represent the content of enumerated objects in their character-like representation (the name of the enumeration constant of the current enumerated value). Only valid names are allowed in deserializations to an enumerated object.

-   List output with the statement [WRITE](javascript:call_link\('abapwrite-.htm'\)). Like [WRITE TO](javascript:call_link\('abapwrite_to.htm'\)), this statement converts an enumerated object to its character-like representation (the name of the enumeration constant of the current enumerated value). The [output length](javascript:call_link\('abenwrite_output_length.htm'\)) is the same as the maximum length of the name (30 characters).

Note

A deserialization of a name of an enumeration constant is one of the few ways of creating an enumerated value from the name in full and dynamically.

Example

WRITE output of the enumeration constants of an enumeration structure.

TYPES:
  BEGIN OF ENUM size STRUCTURE sz,
    s, m, l, xl, xxl,
  END OF ENUM size STRUCTURE sz.
WHILE sy-subrc = 0.
  ASSIGN COMPONENT sy-index OF STRUCTURE sz TO FIELD-SYMBOL(<fs>).
  IF sy-subrc = 0.
    WRITE / <fs>.
  ENDIF.
ENDWHILE.

Executable Example

[Enumerated Objects, Deserialization](javascript:call_link\('abenenum_deserialization_abexa.htm'\))

Forbidden Uses

The following uses are forbidden to ensure that an enumerated object only ever contains a single valid enumerated value:

-   Within ABAP, enumerated objects are never interpreted in accordance with their base type. This means that they cannot be used in operand positions that expect numeric, character-like, or byte-like data types. The only exception to this are the operand positions in which an implicit conversion to a character-like type takes place.

-   Enumerated types are not currently supported by [ABAP Dictionary](javascript:call_link\('abenabap_dictionary.htm'\)). Accordingly, no database tables whose columns have an enumerated type can be defined in ABAP Dictionary.

-   In both ABAP SQL and Native SQL ([EXEC SQL](javascript:call_link\('abapexec.htm'\)), [ADBC](javascript:call_link\('abenadbc_glosry.htm'\) "Glossary Entry")), no [host variables](javascript:call_link\('abenhost_variable_glosry.htm'\) "Glossary Entry") or references to ABAP variables with enumerated type can be used. The actual parameters of [AMDP methods](javascript:call_link\('abenamdp_method_glosry.htm'\) "Glossary Entry") cannot be typed using enumerated types.

-   No enumerated types are supported for the input fields of [selection screens](javascript:call_link\('abenselection_screen_glosry.htm'\) "Glossary Entry").

-   It is not possible to use enumerated values from [lists in the list buffer](javascript:call_link\('abenabap_lists_complex.htm'\)), since there are no conversion rules between character-like types and enumerated types.

If an enumerated object is provided with an invalid value due to a gap in the rules, this results in the following behavior:

-   The result of a conversion to c or string is the string <illegal enum value>, which is displayed accordingly in the ABAP Debugger.

-   An enumerated object with an invalid value can be assigned to other enumerated objects with the same enumerated type without being checked.

-   The expressions [CONV base\_type( enum\_dobj )](javascript:call_link\('abenconv_constructor_enum.htm'\)) and [EXACT base\_type( enum\_dobj )](javascript:call_link\('abenexact_constructor_enum.htm'\)) return the invalid value.

An invalid value must be viewed as an error and should never occur.

Note

Classic [Dynpros](javascript:call_link\('abendynpro_glosry.htm'\) "Glossary Entry") represent a known gap. Enumerated types are not supported by dynpros. When dynpro input fields are taken from a program by using enumerated objects, they are handled like an object of the base type. Any invalid values are passed to the associated enumerated object in the event [PAI](javascript:call_link\('abenpai_glosry.htm'\) "Glossary Entry") without being checked. For this reason, enumerated objects should never be associated with classic dynpros.

Example

The program DEMO\_ENUM\_DYNPRO uses an enumerated object on a dynpro. This can produce invalid values in the program.

Continue
![Example](exa.gif "Example") [Enumerated Objects, Use](javascript:call_link\('abenenum_usage_abexa.htm'\))
![Example](exa.gif "Example") [Enumerated Objects, Type Description](javascript:call_link\('abenenum_description_abexa.htm'\))
![Example](exa.gif "Example") [Enumerated Objects, Deserialization](javascript:call_link\('abenenum_deserialization_abexa.htm'\))



**📖 Source**: [abenenumerated_types_usage.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenenumerated_types_usage.htm)

### abenenum_usage_abexa.htm

> **📖 Official SAP Documentation**: [abenenum_usage_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenenum_usage_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Enumerated Objects](javascript:call_link\('abenenumerated_types_usage.htm'\)) → 

Enumerated Objects, Use

This example demonstrates the use of [enumerated types](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry").

Source Code

REPORT demo\_enumerated\_types.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA html TYPE string.
    CLASS-METHODS:
      class\_constructor,
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: size   TYPE  cl\_demo\_wrap\_browser=>size
                 VALUE cl\_demo\_wrap\_browser=>sz-l,
          format TYPE  cl\_demo\_wrap\_browser=>format
                 VALUE cl\_demo\_wrap\_browser=>fmt-l.
    cl\_demo\_input=>add\_field( EXPORTING text = \`Size (S, M, L, XL)\`
                              CHANGING  field = size ).
    cl\_demo\_input=>request(   EXPORTING text  = \`Format (L, P)\`
                              CHANGING  field = format ).
    cl\_demo\_wrap\_browser=>show( html   = html
                                size   = size
                                format = format ).  ENDMETHOD.
  METHOD class\_constructor.
    cl\_abap\_docu\_external=>get\_abap\_docu\_for\_adt(
       EXPORTING
        language = COND #( WHEN sy-langu = 'D' THEN 'DE' ELSE 'EN' )
      IMPORTING
        html     = html  ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The program calls the method SHOW of class CL\_DEMO\_WRAP\_BROWSER . Two enumerated types are defined as follows in this class:

TYPES:
  BEGIN OF ENUM size STRUCTURE sz,
    s, m, l, xl,
  END OF ENUM size STRUCTURE sz.
TYPES:
  BEGIN OF ENUM format STRUCTURE fmt,
    l, p,
  END OF ENUM format STRUCTURE fmt.

The use of [enumeration structures](javascript:call_link\('abenenumerated_structure_glosry.htm'\) "Glossary Entry") means that the same name l can occur twice. Method SHOW wraps method SHOW\_HTML of class CL\_ABAP\_BROWSER:

METHOD show.
  cl\_abap\_browser=>show\_html(
    html\_string = html
    size    = SWITCH #(  size
                         WHEN sz-s  THEN cl\_abap\_browser=>small
                         WHEN sz-m  THEN cl\_abap\_browser=>medium
                         WHEN sz-l  THEN cl\_abap\_browser=>large
                         WHEN sz-xl THEN cl\_abap\_browser=>xlarge )
    format  = SWITCH #(  format
                         WHEN fmt-l THEN cl\_abap\_browser=>landscape
                         WHEN fmt-p THEN cl\_abap\_browser=>portrait )
    buttons = abap\_true ).
ENDMETHOD.

The input parameters size and format format of the method have the same enumerated types and can only contain their enumerated values. These are mapped to the corresponding constants of class CL\_ABAP\_BROWSER. These constants can be regarded as a workaround for real enumerated types, which were not available when CL\_ABAP\_BROWSER was developed.

Enumerated values can be specified for the size and format when the program is executed. The values are passed internally to the program by deserializing the character-like values into the local enumerated variables size and format. The exception for invalid values is caught internally; here the enumerated variables are initialized, which corresponds to the values of the enumeration constants sz-s and fmt-l.



**📖 Source**: [abenenum_usage_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenenum_usage_abexa.htm)

### abenenum_description_abexa.htm

> **📖 Official SAP Documentation**: [abenenum_description_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenenum_description_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Enumerated Objects](javascript:call_link\('abenenumerated_types_usage.htm'\)) → 

Enumerated Objects, Type Description

This example demonstrates type description in [enumerated objects](javascript:call_link\('abenenumerated_object_glosry.htm'\) "Glossary Entry").

Source Code

REPORT demo\_describe\_enums.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    TYPES:
      BEGIN OF ENUM size,
        s, m, l, xl, xxl,
      END OF ENUM size.
    DATA(size) = VALUE size( ).
    out->begin\_section( 'DESCRIBE FIELD' ).
    DESCRIBE FIELD size TYPE DATA(type)
                        LENGTH DATA(length) IN BYTE MODE
                        OUTPUT-LENGTH DATA(output\_length).
    out->write\_data( type
      )->write\_data( length
      )->write\_data( output\_length ).
    out->next\_section( 'CL\_ABAP\_ENUMDESCR' ).
    DATA(enum\_descr) = CAST cl\_abap\_enumdescr(
      cl\_abap\_typedescr=>describe\_by\_data( size ) ).
    out->write\_data( enum\_descr->kind
      )->write\_data( enum\_descr->type\_kind
      )->write\_data( enum\_descr->base\_type\_kind
      )->write\_data( enum\_descr->members ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The statement [DESCRIBE FIELD](javascript:call_link\('abapdescribe_field.htm'\)) and the type description class CL\_ABAP\_ENUMDESCR are applied to an enumerated variable size of the enumerated type with the same name.



**📖 Source**: [abenenum_description_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenenum_description_abexa.htm)

### abenenum_deserialization_abexa.htm

> **📖 Official SAP Documentation**: [abenenum_deserialization_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenenum_deserialization_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Enumerated Objects](javascript:call_link\('abenenumerated_types_usage.htm'\)) → 

Enumerated Objects, Deserialization

This example demonstrates how a dynamically created XML file is deserialized to an [enumerated object](javascript:call_link\('abenenumerated_object_glosry.htm'\) "Glossary Entry").

Source Code

REPORT.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA input TYPE c LENGTH 3 VALUE 'XL'.
    cl\_demo\_input=>request( CHANGING field = input ).
    input = to\_upper( input ).
    TYPES:
      BEGIN OF ENUM size,
        s, m, l, xl, xxl,
      END OF ENUM size.
    DATA(xml) =
      cl\_abap\_conv\_codepage=>create\_out( )->convert(
        \`<asx:abap version="1.0"\` &&
        \` xmlns:asx="http://www.sap.com/abapxml">\` &&
        \`  <asx:values>\` &&
        \`  <ENUM>\` && input && \`</ENUM>\` &&
        \`  </asx:values>\` &&
        \`</asx:abap>\` ) ##no\_text.
    DATA size TYPE size.
    TRY.
        CALL TRANSFORMATION id
                            SOURCE XML xml
                            RESULT enum = size.
      CATCH cx\_transformation\_error INTO DATA(exc).
        cl\_demo\_output=>display( exc->previous->get\_text( ) ).
        RETURN.
    ENDTRY.
    cl\_demo\_output=>display( |Name:  { size
                           }\\nValue: { CONV i( size ) }| ).
    FIELD-SYMBOLS <fs> TYPE size.
    ASSIGN (input) TO <fs>.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( \`Wrong name\` ).
      RETURN.
    ENDIF.
    ASSERT size = <fs>.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The composition of a a byte string means that it can represent an XML file in asXML format for an enumerated object of the enumerated type size and is deserialized as such. Any invalid entries raise an exception.

Next, the dynamic assignment of a name to a field symbol is displayed. This is successful but the prerequisite here is that the enumerated type size is known in the current context. However, the XML file can be serialized in an enumerated object without static knowledge of the enumerated type.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Internal Tables / System Class for Internal Tables

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Internal Tables / System Class for Internal Tables

Included pages: 7



**📖 Source**: [abenenum_deserialization_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenenum_deserialization_abexa.htm)

### abencl_abap_itab.htm

> **📖 Official SAP Documentation**: [abencl_abap_itab.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_itab.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Internal Tables](javascript:call_link\('abenitab.htm'\)) → 

System Class for Internal Tables

The class CL\_ABAP\_ITAB\_UTILITIES contains the following methods:

-   FLUSH\_ITAB\_KEY and FLUSH\_ITAB\_KEYS can be used to update individual [secondary table keys](javascript:call_link\('abensecondary_table_key_glosry.htm'\) "Glossary Entry") or all secondary table keys of an internal table explicitly. Otherwise the update takes place as a [delayed](javascript:call_link\('abendelayed_update_glosry.htm'\) "Glossary Entry") or [lazy update](javascript:call_link\('abenlazy_update_glosry.htm'\) "Glossary Entry").

-   READ\_BINARY\_SEARCH\_CHECK can be used with the addition [BINARY SEARCH](javascript:call_link\('abapread_table_free.htm'\)) to activate checks on the required sort for test purposes. If the required sort does not exist, the runtime error ITAB\_ILLEGAL\_ORDER is raised when the check is activated.

-   HAS\_COLLECT\_HASH\_ADMIN can be used to check whether the temporary hash management of the statement [COLLECT](javascript:call_link\('abapcollect.htm'\)) exists for a standard table.

-   INDEX\_HEALTH\_CHECK can be used to check the consistency of [primary](javascript:call_link\('abenprimary_table_index_glosry.htm'\) "Glossary Entry") and [secondary table indexes](javascript:call_link\('abensecondary_table_index_glosry.htm'\) "Glossary Entry").

-   VIRTUAL\_SORT can be used to apply virtual sorts to a set of internal tables with the same number of rows. The internal tables are treated internally like a single combined table containing all the columns of the involved internal tables. The result is an array of row numbers of the virtually sorted combined table. See the related [executable examples](javascript:call_link\('abenvirtual_sort_abexas.htm'\)).

Continue
[Examples of Virtual Sorting of Internal Tables](javascript:call_link\('abenvirtual_sort_abexas.htm'\))



**📖 Source**: [abencl_abap_itab.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencl_abap_itab.htm)

### abenvirtual_sort_abexas.htm

> **📖 Official SAP Documentation**: [abenvirtual_sort_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Internal Tables](javascript:call_link\('abenitab.htm'\)) →  [System Class for Internal Tables](javascript:call_link\('abencl_abap_itab.htm'\)) → 

Examples of Virtual Sorting of Internal Tables

Continue
![Example](exa.gif "Example") [Virtual Sorting of an Internal Table](javascript:call_link\('abenvirtual_sort_simple_abexa.htm'\))
![Example](exa.gif "Example") [Virtual Sorting of Two Internal Tables](javascript:call_link\('abenvirtual_sort_combined_abexa.htm'\))
![Example](exa.gif "Example") [Virtual Sorting of an Internal Table with Filters](javascript:call_link\('abenvirtual_sort_filter_abexa.htm'\))
![Example](exa.gif "Example") [Virtual Sorting of Flight Data](javascript:call_link\('abenvirtual_sort_flights_abexa.htm'\))



**📖 Source**: [abenvirtual_sort_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_abexas.htm)

### abenvirtual_sort_simple_abexa.htm

> **📖 Official SAP Documentation**: [abenvirtual_sort_simple_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_simple_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Internal Tables](javascript:call_link\('abenitab.htm'\)) →  [System Class for Internal Tables](javascript:call_link\('abencl_abap_itab.htm'\)) →  [Examples of Virtual Sorting of Internal Tables](javascript:call_link\('abenvirtual_sort_abexas.htm'\)) → 

Virtual Sorting of an Internal Table

This example demonstrates the virtual sorting of a single internal table.

Source Code

REPORT demo\_virtual\_sort\_simple.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES:
      BEGIN OF line,
        col1 TYPE i,
        col2 TYPE i,
        col3 TYPE string,
        col4 TYPE string,
      END OF line,
      itab TYPE STANDARD TABLE OF line WITH EMPTY KEY.
    DATA(rnd) = cl\_abap\_random\_int=>create( seed = + sy-uzeit
                                            min  = 1
                                            max  = 10 ).
    DATA(itab) = VALUE itab( FOR i = 1 UNTIL i > 10
                             ( col1 = rnd->get\_next( )
                               col2 = rnd->get\_next( )
                               col3 = substring(
                                        val = sy-abcde
                                        off = rnd->get\_next( ) - 1
                                        len = 1 )
                               col4 = substring(
                                        val = sy-abcde
                                        off = rnd->get\_next( ) - 1
                                        len = 1 ) ) ).
    DATA(out) = cl\_demo\_output=>new( ).
    out->write( itab ).
    out->next\_section( \`Virtual Sort by col1, col2, Ascending\` ).
    DATA(v\_index) =
      cl\_abap\_itab\_utilities=>virtual\_sort(
        im\_virtual\_source = VALUE #(
         ( source     = REF #( itab )
           components = VALUE #( ( name = 'col1' )
                                 ( name = 'col2' ) ) ) ) ).
    out->write( v\_index ).
    DATA sorted\_tab TYPE itab.
    sorted\_tab = VALUE #( FOR idx IN v\_index ( itab\[ idx \] ) ).
    DATA(test\_tab) = itab.
    SORT test\_tab STABLE BY col1 col2.
    ASSERT sorted\_tab = test\_tab.
    out->write( sorted\_tab ).
    out->next\_section( \`Virtual Sort by col3, col4, Descending\` ).
    v\_index =
      cl\_abap\_itab\_utilities=>virtual\_sort(
        im\_virtual\_source = VALUE #(
         ( source     = REF #( itab )
           components = VALUE #(
                         ( name = 'col3'
                           astext = abap\_true
                           descending = abap\_true )
                         ( name = 'col4'
                           astext = abap\_true
                           descending = abap\_true ) ) ) ) ).
    out->write( v\_index ).
    sorted\_tab = VALUE #( FOR idx IN v\_index ( itab\[ idx \] ) ).
    test\_tab = itab.
    SORT test\_tab STABLE BY col3 AS TEXT DESCENDING
                            col4 AS TEXT DESCENDING.
    ASSERT sorted\_tab = test\_tab.
    out->write( sorted\_tab ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An internal table filled with random numbers and letters is sorted virtually using the method VIRTUAL\_SORT of system class CL\_ABAP\_ITAB\_UTILITIES, first in ascending order by the first two columns and then in descending alphabetical order by the last two columns. The returned array contains the row numbers in the respective sort order. This array is used to fill an internal table sorted\_tab according to the sorting. To compare, an internal table test\_tab with the same content is constructed and sorted with the statement [SORT](javascript:call_link\('abapsort_itab.htm'\)). The results are the same in both cases.



**📖 Source**: [abenvirtual_sort_simple_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_simple_abexa.htm)

### abenvirtual_sort_combined_abexa.htm

> **📖 Official SAP Documentation**: [abenvirtual_sort_combined_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_combined_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Internal Tables](javascript:call_link\('abenitab.htm'\)) →  [System Class for Internal Tables](javascript:call_link\('abencl_abap_itab.htm'\)) →  [Examples of Virtual Sorting of Internal Tables](javascript:call_link\('abenvirtual_sort_abexas.htm'\)) → 

Virtual Sorting of Two Internal Tables

This example demonstrates the virtual sorting of two internal tables.

Source Code

REPORT demo\_virtual\_sort\_combined.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES:
      BEGIN OF line1,
        col1 TYPE i,
        col2 TYPE i,
      END OF line1,
      itab1 TYPE STANDARD TABLE OF line1 WITH EMPTY KEY,
      BEGIN OF line2,
        col1 TYPE string,
        col2 TYPE string,
      END OF line2,
      itab2 TYPE STANDARD TABLE OF line2 WITH EMPTY KEY.
    TYPES:
      BEGIN OF test\_line,
        col11 TYPE i,
        col12 TYPE i,
        col21 TYPE string,
        col22 TYPE string,
      END OF test\_line,
      test\_tab TYPE STANDARD TABLE OF test\_line WITH EMPTY KEY.
    DATA(rnd) = cl\_abap\_random\_int=>create( seed = + sy-uzeit
                                            min  = 0
                                            max  = 1 ).
    DATA(itab1) = VALUE itab1( FOR i = 1 UNTIL i > 10
                               ( col1 = rnd->get\_next( )
                                 col2 = rnd->get\_next( ) ) ).
    DATA(itab2) =
      VALUE itab2( FOR i = 1 UNTIL i > 10
        ( col1 = cond #( when rnd->get\_next( ) = 0 THEN \`X\`
                                                   ELSE \`Y\` )
          col2 = cond #( when rnd->get\_next( ) = 0 THEN \`X\`
                                                   ELSE \`Y\` ) ) ).
    DATA(out) = cl\_demo\_output=>new( ).
    out->write( itab1
      )->write( itab2 ).
    out->next\_section(  \`Virtual Sort of Combined Tables\`
      )->begin\_section( \`itab1 by col1, col2, Ascending\`
      )->next\_section(  \`itab2 by col1, col2, Descending\` ).
    DATA(v\_index) =
      cl\_abap\_itab\_utilities=>virtual\_sort(
        im\_virtual\_source = VALUE #(
         ( source     = REF #( itab1 )
           components = VALUE #( ( name = 'col1' )
                                 ( name = 'col2' ) ) )
         ( source     = REF #( itab2 )
           components = VALUE #( ( name = 'col1'
                                   astext = abap\_true
                                   descending = abap\_true )
                                 ( name = 'col2'
                                   astext = abap\_true
                                   descending = abap\_true ) ) ) ) ).
    out->write( v\_index ).
    DATA sorted\_tab1 TYPE itab1.
    sorted\_tab1 = VALUE #( FOR idx IN v\_index ( itab1\[ idx \] ) ).
    DATA sorted\_tab2 TYPE itab2.
    sorted\_tab2 = VALUE #( FOR idx IN v\_index ( itab2\[ idx \] ) ).
    DATA(comb\_tab) = VALUE test\_tab( FOR i = 1 UNTIL i > 10
                        ( col11 = sorted\_tab1\[ i \]-col1
                          col12 = sorted\_tab1\[ i \]-col2
                          col21 = sorted\_tab2\[ i \]-col1
                          col22 = sorted\_tab2\[ i \]-col2 ) ).
    DATA(test\_tab) = VALUE test\_tab( FOR i = 1 UNTIL i > 10
                        ( col11 = itab1\[ i \]-col1
                          col12 = itab1\[ i \]-col2
                          col21 = itab2\[ i \]-col1
                          col22 = itab2\[ i \]-col2 ) ).
    SORT test\_tab STABLE BY col11
                            col12
                            col21 DESCENDING AS TEXT
                            col22 DESCENDING AS TEXT.
    ASSERT comb\_tab = test\_tab.
    out->write( comb\_tab ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An internal table itab1 containing random numbers and an internal table itab2 containing random letters are sorted together virtually using the method VIRTUAL\_SORT of system class CL\_ABAP\_ITAB\_UTILITIES, which sorts both columns of itab1 in ascending order and both columns of itab2 in descending alphabetical order. The returned array contains the row numbers in the sort order. This array is used to fill the internal table comb\_tab, which combines the columns of the involved tables, according to the sorting. To compare, another table test\_tab, which combines the content from itab1 and itab2, is constructed and sorted using the statement [SORT](javascript:call_link\('abapsort_itab.htm'\)). The results are the same. However, in a real example the combined tables are not usually of interest. See the executable example [Virtual Sorting of Flight Data](javascript:call_link\('abenvirtual_sort_flights_abexa.htm'\)).



**📖 Source**: [abenvirtual_sort_combined_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_combined_abexa.htm)

### abenvirtual_sort_filter_abexa.htm

> **📖 Official SAP Documentation**: [abenvirtual_sort_filter_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_filter_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Internal Tables](javascript:call_link\('abenitab.htm'\)) →  [System Class for Internal Tables](javascript:call_link\('abencl_abap_itab.htm'\)) →  [Examples of Virtual Sorting of Internal Tables](javascript:call_link\('abenvirtual_sort_abexas.htm'\)) → 

Virtual Sorting of an Internal Table with Filters

This example demonstrates the virtual sorting of an internal table with row filtering.

Source Code

REPORT demo\_virtual\_sort\_filter.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES
      itab TYPE STANDARD TABLE OF i WITH EMPTY KEY.
    DATA(rnd) = cl\_abap\_random\_int=>create( seed = + sy-uzeit
                                            min  = 1
                                            max  = 10 ).
    DATA(itab) = VALUE itab( FOR i = 1 UNTIL i > 10
                             ( rnd->get\_next( ) ) ).
    DATA(out) = cl\_demo\_output=>new( ).
    out->write( itab ).
    out->next\_section( \`Virtual Sort by table\_line with Filter\` ).
    DATA(v\_index) =
      cl\_abap\_itab\_utilities=>virtual\_sort(
        im\_virtual\_source = VALUE #(
         ( source     = REF #( itab )
           components = VALUE #( ( name = 'table\_line' ) ) ) )
        im\_filter\_index =  VALUE #( ( 1 ) ( 3 ) ( 5 ) ( 7 ) ( 9 ) ) ).
    out->write( v\_index ).
    DATA sorted\_tab TYPE itab.
    sorted\_tab = VALUE #( FOR idx IN v\_index ( itab\[ idx \] ) ).
    out->write( sorted\_tab ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An internal table filled with random numbers is sorted in ascending order by its row content using the method VIRTUAL\_SORT of system class CL\_ABAP\_ITAB\_UTILITIES. This passes a table filter\_tab containing the row numbers to be sorted. The returned array contains exactly these row numbers in the sort order. A table sorted\_tab is constructed in this order from the respective rows of itab.



**📖 Source**: [abenvirtual_sort_filter_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_filter_abexa.htm)

### abenvirtual_sort_flights_abexa.htm

> **📖 Official SAP Documentation**: [abenvirtual_sort_flights_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_flights_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Internal Tables](javascript:call_link\('abenitab.htm'\)) →  [System Class for Internal Tables](javascript:call_link\('abencl_abap_itab.htm'\)) →  [Examples of Virtual Sorting of Internal Tables](javascript:call_link\('abenvirtual_sort_abexas.htm'\)) → 

Virtual Sorting of Flight Data

This example demonstrates the virtual sorting of an internal table containing flight data.

Source Code

REPORT demo\_virtual\_sort\_flights.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    TYPES:
      BEGIN OF flight,
        carrid   TYPE s\_carr\_id,
        connid   TYPE s\_conn\_id,
        cityfrom TYPE s\_city,
        cityto   TYPE s\_city,
      END OF flight,
      flights TYPE STANDARD TABLE OF flight
              WITH EMPTY KEY,
      BEGIN OF city,
        city      TYPE  s\_city,
        latitude  TYPE  s\_lati,
        longitude TYPE  s\_long,
      END OF city,
      cities TYPE STANDARD TABLE OF city
                  WITH EMPTY KEY.
    CLASS-DATA:
      flight\_tab    TYPE flights,
      from\_city\_tab TYPE cities,
      to\_city\_tab   TYPE cities.
    CLASS-METHODS:
      main,
      class\_constructor.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_output=>new(
      )->next\_section(
      \`Ascending Sort by Latitude, Longitude of CITYFROM, CITYTO\`
      )->write( VALUE flights(
                  FOR <idx>
                  IN cl\_abap\_itab\_utilities=>virtual\_sort(
                       im\_virtual\_source =
                         VALUE #(
                           ( source     = REF #( from\_city\_tab )
                             components =
                               VALUE #( ( name = 'latitude' )
                                        ( name = 'longitude' ) ) )
                           ( source     = REF #( to\_city\_tab )
                             components =
                               VALUE #( ( name = 'latitude' )
                                        ( name = 'longitude' ) ) )
                           ( source     = REF #( flight\_tab )
                             components =
                               VALUE #( ( name = 'carrid' )
                                        ( name = 'connid' ) ) ) ) )
                  ( flight\_tab\[ <idx> \] ) )
      )->next\_section(
      \`Descending Sort by Latitude, Longitude of CITYFROM, CITYTO\`
      )->write( VALUE flights(
                  FOR <idx>
                  IN cl\_abap\_itab\_utilities=>virtual\_sort(
                       im\_virtual\_source =
                         VALUE #(
                           ( source     = REF #( from\_city\_tab )
                             components =
                               VALUE #( ( name = 'latitude'
                                          descending = abap\_true )
                                        ( name = 'longitude'
                                          descending = abap\_true ) ) )
                           ( source     = REF #( to\_city\_tab )
                             components =
                               VALUE #( ( name = 'latitude'
                                          descending = abap\_true )
                                        ( name = 'longitude'
                                          descending = abap\_true ) ) )
                           ( source     = REF #( flight\_tab )
                             components =
                               VALUE #( ( name = 'carrid' )
                                        ( name = 'connid' ) ) ) ) )
                  ( flight\_tab\[ <idx> \] ) )
      )->display( ).  ENDMETHOD.
  METHOD class\_constructor.
    SELECT carrid, connid, cityfrom, cityto
           FROM spfli
           INTO CORRESPONDING FIELDS OF TABLE @flight\_tab.
    SELECT city, latitude, longitude
           FROM sgeocity
           INTO TABLE @DATA(cities).
    TRY.
        from\_city\_tab = VALUE #( FOR <fs> IN flight\_tab
                                 ( cities\[ city = <fs>-cityfrom \] ) ).
        to\_city\_tab   = VALUE #( FOR <fs> IN flight\_tab
                                 ( cities\[ city = <fs>-cityto \] ) ).
      CATCH cx\_sy\_itab\_line\_not\_found.
        MESSAGE 'Flight model data not consistent,' &&
                ' use program SAPBC\_DATA\_GENERATOR' &&
                ' to create the data.' TYPE 'X'.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In this example, an internal table flight\_tab containing flight data is sorted virtually by the longitudes and latitudes of the departure and arrival cities. To do this, two additional tables from\_city\_tab and to\_city\_tab are constructed. The rows of these tables contain the longitudes and latitudes of the departure and arrival cities from the respective rows of flight\_tab.

Virtual sorting with the method VIRTUAL\_SORT of class CL\_ABAP\_ITAB\_UTILITIES takes place at the operand position of a [FOR](javascript:call_link\('abenfor_itab.htm'\)) expression for a table iteration. The virtual sorting involves all three internal tables. The temporary result of the sorting is used to construct a sorted internal table from the rows of flight\_tab. This table is only temporary, and is an input parameter of the method WRITE of class CL\_DEMO\_OUTPUT.

It is sorted once in ascending order and once in descending order. This does not change the order of the rows in the internal tables that are involved. These remain in their original unsorted state. Virtual sorting makes it possible to generate various sorted output data without affecting the original data.



**📖 Source**: [abenvirtual_sort_flights_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_flights_abexa.htm)

### abenvirtual_sort_abexas.htm

> **📖 Official SAP Documentation**: [abenvirtual_sort_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Internal Tables](javascript:call_link\('abenitab.htm'\)) →  [System Class for Internal Tables](javascript:call_link\('abencl_abap_itab.htm'\)) → 

Examples of Virtual Sorting of Internal Tables

Continue
![Example](exa.gif "Example") [Virtual Sorting of an Internal Table](javascript:call_link\('abenvirtual_sort_simple_abexa.htm'\))
![Example](exa.gif "Example") [Virtual Sorting of Two Internal Tables](javascript:call_link\('abenvirtual_sort_combined_abexa.htm'\))
![Example](exa.gif "Example") [Virtual Sorting of an Internal Table with Filters](javascript:call_link\('abenvirtual_sort_filter_abexa.htm'\))
![Example](exa.gif "Example") [Virtual Sorting of Flight Data](javascript:call_link\('abenvirtual_sort_flights_abexa.htm'\))


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / DESCRIBE

**Files**: 11 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / DESCRIBE

Included pages: 11



**📖 Source**: [abenvirtual_sort_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenvirtual_sort_abexas.htm)

### abapdescribe.htm

> **📖 Official SAP Documentation**: [abapdescribe.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) → 

DESCRIBE

Syntax Forms

[Field Properties](javascript:call_link\('abapdescribe_field.htm'\))
1\. DESCRIBE FIELD ...
[Properties of an Internal Table](javascript:call_link\('abapdescribe_table.htm'\))
2\. DESCRIBE TABLE ...
[Distance Between Two Fields](javascript:call_link\('abapdescribe_distance.htm'\))
3\. DESCRIBE DISTANCE ...

Effect

The variants of the statement DESCRIBE listed above can be used to specify some of the attributes displayed by data objects at runtime.

Notes

-   The statement DESCRIBE is used to determine the attributes of data objects of elementary data types. When DESCRIBE is used for structures or data objects of [deep](javascript:call_link\('abendeep_glosry.htm'\) "Glossary Entry") data types like strings, internal tables, or reference variables, only elementary attributes can be identified. Additional information, for example the static or dynamic type of a reference, cannot be determined by DESCRIBE. For this kind of information, the type description classes of [runtime type services](javascript:call_link\('abenrun_time_type_services_glosry.htm'\) "Glossary Entry") (RTTS) should be used. These enable all data object attributes of all data types to be determined. Since the functions of the RTTS type description classes comprise the complete functions of the DESCRIBE statement, the system classes can be used instead of the statement.
    
-   The variant [DESCRIBE LIST](javascript:call_link\('abapdescribe_list.htm'\)) specifies the attributes of lists in the list buffer.
    

Continue
[DESCRIBE FIELD](javascript:call_link\('abapdescribe_field.htm'\))
[DESCRIBE TABLE](javascript:call_link\('abapdescribe_table.htm'\))
[DESCRIBE DISTANCE](javascript:call_link\('abapdescribe_distance.htm'\))
[DESCRIBE - Internal Variant](javascript:call_link\('abendescribe_internal.htm'\))



**📖 Source**: [abapdescribe.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe.htm)

### abapdescribe_field.htm

> **📖 Official SAP Documentation**: [abapdescribe_field.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_field.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [DESCRIBE](javascript:call_link\('abapdescribe.htm'\)) → 

DESCRIBE FIELD

[Quick Reference](javascript:call_link\('abapdescribe_field_shortref.htm'\))

Syntax

DESCRIBE FIELD dobj
  *\[*TYPE typ *\[*COMPONENTS com*\]**\]*
  *\[*LENGTH ilen IN *{*BYTE*|*CHARACTER*}* MODE*\]*
  *\[*DECIMALS dec*\]*
  *\[*OUTPUT-LENGTH olen*\]*
  *\[*HELP-ID hlp*\]*
  *\[*EDIT MASK mask*\]*.

Extras:

[1\. ... TYPE typ *\[*COMPONENTS com*\]*](#!ABAP_ADDITION_1@1@)
[2\. ... LENGTH ilen IN *{*BYTE*|*CHARACTER*}* MODE](#!ABAP_ADDITION_2@2@)
[3\. ... DECIMALS dec](#!ABAP_ADDITION_3@3@)
[4\. ... OUTPUT-LENGTH olen](#!ABAP_ADDITION_4@4@)
[5\. ... HELP-ID hlp](#!ABAP_ADDITION_5@5@)
[6\. ... EDIT MASK mask](#!ABAP_ADDITION_6@6@)

Effect

This statement determines multiple attributes of the data object dobj and assigns them to the specified target fields. The following can be specified as target fields of each addition:

-   Existing variables to which the return value can be converted.
    
-   Inline declarations [DATA(var)](javascript:call_link\('abendata_inline.htm'\)).
    

The various additions make it possible to determine the data type and the number of components for structures, the length used in the memory, the number of [decimal places](javascript:call_link\('abenfractional_portion_glosry.htm'\) "Glossary Entry"), the output length, the name of the data type for a reference to a data element in ABAP Dictionary, and any conversion routines.

Notes

-   Field symbols or formal parameters can be specified in [procedures](javascript:call_link\('abenprocedure_glosry.htm'\) "Glossary Entry") for dobj to identify the attributes of the data object they represent when the statement is executed.
    
-   The statement DESCRIBE is used to determine the attributes of data objects of elementary data types. When DESCRIBE is used for structures or data objects of [deep](javascript:call_link\('abendeep_glosry.htm'\) "Glossary Entry") data types like strings, internal tables, or reference variables, only elementary attributes can be identified. Further details, for example, the static or dynamic type of a reference variable cannot be identified using DESCRIBE. For this kind of information, the type description classes of runtime type services ([RTTS](javascript:call_link\('abenrun_time_type_services_glosry.htm'\) "Glossary Entry")) should be used. These enable all data object attributes of all data types to be determined.
    

Addition 1

... TYPE typ *\[*COMPONENTS com*\]*

Effect

Determines the data type of the data object dobj. The return value is a single character character-like ID. In an inline declaration, a variable of the type c with length 1 is declared. The following tables list the assignment of return values for all possible data types. The ID is case-sensitive.

Numeric Data Type

ID

b

b

s

s

i

I

int8

8

p

P

decfloat16

a

decfloat34

e

f

F

Character-Like Data Type

ID

c

C (exception, see note below)

n

N

string

g

Byte-Like Data Type

ID

x

X

xstring

y

Date/Time Type

ID

d

D

t

T

Enumerated Type

ID

Enumerated type

k

Reference Type

ID

Data reference

l

Object reference

r

Complex Type

ID

Flat structure

u (exception, refer to note below)

Deep structure

v (exception, refer to note below)

Internal table

h

The addition COMPONENTS determines the number of direct components of the data object dobj. The return value has the type i. In an inline declaration, a variable of the type i is declared. If the data object dobj is not a structure, the value 0 is returned. If dobj is a nested structure, only the components of the highest hierarchy level are counted.

Note

If DESCRIBE FIELD is applied directly to a [static box](javascript:call_link\('abenstatic_box_glosry.htm'\) "Glossary Entry"), its data type according to the above table is returned and not the internal ID j for the boxed component.

Example

For the [deep](javascript:call_link\('abendeep_glosry.htm'\) "Glossary Entry") nested structure struc1, identifies the type ID "v" and three components. For the [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") structure struc2, identifies the type ID "u" and two components.

DATA: BEGIN OF struc1,
        comp1 TYPE c LENGTH 1,
        comp2 TYPE string,
        BEGIN OF struc2,
          comp1 TYPE c LENGTH 1,
          comp2 TYPE i,
        END OF struc2,
      END OF struc1.
DESCRIBE FIELD: struc1        TYPE DATA(typ1) COMPONENTS DATA(comp1),
                struc1-struc2 TYPE DATA(typ2) COMPONENTS DATA(comp2).

Addition 2

... LENGTH ilen IN *{*BYTE*|*CHARACTER*}* MODE

Effect

Determines the length used directly by the data object dobj in the memory in bytes or characters depending on the addition MODE. The return value has the type i. In an inline declaration, a variable of the type i is declared.

The variant with the addition IN BYTE MODE identifies the length of the data object dobj in bytes. The variant with the addition IN CHARACTER MODE identifies the length of the data object dobj in characters. When using IN CHARACTER MODE, the data type of dobj must be flat and character-like. For [deep](javascript:call_link\('abendeep_glosry.htm'\) "Glossary Entry") data types, only IN BYTE MODE can be specified. This always identifies the length of the references involved (eight bytes for each reference).

Notes

-   For data objects with a fixed length, the length is identified that is specified when the data object is created. The [built-in function](javascript:call_link\('abenpredefined_function_glosry.htm'\) "Glossary Entry") strlen can be used to identify the used length of character-like data objects while ignoring the trailing blanks.
    
-   In structures, the [alignment gaps](javascript:call_link\('abenalignment_gap_glosry.htm'\) "Glossary Entry") are included in the length. This is particularly significant in the case of alignment gaps that occur before the end of the structure.
    
-   With [enumerated objects](javascript:call_link\('abenenumerated_object_glosry.htm'\) "Glossary Entry"), the addition IN BYTE MODE must be specified and the length of the actual [enumerated value](javascript:call_link\('abenenumerated_value_glosry.htm'\) "Glossary Entry") is determined in the [basic type](javascript:call_link\('abenbase_type_glosry.htm'\) "Glossary Entry").
    

Example

Calculates the bytes required for the representation of one character. The result is greater than 1 in multi-byte systems.

DATA: text  TYPE c LENGTH 1,
      bytes TYPE i.
DESCRIBE FIELD text LENGTH DATA(blen) IN BYTE MODE.
DESCRIBE FIELD text LENGTH DATA(clen) IN CHARACTER MODE.
bytes = blen / clen.

Example

The result len of the following DESCRIBE statement is 9, not 10, due to a trailing alignment gap in struct.

DATA:
  BEGIN OF struct,
    text       TYPE c LENGTH 3,
    hex  TYPE x LENGTH 3,
  END OF struct.
DESCRIBE FIELD struct LENGTH DATA(len) IN BYTE MODE.

Addition 3

... DECIMALS dec

Effect

Determines the [number of decimal places](javascript:call_link\('abenfractional_portion_glosry.htm'\) "Glossary Entry") of the data object dobj. The return value has the type i. In an inline declaration, a variable of the type i is declared.

Note

Only data objects of the data type p can have decimal places. Therefore, the result in dec can be different from 0 only for these data objects.

Example

Detects 0 decimal places and then 4 decimal places.

CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main IMPORTING pack TYPE p.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DESCRIBE FIELD pack DECIMALS DATA(dec).
    cl\_demo\_output=>write( dec ).
  ENDMETHOD.
ENDCLASS.
DATA:
  pack1 TYPE p LENGTH 8 DECIMALS 0,
  pack2 TYPE p LENGTH 8 DECIMALS 4.
START-OF-SELECTION.
  demo=>main( pack1 ).
  demo=>main( pack2 ).
  cl\_demo\_output=>display( ).

Addition 4

... OUTPUT-LENGTH olen

Effect

For data objects with a fixed length, determines the output length of the data object dobj required for [screen layouts](javascript:call_link\('abenscreen_glosry.htm'\) "Glossary Entry"). The return value has the type i. In an inline declaration, a variable of the type i is declared.

Generally, this result corresponds to the predefined output length of the data object in accordance with its data type in the output in the list buffer. In strings, olen is always set to 0. olen expects the data type i.

Notes

-   Normally, the required output length is specified adequately by the entry in the table for predefined [output lengths](javascript:call_link\('abenwrite_output_length.htm'\)). This is not the case when the data type of the data object is defined with a reference to ABAP Dictionary and an output length or a conversion routine is specified in the corresponding domain.
    
-   If the output length defined in a [dynpro](javascript:call_link\('abendynpro_glosry.htm'\) "Glossary Entry") for a [dynpro field](javascript:call_link\('abendynpro_field_glosry.htm'\) "Glossary Entry") with the same name as dobj is shorter than the required output length, an overflow raises a non-handleable exception. When passed to the list buffer, the output is truncated if the output length is shorter than the required output length.
    
-   When separators or templates are provided in the user master record for the output of a data type, they are only displayed if the defined output length is sufficient. The required length can be longer than the output length identified by OUTPUT-LENGTH.
    
-   The output length for strings can be determined using the functions strlen or xstrlen.
    

Example

For date1, identifies the output length 8 associated with the type d. For date2, identifies the output length 10 defined in the domain SYDATS.

DATA: date1 TYPE d,
      date2 TYPE sy-datum.
DESCRIBE FIELD date1 OUTPUT-LENGTH DATA(olen1).
DESCRIBE FIELD date2 OUTPUT-LENGTH DATA(olen2).

Addition 5

... HELP-ID hlp

Effect

If the data type of the data object dobj is determined by a [data element](javascript:call_link\('abendata_element_glosry.htm'\) "Glossary Entry") in ABAP Dictionary, the name of the data type is assigned that was used after the addition TYPE when defining the data object dobj. The return value is a string. In an inline declaration, a variable of the type string is declared.

If the data object does not refer to a data object in ABAP Dictionary, hlp is initialized. hlp expects a character-like data object.

If a field symbol - to which a data object is assigned using the statement ASSIGN COMPONENT - is specified for dobj, and if the data object refers to a component of a structure in ABAP Dictionary, then the complete name of the structure component is returned.

Note

The addition is called HELP-ID because the name of the data type in hlp can be used for the display of the field help or input help assigned in ABAP Dictionary.

Example

After DESCRIBE FIELD, hlp contains the value "SPFLI-CARRID". Since an input help is assigned to this component in ABAP Dictionary, the input help can be displayed using the function module F4IF\_FIELD\_VALUE\_REQUEST. If the name s\_carr\_id is specified after TYPE when defining carrid, hlp contains the value "S\_CARR\_ID” and can be used, for example, to display the field help using the function module HELP\_OBJECT\_SHOW.

DATA: carrid TYPE spfli-carrid,
      struc  TYPE dfies-tabname,
      comp   TYPE dfies-fieldname.
DESCRIBE FIELD carrid HELP-ID DATA(hlp).
SPLIT hlp AT '-' INTO struc comp.
CALL FUNCTION 'F4IF\_FIELD\_VALUE\_REQUEST'
  EXPORTING
    tabname           = struc
    fieldname         = comp
  EXCEPTIONS
    field\_not\_found   = 1
    no\_help\_for\_field = 2
    inconsistent\_help = 3
    no\_values\_found   = 4
    OTHERS            = 5.

Example

Again in this example, hlp contains the value "SPFLI-CARRID" after DESCRIBE FIELD.

DATA spfli TYPE spfli.
ASSIGN COMPONENT 'CARRID' OF STRUCTURE spfli TO FIELD-SYMBOL(<fs>).
DESCRIBE FIELD <fs> HELP-ID DATA(hlp).

Addition 6

... EDIT MASK mask

Effect

If a conversion routine is assigned to the data object dobj by referring to a domain in ABAP Dictionary, the name of the conversion routine is determined and prefixed with two equals signs "==". The return value is a string. In an inline declaration, a variable of the type string is declared. If no conversion routine is assigned to the data object, mask is initialized or remains initial.

Note

If a data object mask meets these requirements, it can be used directly in the addition USING EDIT MASK of the statement WRITE *\[*TO*\]* to call the conversion routine.

Example

Since the data element S\_FLTIME is associated with the conversion routine SDURA by the domain S\_DURA, msk contains the value "==SDURA" after DESCRIBE FIELD and the statement WRITE TO returns the value "5:33" after the conversion from seconds to minutes.

DATA: time    TYPE s\_fltime,
      seconds TYPE i,
      output  TYPE c LENGTH 10.
DESCRIBE FIELD time EDIT MASK DATA(msk).
seconds = 333.
WRITE seconds TO output USING EDIT MASK msk.
cl\_demo\_output=>display\_data( output ).

Continue
![Example](exa.gif "Example") [Determining Elementary Data Types](javascript:call_link\('abendescribe_field_abexa.htm'\))



**📖 Source**: [abapdescribe_field.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_field.htm)

### abendescribe_field_abexa.htm

> **📖 Official SAP Documentation**: [abendescribe_field_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendescribe_field_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [DESCRIBE](javascript:call_link\('abapdescribe.htm'\)) →  [DESCRIBE FIELD](javascript:call_link\('abapdescribe_field.htm'\)) → 

Determining Elementary Data Types

This example demonstrates how the attributes of elementary data types can be determined at runtime.

Source Code

REPORT  demo\_describe\_field.
CLASS conv\_exc DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: dref1 TYPE REF TO data,
          dref2 TYPE REF TO data.
    FIELD-SYMBOLS: <data1> TYPE any,
                   <data2> TYPE any.
    DATA: tdescr1 TYPE c LENGTH 1,
          tdescr2 TYPE c LENGTH 1.
    DATA:  type1 TYPE c LENGTH 30 VALUE 'I',
           type2 TYPE c LENGTH 30 VALUE 'C'.
    cl\_demo\_input=>add\_field( CHANGING field = type1 ).
    cl\_demo\_input=>request(   CHANGING field = type2 ).
    TRY.
        CREATE DATA: dref1 TYPE (type1),
                     dref2 TYPE (type2).
        ASSIGN: dref1->\* TO <data1>,
                dref2->\* TO <data2>.
      CATCH cx\_sy\_create\_data\_error.
        cl\_demo\_output=>display( 'Create data error!' ).
        LEAVE PROGRAM.
    ENDTRY.
    DESCRIBE FIELD: <data1> TYPE tdescr1,
                    <data2> TYPE tdescr2.
    TRY.
        IF tdescr1 <> tdescr2.
          RAISE EXCEPTION TYPE conv\_exc.
        ELSE.
          <data2> = <data1>.
        ENDIF.
      CATCH conv\_exc.
        cl\_demo\_output=>display( \`Assignment from type \` &&
                                 tdescr2                 &&
                                 \` to \`                  &&
                                 tdescr1                 &&
                                 \` not allowed!\` ).
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example implements a type check that only allows assignments to be made if the source and target fields have the same type.

Using the two input fields type1 and type2, the names of elementary data types are entered. First an attempt is made, using the statement CREATE DATA, to create anonymous data objects of the types specified dynamically. If this does not work, an error message is displayed.

The new data objects are assigned to field symbols <data1> and <data2>. Then, the statement DESCRIBE FIELD determines the type of the data objects created dynamically. Only if both data objects have the same type is <data1> assigned to <data2>.

The example does not work if complex data types such as SCARR and SPFLI are entered in the input fields. In this case DESCRIBE FIELD, determines the same types ("u"), which can cause runtime errors if the structures are not convertible.

The [RTTS](javascript:call_link\('abenrtti.htm'\)) methods can be used to check complex data types and object types at runtime.



**📖 Source**: [abendescribe_field_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendescribe_field_abexa.htm)

### abapdescribe_field.htm

> **📖 Official SAP Documentation**: [abapdescribe_field.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_field.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [DESCRIBE](javascript:call_link\('abapdescribe.htm'\)) → 

DESCRIBE FIELD

[Quick Reference](javascript:call_link\('abapdescribe_field_shortref.htm'\))

Syntax

DESCRIBE FIELD dobj
  *\[*TYPE typ *\[*COMPONENTS com*\]**\]*
  *\[*LENGTH ilen IN *{*BYTE*|*CHARACTER*}* MODE*\]*
  *\[*DECIMALS dec*\]*
  *\[*OUTPUT-LENGTH olen*\]*
  *\[*HELP-ID hlp*\]*
  *\[*EDIT MASK mask*\]*.

Extras:

[1\. ... TYPE typ *\[*COMPONENTS com*\]*](#!ABAP_ADDITION_1@1@)
[2\. ... LENGTH ilen IN *{*BYTE*|*CHARACTER*}* MODE](#!ABAP_ADDITION_2@2@)
[3\. ... DECIMALS dec](#!ABAP_ADDITION_3@3@)
[4\. ... OUTPUT-LENGTH olen](#!ABAP_ADDITION_4@4@)
[5\. ... HELP-ID hlp](#!ABAP_ADDITION_5@5@)
[6\. ... EDIT MASK mask](#!ABAP_ADDITION_6@6@)

Effect

This statement determines multiple attributes of the data object dobj and assigns them to the specified target fields. The following can be specified as target fields of each addition:

-   Existing variables to which the return value can be converted.
    
-   Inline declarations [DATA(var)](javascript:call_link\('abendata_inline.htm'\)).
    

The various additions make it possible to determine the data type and the number of components for structures, the length used in the memory, the number of [decimal places](javascript:call_link\('abenfractional_portion_glosry.htm'\) "Glossary Entry"), the output length, the name of the data type for a reference to a data element in ABAP Dictionary, and any conversion routines.

Notes

-   Field symbols or formal parameters can be specified in [procedures](javascript:call_link\('abenprocedure_glosry.htm'\) "Glossary Entry") for dobj to identify the attributes of the data object they represent when the statement is executed.
    
-   The statement DESCRIBE is used to determine the attributes of data objects of elementary data types. When DESCRIBE is used for structures or data objects of [deep](javascript:call_link\('abendeep_glosry.htm'\) "Glossary Entry") data types like strings, internal tables, or reference variables, only elementary attributes can be identified. Further details, for example, the static or dynamic type of a reference variable cannot be identified using DESCRIBE. For this kind of information, the type description classes of runtime type services ([RTTS](javascript:call_link\('abenrun_time_type_services_glosry.htm'\) "Glossary Entry")) should be used. These enable all data object attributes of all data types to be determined.
    

Addition 1

... TYPE typ *\[*COMPONENTS com*\]*

Effect

Determines the data type of the data object dobj. The return value is a single character character-like ID. In an inline declaration, a variable of the type c with length 1 is declared. The following tables list the assignment of return values for all possible data types. The ID is case-sensitive.

Numeric Data Type

ID

b

b

s

s

i

I

int8

8

p

P

decfloat16

a

decfloat34

e

f

F

Character-Like Data Type

ID

c

C (exception, see note below)

n

N

string

g

Byte-Like Data Type

ID

x

X

xstring

y

Date/Time Type

ID

d

D

t

T

Enumerated Type

ID

Enumerated type

k

Reference Type

ID

Data reference

l

Object reference

r

Complex Type

ID

Flat structure

u (exception, refer to note below)

Deep structure

v (exception, refer to note below)

Internal table

h

The addition COMPONENTS determines the number of direct components of the data object dobj. The return value has the type i. In an inline declaration, a variable of the type i is declared. If the data object dobj is not a structure, the value 0 is returned. If dobj is a nested structure, only the components of the highest hierarchy level are counted.

Note

If DESCRIBE FIELD is applied directly to a [static box](javascript:call_link\('abenstatic_box_glosry.htm'\) "Glossary Entry"), its data type according to the above table is returned and not the internal ID j for the boxed component.

Example

For the [deep](javascript:call_link\('abendeep_glosry.htm'\) "Glossary Entry") nested structure struc1, identifies the type ID "v" and three components. For the [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") structure struc2, identifies the type ID "u" and two components.

DATA: BEGIN OF struc1,
        comp1 TYPE c LENGTH 1,
        comp2 TYPE string,
        BEGIN OF struc2,
          comp1 TYPE c LENGTH 1,
          comp2 TYPE i,
        END OF struc2,
      END OF struc1.
DESCRIBE FIELD: struc1        TYPE DATA(typ1) COMPONENTS DATA(comp1),
                struc1-struc2 TYPE DATA(typ2) COMPONENTS DATA(comp2).

Addition 2

... LENGTH ilen IN *{*BYTE*|*CHARACTER*}* MODE

Effect

Determines the length used directly by the data object dobj in the memory in bytes or characters depending on the addition MODE. The return value has the type i. In an inline declaration, a variable of the type i is declared.

The variant with the addition IN BYTE MODE identifies the length of the data object dobj in bytes. The variant with the addition IN CHARACTER MODE identifies the length of the data object dobj in characters. When using IN CHARACTER MODE, the data type of dobj must be flat and character-like. For [deep](javascript:call_link\('abendeep_glosry.htm'\) "Glossary Entry") data types, only IN BYTE MODE can be specified. This always identifies the length of the references involved (eight bytes for each reference).

Notes

-   For data objects with a fixed length, the length is identified that is specified when the data object is created. The [built-in function](javascript:call_link\('abenpredefined_function_glosry.htm'\) "Glossary Entry") strlen can be used to identify the used length of character-like data objects while ignoring the trailing blanks.
    
-   In structures, the [alignment gaps](javascript:call_link\('abenalignment_gap_glosry.htm'\) "Glossary Entry") are included in the length. This is particularly significant in the case of alignment gaps that occur before the end of the structure.
    
-   With [enumerated objects](javascript:call_link\('abenenumerated_object_glosry.htm'\) "Glossary Entry"), the addition IN BYTE MODE must be specified and the length of the actual [enumerated value](javascript:call_link\('abenenumerated_value_glosry.htm'\) "Glossary Entry") is determined in the [basic type](javascript:call_link\('abenbase_type_glosry.htm'\) "Glossary Entry").
    

Example

Calculates the bytes required for the representation of one character. The result is greater than 1 in multi-byte systems.

DATA: text  TYPE c LENGTH 1,
      bytes TYPE i.
DESCRIBE FIELD text LENGTH DATA(blen) IN BYTE MODE.
DESCRIBE FIELD text LENGTH DATA(clen) IN CHARACTER MODE.
bytes = blen / clen.

Example

The result len of the following DESCRIBE statement is 9, not 10, due to a trailing alignment gap in struct.

DATA:
  BEGIN OF struct,
    text       TYPE c LENGTH 3,
    hex  TYPE x LENGTH 3,
  END OF struct.
DESCRIBE FIELD struct LENGTH DATA(len) IN BYTE MODE.

Addition 3

... DECIMALS dec

Effect

Determines the [number of decimal places](javascript:call_link\('abenfractional_portion_glosry.htm'\) "Glossary Entry") of the data object dobj. The return value has the type i. In an inline declaration, a variable of the type i is declared.

Note

Only data objects of the data type p can have decimal places. Therefore, the result in dec can be different from 0 only for these data objects.

Example

Detects 0 decimal places and then 4 decimal places.

CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main IMPORTING pack TYPE p.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DESCRIBE FIELD pack DECIMALS DATA(dec).
    cl\_demo\_output=>write( dec ).
  ENDMETHOD.
ENDCLASS.
DATA:
  pack1 TYPE p LENGTH 8 DECIMALS 0,
  pack2 TYPE p LENGTH 8 DECIMALS 4.
START-OF-SELECTION.
  demo=>main( pack1 ).
  demo=>main( pack2 ).
  cl\_demo\_output=>display( ).

Addition 4

... OUTPUT-LENGTH olen

Effect

For data objects with a fixed length, determines the output length of the data object dobj required for [screen layouts](javascript:call_link\('abenscreen_glosry.htm'\) "Glossary Entry"). The return value has the type i. In an inline declaration, a variable of the type i is declared.

Generally, this result corresponds to the predefined output length of the data object in accordance with its data type in the output in the list buffer. In strings, olen is always set to 0. olen expects the data type i.

Notes

-   Normally, the required output length is specified adequately by the entry in the table for predefined [output lengths](javascript:call_link\('abenwrite_output_length.htm'\)). This is not the case when the data type of the data object is defined with a reference to ABAP Dictionary and an output length or a conversion routine is specified in the corresponding domain.
    
-   If the output length defined in a [dynpro](javascript:call_link\('abendynpro_glosry.htm'\) "Glossary Entry") for a [dynpro field](javascript:call_link\('abendynpro_field_glosry.htm'\) "Glossary Entry") with the same name as dobj is shorter than the required output length, an overflow raises a non-handleable exception. When passed to the list buffer, the output is truncated if the output length is shorter than the required output length.
    
-   When separators or templates are provided in the user master record for the output of a data type, they are only displayed if the defined output length is sufficient. The required length can be longer than the output length identified by OUTPUT-LENGTH.
    
-   The output length for strings can be determined using the functions strlen or xstrlen.
    

Example

For date1, identifies the output length 8 associated with the type d. For date2, identifies the output length 10 defined in the domain SYDATS.

DATA: date1 TYPE d,
      date2 TYPE sy-datum.
DESCRIBE FIELD date1 OUTPUT-LENGTH DATA(olen1).
DESCRIBE FIELD date2 OUTPUT-LENGTH DATA(olen2).

Addition 5

... HELP-ID hlp

Effect

If the data type of the data object dobj is determined by a [data element](javascript:call_link\('abendata_element_glosry.htm'\) "Glossary Entry") in ABAP Dictionary, the name of the data type is assigned that was used after the addition TYPE when defining the data object dobj. The return value is a string. In an inline declaration, a variable of the type string is declared.

If the data object does not refer to a data object in ABAP Dictionary, hlp is initialized. hlp expects a character-like data object.

If a field symbol - to which a data object is assigned using the statement ASSIGN COMPONENT - is specified for dobj, and if the data object refers to a component of a structure in ABAP Dictionary, then the complete name of the structure component is returned.

Note

The addition is called HELP-ID because the name of the data type in hlp can be used for the display of the field help or input help assigned in ABAP Dictionary.

Example

After DESCRIBE FIELD, hlp contains the value "SPFLI-CARRID". Since an input help is assigned to this component in ABAP Dictionary, the input help can be displayed using the function module F4IF\_FIELD\_VALUE\_REQUEST. If the name s\_carr\_id is specified after TYPE when defining carrid, hlp contains the value "S\_CARR\_ID” and can be used, for example, to display the field help using the function module HELP\_OBJECT\_SHOW.

DATA: carrid TYPE spfli-carrid,
      struc  TYPE dfies-tabname,
      comp   TYPE dfies-fieldname.
DESCRIBE FIELD carrid HELP-ID DATA(hlp).
SPLIT hlp AT '-' INTO struc comp.
CALL FUNCTION 'F4IF\_FIELD\_VALUE\_REQUEST'
  EXPORTING
    tabname           = struc
    fieldname         = comp
  EXCEPTIONS
    field\_not\_found   = 1
    no\_help\_for\_field = 2
    inconsistent\_help = 3
    no\_values\_found   = 4
    OTHERS            = 5.

Example

Again in this example, hlp contains the value "SPFLI-CARRID" after DESCRIBE FIELD.

DATA spfli TYPE spfli.
ASSIGN COMPONENT 'CARRID' OF STRUCTURE spfli TO FIELD-SYMBOL(<fs>).
DESCRIBE FIELD <fs> HELP-ID DATA(hlp).

Addition 6

... EDIT MASK mask

Effect

If a conversion routine is assigned to the data object dobj by referring to a domain in ABAP Dictionary, the name of the conversion routine is determined and prefixed with two equals signs "==". The return value is a string. In an inline declaration, a variable of the type string is declared. If no conversion routine is assigned to the data object, mask is initialized or remains initial.

Note

If a data object mask meets these requirements, it can be used directly in the addition USING EDIT MASK of the statement WRITE *\[*TO*\]* to call the conversion routine.

Example

Since the data element S\_FLTIME is associated with the conversion routine SDURA by the domain S\_DURA, msk contains the value "==SDURA" after DESCRIBE FIELD and the statement WRITE TO returns the value "5:33" after the conversion from seconds to minutes.

DATA: time    TYPE s\_fltime,
      seconds TYPE i,
      output  TYPE c LENGTH 10.
DESCRIBE FIELD time EDIT MASK DATA(msk).
seconds = 333.
WRITE seconds TO output USING EDIT MASK msk.
cl\_demo\_output=>display\_data( output ).

Continue
![Example](exa.gif "Example") [Determining Elementary Data Types](javascript:call_link\('abendescribe_field_abexa.htm'\))



**📖 Source**: [abapdescribe_field.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_field.htm)

### abapdescribe_table.htm

> **📖 Official SAP Documentation**: [abapdescribe_table.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_table.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [DESCRIBE](javascript:call_link\('abapdescribe.htm'\)) → 

DESCRIBE TABLE

[Quick Reference](javascript:call_link\('abapdescribe_table_shortref.htm'\))

Syntax

DESCRIBE TABLE itab *\[*KIND knd*\]* *\[*LINES lin*\]* *\[*OCCURS n*\]*.

Extras:

[1\. ... KIND knd](#!ABAP_ADDITION_1@1@)
[2\. ... LINES lin](#!ABAP_ADDITION_2@2@)
[3\. ... OCCURS n](#!ABAP_ADDITION_3@3@)

Effect

This statement determines some of the properties of the internal table itab and assigns them to the specified target fields. The following can be specified as target fields of each addition:

-   Existing variables to which the return value can be converted.
    
-   Inline declarations [DATA(var)](javascript:call_link\('abendata_inline.htm'\)).
    

The various additions enable the table category, the number of currently filled rows, and the initial memory requirement to be determined.

In addition, the system fields sy-tfill and sy-tleng are filled with the current number of table rows and the length of a table row in bytes.

Notes

-   For more detailed information about an internal table, it is best to use the methods of the [RTTS](javascript:call_link\('abenrun_time_type_services_glosry.htm'\) "Glossary Entry") of the statement DESCRIBE TABLE.
    
-   If no addition is specified, the statement DESCRIBE TABLE only sets the system fields sy-tfill and sy-tleng.
    

Addition 1

... KIND knd

Effect

Determines the table category of the internal table itab. The return value is a single character character-like ID. In an inline declaration, a variable of the type c with length 1 is declared.

The possible IDs are "T" for [standard tables](javascript:call_link\('abenstandard_table_glosry.htm'\) "Glossary Entry"), "S" for sorted tables, and "H" for [hashed tables](javascript:call_link\('abenhashed_table_glosry.htm'\) "Glossary Entry"). These values are also defined as constants sydes\_kind-standard, sydes\_kind-sorted, and sydes\_kind-hashed in the [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") SYDES.

Example

Sorts a generically typed internal table in a method in descending order. Since [sorted tables](javascript:call_link\('abensorted_table_glosry.htm'\) "Glossary Entry") cannot be sorted in descending order, the table category is checked to prevent non-handleable exceptions from being raised.

CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS sort\_descending CHANGING itab TYPE ANY TABLE.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD sort\_descending.
    DESCRIBE TABLE itab KIND DATA(tabkind).
    IF tabkind = sydes\_kind-standard OR
       tabkind = sydes\_kind-hashed.
      SORT itab DESCENDING.
    ELSEIF tabkind = sydes\_kind-sorted.
      MESSAGE '...' TYPE 'E'.
    ELSE.
      MESSAGE '...' TYPE 'E'.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

Addition 2

... LINES lin

Effect

Determines the current number of table rows in the internal table itab. The return value has the type i. In an inline declaration, a variable of the type i is declared.

Note

The current number of rows of an internal table can also be determined using the [built-in function](javascript:call_link\('abenpredefined_function_glosry.htm'\) "Glossary Entry") [lines](javascript:call_link\('abendescriptive_functions_table.htm'\)), which can be used in suitable [operand positions](javascript:call_link\('abenexpression_positions.htm'\)).

Example

The example shows that the addition of LINES to DESCRIBE TABLE and the built-in function [lines](javascript:call_link\('abendescriptive_functions_table.htm'\)) have the same result.

SELECT carrid
       FROM scarr
       INTO TABLE @DATA(scarr\_tab).
DESCRIBE TABLE scarr\_tab LINES DATA(lines).
ASSERT lines = lines( scarr\_tab ).

Addition 3

... OCCURS n

Effect

Determines the initial memory requirements defined using the addition [INITIAL SIZE](javascript:call_link\('abaptypes_itab.htm'\)) or the obsolete addition [OCCURS](javascript:call_link\('abaptypes_occurs.htm'\)) when the internal table is created. The return value has the type i. In an inline declaration, a variable of the type i is declared.

Example

The example shows that the addition of OCCURS to DESCRIBE TABLE and the attribute INITIAL\_SIZE of a type description object of class CL\_ABAP\_TABLEDESCR produce the same value.

DATA itab TYPE TABLE OF i INITIAL SIZE 10 WITH EMPTY KEY.
DESCRIBE TABLE itab OCCURS DATA(occ).
ASSERT occ = CAST cl\_abap\_tabledescr(
  cl\_abap\_typedescr=>describe\_by\_data( itab ) )->initial\_size.



**📖 Source**: [abapdescribe_table.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_table.htm)

### abapdescribe_distance.htm

> **📖 Official SAP Documentation**: [abapdescribe_distance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_distance.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [DESCRIBE](javascript:call_link\('abapdescribe.htm'\)) → 

DESCRIBE DISTANCE

[Quick Reference](javascript:call_link\('abapdescribe_distance_shortref.htm'\))

Syntax

DESCRIBE DISTANCE BETWEEN dobj1 AND dobj2 INTO dst
                          IN *{*BYTE*|*CHARACTER*}* MODE.

Effect

This statement determines the distance between the start positions of the data objects dobj1 and dobj2.

The return value has the type i. The following can be specified for dst:

-   An existing variable to which the return value can be converted.
    
-   An inline declaration [DATA(var)](javascript:call_link\('abendata_inline.htm'\)), where a variable of type i is declared.
    

It is not important in which order dobj1 and dobj2 are specified.

The variant with the addition IN BYTE MODE determines the distance in bytes. The variant with the addition IN CHARACTER MODE converts the distance into characters that can be stored in this length according to the current character format. When this addition is used in IN CHARACTER MODE and the determined distance cannot be converted into a number of characters, a non-handleable exception is raised.

In the case of [deeper](javascript:call_link\('abendeep_glosry.htm'\) "Glossary Entry") data types, the referenced data object is not relevant but the position of the internal reference (for strings and internal tables) or the reference variables instead.

Notes

-   The distance between data objects should only be determined within the same structure and only the components of the structures should be used, since this is the only way to guarantee that they follow each other immediately in the memory. Note that the [alignment gaps](javascript:call_link\('abenalignment_gap_glosry.htm'\) "Glossary Entry") are counted as well. Therefore, use the addition in IN BYTE MODE to avoid a non-handleable exception.
    
-   With respect to DESCRIBE DISTANCE, every substructure declared as a [boxed component](javascript:call_link\('abenboxed_component_glosry.htm'\) "Glossary Entry") is an independent structure. The distance between components which are not in the same boxed component is undefined.
    

Example

The results of the two statements in a Unicode system are 5 and 10.

DATA text TYPE c LENGTH 10 VALUE '0123456789'.
DESCRIBE DISTANCE BETWEEN text+2(1) AND text+7(1)
         INTO DATA(cdist)
         IN CHARACTER MODE.
DESCRIBE DISTANCE BETWEEN text+2(1) AND text+7(1)
         INTO DATA(bdist)
         IN BYTE MODE.

Executable Example

[Determining Data Object Distances](javascript:call_link\('abendescribe_distance_abexa.htm'\))

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Non-Handleable Exceptions

-   Cause: Distance cannot be converted into characters.
    Runtime error: UC\_NO\_CHAR\_NUMBER
    

Continue
![Example](exa.gif "Example") [Determining Data Object Distances](javascript:call_link\('abendescribe_distance_abexa.htm'\))



**📖 Source**: [abapdescribe_distance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_distance.htm)

### abendescribe_distance_abexa.htm

> **📖 Official SAP Documentation**: [abendescribe_distance_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendescribe_distance_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [DESCRIBE](javascript:call_link\('abapdescribe.htm'\)) →  [DESCRIBE DISTANCE](javascript:call_link\('abapdescribe_distance.htm'\)) → 

Determining Data Object Distances

The example demonstrates how the distance between two data objects can be determined at runtime.

Source Code

REPORT demo\_describe\_distance.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: BEGIN OF struc,
            comp1 TYPE i,
            comp2 TYPE x LENGTH 1,
            comp3 TYPE c LENGTH 4 VALUE 'Hey',
            comp4 TYPE c LENGTH 4 VALUE 'you!',
            comp5 TYPE x,
          END OF struc.
    FIELD-SYMBOLS: <hex>    TYPE x,
                   <result> TYPE c.
    DESCRIBE DISTANCE BETWEEN:
             struc       AND struc-comp3 INTO DATA(off) IN BYTE MODE,
             struc-comp3 AND struc-comp5 INTO DATA(len) IN BYTE MODE.
    ASSIGN: struc TO <hex> CASTING,
            <hex>+off(len) TO <result> CASTING.
    cl\_demo\_output=>display(
      |Offset off is { off }.\\n| &&
      |Length len is { len }.\\n| &&
      |<result> points to "{ <result> }".| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Determines the offset and length, in bytes, of a character-like fragment within the struc structure, accesses the fragment using an offset/length access, and assigns it a field symbol of type c. Since the structure is not just character-like, the offset/length access takes place using a field symbol. If not, a syntax error occurs. The field symbol is of the type x, since offsets and lengths are determined in bytes. The field symbol <result> points to the fragment "Hey you!".



**📖 Source**: [abendescribe_distance_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendescribe_distance_abexa.htm)

### abapdescribe_distance.htm

> **📖 Official SAP Documentation**: [abapdescribe_distance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_distance.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [DESCRIBE](javascript:call_link\('abapdescribe.htm'\)) → 

DESCRIBE DISTANCE

[Quick Reference](javascript:call_link\('abapdescribe_distance_shortref.htm'\))

Syntax

DESCRIBE DISTANCE BETWEEN dobj1 AND dobj2 INTO dst
                          IN *{*BYTE*|*CHARACTER*}* MODE.

Effect

This statement determines the distance between the start positions of the data objects dobj1 and dobj2.

The return value has the type i. The following can be specified for dst:

-   An existing variable to which the return value can be converted.
    
-   An inline declaration [DATA(var)](javascript:call_link\('abendata_inline.htm'\)), where a variable of type i is declared.
    

It is not important in which order dobj1 and dobj2 are specified.

The variant with the addition IN BYTE MODE determines the distance in bytes. The variant with the addition IN CHARACTER MODE converts the distance into characters that can be stored in this length according to the current character format. When this addition is used in IN CHARACTER MODE and the determined distance cannot be converted into a number of characters, a non-handleable exception is raised.

In the case of [deeper](javascript:call_link\('abendeep_glosry.htm'\) "Glossary Entry") data types, the referenced data object is not relevant but the position of the internal reference (for strings and internal tables) or the reference variables instead.

Notes

-   The distance between data objects should only be determined within the same structure and only the components of the structures should be used, since this is the only way to guarantee that they follow each other immediately in the memory. Note that the [alignment gaps](javascript:call_link\('abenalignment_gap_glosry.htm'\) "Glossary Entry") are counted as well. Therefore, use the addition in IN BYTE MODE to avoid a non-handleable exception.
    
-   With respect to DESCRIBE DISTANCE, every substructure declared as a [boxed component](javascript:call_link\('abenboxed_component_glosry.htm'\) "Glossary Entry") is an independent structure. The distance between components which are not in the same boxed component is undefined.
    

Example

The results of the two statements in a Unicode system are 5 and 10.

DATA text TYPE c LENGTH 10 VALUE '0123456789'.
DESCRIBE DISTANCE BETWEEN text+2(1) AND text+7(1)
         INTO DATA(cdist)
         IN CHARACTER MODE.
DESCRIBE DISTANCE BETWEEN text+2(1) AND text+7(1)
         INTO DATA(bdist)
         IN BYTE MODE.

Executable Example

[Determining Data Object Distances](javascript:call_link\('abendescribe_distance_abexa.htm'\))

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Non-Handleable Exceptions

-   Cause: Distance cannot be converted into characters.
    Runtime error: UC\_NO\_CHAR\_NUMBER
    

Continue
![Example](exa.gif "Example") [Determining Data Object Distances](javascript:call_link\('abendescribe_distance_abexa.htm'\))



**📖 Source**: [abapdescribe_distance.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_distance.htm)

### abendescribe_internal.htm

> **📖 Official SAP Documentation**: [abendescribe_internal.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendescribe_internal.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [DESCRIBE](javascript:call_link\('abapdescribe.htm'\)) → 

DESCRIBE - Internal Variant

This statement is for internal use only.
It must not be used in application programs.

-   [DESCRIBE FIELD INTO](javascript:call_link\('abapdescribe_field_into.htm'\))

Continue
[DESCRIBE FIELD INTO](javascript:call_link\('abapdescribe_field_into.htm'\))



**📖 Source**: [abendescribe_internal.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendescribe_internal.htm)

### abapdescribe_field_into.htm

> **📖 Official SAP Documentation**: [abapdescribe_field_into.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_field_into.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [DESCRIBE](javascript:call_link\('abapdescribe.htm'\)) →  [DESCRIBE - Internal Variant](javascript:call_link\('abendescribe_internal.htm'\)) → 

DESCRIBE FIELD INTO

This statement is for internal use only.
It must not be used in application programs.

Syntax

DESCRIBE FIELD dobj INTO td.

Effect

All attributes of the field f, its components, subcomponents, and so on, are in the output of the field td (type description). td must have the type SYDES\_DESC, defined in the [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") SYDES.

The structure SYDES\_DESC has two table-like components TYPES and NAMES:

-   The tree structure of the type belonging to f is mapped to TYPES. The components of a node are stored in the table TYPES in a continuous manner. The beginning and end of the row area that represents the components are stored in TYPES-FROM and TYPES-TO. The reference to the superior node can be found in TYPES-BACK. If no superior or subordinate node exists, then this is marked by the value 0 (for the relevance of further components, see the following sections).
    
-   The names of components, types, and so on. are not stored directly in TYPES. Instead, the components TYPES-IDX\_... hold an index in the name table NAMES. The value 0 indicates that there is no reference to the name table.
    NAMES contains the names in the component NAMES-NAME, possibly in parts. If a name continues in the following row, this is indicated by an asterisk ('\*') in the component NAMES-CONTINUE.
    

The type description table (TYPES) not only stores information about the tree structure but also further information about the type of f or its components. In particular, this includes all information that can be determined using the usual additions of DESCRIBE FIELD. In detail, TYPES contains the following columns:

IDX\_NAME

Component name

IDX\_USER\_TYPE

Name of a user-defined type, in other words a type defined by a [TYPES](javascript:call_link\('abaptypes.htm'\)) statement. Derived types (... TYPE A-B) and structures from ABAP Dictionary are not considered to be user-defined types.

CONTEXT

For user-defined types only: The context in which the type is defined. Possible values are defined in the constant SYDES\_CONTEXT of the type group SYDES. Only use these constants to carry out a comparison. The following type contexts are distinguished:
SYDES\_CONTEXT-PROGRAM: Program-global type
SYDES\_CONTEXT-FORM : FORM\-local type
SYDES\_CONTEXT-FUNCTION: FUNCTION\-local type
SYDES\_CONTEXT-METHOD : METHOD\-local type

IDX\_CONTEXT\_NAME

For user-defined types only:
In a local context: The name of the FORM or FUNCTION in which the type was defined. The name of the associated program is then the first entry in the name table.
In a global context: The name of the program in which the type was defined.

IDX\_EDIT\_MASK

Conversion routine from ABAP Dictionary, like the addition EDIT MASK in a simple DESCRIBE.

IDX\_HELP\_ID

Help ID when referencing fields from ABAP Dictionary

LENGTH

Internal length, like the addition LENGTH in a simple DESCRIBE

OUTPUT\_LENGTH

Output length, like the addition OUTPUT-LENGTH in a simple DESCRIBE

DECIMALS

Number of [decimal digits](javascript:call_link\('abendecimal_place_glosry.htm'\) "Glossary Entry"), like the addition DECIMALS in a simple DESCRIBE

TYPE

ABAP type, like the addition TYPE in a simple DESCRIBE. If DESCRIBE INTO is applied to a nested structure which contains a [boxed component](javascript:call_link\('abenboxed_component_glosry.htm'\) "Glossary Entry"), the type is returned with the internal ID j ([static box](javascript:call_link\('abenstatic_box_glosry.htm'\) "Glossary Entry")).

TABLE\_KIND

A [table category](javascript:call_link\('abaptypes_tabkind.htm'\)) is stored here for the components which represent an internal table. The same values are returned as with the variant [DESCRIBE TABLE itab KIND k](javascript:call_link\('abapdescribe_table.htm'\)). For components which do not represent a table, the return code is set to SYDES\_KIND-UNDEFINED (see type group SYDES).

Example

Take the following definition of the complex data type EMPLOYEE\_STRUC:

PROGRAM DESCTEST.
TYPES: BEGIN OF name\_struc,
         first  TYPE c LENGTH 20,
         last   TYPE c LENGTH 20,
       END OF name\_struc,
       BEGIN OF absence\_time\_struc,
         day        TYPE d,
         from       TYPE t,
         to         TYPE t,
       END OF absence\_time\_struc,
       phone\_number TYPE n LENGTH 20,
       BEGIN OF employee\_struc,
         id         LIKE sbook-customid,
         name       TYPE name\_struc,
         BEGIN OF address,
           street  TYPE c LENGTH 30,
           zipcode TYPE n LENGTH 4,
           place   TYPE c LENGTH 30,
         END OF address,
         salary\_per\_month TYPE p LENGTH 10 DECIMALS 3,
         absent           TYPE STANDARD TABLE OF absence\_time\_struc
                               WITH NON-UNIQUE DEFAULT KEY,
         phone            TYPE STANDARD TABLE OF phone\_number
                               WITH NON-UNIQUE DEFAULT KEY,
       END OF employee\_struc.

The structure of the type can be determined by collecting the type group SYDES as follows:

DATA: employee TYPE employee\_struc,
      td       TYPE sydes\_desc.
DESCRIBE FIELD employee INTO td.

The following table shows a few selected columns of the type description table TD-TYPES. To make it easier to read, the names of the columns IDX\_NAME, IDX\_UERR\_TYPE, and IDX\_EDIT\_MASK have been shortened:

   |FROM| TO |BACK|NAME|UTYP|EMSK|TYPE
\---|----|----|----|----|----|----|----
01 |  2 |  7 |  0 |  0 |  2 |  0 |  v
02 |  0 |  0 |  1 |  6 |  0 |  4 |  N
03 |  8 |  9 |  1 |  7 |  5 |  0 |  u
04 | 10 | 12 |  1 |  8 |  0 |  0 |  u
05 |  0 |  0 |  1 |  9 |  0 |  0 |  P
06 | 13 | 13 |  1 | 11 |  0 |  0 |  h
07 | 17 | 17 |  1 | 12 |  0 |  0 |  h
08 |  0 |  0 |  3 | 13 |  0 |  0 |  C
09 |  0 |  0 |  3 | 14 |  0 |  0 |  C
10 |  0 |  0 |  4 | 15 |  0 |  0 |  C
11 |  0 |  0 |  4 | 16 |  0 |  0 |  N
12 |  0 |  0 |  4 | 17 |  0 |  0 |  C
13 | 14 | 16 |  6 |  0 | 18 |  0 |  u
14 |  0 |  0 | 13 | 20 |  0 |  0 |  D
15 |  0 |  0 | 13 | 21 |  0 |  0 |  T
16 |  0 |  0 | 13 | 22 |  0 |  0 |  T
17 |  0 |  0 |  7 |  0 |  0 |  0 |  N

Note that the entries in rows 6 and 7 represent internal tables (ABAP type h). In an internal table, there is always an entry for the associated row type (rows 13 and 17).
The indexes in the rows 5 to 7 refer to entries in the name table TD-NAMES. Taking, for example, row 3, the associated component name in TD-NAMES is found from row 7 (NAME) onward and the associated user type from row 5 (NAME\_STRUC) onward.
The name table TD-NAMES contains the following entries. Note that the names SALARY\_PER\_MONTH and ABSENCE\_TIME\_STRUC are stored in two parts:

   |CONTINUE|NAME                   |CONTINUE|NAME
\---|--------|--------------     ----|--------|--------------
01 |        |DESCTEST            12 |        |PHONE
02 |        |EMPLOYEE\_STRUC      13 |        |FIRST
03 |        |SBOOK-CUSTOMID      14 |        |LAST
04 |        |==ALPHA             15 |        |STREET
05 |        |NAME\_STRUC          16 |        |ZIPCODE
06 |        |ID                  17 |        |PLACE
07 |        |NAME                18 |   \*    |ABSENCE\_TIME\_ST
08 |        |ADDRESS             19 |        |RUC
09 |   \*    |SALARY\_PER\_MONT     20 |        |DAY
10 |        |H                   21 |        |FROM
11 |        |ABSENT              22 |        |TO



**📖 Source**: [abapdescribe_field_into.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_field_into.htm)

### abendescribe_internal.htm

> **📖 Official SAP Documentation**: [abendescribe_internal.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendescribe_internal.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [DESCRIBE](javascript:call_link\('abapdescribe.htm'\)) → 

DESCRIBE - Internal Variant

This statement is for internal use only.
It must not be used in application programs.

-   [DESCRIBE FIELD INTO](javascript:call_link\('abapdescribe_field_into.htm'\))

Continue
[DESCRIBE FIELD INTO](javascript:call_link\('abapdescribe_field_into.htm'\))


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / RTTS - Runtime Type Services

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / RTTS - Runtime Type Services

Included pages: 3



**📖 Source**: [abendescribe_internal.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendescribe_internal.htm)

### abenrtti.htm

> **📖 Official SAP Documentation**: [abenrtti.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrtti.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) → 

RTTS - Runtime Type Services

The [RTTS](javascript:call_link\('abenrun_time_type_services_glosry.htm'\) "Glossary Entry") are implemented using a hierarchy of [type description classes](javascript:call_link\('abentype_class_glosry.htm'\) "Glossary Entry") that contain the methods for [Runtime Type Creation (RTTC)](javascript:call_link\('abenrun_time_type_creation_glosry.htm'\) "Glossary Entry") and [Runtime Type Identification (RTTI)](javascript:call_link\('abenrun_time_type_identific_glosry.htm'\) "Glossary Entry"). Using these system classes it is possible to

-   determine type information of existing [instances](javascript:call_link\('abeninstance_glosry.htm'\) "Glossary Entry") and [type names](javascript:call_link\('abentype_names.htm'\)) in the [ABAP type system](javascript:call_link\('abentypes_objects_oview.htm'\)) at runtime.

-   define new data types at runtime.

Concept

The properties of the types are represented by the attributes of [type description objects](javascript:call_link\('abentype_object_glosry.htm'\) "Glossary Entry"). For each type there is exactly one type description object. The attributes of the type description object contain information about the properties of the type. For each category of type (elementary type, table, class, and so on), there is a type description class with special attributes for the special type properties. The class hierarchy of the type description classes corresponds to the hierarchy of the type categories in the [ABAP type system](javascript:call_link\('abentypes_objects_oview.htm'\)).

In addition, type description classes for complex types, references, classes, and interfaces have special methods for specifying references to partial types. These methods can be used can navigate to all partial types using a composite type.

Type description objects can only be created using the methods of type description classes. To get a reference to a type description object of a type, the static methods of the class CL\_ABAP\_TYPEDESCR can be used or call methods of the special type description classes.

Note

In the statement [CREATE DATA](javascript:call_link\('abapcreate_data.htm'\)), type description objects can be specified after the addition [HANDLE](javascript:call_link\('abapcreate_data_handle.htm'\)) to create data objects with dynamically created data types.

Hierarchy of Type Description Classes

CL\_ABAP\_TYPEDESCR
  |
  |--CL\_ABAP\_DATADESCR
  |   |
  |   |--CL\_ABAP\_ELEMDESCR
  |   |   |
  |   |   |--CL\_ABAP\_ENUMDESCR
  |   |
  |   |--CL\_ABAP\_REFDESCR
  |   |--CL\_ABAP\_COMPLEXDESCR
  |       |
  |       |--CL\_ABAP\_STRUCTDESCR
  |       |--CL\_ABAP\_TABLEDESCR
  |
  |--CL\_ABAP\_OBJECTDESCR
     |
     |--CL\_ABAP\_CLASSDESCR
     |--CL\_ABAP\_INTFDESCR

Example

Reading the type attributes of an elementary type from a type object generated with the method DESCRIBE\_BY\_DATA.

TYPES my\_type TYPE p LENGTH 16 DECIMALS 6.
DATA  my\_data TYPE my\_type.
DATA(descr) = cl\_abap\_typedescr=>describe\_by\_data( my\_data ).
cl\_demo\_output=>display(
  |Typename: { descr->absolute\_name }\\n| &&
  |Kind:     { descr->type\_kind     }\\n| &&
  |Length:   { descr->length        }\\n| &&
  |Decimals: { descr->decimals      }\\n| ).

Example

Reading the attributes of the components of a structure. The reference to the type object is assigned using a down cast to a reference variable of type CL\_ABAP\_STRUCT\_DESCR.

cl\_demo\_output=>display( CAST cl\_abap\_structdescr(
  cl\_abap\_typedescr=>describe\_by\_name( 'SYST' ) )->components ).

Continue
![Example](exa.gif "Example") [Determining Data Types](javascript:call_link\('abenrtti_data_type_abexa.htm'\))
![Example](exa.gif "Example") [Determining Object Types](javascript:call_link\('abenrtti_object_type_abexa.htm'\))



**📖 Source**: [abenrtti.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrtti.htm)

### abenrtti_data_type_abexa.htm

> **📖 Official SAP Documentation**: [abenrtti_data_type_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrtti_data_type_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [RTTS - Runtime Type Services](javascript:call_link\('abenrtti.htm'\)) → 

Determining Data Types

This example demonstrates how the attributes of data types can be determined at runtime.

Source Code

REPORT demo\_rtti\_data\_types.
CLASS conv\_exc DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: type1 TYPE c LENGTH 30 VALUE 'SCARR',
          type2 TYPE c LENGTH 30 VALUE 'SPFLI'.
    DATA: dref1 TYPE REF TO data,
          dref2 TYPE REF TO data.
    FIELD-SYMBOLS: <data1> TYPE any,
                   <data2> TYPE any.
    DATA: descr\_ref1 TYPE REF TO cl\_abap\_typedescr,
          descr\_ref2 TYPE REF TO cl\_abap\_typedescr.
    cl\_demo\_input=>add\_field( CHANGING field = type1 ).
    cl\_demo\_input=>request(   CHANGING field = type2 ).
    TRY.
        CREATE DATA: dref1 TYPE (type1),
                     dref2 TYPE (type2).
        ASSIGN: dref1->\* TO <data1>,
                dref2->\* TO <data2>.
      CATCH cx\_sy\_create\_data\_error.
        cl\_demo\_output=>display( 'Create data error!' ).
        LEAVE PROGRAM.
    ENDTRY.
    descr\_ref1 = cl\_abap\_typedescr=>describe\_by\_data( <data1> ).
    descr\_ref2 = cl\_abap\_typedescr=>describe\_by\_data( <data2> ).
    TRY.
        IF descr\_ref1 <> descr\_ref2.
          RAISE EXCEPTION TYPE conv\_exc.
        ELSE.
          <data2> = <data1>.
        ENDIF.
      CATCH conv\_exc.
        cl\_demo\_output=>display(
          \`Assignment from type \`    &&
          descr\_ref2->absolute\_name  &&
          \` to \`                     &&
          descr\_ref1->absolute\_name  &&
          \` not allowed!\` ).
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example expands on the [executable example](javascript:call_link\('abendescribe_field_abexa.htm'\)) for DESCRIBE FIELD, where the correct way to check any data type is described.

When complex types, such as SCARR and SPFLI, are entered in the input fields, the RTTI determines the full [absolute type name](javascript:call_link\('abenabsolute_typename_glosry.htm'\) "Glossary Entry").



**📖 Source**: [abenrtti_data_type_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrtti_data_type_abexa.htm)

### abenrtti_object_type_abexa.htm

> **📖 Official SAP Documentation**: [abenrtti_object_type_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrtti_object_type_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing Internal Data](javascript:call_link\('abenabap_data_working.htm'\)) →  [Attributes of Data Objects](javascript:call_link\('abendescribe_field.htm'\)) →  [RTTS - Runtime Type Services](javascript:call_link\('abenrtti.htm'\)) → 

Determining Object Types

This example demonstrates how the dynamic types of objects can be determined at runtime.

Source Code

REPORT demo\_rtti\_object\_types.
CLASS conv\_exc DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS c1 DEFINITION.
ENDCLASS.
CLASS c2 DEFINITION.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: otype1 TYPE c LENGTH 30 VALUE 'C1',
          otype2 TYPE c LENGTH 30 VALUE 'C2'.
    DATA: oref1 TYPE REF TO object,
          oref2 TYPE REF TO object.
    DATA: descr\_ref1 TYPE REF TO cl\_abap\_typedescr,
          descr\_ref2 TYPE REF TO cl\_abap\_typedescr.
    cl\_demo\_input=>add\_field( CHANGING field = otype1 ).
    cl\_demo\_input=>request(   CHANGING field = otype2 ).
    TRY.
        otype1 = cl\_abap\_dyn\_prg=>check\_whitelist\_str(
          EXPORTING
            val                      = otype1
            whitelist                =  \`C1,C2\` ).
        otype2 = cl\_abap\_dyn\_prg=>check\_whitelist\_str(
          EXPORTING
            val                      = otype2
            whitelist                =  \`C1,C2\` ).
      CATCH cx\_abap\_not\_in\_whitelist.
        cl\_demo\_output=>display( 'Input not allowed' ).
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        CREATE OBJECT: oref1 TYPE (otype1),
                       oref2 TYPE (otype2).
      CATCH cx\_sy\_create\_object\_error.
        cl\_demo\_output=>display( 'Create object error!' ).
        LEAVE PROGRAM.
      CATCH cx\_root.
        cl\_demo\_output=>display( 'Other error!' ).
        LEAVE PROGRAM.
    ENDTRY.
    descr\_ref1 = cl\_abap\_typedescr=>describe\_by\_object\_ref( oref1 ).
    descr\_ref2 = cl\_abap\_typedescr=>describe\_by\_object\_ref( oref2 ).
    TRY.
        IF descr\_ref1 <> descr\_ref2.
          RAISE EXCEPTION TYPE conv\_exc.
        ELSE.
          oref1 = oref2.
        ENDIF.
      CATCH conv\_exc.
        cl\_demo\_output=>display(
          \`Assignment from type \`   && |\\n| &&
          descr\_ref2->absolute\_name && |\\n| &&
          \`to \`                     && |\\n| &&
          descr\_ref1->absolute\_name && |\\n| &&
          \`not allowed!\` ).
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example is the object type counterpart of the [executable example](javascript:call_link\('abenrtti_data_type_abexa.htm'\)) for data types. Here, the dynamic type of reference variables is determined, namely the [absolute type name](javascript:call_link\('abenabsolute_typename_glosry.htm'\) "Glossary Entry") of the class of the referenced object.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing External Data / ABAP File Interface / Authorization for File Access

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing External Data / ABAP File Interface / Authorization for File Access

Included pages: 3



**📖 Source**: [abenrtti_object_type_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrtti_object_type_abexa.htm)

### abendataset_auth.htm

> **📖 Official SAP Documentation**: [abendataset_auth.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendataset_auth.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing External Data](javascript:call_link\('abenabap_language_external_data.htm'\)) →  [ABAP File Interface](javascript:call_link\('abenabap_language_files.htm'\)) → 

Authorization for File Access

-   [Automatic Authorization Checks](javascript:call_link\('abenfile_interface_authority.htm'\))

-   [Validation of File Names](javascript:call_link\('abendataset_auth_self.htm'\))

Continue
[Automatic Authorization Checks](javascript:call_link\('abenfile_interface_authority.htm'\))
[Validation of File Names](javascript:call_link\('abendataset_auth_self.htm'\))



**📖 Source**: [abendataset_auth.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendataset_auth.htm)

### abenfile_interface_authority.htm

> **📖 Official SAP Documentation**: [abenfile_interface_authority.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenfile_interface_authority.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing External Data](javascript:call_link\('abenabap_language_external_data.htm'\)) →  [ABAP File Interface](javascript:call_link\('abenabap_language_files.htm'\)) →  [Authorization for File Access](javascript:call_link\('abendataset_auth.htm'\)) → 

Automatic Authorization Checks

The following authorization checks take place automatically when data is accessed:

-   [Authorization Check in the Operating System](#abenfile-interface-authority-1--------authorization-checks-for-special-files---@ITOC@@ABENFILE_INTERFACE_AUTHORITY_2)

-   [Authorization Object S\_DATASET](#abenfile-interface-authority-3--------database-table-spth-and-authorization-object-s--path---@ITOC@@ABENFILE_INTERFACE_AUTHORITY_4)

Authorization Check in the Operating System

From the point of view of the operating system on the [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") of a AS Instance, all files are accessed from [AS ABAP](javascript:call_link\('abensap_nw_abap_glosry.htm'\) "Glossary Entry"). As a consequence, the user of the operating system that creates an instance of the [AS ABAP](javascript:call_link\('abensap_nw_abap_glosry.htm'\) "Glossary Entry") AS Instance must have the authority to read and write to all files and directories that are handled by the ABAP file interface. If this authorization does not exist, the file interface statements can only be partially carried out, or not at all. If a statement cannot be executed because of lack of authorization in the operating system, the return value sy-subrc is set to not equal to 0.

Authorization Checks for Special Files

Every time a PSE file (file with the extension .pse for a Personal Security Environment) is accessed, an automatic authorization check for the current user is performed with the value "01" for the field ACTVT of the authorization object S\_RZL\_ADM of the system administrator.

Authorization Object S\_DATASET

An authorization check is performed for the current user each time a file is opened or deleted using the following:

-   [OPEN DATASET](javascript:call_link\('abapopen_dataset.htm'\))

-   [DELETE DATASET](javascript:call_link\('abapdelete_dataset.htm'\))

Also, the current program is executed using the predefined authorization object S\_DATASET. This authorization object contains the authorization fields PROGRAM for the program names, FILENAME for the opened files, and ACTVT with the activities Delete, Read, Write, Read with Filter, and Write with Filter. If the user or program does not have the necessary authorization, a handleable exception of the class CX\_SY\_FILE\_AUTHORITY is raised. To avoid this, the function module AUTHORITY\_CHECK\_DATASET can be called before the relevant ABAP statement to check whether the authorization exists.

Note

In the authorization check with the authorization object S\_DATASET, the [physical file name](javascript:call_link\('abenphysical_filename_glosry.htm'\) "Glossary Entry") used in the statements above and the values of the authorization field FILENAME are subject to a literal comparison. Any relative paths specified are not transformed to absolute paths. To avoid unexpected results, it is best to specify only absolute paths in physical file names.

Database Table SPTH and Authorization Object S\_PATH

An automatic check is made when the following statements access files:

-   [OPEN DATASET](javascript:call_link\('abapopen_dataset.htm'\))

-   [DELETE DATASET](javascript:call_link\('abapdelete_dataset.htm'\))

This check is made on entries in the database tables SPTH. The entries in the database table SPTH control the general read and write accesses from ABAP programs to files and whether files should be backed up or not.

In the database table SPTH, reads and writes can be forbidden on all files specified absolutely or relatively, regardless of the [authorization objects](javascript:call_link\('abenauthorization_object_glosry.htm'\) "Glossary Entry"). For the remaining files (those that are generally allowed to be accessed for read or write according to the database table SPTH), authorization checks can be carried out on the basis of authorization objects. In the database table SPTH, authorization groups from the table SPTHB (texts in SPTHT, shared view V\_SPT) for program-independent authorization checks can be defined. The following table shows the columns of the database table SPTH. If the check on the database table SPTH has a negative result, a handleable exception of the class CX\_SY\_FILE\_AUTHORITY is raised.

Column

Meaning

PATH

Absolute or relative path specified for directory names or file names. The content specified in the other columns of this row applies to all the files of the AS Instance that are best described by the entry in this column.

SAVEFLAG

The value "X" in this column can be evaluated by backups. The ABAP runtime environment does not itself make any backups.

FS\_NOREAD

If this column contains the value "X", the files specified in the column PATH cannot be accessed from ABAP. This setting overrides the setting in the columns FS\_NOWRITE and FS\_BRGRU as well as the authorization check on the authorization object S\_DATASET.

FS\_NOWRITE

If this column contains the value "X", writes cannot be performed on the files specified in the column PATH from ABAP. This setting overrides the setting in the column FS\_BRGRU as well as the authorization check on the authorization object S\_DATASET.

FS\_BRGRU

In this column, an authorization group can be specified that is defined in the table SPTHB. The files of multiple rows can be grouped together in this way. When the database table SPTH is evaluated, an authorization check for the current user is made against the authorization object S\_PATH (which contains an authorization field FS\_BRGRU and an authorization field ACTVT with the possible values "03" (Display), "02" (Change), "A6" (Display with Addition [FILTER](javascript:call_link\('abapopen_dataset_os_addition.htm'\)) ), and "A7" (Change with Addition [FILTER](javascript:call_link\('abapopen_dataset_os_addition.htm'\))). This makes it possible to grant access to the files specified in PATH to specific users. If no authorization group is entered, no authorization check is made against the authorization object S\_PATH.

In the paths specified in the column PATH, placeholders can be specified for specific [profile parameters](javascript:call_link\('abenprofile_parameter_glosry.htm'\) "Glossary Entry") or for the current [client](javascript:call_link\('abenclient_glosry.htm'\) "Glossary Entry"):

... <P=name> ...

When evaluated, a placeholder is replaced by the value of the profile parameter specified in name or by the current [client ID](javascript:call_link\('abenclient_identifier_glosry.htm'\) "Glossary Entry"). The possible values for name are specified in the documentation of the table SPTH.

When a file is accessed using the statements [OPEN DATASET](javascript:call_link\('abapopen_dataset.htm'\)) and [DELETE DATASET](javascript:call_link\('abapdelete_dataset.htm'\)), a [physical file name](javascript:call_link\('abenphysical_filename_glosry.htm'\) "Glossary Entry") is used. When the content of the database table SPTH is transformed, a check is made to see whether the physical file name starts with an entry in the column PATH and the row with the longest matching path is used. Before the check, a specified path in the physical file name is standardized as follows:

-   Any ../ segments are removed. For example, a path specified as /tmp/sub1/../sub2/file is transformed to /tmp/sub2/file.

-   If the operating system is not an MS Windows operating system, the / characters are converted to \\ characters and all letters are changed to uppercase letters.

If no matching path is specified in the column PATH, the row is used in which the column PATH contains the entry "\*". If this entry does not exist either, no automatic authorization check is made.

The character "\*" in the column PATH is relevant only if it is the only character entered here. When specified within paths, is subject to literal comparisons and is not used as a wildcard character.

Notes

-   In comparison to the authorization check using the authorization object S\_DATASET (see above), an authorization check using the authorization object S\_PATH is independent of the ABAP program in which it occurs.

-   Paths specified in the column PATH should usually exist in a standardized form.

-   When the path specified is standardized to a physical file name, any relative paths specified are not transformed to absolute paths. Any links and any other changeable information are not resolved.

-   The comparison rule for a path specified in the column PATH with a physical file name used to access a file is both literal and (due to the check on whether the initial segment matches) generic too. The following aspects should be noted to avoid unexpected results:

-   The character "\*" only has a special function if it is the only character in the column PATH.

-   The table SPTH should always contain an entry with the value "\*" for the column PATH. This entry is used whenever no other entries match.

-   The names of directories should always be closed with the character "/". If this is not the case, a path specified as "/tmp" in the column PATH specifies all files and directories that start with "/tmp" (like "/tmpxxx") and not just the directory "/tmp/".

-   Any path specified in the column PATH is not unique. It can contain hard links and soft links. Mount points, network paths, and similar entries can also be specified. This means the following must be noted:

-   A combination of paths specified in the column PATH with values "X" in the columns FS\_NOREAD and FS\_NOWRITE defines non-user-specific blacklists of forbidden paths. The access rights are not necessarily unique, which makes them difficult to delimit sufficiently.

-   A combination of paths specified in the column PATH with authorization groups in the column FS\_BRGRU defines whitelists of valid paths for authorized users. In this case, the lack of uniqueness of the access rights is not critical.

For this reason, is recommended that the authorization groups in the column FS\_BRGRU and the authorization object S\_PATH are used instead of the columns FS\_NOREAD and FS\_NOWRITE.

-   Unlike in an authorization check using the authorization object S\_PATH, checks made on the columns FS\_NOREAD and FS\_NOWRITE are not made as part of the general [authorization concept](javascript:call_link\('abenbc_authority_check.htm'\)) and none of the associated log entries are written.

-   For compatibility reasons, even empty values are accepted for the activity when the authorization object S\_PATH is checked, which means that files can be opened using the addition [FILTER](javascript:call_link\('abapopen_dataset_os_addition.htm'\)).

-   The column SAVEFLAG, used for backups, should only be used together with a value in another column, preferably FS\_BRGRU. If not, no authorization check is made on files covered by the path specified in PATH.

Example

The table SPTH is filled as follows:

PATH

SAVEFLAG

FS\_NOREAD

FS\_NOWRITE

FS\_BRGRU

\*

\-

\-

\-

SUPR

/

\-

\-

\-

ROOT

/dir\_open/

\-

\-

\-

\-

/tmp/sub/data/

\-

\-

\-

UDAT

/tmp/sub/data/work/

\-

\-

\-

UWRK

/tmp/sub/prefix

\-

\-

\-

UPRE

These entries have the following effects:

-   Every user can make reads and writes on files in the directory /dir\_open and its subdirectories, since no restrictions are entered.

-   Only users with an authorization for the authorization group UWRK can access files in the directory /tmp/sub/data/work/ and its subdirectories.

-   Only users with an authorization for the authorization group UDAT can access files in the directory /tmp/sub/data/ and its subdirectories (with the exception of /tmp/sub/data/work/). Instead, an authorization for the authorization group UWRK is required for /tmp/sub/data/work/.

-   Users with an authorization for the authorization group UPRE can access not just those files in the directory /tmp/sub whose names start with prefix but also all files in subdirectories whose names start with /tmp/sub/prefix. If restricted access to files in a subdirectory /tmp/sub/prefix is required, the entry made in PATH must be closed using "/".

-   User with an authorization for the authorization group ROOT can access files in any directory, as long as the physical file name is specified with "/" at the start or is absolute.

-   Users with an authorization for the authorization group SUPR can access files in any directories specified as relative directories as long as the directories are not specified with "/" at the start.

Example

The table SPTH is filled as follows:

PATH

SAVEFLAG

FS\_NOREAD

FS\_NOWRITE

FS\_BRGRU

\*

\-

X

X

\-

/

\-

\-

\-

ROOT

/tmp/

\-

\-

\-

\-

/tmp/myfiles/

\-

\-

\-

FILE

The entries have the following properties:

-   The entries in the first row apply to all fields on the AS Instance except for those in the paths /, /tmp/, and their subdirectories.

-   The entries in the second row apply to all fields on the AS Instance in the path / except for the files in the path /tmp and its subdirectories.

-   The entries in the third row apply to all fields on the AS Instance in the path /tmp except for the files in the path /tmp/myfiles and its subdirectories.

-   The entries in the fourth row apply to the fields in the path /tmp/myfiles and its subdirectories.

The entries dictate that no user can make reads or writes on files specified using relative paths. Users with authorization for the authorization group ROOT can access all files specified using absolute paths except for the files in the path /tmp/myfiles. All users can make both reads and writes on the files in the path /tmp. Only users who have an authorization for the authorization group FILE can make reads and writes on the files in the path /tmp/myfiles. When the table above is applied, this means that the following program lines produce a runtime error for all users except those with authorization for the authorization group ROOT,

DATA fname TYPE string.
fname = \`/system/files\`.
OPEN DATASET fname FOR OUTPUT IN BINARY MODE.

This configuration forbids the use of any relative paths when files are accessed. This rule is generally only advisable if this behavior is explicitly required.

-   All permitted paths should be specified in the table SPTH and associated with the appropriate authorization groups.

-   Access to the path specified as "\* should also be subject to an authorization group permitting access using any relative paths for authorized users.



**📖 Source**: [abenfile_interface_authority.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenfile_interface_authority.htm)

### abendataset_auth_self.htm

> **📖 Official SAP Documentation**: [abendataset_auth_self.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendataset_auth_self.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing External Data](javascript:call_link\('abenabap_language_external_data.htm'\)) →  [ABAP File Interface](javascript:call_link\('abenabap_language_files.htm'\)) →  [Authorization for File Access](javascript:call_link\('abendataset_auth.htm'\)) → 

Validation of File Names

Alongside the [automatic authorization checks](javascript:call_link\('abenfile_interface_authority.htm'\)), it may be necessary to validate file names before they are used to prevent [directory traversals](javascript:call_link\('abendirectory_traversal_glosry.htm'\) "Glossary Entry"). This is particularly important if

-   the automatic authorization checks are not enough, for example because the database table SPTH or the authorizations for the authorization object S\_DATASET have not been defined in full.

-   programs with [physical file names](javascript:call_link\('abenphysical_filename_glosry.htm'\) "Glossary Entry") are used, and these file names are provided using external interfaces such as APIs or UIs.

However if logical file names are consistently used, there is no need for validation.

-   [Using Logical File Names](#abendataset-auth-self-1--------using-physical-file-names---@ITOC@@ABENDATASET_AUTH_SELF_2)

-   [Self-Programmed Validation](#abendataset-auth-self-3--------validation-with-logical-file-names---@ITOC@@ABENDATASET_AUTH_SELF_4)

Using Logical File Names

File names do not usually need to be validated if a program is consistent in using only [logical file names](javascript:call_link\('abenlogical_filename_glosry.htm'\) "Glossary Entry") created by the system administrator in the transactions FILE or SF01. Next, the set of logical file names available to an application defines the set of possible physical file names. The associated physical file names are not edited explicitly in the program. Instead, the function module FILE\_GET\_NAME is used to create the physical file name from the logical file name directly before it is used in a [statement of the file interface](javascript:call_link\('abenfile_interface_statements.htm'\)) and used for file access.

Example

The following program works with a logical file name in field log\_name. The function module FILE\_GET\_NAME uses this file name to create a platform-specific physical file name in phys\_name (for use in the statement OPEN DATASET). As the value abap\_true is passed to parameter INCLUDING\_DIR, the physical file name is absolute; in other words, it contains an absolute path.

DATA: log\_name  TYPE filename-fileintern,
      phys\_name TYPE string.
...
CALL FUNCTION 'FILE\_GET\_NAME'
  EXPORTING
    logical\_filename = log\_name
    including\_dir    = abap\_true
  IMPORTING
    file\_name        = phys\_name
  EXCEPTIONS
    file\_not\_found   = 2
    OTHERS           = 4.
IF sy-subrc <> 0.
  MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                      DISPLAY LIKE sy-msgty.
  RETURN.
ENDIF.
OPEN DATASET phys\_name FOR OUTPUT IN TEXT MODE ENCODING UTF-8 .
...

Using Physical File Names

If a program uses [physical file names](javascript:call_link\('abenphysical_filename_glosry.htm'\) "Glossary Entry"), the name almost always needs to be validated.

Self-Programmed Validation

If valid directories and file names are defined precisely (as is often the case in programs from the technical infrastructure), this type of validation can be skipped. The following can be used, for example:

-   Methods from [character string processing](javascript:call_link\('abenabap_data_string.htm'\)),

-   Methods from class CL\_ABAP\_DYN\_PRG for checking whitelists,

-   Methods in the class CL\_FS\_PATH

However, self-programmed validations (especially when using character string processing) is suitable only for simple cases. For all other cases, validation with logical file names is usually recommended.

Validation with logical file names

In many cases, directories and file names are generic, and are predefined by the system administrator when configuring the system. They can be modified or enhanced while the system is running. In these cases, the concept of logical file names should be employed when handling physical file names explicitly.

In addition to the case above, where a program uses only logical file names, the associations between logical and physical file names can also be useful when handling physical file names for validation purposes. As long as the list of logical file names is complete, the function module FILE\_VALIDATE\_NAME can be called before a file is accessed. This module checks whether the physical file name is associated with a logical file name or whether the directory is valid. In this way, the function module checks whether the physical file exists in the set defined by the logical file names.

Note

The function module FILE\_VALIDATE\_NAME always checks absolute file names with specified paths. If a relative file name is passed for checking, the default path is implicitly added as a prefix to DIR\_HOME in accordance with the [profile parameter](javascript:call_link\('abenprofile_parameter_glosry.htm'\) "Glossary Entry").

Example

Validation of a directory. For a directory, the logical file name contained in log\_name must have been created in the format DIR using transaction FILE. The function module FILE\_GET\_NAME provides the platform-specific path for this directory in path. For a directory, the value abap\_true must be passed to parameter INCLUDING\_DIR, otherwise the function module is terminated with an exception. The method IS\_RELATIVE of class CL\_FS\_PATH is used to check whether a file name phys\_name entered by a user is relative or contains an absolute path. An existing absolute file name is applied without being modified. Relative file names are concatenated with the path. This is done using the method APPEND\_PATH\_NAME of a path object from the class CL\_FS\_PATH created from path. This object is platform-independent and works regardless of whether path contains a closing separator like \\. Finally, phys\_name with FILE\_VALIDATE\_NAME is validated by checking the directory of log\_name. This check is also necessary when creating a chain from the path and relative file name. This is because the specified relative file name can contains parts such as \\..\\, which can point to path locations outside of the permitted directory.

DATA: phys\_name TYPE string,
      log\_name  TYPE filename-fileintern,
      path      TYPE string.
...
CALL FUNCTION 'FILE\_GET\_NAME'
  EXPORTING
    logical\_filename = log\_name
    including\_dir    = abap\_true
  IMPORTING
    file\_name        = path
  EXCEPTIONS
    file\_not\_found   = 2
    OTHERS           = 4.
IF sy-subrc <> 0.
  MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno DISPLAY LIKE sy-msgty.
  RETURN.
ENDIF.
cl\_demo\_input=>request( CHANGING field = phys\_name ).
IF cl\_fs\_path=>create( phys\_name )->is\_relative( ) = abap\_true.
  DATA(pref) = cl\_fs\_path=>create( path ).
  pref->append\_path\_name( phys\_name ).
  phys\_name = pref->get\_path\_name( ).
ENDIF.
CALL FUNCTION 'FILE\_VALIDATE\_NAME'
  EXPORTING
    logical\_filename           = log\_name
  CHANGING
    physical\_filename          = phys\_name
  EXCEPTIONS
    logical\_filename\_not\_found = 1
    validation\_failed          = 2
    OTHERS                     = 4.
IF sy-subrc <> 0.
  MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                      DISPLAY LIKE sy-msgty.
  RETURN.
ENDIF.
OPEN DATASET phys\_name FOR OUTPUT IN TEXT MODE ENCODING UTF-8 .


---


## ABAP Keyword Documentation / ABAP − Reference / Processing External Data / ABAP File Interface / Statements for the ABAP File Interface / OPEN DATASET / OPEN DATASET - mode

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing External Data / ABAP File Interface / Statements for the ABAP File Interface / OPEN DATASET / OPEN DATASET - mode

Included pages: 5



**📖 Source**: [abendataset_auth_self.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendataset_auth_self.htm)

### abapopen_dataset_mode.htm

> **📖 Official SAP Documentation**: [abapopen_dataset_mode.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapopen_dataset_mode.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing External Data](javascript:call_link\('abenabap_language_external_data.htm'\)) →  [ABAP File Interface](javascript:call_link\('abenabap_language_files.htm'\)) →  [Statements for the ABAP File Interface](javascript:call_link\('abenfile_interface_statements.htm'\)) →  [OPEN DATASET](javascript:call_link\('abapopen_dataset.htm'\)) → 

OPEN DATASET - mode

[Quick Reference](javascript:call_link\('abapopen_dataset_shortref.htm'\))

Syntax

... *{*BINARY MODE*}*
  *|* *{*TEXT MODE [encoding](javascript:call_link\('abapopen_dataset_encoding.htm'\)) *\[*[linefeed](javascript:call_link\('abapopen_dataset_linefeed.htm'\))*\]**}*
  *|* *{*LEGACY BINARY MODE *\[* [endian](javascript:call_link\('abapopen_dataset_endian.htm'\))*\]**\[* [CODE PAGE cp](javascript:call_link\('abapopen_dataset_code_page.htm'\))*\]**}*
  *|* *{*LEGACY TEXT MODE *\[* [endian](javascript:call_link\('abapopen_dataset_endian.htm'\))*\]* *\[* [CODE PAGE cp](javascript:call_link\('abapopen_dataset_code_page.htm'\))*\]* *\[* [linefeed](javascript:call_link\('abapopen_dataset_linefeed.htm'\))*\]**}* ...

Alternatives:

[1\. ... BINARY MODE](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... TEXT MODE](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... LEGACY BINARY MODE](#!ABAP_ALTERNATIVE_3@3@)
[4\. ... LEGACY TEXT MODE](#!ABAP_ALTERNATIVE_4@4@)

Effect

These mandatory additions define whether the file is handled as a binary file or as a text file. By specifying LEGACY, files can be written in the format that is expected by a non- [Unicode system](javascript:call_link\('abenunicode_system_glosry.htm'\) "Glossary Entry"), and files that have been created by a non-Unicode-system can be read. The [byte order](javascript:call_link\('abenbyte_order_glosry.htm'\) "Glossary Entry") or the [code page](javascript:call_link\('abencodepage_glosry.htm'\) "Glossary Entry") must be specified explicitly.

Alternative 1

... BINARY MODE

Effect

The addition IN BINARY MODE opens the file as a binary file. When writing to a binary file, the binary content of a data object is passed in unchanged form to the file. When reading from a binary file, the binary content of the file is passed in unchanged form to a data object.

Example

Opens a binary file for reads and writes. The binary data is created by converting a string to [UTF-8](javascript:call_link\('abenutf8_glosry.htm'\) "Glossary Entry").

DATA(utf8) =
  cl\_abap\_conv\_codepage=>create\_out( )->convert( 'Blahblahblah ...' ).
DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN BINARY MODE.
TRANSFER utf8 TO dset.
CLOSE DATASET dset.
...
CLEAR utf8.
OPEN DATASET dset FOR INPUT IN BINARY MODE
READ DATASET dset INTO utf8.
CLOSE DATASET dset.
cl\_demo\_output=>display(
  cl\_abap\_conv\_codepage=>create\_in( )->convert( utf8 ) ).
DELETE DATASET dset.

Alternative 2

... TEXT MODE

Effect

The addition IN TEXT MODE opens the file as a text file. Only the content of character-like data objects can be passed to text files and read from text files.

The addition [encoding](javascript:call_link\('abapopen_dataset_encoding.htm'\)) defines how the characters are represented in the text file. When writing to a text file, the content of a data object is converted to the representation entered after encoding, and passed to the file. If the data type is character-like and [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry"), any trailing blanks are cut off. In the data type string, trailing blanks are not cut off.

The end-of-line selection of the relevant platform is applied to the passed data by default. When reading from a text file, the content of the file is read until the next end-of-line selection, converted from the format specified after ENCODING into the current character format, and passed to a data object. The end-of-line selection used is controlled using the addition [linefeed](javascript:call_link\('abapopen_dataset_linefeed.htm'\)).

Example

Opens a text file for reads and writes. A line end marking is appended in every write in every TRANSFER statement. Any reads are performed row by row. Compare the example for the addition NO END OF LINE of the statement [TRANSFER](javascript:call_link\('abaptransfer.htm'\)).

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING DEFAULT.
DO 5 TIMES.
  TRANSFER 'Blah' TO dset.
ENDDO.
CLOSE DATASET dset.
...
DATA text TYPE string.
OPEN DATASET dset FOR INPUT IN TEXT MODE ENCODING UTF-8
                               SKIPPING BYTE-ORDER MARK.
DO.
  READ DATASET dset INTO text.
  IF sy-subrc <> 0.
    EXIT.
  ENDIF.
  cl\_demo\_output=>write( text ).
ENDDO.
CLOSE DATASET dset.
cl\_demo\_output=>display( ).
DELETE DATASET dset.

Alternative 3

... LEGACY BINARY MODE

Effect

Opening a [legacy file](javascript:call_link\('abenlegacy_file_glosry.htm'\) "Glossary Entry"). The addition IN LEGACY BINARY MODE opens the file as a legacy binary file, where [endian](javascript:call_link\('abapopen_dataset_endian.htm'\)) can be used to specify the [byte order](javascript:call_link\('abenbyte_order_glosry.htm'\) "Glossary Entry") and [CODE PAGE](javascript:call_link\('abapopen_dataset_code_page.htm'\)) can be used to specify the [code page](javascript:call_link\('abencodepage_glosry.htm'\) "Glossary Entry") that handle the content of the file.

Note

When a flat character-like field is written to the legacy binary files, the number of bytes written to the file is the same as the number of characters in the source field. The field content can be influenced by this when writing texts in Eastern Asian languages. It is therefore best to only write texts opened without the addition LEGACY to text files.

Example

See the example for the addition [endian](javascript:call_link\('abapopen_dataset_endian.htm'\)).

Alternative 4

... LEGACY TEXT MODE

Effect

Opening a [legacy file](javascript:call_link\('abenlegacy_file_glosry.htm'\) "Glossary Entry"). The addition IN LEGACY TEXT MODE opens the file as a legacy text file, where (in legacy binary files) [endian](javascript:call_link\('abapopen_dataset_endian.htm'\)) can be used to specify the byte order and [CODE PAGE](javascript:call_link\('abapopen_dataset_code_page.htm'\)) can be used to specify the code page that handle the content of the file. The syntax and semantics of *{*BIG*|*LITTLE*}* ENDIAN and CODE PAGE cp are the same as in legacy binary files. The syntax and meaning of [linefeed](javascript:call_link\('abapopen_dataset_linefeed.htm'\)) are the same as for regular text files.

In contrast to legacy binary files, the trailing blanks are cut off when writing character-like [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") data objects to a legacy text file. Also, as in the case of a text file, an [end-of-line selection](javascript:call_link\('abapopen_dataset_linefeed.htm'\)) is appended to the passed data by default. Unlike the text files opened by the addition IN TEXT MODE, there is no check on whether the data objects used in writing or reading are character-like. Also, the LENGTH additions of the statements READ DATASET and TRANSFER are used for counting. In legacy text files these additions count in bytes, and an text files they count in the units of a character represented in the memory.

Notes

-   As is the case with legacy binary files, it is possible to access text files written in non-Unicode systems as legacy text files. In this case, the content is converted accordingly.
    
-   When writing to a flat character-like field in legacy text files, the maximum number of bytes that can be written to the file is the maximum number of characters in the source field. The field content can be influenced by this when writing texts in Eastern Asian languages. It is therefore best to only write texts opened without the addition LEGACY to text files.
    

Example

See the example for the addition [CODE PAGE](javascript:call_link\('abapopen_dataset_code_page.htm'\)).

Continue
[OPEN DATASET - encoding](javascript:call_link\('abapopen_dataset_encoding.htm'\))
[OPEN DATASET - WITH LINEFEED](javascript:call_link\('abapopen_dataset_linefeed.htm'\))
[OPEN DATASET - endian](javascript:call_link\('abapopen_dataset_endian.htm'\))
[OPEN DATASET - CODE PAGE](javascript:call_link\('abapopen_dataset_code_page.htm'\))



**📖 Source**: [abapopen_dataset_mode.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapopen_dataset_mode.htm)

### abapopen_dataset_encoding.htm

> **📖 Official SAP Documentation**: [abapopen_dataset_encoding.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapopen_dataset_encoding.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing External Data](javascript:call_link\('abenabap_language_external_data.htm'\)) →  [ABAP File Interface](javascript:call_link\('abenabap_language_files.htm'\)) →  [Statements for the ABAP File Interface](javascript:call_link\('abenfile_interface_statements.htm'\)) →  [OPEN DATASET](javascript:call_link\('abapopen_dataset.htm'\)) →  [OPEN DATASET - mode](javascript:call_link\('abapopen_dataset_mode.htm'\)) → 

OPEN DATASET - encoding

[Quick Reference](javascript:call_link\('abapopen_dataset_shortref.htm'\))

Syntax

... ENCODING *{* DEFAULT
             *|* *{*UTF-8 *\[*SKIPPING*|*WITH BYTE-ORDER MARK*\]**}*
             *|* NON-UNICODE *}* ...

Alternatives:

[1\. ... DEFAULT](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... UTF-8 *\[*SKIPPING*|*WITH BYTE-ORDER MARK*\]*](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... NON-UNICODE](#!ABAP_ALTERNATIVE_3@3@)

Effect

The additions after the mandatory addition ENCODING define the character representation in which the content of a text file is handled.

Programming Guideline

[Write text files in UTF-8 and with a byte order mark.](javascript:call_link\('abencodepage_file_guidl.htm'\) "Guideline")

Note

It is best to always write files in UTF-8 (if all readers can process this format). Otherwise, the code page can depend on the [text environment](javascript:call_link\('abentext_environment_glosry.htm'\) "Glossary Entry") and it is difficult to identify the code page from the file content.

Alternative 1

... DEFAULT

Effect

If specified, DEFAULT is the same as specifying UTF-8.

Alternative 2

... UTF-8 *\[*SKIPPING*|*WITH BYTE-ORDER MARK*\]*

Addition:

[... SKIPPING*|*WITH BYTE-ORDER MARK](#!ABAP_ONE_ADD@1@)

Effect

The characters in the file are handled in accordance with the Unicode character representation [UTF-8](javascript:call_link\('abenutf8_glosry.htm'\) "Glossary Entry").

Notes

-   The class CL\_ABAP\_FILE\_UTILITIES contains the method CHECK\_UTF8 for determining whether a file is a UTF-8 file.
    
-   A UTF-16 file can only be opened as a binary file.
    

Example

Opens a text file as a UTF-8 file and writes a string containing German umlaut characters to the file. After a file is read to a byte string, the string can be converted from UTF-8 to a character string using the method CONVERT of the interface IF\_ABAP\_CONV\_IN and objects created by the class CL\_ABAP\_CONV\_CODEPAGE.

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING UTF-8.
TRANSFER 'ÄäÖöÜü' TO dset.
CLOSE DATASET dset.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
cl\_demo\_output=>display(
  cl\_abap\_conv\_codepage=>create\_in( )->convert( xstr ) ).
DELETE DATASET dset.

Addition

... SKIPPING*|*WITH BYTE-ORDER MARK

Effect

This addition defines how the byte order mark (BOM), with which a file encoded in the UTF-8 format can begin, is handled. The BOM is a sequence of three bytes that indicates that a file is encoded in [UTF-8](javascript:call_link\('abenutf8_glosry.htm'\) "Glossary Entry").

-   SKIPPING BYTE-ORDER MARK
    is only permitted if the file is opened for reading or changing using [FOR INPUT](javascript:call_link\('abapopen_dataset_access.htm'\)) or [FOR UPDATE](javascript:call_link\('abapopen_dataset_access.htm'\)). If there is a BOM at the start of the file, this is ignored and the file pointer is set after it. Without the addition, the BOM is handled as normal file content.
    
-   WITH BYTE-ORDER MARK
    is only permitted if the file is opened for writing using [FOR OUTPUT](javascript:call_link\('abapopen_dataset_access.htm'\)). When the file is opened, a BOM is inserted at the start of the file. Without the addition, no BOM is inserted.
    

The addition BYTE-ORDER MARK cannot be used together with the [AT POSITION](javascript:call_link\('abapopen_dataset_position.htm'\)) addition.

Notes

-   When opening UTF-8 files for reading, it is best to always enter the addition SKIPPING BYTE-ORDER MARK to prevent a BOM from being handled as file content.
    
-   It is recommended that a file for reading is always opened as a UTF-8 file using the addition WITH BYTE-ORDER MARK (as long as all readers can process this format).
    
-   The method CREATE\_UTF8\_FILE\_WITH\_BOM in the system class CL\_ABAP\_FILE\_UTILITIES can be used to create a file with BOM.
    

Example

The binary content of the text file opened using WITH BYTE-ORDER MARK is EFBBBF616263. EFBBBF is specified as a BOM at the start of the file. This is followed by the UTF-8 representation 616263 of the actual characters abc.

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE
                  ENCODING UTF-8 WITH BYTE-ORDER MARK.
TRANSFER 'aaa' TO dset NO END OF LINE.
CLOSE DATASET dset.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
cl\_demo\_output=>display( xstr ).
DELETE DATASET dset.

Alternative 3

... NON-UNICODE

Effect

The characters of the file are handled in accordance with the non-Unicode code page that would be assigned when reading or writing data in a non-Unicode system (as specified by the entry in the database table TCP0C in the current [text environment](javascript:call_link\('abentext_environment_glosry.htm'\) "Glossary Entry")).

Example

Writes German umlaut characters to a non-Unicode code page. This code page is then extracted from the database table TCP0C and used to open the file as a a legacy text file.

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING NON-UNICODE.
TRY.
    TRANSFER 'ÄäÖöÜü' TO dset.
  CATCH cx\_sy\_conversion\_codepage INTO DATA(exc).
    cl\_demo\_output=>display( 'Error writing to non-unicode codepage' ).
    RETURN.
ENDTRY.
CLOSE DATASET dset.
SELECT SINGLE charco
       FROM tcp0c
       WHERE platform = @sy-opsys AND
             langu   = @sy-langu AND
             country  = ' '
       INTO @DATA(cp).
DATA text TYPE string.
OPEN DATASET dset FOR INPUT IN LEGACY TEXT MODE CODE PAGE cp.
READ DATASET dset INTO text.
CLOSE DATASET dset.
cl\_demo\_output=>display( text ).
DELETE DATASET dset.



**📖 Source**: [abapopen_dataset_encoding.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapopen_dataset_encoding.htm)

### abapopen_dataset_linefeed.htm

> **📖 Official SAP Documentation**: [abapopen_dataset_linefeed.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapopen_dataset_linefeed.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing External Data](javascript:call_link\('abenabap_language_external_data.htm'\)) →  [ABAP File Interface](javascript:call_link\('abenabap_language_files.htm'\)) →  [Statements for the ABAP File Interface](javascript:call_link\('abenfile_interface_statements.htm'\)) →  [OPEN DATASET](javascript:call_link\('abapopen_dataset.htm'\)) →  [OPEN DATASET - mode](javascript:call_link\('abapopen_dataset_mode.htm'\)) → 

OPEN DATASET - WITH LINEFEED

[Quick Reference](javascript:call_link\('abapopen_dataset_shortref.htm'\))

Syntax

... WITH *{* NATIVE
         *|* SMART
         *|* UNIX
         *|* WINDOWS *}* LINEFEED ...

Alternatives:

[1\. ... WITH NATIVE LINEFEED](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... WITH SMART LINEFEED](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... WITH UNIX LINEFEED](#!ABAP_ALTERNATIVE_3@3@)
[4\. ... WITH WINDOWS LINEFEED](#!ABAP_ALTERNATIVE_4@4@)

Effect

These additions determine which line end marker is used for [text files](javascript:call_link\('abentext_file_glosry.htm'\) "Glossary Entry") or [legacy](javascript:call_link\('abenlegacy_file_glosry.htm'\) "Glossary Entry") text files. If these additions are used, the [profile parameter](javascript:call_link\('abenprofile_parameter_glosry.htm'\) "Glossary Entry") abap/NTfmode is ignored. The two values "UNIX" or "NT" cannot both be specified in the addition [TYPE](javascript:call_link\('abapopen_dataset_os_addition.htm'\)) at the same time.

If these additions are not used, the line end marker is determined as follows, depending on the operating system of the current [AS Instance](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry") [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry"):

-   The line end marker for Unix is "LF". On Unix, OS/390, and IBM i5/OS (previously known as OS/400), only "LF" is used for reading and writing.
    
-   The line end marker for MS Windows is "CRLF". On MS Windows, however, the values of the [profile parameter](javascript:call_link\('abenprofile_parameter_glosry.htm'\) "Glossary Entry") abap/NTfmode can also be used to specify whether new files are handled according to Unix conventions or Windows conventions. If the profile parameter has the value "b", the Unix line end marker "LF" is used. If the profile parameter has the value "t" or is initial, the Windows line end marker "CRLF" is used. The setting in the profile parameter can be overridden with the addition [TYPE](javascript:call_link\('abapopen_dataset_os_addition.htm'\)) and the value "UNIX" or "NT". If an existing file is opened without the addition TYPE, this file is searched for the first line end marker ("LF" or "CRLF"), and this is used for the whole file. If no line end marker is found, the profile parameter is used. This applies particularly if an existing file is completely overwritten with [FOR OUTPUT](javascript:call_link\('abapopen_dataset_access.htm'\)).
    

If an addition WITH NATIVE*|*SMART*|*UNIX*|*WINDOWS LINEFEED is used, this setting can be changed for the open file using the statement [SET DATASET](javascript:call_link\('abapset_dataset.htm'\)). If neither of the additions is used, the line end marker cannot be changed using SET DATASET either.

Notes

-   Without the use of an addition WITH LINEFEED, the line end marker is dependent on various implicit factors such as the operating system of the current AS Instance [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry"), a profile parameter, and line end markings that are already used. For this reason, the explicit use of WITH LINEFEED is recommended, which renders the use of the addition [TYPE](javascript:call_link\('abapopen_dataset_os_addition.htm'\)) for setting the line end marker obsolete.
    
-   The line end marker that is currently used can be determined for every open file using [GET DATASET](javascript:call_link\('abapget_dataset.htm'\)).
    

Alternative 1

... WITH NATIVE LINEFEED

Effect

This addition defines the line end marker independently of the [access type](javascript:call_link\('abapopen_dataset_access.htm'\)) in accordance with the operating system of the current AS Instance [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry"), in other words "LF” for Unix, OS/390, and IBM i5/OS (previously known as OS/400), and "CRLF” for MS Windows.

The line end marker is interpreted in accordance with the current code page. If a code page is specified explicitly using the addition [CODE PAGE](javascript:call_link\('abapopen_dataset_mode.htm'\)), the control characters of the line end marker must be available or be written according to this code page.

Note

The addition WITH NATIVE LINEFEED is intended for editing files on a host computer that can also be accessed by other means. The addition receives the appropriate line end marker without the program needing to know the operating system.

Example

The following example shows the UTF 8 representation of the current line end marking. Comparisons with the corresponding control characters in [string templates](javascript:call_link\('abenstring_template_glosry.htm'\) "Glossary Entry") ensure that it is either "LF" or "CRLF".

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING DEFAULT
                  WITH NATIVE LINEFEED.
TRANSFER 'abc' TO dset.
CLOSE DATASET dset.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
SHIFT xstr BY 3 PLACES LEFT IN BYTE MODE.
cl\_demo\_output=>display( xstr ).
DELETE DATASET dset.
ASSERT xstr = cl\_abap\_conv\_codepage=>create\_out( )->convert( |\\n| ) OR
       xstr = cl\_abap\_conv\_codepage=>create\_out( )->convert( |\\r\\n| ).

Alternative 2

... WITH SMART LINEFEED

Effect

This addition depends on the [access type](javascript:call_link\('abapopen_dataset_access.htm'\)):

-   In files that are opened for reading using FOR INPUT, both "LF" and "CRLF" are interpreted as a line end marker. When opening an EBCDIC file with the addition [CODEPAGE](javascript:call_link\('abapopen_dataset_mode.htm'\)), the corresponding ASCII control characters are recognized alongside the "LF", "CRLF", and EBCDIC control characters. In addition, the EBCDIC control characters "NL" (line separator) is also interpreted as a line end marker.
    
-   In files opened for appending or changing with FOR APPENDING or FOR UPDATE, the program searches for a line end marker that is already used in the file. The end of the file is identified first. If no line end marker is found here, a number of characters at the beginning is analyzed. If a line end marker is found, this is used when writing to the file. This is also affected by the addition [CODE PAGE](javascript:call_link\('abapopen_dataset_mode.htm'\)). For example, ASCII line end markers are recognized and used in a file opened with EBCDIC, but not the other way round. If no line end marker is found or no search is possible (for example, if the file is opened with the addition [FILTER](javascript:call_link\('abapopen_dataset_os_addition.htm'\))), the line end marker is defined in accordance with the operating system of the current AS Instance [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry"), as with the addition WITH NATIVE LINEFEED.
    
-   In files opened for writing using FOR OUTPUT, the line end marker is determined in accordance with the operating system the current AS Instance [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry"), as with the addition WITH NATIVE LINEFEED.
    

Note

The addition WITH SMART LINEFEED is intended for the generic editing of files in heterogeneous environments. The line end marker is recognized and set for different formats. Using this addition is the best solution for most application cases.

Example

Writes a text file with the line end marking "CRLF". Using the addition WITH SMART LINEFEED (open to read), this marking is also detected on platforms that expect "LF".

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING DEFAULT
                  WITH WINDOWS LINEFEED.
TRANSFER 'abc' TO dset.
TRANSFER 'def' TO dset.
CLOSE DATASET dset.
DATA str TYPE string.
OPEN DATASET dset FOR INPUT IN TEXT MODE ENCODING DEFAULT
                  WITH SMART LINEFEED.
DATA out TYPE string.
WHILE sy-subrc = 0.
  READ DATASET dset INTO str.
  out = out && str.
ENDWHILE.
CLOSE DATASET dset.
cl\_demo\_output=>display( out ).
DELETE DATASET dset.

Alternative 3

... WITH UNIX LINEFEED

Effect

The line end marker is set to ["LF"](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") regardless of the [access type](javascript:call_link\('abapopen_dataset_access.htm'\)) and operating system of the current AS Instance [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry").

The line end marker is interpreted in accordance with the current code page. If a code page is specified explicitly using the addition [CODE PAGE](javascript:call_link\('abapopen_dataset_mode.htm'\)), the control character for the line end marker must be available or be written according to this code page.

Note

The addition WITH UNIX LINEFEED is intended for editing Unix files in which the specific line end markers are to be retained, even if the operating system of the current AS Instance [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") is [MS](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") Windows.

Example

The following example sets the line end marking to "LF". This marking is detected after it is read to a binary file and compared with the corresponding control character in a [string template](javascript:call_link\('abenstring_template_glosry.htm'\) "Glossary Entry").

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING DEFAULT
                  WITH UNIX LINEFEED.
TRANSFER 'abc' TO dset.
CLOSE DATASET dset.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
SHIFT xstr BY 3 PLACES LEFT IN BYTE MODE.
cl\_demo\_output=>display( xstr ).
DELETE DATASET dset.
ASSERT xstr = cl\_abap\_conv\_codepage=>create\_out( )->convert( |\\n| ).

Alternative 4

... WITH WINDOWS LINEFEED

Effect

The line end marker is set to "CRLF" regardless of the [access type](javascript:call_link\('abapopen_dataset_access.htm'\)) and operating system of the current AS Instance [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry").

The line end marker is interpreted in accordance with the current code page. If a code page is specified explicitly using the addition [CODE PAGE](javascript:call_link\('abapopen_dataset_mode.htm'\)), the control character for the line end marker must be available or be written according to this code page.

Note

The addition WITH WINDOWS LINEFEED is intended for use with MS Windows files in which the specific line end marker is to be retained, even if the operating system of the current AS Instance [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") is Unix, OS/390, or IBM i5/OS (previously known as OS/400).

Example

The following example sets the line end marking to "CRLF". This marking is detected after it is read to a binary file and compared with the corresponding control character in a [string template](javascript:call_link\('abenstring_template_glosry.htm'\) "Glossary Entry").

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING DEFAULT
                  WITH WINDOWS LINEFEED.
TRANSFER 'abc' TO dset.
CLOSE DATASET dset.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
SHIFT xstr BY 3 PLACES LEFT IN BYTE MODE.
cl\_demo\_output=>display( xstr ).
DELETE DATASET dset.
ASSERT xstr = cl\_abap\_conv\_codepage=>create\_out( )->convert( |\\r\\n| ).



**📖 Source**: [abapopen_dataset_linefeed.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapopen_dataset_linefeed.htm)

### abapopen_dataset_endian.htm

> **📖 Official SAP Documentation**: [abapopen_dataset_endian.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapopen_dataset_endian.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing External Data](javascript:call_link\('abenabap_language_external_data.htm'\)) →  [ABAP File Interface](javascript:call_link\('abenabap_language_files.htm'\)) →  [Statements for the ABAP File Interface](javascript:call_link\('abenfile_interface_statements.htm'\)) →  [OPEN DATASET](javascript:call_link\('abapopen_dataset.htm'\)) →  [OPEN DATASET - mode](javascript:call_link\('abapopen_dataset_mode.htm'\)) → 

OPEN DATASET - endian

[Quick Reference](javascript:call_link\('abapopen_dataset_shortref.htm'\))

Syntax

... *{*BIG*|*LITTLE*}* ENDIAN ...

Effect

This addition specifies that, when a [legacy file](javascript:call_link\('abenlegacy_file_glosry.htm'\) "Glossary Entry") is opened, numeric data objects of the type i, int8, decfloat16, decfloat34, f, or s are stored in the file in the [byte order](javascript:call_link\('abenbyte_order_glosry.htm'\) "Glossary Entry") Big Endian or Little Endian. When a data object of these types is written or read, a conversion between these orders and the byte order of the current platform is performed, if necessary. If the addition is not specified, the byte order of the [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") of the current [AS Instance](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry") is used.

Notes

-   The statement [SET DATASET](javascript:call_link\('abapset_dataset.htm'\)) can be used to specify a different byte order for an opened legacy file.
    
-   The addition *{*BIG*|*LITTLE*}* ENDIAN replaces the use of the obsolete statement [TRANSLATE NUMBER FORMAT](javascript:call_link\('abaptranslate.htm'\)) in the case of file accesses.
    

Example

Opens a legacy binary file with different byte orders for writing. In each case, the integer 111 is written to the file and the content is read in binary format to a byte string. The results are 0000006F and 6F000000, that is, 111 in binary format in Big Endian and Little Endian.

DATA(dset) = 'test.dat'.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR OUTPUT IN LEGACY BINARY MODE BIG ENDIAN.
TRANSFER 111 TO dset.
CLOSE DATASET dset.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
cl\_demo\_output=>write( xstr ).
OPEN DATASET dset FOR OUTPUT IN LEGACY BINARY MODE LITTLE ENDIAN.
TRANSFER 111 TO dset.
CLOSE DATASET dset.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
cl\_demo\_output=>write( xstr ).
cl\_demo\_output=>display( ).
DELETE DATASET dset.



**📖 Source**: [abapopen_dataset_endian.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapopen_dataset_endian.htm)

### abapopen_dataset_code_page.htm

> **📖 Official SAP Documentation**: [abapopen_dataset_code_page.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapopen_dataset_code_page.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Processing External Data](javascript:call_link\('abenabap_language_external_data.htm'\)) →  [ABAP File Interface](javascript:call_link\('abenabap_language_files.htm'\)) →  [Statements for the ABAP File Interface](javascript:call_link\('abenfile_interface_statements.htm'\)) →  [OPEN DATASET](javascript:call_link\('abapopen_dataset.htm'\)) →  [OPEN DATASET - mode](javascript:call_link\('abapopen_dataset_mode.htm'\)) → 

OPEN DATASET - CODE PAGE

[Quick Reference](javascript:call_link\('abapopen_dataset_shortref.htm'\))

Syntax

...  CODE PAGE cp ...

Effect

This addition specifies that, when a [legacy file](javascript:call_link\('abenlegacy_file_glosry.htm'\) "Glossary Entry") is opened, the representation of character-like data objects in the file is based on the code page specified in cp. When a character-like data object is written or read, a conversion between this code page and the current character representation is performed, if necessary. If this addition is not specified, the characters in the file are handled in accordance with the non-Unicode code page that would be assigned when reading or writing data in a non-Unicode system (as specified by the entry in the database table TCP0C in the current [text environment](javascript:call_link\('abentext_environment_glosry.htm'\) "Glossary Entry")).

If specified, the code page cp expects a character-like data object that must contain, when the statement is executed, the name of a non-Unicode page from the column CPCODEPAGE in the database table TCP00. Unicode code pages cannot be specified.

Notes

-   This addition enables the automatic conversion of file content to the current Unicode character representation [UCS-2](javascript:call_link\('abenucs2_glosry.htm'\) "Glossary Entry") when reading and writing files. In this way, files saved in any non-Unicode systems can be imported.
    
-   The statement [SET DATASET](javascript:call_link\('abapset_dataset.htm'\)) can be used to specify a different code page for an opened legacy file.
    
-   The addition CODE PAGE replaces the use of the obsolete statement [TRANSLATE CODE PAGE](javascript:call_link\('abaptranslate.htm'\)) in when accessing files.
    

Example

Opens legacy text files with the IDs 1101 for 7-Bit USA ASCII and 1102 for 7-Bit German ASCII from the table TCP00. When a German umlaut character is written to the open file with the ID 1101, an exception of the class CX\_SY\_CONVERSION\_CODEPAGE is raised. When the character is written to the open file with the ID 1102, this exception is not raised. See also the example for the addition [REPLACEMENT CHARACTER](javascript:call_link\('abapopen_dataset_error_handling.htm'\)).

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN LEGACY TEXT MODE CODE PAGE '1101'.
TRY.
    TRANSFER 'ÄaÖöÜü' TO dset.
  CATCH cx\_sy\_conversion\_codepage INTO DATA(exc).
    cl\_demo\_output=>write( 'Error writing to 7-Bit USA ASCII' ).
ENDTRY.
CLOSE DATASET dset.
OPEN DATASET dset FOR OUTPUT IN LEGACY TEXT MODE CODE PAGE '1102'.
TRY.
    TRANSFER 'ÄaÖöÜü' TO dset.
  CATCH cx\_sy\_conversion\_codepage INTO exc.
    cl\_demo\_output=>write( 'Error writing to 7-Bit German ASCII' ).
ENDTRY.
CLOSE DATASET dset.
cl\_demo\_output=>display( ).
DELETE DATASET dset.


---


## ABAP Keyword Documentation / ABAP − Reference / Text Repositories / Messages / System Interfaces for Messages

**Files**: 13 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Text Repositories / Messages / System Interfaces for Messages

Included pages: 13



**📖 Source**: [abapopen_dataset_code_page.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapopen_dataset_code_page.htm)

### abenmessage_interfaces.htm

> **📖 Official SAP Documentation**: [abenmessage_interfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmessage_interfaces.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) → 

System Interfaces for Messages

-   [IF\_T100\_MESSAGE](javascript:call_link\('abenif_t100_message.htm'\))

-   [IF\_T100\_DYN\_MSG](javascript:call_link\('abenif_t100_dyn_msg.htm'\))

Note

The system interfaces for messages are designed mainly for [exception texts](javascript:call_link\('abenexception_texts.htm'\)) and [exception classes for messages](javascript:call_link\('abenmessage_exceptions.htm'\)).

Continue
[System Interface IF\_T100\_MESSAGE for Messages](javascript:call_link\('abenif_t100_message.htm'\))
[System Interface IF\_T100\_DYN\_MSG for Messages](javascript:call_link\('abenif_t100_dyn_msg.htm'\))



**📖 Source**: [abenmessage_interfaces.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmessage_interfaces.htm)

### abenif_t100_message.htm

> **📖 Official SAP Documentation**: [abenif_t100_message.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_message.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) → 

System Interface IF\_T100\_MESSAGE for Messages

The interface IF\_T100\_MESSAGE associates classes with [messages](javascript:call_link\('abenmessage_glosry.htm'\) "Glossary Entry"). To do this, IF\_T100\_MESSAGE contains a structured attribute T100KEY of the type SCX\_T100KEY, which specifies a [message](javascript:call_link\('abenmessage_glosry.htm'\) "Glossary Entry") in the table T100:

-   The component MSGID contains the [message class](javascript:call_link\('abenmessage_class_glosry.htm'\) "Glossary Entry").

-   The component MSGNO contains the [message number](javascript:call_link\('abenmessage_number_glosry.htm'\) "Glossary Entry").

-   The components ATTR1 to ATTR4 contain the names of class attributes whose content is used as placeholder texts for any placeholders in the texts of the message.

The message text can be accessed as follows:

-   The interface IF\_T100\_MESSAGE includes the interface IF\_MESSAGE (which should not be used as a standalone interface). This interface contains the methods GET\_TEXT and GET\_LONGTEXT, which can be implemented by a class with the interface IF\_T100\_MESSAGE in such a way that they return the short text and long text of the current message. This can be done using the corresponding methods of the class CL\_MESSAGE\_HELPER.

-   In the variant [MESSAGE oref](javascript:call_link\('abapmessage_msg.htm'\)) of the statement [MESSAGE](javascript:call_link\('abapmessage.htm'\)), an [interface reference variable](javascript:call_link\('abeninterface_ref_variable_glosry.htm'\) "Glossary Entry") of the type IF\_T100\_MESSAGE or a [class reference variable](javascript:call_link\('abenclass_reference_variabl_glosry.htm'\) "Glossary Entry") of a class that implements this interface can be specified to display the message in question.

The statement MESSAGE or the class CL\_MESSAGE\_HELPER evaluate the content of the structure T100KEY here:

-   The components MSGID and MSGNO are scanned by message class and message class for a message. If a message is found, its texts are used. If not, a short text is generated that counts the message class and message number plus the placeholder texts from the assigned class attributes.

-   If they exist, the placeholders "&1" to "&4" and "&" of the short text or "&V1&" to "&V4&" of the long text of the message are replaced by the content of the class attributes specified in the components ATTR1 to ATTR4 in accordance with the rules of the addition [WITH](javascript:call_link\('abapmessage.htm'\)) of the statement [MESSAGE](javascript:call_link\('abapmessage.htm'\)). If an attribute specified in the components ATTR1 to ATTR4 does not exist or if an attribute cannot be converted to a placeholder text, the character "&" is added to the start and the end of the attribute name and used as a placeholder text. If one of the components ATTR1 to ATTR4 is initial, the corresponding placeholder text is initialized‎.

Notes

-   The interface IF\_T100\_MESSAGE is mainly designed for use with [exception texts](javascript:call_link\('abenexception_texts.htm'\)) in [exception classes](javascript:call_link\('abenexception_class_glosry.htm'\) "Glossary Entry"). If the interface is included in regular classes and in local exception classes, the filling of the interface structure T100KEY must be programmed here separately. The implementation of the interface methods GET\_TEXT and GET\_LONGTEXT, however, is already contained in the superclass CX\_ROOT and alias names are declared for these methods here. When creating global exception classes, tool support is provided for filling the structure T100KEY and for mapping attributes to placeholders. This is done using structured constants that can be specified when an exception is raised.

-   The method GET\_LATEST\_T100\_EXCEPTION in the class CL\_MESSAGE\_HELPER is used to return the last object in a chain of exception objects that has an [exception text](javascript:call_link\('abenexception_texts.htm'\)) defined by a message. Here, the chain is created using the attribute PREVIOUS.

-   The interface IF\_T100\_MESSAGE does not have any attributes for the message type.

-   The interface [IF\_T100\_DYN\_MSG](javascript:call_link\('abenif_t100_dyn_msg.htm'\)) adds predefined attributes for the message type and the placeholders of the message to the interface IF\_T100\_MESSAGE. IF\_T100\_MESSAGE is designed for static [exception texts](javascript:call_link\('abenexception_texts.htm'\)) of exception classes, but IF\_T100\_DYN\_MSG can [associate](javascript:call_link\('abenmessage_exceptions.htm'\)) any messages with exception classes.

Example

Uses [THROW](javascript:call_link\('abenconditional_expression_result.htm'\)) to raise an exception of the class CX\_DEMO\_T100, which binds the interface IF\_T100\_MESSAGE.

DATA col TYPE c LENGTH 1.
...
DATA(color) = COND string(
                WHEN col = 'R' THEN 'red'
                WHEN col = 'B' THEN 'blue'
                WHEN col = 'G' THEN 'green'
                ELSE THROW cx\_demo\_t100(
                     textid = cx\_demo\_t100=>demo
                     text1  = 'Illegal value:'
                     text2  = CONV #( col ) ) ).

Executable Examples

-   [System Interface IF\_T100\_MESSAGE in a Regular Class](javascript:call_link\('abenif_t100_message_abexa.htm'\))

-   [System Interface IF\_T100\_MESSAGE in a Local Exception Class](javascript:call_link\('abenmessage_interface_abexa.htm'\))

-   [System Interface IF\_T100\_MESSAGE in Global Exception Class](javascript:call_link\('abenmessage_interface_global_abexa.htm'\))

-   [System Interface IF\_T100\_MESSAGE for Exception with Message](javascript:call_link\('abenmessage_interface_reuse_abexa.htm'\))

Continue
![Example](exa.gif "Example") [IF\_T100\_MESSAGE in Regular Class](javascript:call_link\('abenif_t100_message_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_MESSAGE in Local Exception Class](javascript:call_link\('abenmessage_interface_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_MESSAGE in Global Exception Class](javascript:call_link\('abenmessage_interface_global_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_MESSAGE for Exception with Message](javascript:call_link\('abenmessage_interface_reuse_abexa.htm'\))



**📖 Source**: [abenif_t100_message.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_message.htm)

### abenif_t100_message_abexa.htm

> **📖 Official SAP Documentation**: [abenif_t100_message_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_message_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) →  [System Interface IF\_T100\_MESSAGE for Messages](javascript:call_link\('abenif_t100_message.htm'\)) → 

IF\_T100\_MESSAGE in Regular Class

This example demonstrates how a regular class is associated with a message

Source Code

REPORT demo\_if\_t100\_message.
CLASS msg DEFINITION.
  PUBLIC SECTION.
    INTERFACES if\_t100\_message.
    ALIASES: get\_text FOR if\_message~get\_text,
             get\_longtext FOR if\_message~get\_longtext.
    METHODS constructor IMPORTING id TYPE symsgid
                                  no TYPE symsgno
                                  v1 TYPE string OPTIONAL
                                  v2 TYPE string OPTIONAL
                                  v3 TYPE string OPTIONAL
                                  v4 TYPE string OPTIONAL.
    DATA: attr1 TYPE c LENGTH 50,
          attr2 TYPE c LENGTH 50,
          attr3 TYPE c LENGTH 50,
          attr4 TYPE c LENGTH 50.
ENDCLASS.
CLASS msg IMPLEMENTATION.
  METHOD constructor.
    if\_t100\_message~t100key-msgid = id.
    if\_t100\_message~t100key-msgno = no.
    if\_t100\_message~t100key-attr1 = 'ATTR1'.
    if\_t100\_message~t100key-attr2 = 'ATTR2'.
    if\_t100\_message~t100key-attr3 = 'ATTR3'.
    if\_t100\_message~t100key-attr4 = 'ATTR4'.
    attr1 = v1.
    attr2 = v2.
    attr3 = v3.
    attr4 = v4.
  ENDMETHOD.
  METHOD if\_message~get\_text.
    result = cl\_message\_helper=>get\_text\_for\_message( me ).
  ENDMETHOD.
  METHOD if\_message~get\_longtext.
    result = cl\_message\_helper=>get\_longtext\_for\_message( me ).
  ENDMETHOD.
ENDCLASS.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    DATA(id) = \`SABAPDEMOS\`.
    DATA(no) = \`888\`.
    DATA(v1) = \`Hello,\`.
    DATA(v2) = \`I am\`.
    DATA(v3) = \`a\`.
    DATA(v4) = \`Message!\`.
    cl\_demo\_input=>new(
      )->add\_field( CHANGING field = id
      )->add\_field( CHANGING field = no
      )->add\_field( CHANGING field = v1
      )->add\_field( CHANGING field = v2
      )->add\_field( CHANGING field = v3
      )->add\_field( CHANGING field = v4
      )->request( ).
    DATA(mref) = NEW msg( id = CONV #( id )
                          no = CONV #( no )
                          v1 = v1
                          v2 = v2
                          v3 = v3
                          v4 = v4 ).
    cl\_demo\_output=>display( mref->get\_text( ) ).
    MESSAGE mref TYPE 'I'.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

Objects in the example class msg can represent any messages from the table T100 and be used in the statement [MESSAGE](javascript:call_link\('abapmessage.htm'\)). The four attributes ATTR1 to ATTR4 stand for the content of four placeholders. The constructor provides input parameters for all necessary values. In the constructor, the message class and the message number are written directly to the associated components of the interface structure T100KEY. The identically named attributes are assigned to the components ATTR1 to ATTR4 and filled with the passed values.

Once the class is instantiated, the message text is filled using the interface method GET\_TEXT, which is implemented in an appropriate way in the class and which has an alias name declared. The object of the class is used directly as an operand of the statement [MESSAGE](javascript:call_link\('abapmessage.htm'\)). A message type must be specified here.

Note

See also the executable example [System Interface IF\_T100\_DYN\_MSG in Regular Class](javascript:call_link\('abenif_t100_dyn_msg_abexa.htm'\)).



**📖 Source**: [abenif_t100_message_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_message_abexa.htm)

### abenmessage_interface_abexa.htm

> **📖 Official SAP Documentation**: [abenmessage_interface_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmessage_interface_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) →  [System Interface IF\_T100\_MESSAGE for Messages](javascript:call_link\('abenif_t100_message.htm'\)) → 

IF\_T100\_MESSAGE in Local Exception Class

This example demonstrates how a local exception class is associated with a message

Source Code

REPORT demo\_message\_oref.
CLASS cx\_t100 DEFINITION INHERITING FROM cx\_dynamic\_check.
  PUBLIC SECTION.
    INTERFACES if\_t100\_message.
    METHODS constructor IMPORTING id    TYPE symsgid
                                  no    TYPE symsgno
                                  text1 TYPE csequence OPTIONAL
                                  text2 TYPE csequence OPTIONAL
                                  text3 TYPE csequence OPTIONAL
                                  text4 TYPE csequence OPTIONAL.
    DATA text1 TYPE c LENGTH 50.
    DATA text2 TYPE c LENGTH 50.
    DATA text3 TYPE c LENGTH 50.
    DATA text4 TYPE c LENGTH 50.
ENDCLASS.
CLASS cx\_t100 IMPLEMENTATION.
  METHOD constructor.
    super->constructor( ).
    me->text1 = text1.
    me->text2 = text2.
    me->text3 = text3.
    me->text4 = text4.
    if\_t100\_message~t100key-msgid = id.
    if\_t100\_message~t100key-msgno = no.
    if\_t100\_message~t100key-attr1 = 'TEXT1'.
    if\_t100\_message~t100key-attr2 = 'TEXT2'.
    if\_t100\_message~t100key-attr3 = 'TEXT3'.
    if\_t100\_message~t100key-attr4 = 'TEXT4'.
  ENDMETHOD.
ENDCLASS.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS meth
      RAISING cx\_t100.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    TRY.
        meth( ).
      CATCH cx\_t100 INTO DATA(oref).
        cl\_demo\_output=>display( oref->get\_text( ) ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.
  ENDMETHOD.
  METHOD meth.
    RAISE EXCEPTION TYPE cx\_t100
      EXPORTING
        id    = 'SABAPDEMOS'
        no    = '888'
        text1 = 'I'
        text2 = 'am'
        text3 = 'an'
        text4 = 'Exception!'.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

The functional method meth raises an exception from the local exception class cx\_t100 that implements the interface [IF\_T100\_MESSAGE](javascript:call_link\('abenif_t100_message.htm'\)). When the exception is raised, the constructor is given a message class, a message number, and values for the placeholders of the message.

The constructor of the local exception class cx\_t100 fills the attribute T100KEY of the interface IF\_T100\_MESSAGE with the values passed. In this way, the exception class represents the passed message from the table T100 in which the placeholders "&" are replaced with the content of the attributes text1 to text4.

The method main catches the exception in the reference variable oref and indicates the following:

-   The exception text can be filled using the method GET\_TEXT of the component interface IF\_MESSAGE in the interface IF\_T100\_MESSAGE. The implementation of the method GET\_TEXT is in the superclass CX\_ROOT, which includes the interface IF\_MESSAGE.

-   The reference variable can be used directly as an operand of the statement [MESSAGE](javascript:call_link\('abapmessage.htm'\)).

See also the executable examples listed below.

-   [System Interface IF\_T100\_MESSAGE in Global Exception Class](javascript:call_link\('abenmessage_interface_global_abexa.htm'\))

-   [System Interface IF\_T100\_DYN\_MSG in Local Exception Class](javascript:call_link\('abenraise_message_abexa.htm'\))



**📖 Source**: [abenmessage_interface_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmessage_interface_abexa.htm)

### abenmessage_interface_global_abexa.htm

> **📖 Official SAP Documentation**: [abenmessage_interface_global_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmessage_interface_global_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) →  [System Interface IF\_T100\_MESSAGE for Messages](javascript:call_link\('abenif_t100_message.htm'\)) → 

IF\_T100\_MESSAGE in Global Exception Class

This example demonstrates how a global exception class is associated with a message

Source Code

REPORT demo\_message\_oref\_global.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS meth
      RAISING cx\_demo\_t100.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    TRY.
        meth( ).
      CATCH cx\_demo\_t100 INTO DATA(oref).
        cl\_demo\_output=>display( oref->get\_text( ) ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.
  ENDMETHOD.
  METHOD meth.
    RAISE EXCEPTION TYPE cx\_demo\_t100
      EXPORTING
        textid = cx\_demo\_t100=>demo
        text1  = 'I'
        text2  = 'am'
        text3  = 'an'
        text4  = 'Exception!'.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

This executable example works in the same way as the example in [System Interface IF\_T100\_MESSAGE in a Local Exception Class](javascript:call_link\('abenmessage_interface_abexa.htm'\)). Here, however, the interface IF\_T100\_MESSAGE is included in the global [exception class](javascript:call_link\('abenexception_class_glosry.htm'\) "Glossary Entry") CX\_DEMO\_T100. The association with a message class was made at the same time as the class was created. This dictates that the exception class is generated in such a way that it supports messages as [exception texts](javascript:call_link\('abenexception_texts.htm'\)), rather than merely including the interface IF\_T100\_MESSAGE.

On the tab Texts in [Class Builder](javascript:call_link\('abenclass_builder_glosry.htm'\) "Glossary Entry"), the message 888 from the message class SABAPDEMOS is assigned to the exception text DEMO of the exception class under Message Text. The placeholders of the message are associated with the attributes TEXT1 to TEXT4. The source text of the public section of the class implements this assignment using the structured constant DEMO with the type SCX\_T100KEY. The constructor has an input parameter TEXTID that can be passed the constant DEMO and the input parameters TEXT1 to TEXT4 used to fill the attributes with the same names.

A structure passed to the input parameter TEXTID when an exception from this class is raised is assigned to the structure T100KEY of the interface IF\_T100\_MESSAGE. This uses the corresponding message as an exception text. It is recommended that only the predefined constants of the class are passed, as shown here.

See also the executable examples listed below.

-   [System Interface IF\_T100\_MESSAGE for Exception with Message](javascript:call_link\('abenmessage_interface_reuse_abexa.htm'\))

-   [System Interface IF\_T100\_DYN\_MSG in Global Exception Class](javascript:call_link\('abenraise_message_global_abexa.htm'\))



**📖 Source**: [abenmessage_interface_global_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmessage_interface_global_abexa.htm)

### abenmessage_interface_reuse_abexa.htm

> **📖 Official SAP Documentation**: [abenmessage_interface_reuse_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmessage_interface_reuse_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) →  [System Interface IF\_T100\_MESSAGE for Messages](javascript:call_link\('abenif_t100_message.htm'\)) → 

IF\_T100\_MESSAGE for Exception with Message

This example demonstrates the [MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)) addition when an exception is raised using IF\_T100\_MESSAGE.

Source Code

REPORT demo\_raise\_message\_reuse\_attr.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS meth EXCEPTIONS exception.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    TRY.
        meth( EXCEPTIONS exception = 4 ).
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE cx\_demo\_t100
            MESSAGE ID sy-msgid
                    NUMBER sy-msgno
            EXPORTING text1 = conv #( sy-msgv1 )
                      text2 = conv #( sy-msgv2 )
                      text3 = conv #( sy-msgv3 )
                      text4 = conv #( sy-msgv4 ).
        ENDIF.
      CATCH cx\_demo\_t100 INTO DATA(oref).
        cl\_demo\_output=>display(
          |Caught exception:\\n\\n| &&
          |"{ oref->get\_text( ) }"| ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.
  ENDMETHOD.
  METHOD meth.
    MESSAGE e888(sabapdemos) WITH 'I' 'am' 'an' 'Exception!'
                             RAISING exception.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

This example demonstrates the transformation of a non-class-based exception raised in a method using [MESSAGE RAISING](javascript:call_link\('abapmessage_raising.htm'\)) and, when the method is called, handled using the addition [EXCEPTIONS](javascript:call_link\('abapcall_method_parameters.htm'\)) to a class-based exception. It uses the exception CX\_DEMO\_T100 from the [executable example](javascript:call_link\('abenmessage_interface_global_abexa.htm'\)) for the system interface IF\_T100\_MESSAGE in a global exception class, which includes only the interface [IF\_T100\_MESSAGE](javascript:call_link\('abenif_t100_message.htm'\)) and not [IF\_T100\_DYN\_MSG](javascript:call_link\('abenif_t100_message.htm'\)).

The properties of the message sent using MESSAGE RAISING are available in the system fields sy-msgty, sy-msgid, sy-msgno, and sy-msgv1 to sy-msgv4 after the exception is caught.

-   sy-msgid and sy-msgno are used after the addition [MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)) of the statement [RAISE EXCEPTION](javascript:call_link\('abapraise_exception_class.htm'\)) to associate the exception object with the message.

-   sy-msgv1 to sy-msgv4 are assigned to the input parameters of the instance constructor, which themselves are assigned to the identically named attributes.

-   sy-msgty cannot be passed further in this case.

The [executable example](javascript:call_link\('abenraise_message_global_abexa.htm'\)) for the system interface IF\_T100\_DYN\_MSG in a global exception demonstrates how all properties of the message can be specified after the addition [MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)).



**📖 Source**: [abenmessage_interface_reuse_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmessage_interface_reuse_abexa.htm)

### abenif_t100_message.htm

> **📖 Official SAP Documentation**: [abenif_t100_message.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_message.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) → 

System Interface IF\_T100\_MESSAGE for Messages

The interface IF\_T100\_MESSAGE associates classes with [messages](javascript:call_link\('abenmessage_glosry.htm'\) "Glossary Entry"). To do this, IF\_T100\_MESSAGE contains a structured attribute T100KEY of the type SCX\_T100KEY, which specifies a [message](javascript:call_link\('abenmessage_glosry.htm'\) "Glossary Entry") in the table T100:

-   The component MSGID contains the [message class](javascript:call_link\('abenmessage_class_glosry.htm'\) "Glossary Entry").

-   The component MSGNO contains the [message number](javascript:call_link\('abenmessage_number_glosry.htm'\) "Glossary Entry").

-   The components ATTR1 to ATTR4 contain the names of class attributes whose content is used as placeholder texts for any placeholders in the texts of the message.

The message text can be accessed as follows:

-   The interface IF\_T100\_MESSAGE includes the interface IF\_MESSAGE (which should not be used as a standalone interface). This interface contains the methods GET\_TEXT and GET\_LONGTEXT, which can be implemented by a class with the interface IF\_T100\_MESSAGE in such a way that they return the short text and long text of the current message. This can be done using the corresponding methods of the class CL\_MESSAGE\_HELPER.

-   In the variant [MESSAGE oref](javascript:call_link\('abapmessage_msg.htm'\)) of the statement [MESSAGE](javascript:call_link\('abapmessage.htm'\)), an [interface reference variable](javascript:call_link\('abeninterface_ref_variable_glosry.htm'\) "Glossary Entry") of the type IF\_T100\_MESSAGE or a [class reference variable](javascript:call_link\('abenclass_reference_variabl_glosry.htm'\) "Glossary Entry") of a class that implements this interface can be specified to display the message in question.

The statement MESSAGE or the class CL\_MESSAGE\_HELPER evaluate the content of the structure T100KEY here:

-   The components MSGID and MSGNO are scanned by message class and message class for a message. If a message is found, its texts are used. If not, a short text is generated that counts the message class and message number plus the placeholder texts from the assigned class attributes.

-   If they exist, the placeholders "&1" to "&4" and "&" of the short text or "&V1&" to "&V4&" of the long text of the message are replaced by the content of the class attributes specified in the components ATTR1 to ATTR4 in accordance with the rules of the addition [WITH](javascript:call_link\('abapmessage.htm'\)) of the statement [MESSAGE](javascript:call_link\('abapmessage.htm'\)). If an attribute specified in the components ATTR1 to ATTR4 does not exist or if an attribute cannot be converted to a placeholder text, the character "&" is added to the start and the end of the attribute name and used as a placeholder text. If one of the components ATTR1 to ATTR4 is initial, the corresponding placeholder text is initialized‎.

Notes

-   The interface IF\_T100\_MESSAGE is mainly designed for use with [exception texts](javascript:call_link\('abenexception_texts.htm'\)) in [exception classes](javascript:call_link\('abenexception_class_glosry.htm'\) "Glossary Entry"). If the interface is included in regular classes and in local exception classes, the filling of the interface structure T100KEY must be programmed here separately. The implementation of the interface methods GET\_TEXT and GET\_LONGTEXT, however, is already contained in the superclass CX\_ROOT and alias names are declared for these methods here. When creating global exception classes, tool support is provided for filling the structure T100KEY and for mapping attributes to placeholders. This is done using structured constants that can be specified when an exception is raised.

-   The method GET\_LATEST\_T100\_EXCEPTION in the class CL\_MESSAGE\_HELPER is used to return the last object in a chain of exception objects that has an [exception text](javascript:call_link\('abenexception_texts.htm'\)) defined by a message. Here, the chain is created using the attribute PREVIOUS.

-   The interface IF\_T100\_MESSAGE does not have any attributes for the message type.

-   The interface [IF\_T100\_DYN\_MSG](javascript:call_link\('abenif_t100_dyn_msg.htm'\)) adds predefined attributes for the message type and the placeholders of the message to the interface IF\_T100\_MESSAGE. IF\_T100\_MESSAGE is designed for static [exception texts](javascript:call_link\('abenexception_texts.htm'\)) of exception classes, but IF\_T100\_DYN\_MSG can [associate](javascript:call_link\('abenmessage_exceptions.htm'\)) any messages with exception classes.

Example

Uses [THROW](javascript:call_link\('abenconditional_expression_result.htm'\)) to raise an exception of the class CX\_DEMO\_T100, which binds the interface IF\_T100\_MESSAGE.

DATA col TYPE c LENGTH 1.
...
DATA(color) = COND string(
                WHEN col = 'R' THEN 'red'
                WHEN col = 'B' THEN 'blue'
                WHEN col = 'G' THEN 'green'
                ELSE THROW cx\_demo\_t100(
                     textid = cx\_demo\_t100=>demo
                     text1  = 'Illegal value:'
                     text2  = CONV #( col ) ) ).

Executable Examples

-   [System Interface IF\_T100\_MESSAGE in a Regular Class](javascript:call_link\('abenif_t100_message_abexa.htm'\))

-   [System Interface IF\_T100\_MESSAGE in a Local Exception Class](javascript:call_link\('abenmessage_interface_abexa.htm'\))

-   [System Interface IF\_T100\_MESSAGE in Global Exception Class](javascript:call_link\('abenmessage_interface_global_abexa.htm'\))

-   [System Interface IF\_T100\_MESSAGE for Exception with Message](javascript:call_link\('abenmessage_interface_reuse_abexa.htm'\))

Continue
![Example](exa.gif "Example") [IF\_T100\_MESSAGE in Regular Class](javascript:call_link\('abenif_t100_message_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_MESSAGE in Local Exception Class](javascript:call_link\('abenmessage_interface_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_MESSAGE in Global Exception Class](javascript:call_link\('abenmessage_interface_global_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_MESSAGE for Exception with Message](javascript:call_link\('abenmessage_interface_reuse_abexa.htm'\))



**📖 Source**: [abenif_t100_message.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_message.htm)

### abenif_t100_dyn_msg.htm

> **📖 Official SAP Documentation**: [abenif_t100_dyn_msg.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_dyn_msg.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) → 

System Interface IF\_T100\_DYN\_MSG for Messages

The interface IF\_T100\_DYN\_MSG contains the interface [IF\_T100\_MESSAGE](javascript:call_link\('abenif_t100_message.htm'\)) as a component interface and adds the following to it:

-   The attribute MSGTY for the message type

-   The attributes MSGV1 to MSGV4 for the placeholders of the message

Like IF\_T100\_MESSAGE, the interface IF\_T100\_DYN\_MSG associates classes with messages, with the attributes for the message type and placeholders of the message being predefined.

Notes

-   The interface IF\_T100\_DYN\_MSG is designed specifically for raising class-based exceptions with the addition [MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)) of the statement [RAISE EXCEPTION](javascript:call_link\('abapraise_exception_class.htm'\)) or the addition [THROW](javascript:call_link\('abenconditional_expression_result.htm'\)) in [conditional expressions](javascript:call_link\('abenconditional_expressions.htm'\)). The properties of the message specified after MESSAGE are assigned automatically to the associated attributes in [exception classes](javascript:call_link\('abenexceptions_classes.htm'\)) that include IF\_T100\_DYN\_MSG.

-   The addition [MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)) to RAISE EXCEPTION and/or THROW has a short form USING MESSAGE. This can be used for exception classes with the interface IF\_T100\_DYN\_MSG and enables determining the message from the current content of system fields sy-msg.... The short form can be used for transforming classical exceptions in class-based exceptions.

-   If the object reference variable oref points to an object that includes the system interface IF\_T100\_DYN\_MSG in the variant [MESSAGE oref](javascript:call_link\('abapmessage_msg.htm'\)) of the statement [MESSAGE](javascript:call_link\('abapmessage.htm'\)), the addition TYPE can be omitted and the message type from the interface attribute MSGTY of the object is used implicitly.

Example

Uses [THROW](javascript:call_link\('abenconditional_expression_result.htm'\)) to raise an exception of the class CX\_DEMO\_DYN\_T100, which binds the interface IF\_T100\_DYN\_MSG.

DATA col TYPE c LENGTH 1.
...
DATA(color) = COND string(
                WHEN col = 'R' THEN 'red'
                WHEN col = 'B' THEN 'blue'
                WHEN col = 'G' THEN 'green'
                ELSE THROW cx\_demo\_dyn\_t100(
                     MESSAGE e888(sabapdemos)
                       WITH 'Illegal value:' col ) ).

Executable Examples

-   [System Interface IF\_T100\_DYN\_MSG in a Regular Class](javascript:call_link\('abenif_t100_dyn_msg_abexa.htm'\))

-   [System Interface IF\_T100\_DYN\_MSG in a Local Exception Class](javascript:call_link\('abenraise_message_abexa.htm'\))

-   [System Interface IF\_T100\_DYN\_MSG in a Global Exception Class](javascript:call_link\('abenraise_message_global_abexa.htm'\))

-   [System Interface IF\_T100\_DYN\_MSG for Exception error\_message](javascript:call_link\('abenraise_error_message_abexa.htm'\))

Continue
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Regular Class](javascript:call_link\('abenif_t100_dyn_msg_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Local Exception Class](javascript:call_link\('abenraise_message_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Global Exception Class](javascript:call_link\('abenraise_message_global_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG for Exception error\_message](javascript:call_link\('abenraise_error_message_abexa.htm'\))



**📖 Source**: [abenif_t100_dyn_msg.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_dyn_msg.htm)

### abenif_t100_dyn_msg_abexa.htm

> **📖 Official SAP Documentation**: [abenif_t100_dyn_msg_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_dyn_msg_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) →  [System Interface IF\_T100\_DYN\_MSG for Messages](javascript:call_link\('abenif_t100_dyn_msg.htm'\)) → 

IF\_T100\_DYN\_MSG in a Regular Class

This example demonstrates how a regular class is associated with a message

Source Code

REPORT demo\_if\_t100\_dyn\_msg.
CLASS msg DEFINITION.
  PUBLIC SECTION.
    INTERFACES if\_t100\_dyn\_msg.
    ALIASES: msgty FOR if\_t100\_dyn\_msg~msgty,
             get\_text FOR if\_message~get\_text,
             get\_longtext FOR if\_message~get\_longtext.
    METHODS constructor IMPORTING id TYPE symsgid
                                  no TYPE symsgno
                                  ty TYPE symsgty
                                  v1 TYPE string OPTIONAL
                                  v2 TYPE string OPTIONAL
                                  v3 TYPE string OPTIONAL
                                  v4 TYPE string OPTIONAL.
ENDCLASS.
CLASS msg IMPLEMENTATION.
  METHOD constructor.
    if\_t100\_message~t100key-msgid = id.
    if\_t100\_message~t100key-msgno = no.
    if\_t100\_dyn\_msg~msgty = ty.
    if\_t100\_message~t100key-attr1 = 'IF\_T100\_DYN\_MSG~MSGV1'.
    if\_t100\_message~t100key-attr2 = 'IF\_T100\_DYN\_MSG~MSGV2'.
    if\_t100\_message~t100key-attr3 = 'IF\_T100\_DYN\_MSG~MSGV3'.
    if\_t100\_message~t100key-attr4 = 'IF\_T100\_DYN\_MSG~MSGV4'.
    if\_t100\_dyn\_msg~msgv1 = v1.
    if\_t100\_dyn\_msg~msgv2 = v2.
    if\_t100\_dyn\_msg~msgv3 = v3.
    if\_t100\_dyn\_msg~msgv4 = v4.
  ENDMETHOD.
  METHOD if\_message~get\_text.
    result = cl\_message\_helper=>get\_text\_for\_message( me ).
  ENDMETHOD.
  METHOD if\_message~get\_longtext.
    result = cl\_message\_helper=>get\_longtext\_for\_message( me ).
  ENDMETHOD.
ENDCLASS.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    DATA(id) = \`SABAPDEMOS\`.
    DATA(no) = \`888\`.
    DATA(ty) = \`I\`.
    DATA(v1) = \`Hello,\`.
    DATA(v2) = \`I am\`.
    DATA(v3) = \`a\`.
    DATA(v4) = \`Message!\`.
    cl\_demo\_input=>new(
      )->add\_field( CHANGING field = id
      )->add\_field( CHANGING field = no
      )->add\_field( CHANGING field = ty
      )->add\_field( CHANGING field = v1
      )->add\_field( CHANGING field = v2
      )->add\_field( CHANGING field = v3
      )->add\_field( CHANGING field = v4
      )->request( ).
    IF strlen( ty ) > 1 OR 'AEISX' NS ty.
      cl\_demo\_output=>display(
        |Invalid message type: { ty }|  ).
      RETURN.
    ENDIF.
    DATA(mref) = NEW msg( id = CONV #( id )
                          no = CONV #( no )
                          ty = CONV #( ty )
                          v1 = v1
                          v2 = v2
                          v3 = v3
                          v4 = v4 ).
    cl\_demo\_output=>display(
      |{ mref->get\_text( ) }, Type: { mref->msgty }| ).
    MESSAGE mref TYPE 'I' DISPLAY LIKE mref->msgty.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

This example applies the [executable example](javascript:call_link\('abenif_t100_message_abexa.htm'\)) for the interface IF\_T100\_MESSAGE to the interface IF\_T100\_DYN\_MSG directly. If IF\_T100\_DYN\_MSG is used, it is no longer necessary to create separate attributes for the placeholders of the message. The attributes of the interface are used instead. Furthermore, a message type can be saved and evaluated in the interface attribute msgty. If IF\_T100\_MESSAGE is used, a separate attribute must be declared here.



**📖 Source**: [abenif_t100_dyn_msg_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_dyn_msg_abexa.htm)

### abenraise_message_abexa.htm

> **📖 Official SAP Documentation**: [abenraise_message_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_message_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) →  [System Interface IF\_T100\_DYN\_MSG for Messages](javascript:call_link\('abenif_t100_dyn_msg.htm'\)) → 

IF\_T100\_DYN\_MSG in a Local Exception Class

This example demonstrates how a local exception class is associated with a message

Source Code

REPORT demo\_raise\_message.
CLASS cx\_dyn\_t100 DEFINITION INHERITING FROM cx\_dynamic\_check.
  PUBLIC SECTION.
    INTERFACES if\_t100\_dyn\_msg.
    ALIASES msgty FOR if\_t100\_dyn\_msg~msgty.
ENDCLASS.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS meth
      RAISING cx\_dyn\_t100.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    TRY.
        meth( ).
      CATCH cx\_dyn\_t100 INTO DATA(oref).
        cl\_demo\_output=>display(
          |Caught exception:\\n\\n| &&
          |"{ oref->get\_text( ) }", Type { oref->msgty } | ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE oref->msgty.
    ENDTRY.
  ENDMETHOD.
  METHOD meth.
    RAISE EXCEPTION TYPE cx\_dyn\_t100
          MESSAGE e888(sabapdemos) WITH 'I' 'am' 'an' 'Exception!'.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

This example applies the [executable example](javascript:call_link\('abenmessage_interface_abexa.htm'\)) for the interface IF\_T100\_MESSAGE to the interface IF\_T100\_DYN\_MSG directly. The local class cx\_dyn\_t100 includes the interface [IF\_T100\_DYN\_MSG](javascript:call_link\('abenif_t100_dyn_msg.htm'\)) and the addition [MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)) of the statement [RAISE EXCEPTION](javascript:call_link\('abapraise_exception_class.htm'\)) is used to raise the exception in the method meth.

Unlike when using [IF\_T100\_MESSAGE](javascript:call_link\('abenif_t100_message.htm'\)), no separate attributes for the placeholders of the message and no implementation of the instance constructor are required in cx\_dyn\_t100. Furthermore, the message type is passed in an attribute of the exception object when IF\_T100\_DYN\_MSG is used. An alias name is used here.



**📖 Source**: [abenraise_message_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_message_abexa.htm)

### abenraise_message_global_abexa.htm

> **📖 Official SAP Documentation**: [abenraise_message_global_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_message_global_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) →  [System Interface IF\_T100\_DYN\_MSG for Messages](javascript:call_link\('abenif_t100_dyn_msg.htm'\)) → 

IF\_T100\_DYN\_MSG in a Global Exception Class

This example demonstrates how a global exception class is associated with a message

Source Code

REPORT demo\_raise\_message\_global.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS meth EXCEPTIONS exception.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    TRY.
        meth( EXCEPTIONS exception = 4 ).
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE cx\_demo\_dyn\_t100
            MESSAGE ID sy-msgid
                    TYPE sy-msgty
                    NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      CATCH cx\_demo\_dyn\_t100 INTO DATA(oref).
        cl\_demo\_output=>display(
          |Caught exception:\\n\\n| &&
          |"{ oref->get\_text( ) }", Type { oref->msgty } | ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE oref->msgty.
    ENDTRY.
  ENDMETHOD.
  METHOD meth.
    MESSAGE e888(sabapdemos) WITH 'I' 'am' 'an' 'Exception!'
                             RAISING exception.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

This example demonstrates the transformation of a non-class-based exception raised in a method using [MESSAGE RAISING](javascript:call_link\('abapmessage_raising.htm'\)) and, when the method is called, handled using the addition [EXCEPTIONS](javascript:call_link\('abapcall_method_parameters.htm'\)) to a class-based exception. This example works in the same way as the [executable example](javascript:call_link\('abenmessage_interface_reuse_abexa.htm'\)) for the system interface [IF\_T100\_MESSAGE](javascript:call_link\('abenif_t100_message.htm'\)), but uses the class CX\_DEMO\_DYN\_T100, which includes the system interface [IF\_T100\_DYN\_MSG](javascript:call_link\('abenif_t100_dyn_msg.htm'\)).

-   In both cases, sy-msgid and sy-msgno can be used after the addition [MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)) of the statement [RAISE EXCEPTION](javascript:call_link\('abapraise_exception_class.htm'\)) to associate the exception object with the message.

-   sy-msgv1 to sy-msgv4 can be specified after [WITH](javascript:call_link\('abapraise_exception_message.htm'\)) and are assigned here to the interface attributes MSGV1 to MSGV4 automatically.

-   sy-msgty can also be passed further here using [MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)).

Note

See also the executable [example](javascript:call_link\('abenraise_message_glbl_shrt_abexa.htm'\)) for using a short form of statement [RAISE EXCEPTION MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)).



**📖 Source**: [abenraise_message_global_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_message_global_abexa.htm)

### abenraise_error_message_abexa.htm

> **📖 Official SAP Documentation**: [abenraise_error_message_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_error_message_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) →  [System Interface IF\_T100\_DYN\_MSG for Messages](javascript:call_link\('abenif_t100_dyn_msg.htm'\)) → 

IF\_T100\_DYN\_MSG for Exception error\_message

This example demonstrates how a caught message of a function module is forwarded.

Source Code

REPORT demo\_raise\_error\_message.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TRY.
        CALL FUNCTION 'DEMO\_FUNCTION\_MESSAGE'
          EXPORTING
            message\_type  = 'A'
            message\_place = 'in Function Module'
            message\_event = 'START-OF-SELECTION'
          EXCEPTIONS
            error\_message = 4.
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE cx\_demo\_dyn\_t100
            MESSAGE ID sy-msgid
            TYPE sy-msgty
            NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      CATCH cx\_demo\_dyn\_t100 INTO DATA(oref).
        cl\_demo\_output=>display(
          |Caught exception:\\n\\n| &&
          |"{ oref->get\_text( ) }", Type { oref->msgty } | ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE oref->msgty.
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example works in basically the same way as the [executable example](javascript:call_link\('abenraise_message_global_abexa.htm'\)) when transforming a classic exception raised using MESSAGE RAISING to a class-based exception. Here, however, a message of type A caught using [error\_message](javascript:call_link\('abapcall_function_parameter.htm'\)) is transformed.

Note

See also the executable [example](javascript:call_link\('abenraise_error_message_shrt_abexa.htm'\)) for using a short form of statement [RAISE EXCEPTION MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)).



**📖 Source**: [abenraise_error_message_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenraise_error_message_abexa.htm)

### abenif_t100_dyn_msg.htm

> **📖 Official SAP Documentation**: [abenif_t100_dyn_msg.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_dyn_msg.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Text Repositories](javascript:call_link\('abenabap_texts.htm'\)) →  [Messages](javascript:call_link\('abenabap_messages.htm'\)) →  [System Interfaces for Messages](javascript:call_link\('abenmessage_interfaces.htm'\)) → 

System Interface IF\_T100\_DYN\_MSG for Messages

The interface IF\_T100\_DYN\_MSG contains the interface [IF\_T100\_MESSAGE](javascript:call_link\('abenif_t100_message.htm'\)) as a component interface and adds the following to it:

-   The attribute MSGTY for the message type

-   The attributes MSGV1 to MSGV4 for the placeholders of the message

Like IF\_T100\_MESSAGE, the interface IF\_T100\_DYN\_MSG associates classes with messages, with the attributes for the message type and placeholders of the message being predefined.

Notes

-   The interface IF\_T100\_DYN\_MSG is designed specifically for raising class-based exceptions with the addition [MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)) of the statement [RAISE EXCEPTION](javascript:call_link\('abapraise_exception_class.htm'\)) or the addition [THROW](javascript:call_link\('abenconditional_expression_result.htm'\)) in [conditional expressions](javascript:call_link\('abenconditional_expressions.htm'\)). The properties of the message specified after MESSAGE are assigned automatically to the associated attributes in [exception classes](javascript:call_link\('abenexceptions_classes.htm'\)) that include IF\_T100\_DYN\_MSG.

-   The addition [MESSAGE](javascript:call_link\('abapraise_exception_message.htm'\)) to RAISE EXCEPTION and/or THROW has a short form USING MESSAGE. This can be used for exception classes with the interface IF\_T100\_DYN\_MSG and enables determining the message from the current content of system fields sy-msg.... The short form can be used for transforming classical exceptions in class-based exceptions.

-   If the object reference variable oref points to an object that includes the system interface IF\_T100\_DYN\_MSG in the variant [MESSAGE oref](javascript:call_link\('abapmessage_msg.htm'\)) of the statement [MESSAGE](javascript:call_link\('abapmessage.htm'\)), the addition TYPE can be omitted and the message type from the interface attribute MSGTY of the object is used implicitly.

Example

Uses [THROW](javascript:call_link\('abenconditional_expression_result.htm'\)) to raise an exception of the class CX\_DEMO\_DYN\_T100, which binds the interface IF\_T100\_DYN\_MSG.

DATA col TYPE c LENGTH 1.
...
DATA(color) = COND string(
                WHEN col = 'R' THEN 'red'
                WHEN col = 'B' THEN 'blue'
                WHEN col = 'G' THEN 'green'
                ELSE THROW cx\_demo\_dyn\_t100(
                     MESSAGE e888(sabapdemos)
                       WITH 'Illegal value:' col ) ).

Executable Examples

-   [System Interface IF\_T100\_DYN\_MSG in a Regular Class](javascript:call_link\('abenif_t100_dyn_msg_abexa.htm'\))

-   [System Interface IF\_T100\_DYN\_MSG in a Local Exception Class](javascript:call_link\('abenraise_message_abexa.htm'\))

-   [System Interface IF\_T100\_DYN\_MSG in a Global Exception Class](javascript:call_link\('abenraise_message_global_abexa.htm'\))

-   [System Interface IF\_T100\_DYN\_MSG for Exception error\_message](javascript:call_link\('abenraise_error_message_abexa.htm'\))

Continue
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Regular Class](javascript:call_link\('abenif_t100_dyn_msg_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Local Exception Class](javascript:call_link\('abenraise_message_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Global Exception Class](javascript:call_link\('abenraise_message_global_abexa.htm'\))
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG for Exception error\_message](javascript:call_link\('abenraise_error_message_abexa.htm'\))


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / RFC Overview

**Files**: 13 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

Included pages: 6



**📖 Source**: [abenif_t100_dyn_msg.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenif_t100_dyn_msg.htm)

### abenrfc_abexas.htm

> **📖 Official SAP Documentation**: [abenrfc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) → 

Examples for Remote Function Call

Continue
![Example](exa.gif "Example") [Parameter Passing in sRFC and aRFC](javascript:call_link\('abenrfc_parameters_abexa.htm'\))
![Example](exa.gif "Example") [Exception Handling in RFC](javascript:call_link\('abenrfc_exceptions_abexa.htm'\))
![Example](exa.gif "Example") [Parallel Asynchronous RFC](javascript:call_link\('abenparallel_rfc_abexa.htm'\))
![Example](exa.gif "Example") [Dynamic RFC Destination](javascript:call_link\('abenrfc_dynamic_dest_abexa.htm'\))
![Example](exa.gif "Example") [Implicit Logon Data in RFC](javascript:call_link\('abenrfc_logon_data_abexa.htm'\))



**📖 Source**: [abenrfc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_abexas.htm)

### abenrfc_parameters_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_parameters_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_parameters_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Parameter Passing in sRFC and aRFC

This example demonstrates parameter passing in two RFC variants.

Source Code

REPORT demo\_rfc\_parameters.
CLASS demo\_rfc DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main,
      callback IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    CLASS-DATA:
      val\_in     TYPE string,
      val\_out    TYPE string,
      val\_in\_out TYPE string,
      msg        TYPE c LENGTH 80,
      out        TYPE REF TO if\_demo\_output.
ENDCLASS.
CLASS demo\_rfc IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    "Synchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    out->next\_section( 'sRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    "Asynchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      STARTING NEW TASK 'DEMO'
      CALLING demo\_rfc=>callback ON END OF TASK
      EXPORTING
        p\_in                  = val\_in
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling aRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    WAIT FOR ASYNCHRONOUS TASKS UNTIL val\_out IS NOT INITIAL
                                UP TO 10 SECONDS.
    out->next\_section( 'aRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    out->display( ).
  ENDMETHOD.
  METHOD callback.
    val\_out    = \`\`.
    val\_in\_out = \`\`.
    RECEIVE RESULTS FROM FUNCTION 'DEMO\_RFM\_PARAMETERS'
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( '|Error when receiving aRFC.\\n{ msg }|' ).
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_rfc=>main( ).

Description

The function module DEMO\_RFM\_PARAMETERS is called using [synchronous](javascript:call_link\('abapcall_function_destination.htm'\)) and [asynchronous](javascript:call_link\('abapcall_function_starting.htm'\)) RFC.

-   In synchronous calls, parameters are passed and applied directly in the statement CALL FUNCTION.

-   In asynchronous calls, parameters can only be passed in the statement CALL FUNCTION. Parameters are applied using the statement [RECEIVE](javascript:call_link\('abapreceive.htm'\)) in a callback routine. The statement [WAIT FOR ASYNCHRONOUS TASKS](javascript:call_link\('abapwait_until.htm'\)) is used to wait for this routine.



**📖 Source**: [abenrfc_parameters_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_parameters_abexa.htm)

### abenrfc_exceptions_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_exceptions_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_exceptions_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Exception Handling in RFC

This example demonstrates exception handling in RFC.

Source Code

REPORT demo\_rfc\_exceptions.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA msg TYPE c LENGTH 255.
    DATA(out) = cl\_demo\_output=>new( ).
    "Classical exception handling
    CALL FUNCTION 'DEMO\_RFM\_CLASSIC\_EXCEPTION'
      DESTINATION 'NONE'
      EXCEPTIONS
        system\_failure        = 1  MESSAGE msg
        communication\_failure = 2  MESSAGE msg
        OTHERS                = 3.
    CASE sy-subrc.
      WHEN 1.
        out->write( |EXCEPTION SYSTEM\_FAILURE | && msg ).
      WHEN 2.
        out->write( |EXCEPTION COMMUNICATION\_FAILURE | && msg ).
      WHEN 3.
        out->write( |EXCEPTION OTHERS| ).
    ENDCASE.
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The DEMO\_RFM\_CLASSIC\_EXCEPTION function module triggers the non-class-based exception CLASSIC\_EXCEPTION.

When DEMO\_RFM\_CLASSIC\_EXCEPTION is called, EXCEPTIONS is specified and values for sy-subrc are assigned to the possible classic exceptions. If none of the predefined RFC interface exceptions are raised, sy-subrc is set to 3.



**📖 Source**: [abenrfc_exceptions_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_exceptions_abexa.htm)

### abenparallel_rfc_abexa.htm

> **📖 Official SAP Documentation**: [abenparallel_rfc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenparallel_rfc_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Parallel Asynchronous RFC

This example demonstrates parallel asynchronous RFC processing.

Source Code

REPORT demo\_parallel\_rfc.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: main,
                   callbback\_meth IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    TYPES: BEGIN OF task\_type,
           name TYPE string,
           dest TYPE string,
         END OF task\_type.
    CLASS-DATA: task\_list TYPE STANDARD TABLE OF task\_type,
                task\_wa   TYPE task\_type,
                rcv\_jobs  TYPE i,
                mess      TYPE c LENGTH 80.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: snd\_jobs  TYPE i,
          exc\_flag  TYPE i,
          indx      TYPE c LENGTH 4,
          name      TYPE c LENGTH 8.
    DATA(out) = cl\_demo\_output=>new( ).
    DO 10 TIMES.
      indx = sy-index.
      name = 'Task' && indx.
      CALL FUNCTION 'RFC\_SYSTEM\_INFO'
        STARTING NEW TASK name
        DESTINATION IN GROUP DEFAULT
        CALLING callbback\_meth ON END OF TASK
        EXCEPTIONS
          system\_failure        = 1 MESSAGE mess
          communication\_failure = 2 MESSAGE mess
          resource\_failure      = 3.
      CASE sy-subrc.
        WHEN 0.
          snd\_jobs = snd\_jobs + 1.
        WHEN 1 OR 2.
          out->write\_text( mess ).
        WHEN 3.
          IF snd\_jobs >= 1 AND
             exc\_flag = 0.
             exc\_flag = 1.
            WAIT UNTIL rcv\_jobs >= snd\_jobs
                 UP TO 5 SECONDS.
          ENDIF.
          IF sy-subrc = 0.
            exc\_flag = 0.
          ELSE.
            out->display( 'Resource failure' ).
          ENDIF.
        WHEN OTHERS.
          out->display( 'Other error' ).
      ENDCASE.
    ENDDO.
    WAIT UNTIL rcv\_jobs >= snd\_jobs.
    out->display( task\_list ).  ENDMETHOD.
  METHOD callbback\_meth.
    DATA info TYPE rfcsi.
    task\_wa-name = p\_task.
    rcv\_jobs = rcv\_jobs + 1.
    RECEIVE RESULTS FROM FUNCTION 'RFC\_SYSTEM\_INFO'
      IMPORTING
        rfcsi\_export = info
      EXCEPTIONS
        system\_failure        = 1 MESSAGE mess
        communication\_failure = 2 MESSAGE mess.
    IF sy-subrc = 0.
      task\_wa-dest = info-rfcdest.
    ELSE.
      task\_wa-dest = mess.
    ENDIF.
    APPEND task\_wa TO task\_list.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Parallel asynchronous processing of the function module RFC\_SYSTEM\_INFO using [asynchronous remote function calls](javascript:call_link\('abenasynchronous_rfc_glosry.htm'\) "Glossary Entry"). Ten calls with different task IDs name are made, which each run in a separate [work process](javascript:call_link\('abenwork_process_glosry.htm'\) "Glossary Entry"). The callback routine callbback\_meth counts the completed function modules and receives information about the target system.

The addition GROUP DEFAULT is used to distribute the execution across all [AS Instances](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry")s of the current AS ABAP. If no more free work processes are available after at least one successful call, the execution of the program is stopped until all function modules started up to that point have been completed. This stoppage is limited to a maximum of 5 seconds.

After all function modules have been started, the system waits until all callback routines have been executed. After that, the internal table task\_list filled there is produced. The output shows the order in which the individual tasks were completed and on which AS Instance.



**📖 Source**: [abenparallel_rfc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenparallel_rfc_abexa.htm)

### abenrfc_dynamic_dest_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_dynamic_dest_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_dynamic_dest_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Dynamic RFC Destination

This example demonstrates how [dynamic destinations](javascript:call_link\('abenrfc_destination.htm'\)) are created.

Source Code

REPORT demo\_rfc\_dynamic\_dest.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      val\_in     TYPE string VALUE \`val\_in\`,
      val\_in\_out TYPE string VALUE \`val\_in\_out\`,
      val\_out    TYPE string,
      msg        TYPE c LENGTH 80.
    IF sy-uname IS INITIAL.
      cl\_demo\_output=>display(
        |Example not possible for anonymous user| ).
      RETURN.
    ENDIF.
    DATA(in) = cl\_demo\_input=>new( ).
    DATA(client) = sy-mandt.
    in->add\_field( CHANGING field = client ).
    DATA(uname) = sy-uname.
    in->add\_field( CHANGING field = uname ).
    DATA(langu) = sy-langu.
    in->add\_field( CHANGING field = langu ).
    DATA(sysid) = sy-sysid.
    in->add\_field( CHANGING field = sysid ).
    DATA(host) = CONV rfchost( sy-host ).
    in->add\_field( CHANGING field = host ).
    DATA(group) = CONV rfcload( 'PUBLIC' ).
    in->add\_field( CHANGING field = group ).
    in->request( ).
    DATA(dest) = cl\_dynamic\_destination=>create\_rfc\_destination(
                   logon\_client   = client
                   logon\_user     = uname
                   logon\_language = langu
                   sid            = sysid
                   server         = host
                   group          = group ).
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION dest
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    cl\_demo\_output=>display( |{ val\_out }\\n{ val\_in\_out }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The method CREATE\_RFC\_DESTINATION of class CL\_DYNAMIC\_DESTINATION is used to create a [dynamic destination](javascript:call_link\('abenrfc_destination.htm'\)). Input values, whose default values are determined from system fields for the current AS ABAP, are passed as parameters. A remote-enabled function module is called using the dynamic destination. The call is only successful if the destination is created correctly.



**📖 Source**: [abenrfc_dynamic_dest_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_dynamic_dest_abexa.htm)

### abenrfc_logon_data_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_logon_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_logon_data_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Implicit Logon Data in RFC

This example demonstrates how the logon data of an RFC session is set implicitly.

Source Code

REPORT demo\_rfc\_implicit\_logon\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      BEGIN OF logon\_data,
        uname       TYPE sy-uname,
        mandt       TYPE sy-mandt,
        logon\_langu TYPE sy-langu,
        langu       TYPE sy-langu,
      END OF logon\_data.
    IF cl\_abap\_syst=>get\_logon\_language( ) <> 'E'.
      SET LOCALE LANGUAGE 'E'.
    ELSE.
      SET LOCALE LANGUAGE 'D'.
    ENDIF.
    logon\_data = VALUE #(
        uname       = sy-uname
        mandt       = sy-mandt
        logon\_langu = cl\_abap\_syst=>get\_logon\_language( )
        langu       = cl\_abap\_syst=>get\_language( ) ).
    ASSERT logon\_data-langu = sy-langu.
    DATA(out) = cl\_demo\_output=>new(
      )->next\_section( 'Parameters of Caller'
      )->write( logon\_data ).
    CALL FUNCTION 'DEMO\_RFM\_LOGON\_DATA' DESTINATION 'NONE'
      IMPORTING
        uname       = logon\_data-uname
        mandt       = logon\_data-mandt
        logon\_langu = logon\_data-logon\_langu
        langu       = logon\_data-langu.
    out->next\_section( 'Parameters of Callee'
      )->write( logon\_data )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

A remote-enabled function module DEMO\_RFM\_LOGON\_DATA is called with the destination "NONE" using the RFC interface. The logon data user name, client, and logon language of the corresponding [RFC session](javascript:call_link\('abenrfc_context.htm'\)) are provided implicitly. To demonstrate that the [logon language](javascript:call_link\('abenlogon_language_glosry.htm'\) "Glossary Entry") of the RFC session is set by the language of the [text environment](javascript:call_link\('abentext_environment_glosry.htm'\) "Glossary Entry") of the caller, this is set before the call with the statement [SET LOCALE LANGUAGE](javascript:call_link\('abapset_locale.htm'\)) to a language different from the logon language of the caller. In the called RFM the language of the text environment of the RFC session is also changed and is then different to the logon language there as well.

If the function module DEMO\_RFM\_LOGON\_DATA is called remotely again, the RFC session is reused with the existing logon data. Changing the language of the text environment again in the caller would have no effect.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / CALL FUNCTION - RFC / CALL FUNCTION - DESTINATION

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

Included pages: 6



**📖 Source**: [abenrfc_logon_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_logon_data_abexa.htm)

### abenrfc_abexas.htm

> **📖 Official SAP Documentation**: [abenrfc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) → 

Examples for Remote Function Call

Continue
![Example](exa.gif "Example") [Parameter Passing in sRFC and aRFC](javascript:call_link\('abenrfc_parameters_abexa.htm'\))
![Example](exa.gif "Example") [Exception Handling in RFC](javascript:call_link\('abenrfc_exceptions_abexa.htm'\))
![Example](exa.gif "Example") [Parallel Asynchronous RFC](javascript:call_link\('abenparallel_rfc_abexa.htm'\))
![Example](exa.gif "Example") [Dynamic RFC Destination](javascript:call_link\('abenrfc_dynamic_dest_abexa.htm'\))
![Example](exa.gif "Example") [Implicit Logon Data in RFC](javascript:call_link\('abenrfc_logon_data_abexa.htm'\))



**📖 Source**: [abenrfc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_abexas.htm)

### abenrfc_parameters_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_parameters_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_parameters_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Parameter Passing in sRFC and aRFC

This example demonstrates parameter passing in two RFC variants.

Source Code

REPORT demo\_rfc\_parameters.
CLASS demo\_rfc DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main,
      callback IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    CLASS-DATA:
      val\_in     TYPE string,
      val\_out    TYPE string,
      val\_in\_out TYPE string,
      msg        TYPE c LENGTH 80,
      out        TYPE REF TO if\_demo\_output.
ENDCLASS.
CLASS demo\_rfc IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    "Synchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    out->next\_section( 'sRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    "Asynchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      STARTING NEW TASK 'DEMO'
      CALLING demo\_rfc=>callback ON END OF TASK
      EXPORTING
        p\_in                  = val\_in
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling aRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    WAIT FOR ASYNCHRONOUS TASKS UNTIL val\_out IS NOT INITIAL
                                UP TO 10 SECONDS.
    out->next\_section( 'aRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    out->display( ).
  ENDMETHOD.
  METHOD callback.
    val\_out    = \`\`.
    val\_in\_out = \`\`.
    RECEIVE RESULTS FROM FUNCTION 'DEMO\_RFM\_PARAMETERS'
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( '|Error when receiving aRFC.\\n{ msg }|' ).
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_rfc=>main( ).

Description

The function module DEMO\_RFM\_PARAMETERS is called using [synchronous](javascript:call_link\('abapcall_function_destination.htm'\)) and [asynchronous](javascript:call_link\('abapcall_function_starting.htm'\)) RFC.

-   In synchronous calls, parameters are passed and applied directly in the statement CALL FUNCTION.

-   In asynchronous calls, parameters can only be passed in the statement CALL FUNCTION. Parameters are applied using the statement [RECEIVE](javascript:call_link\('abapreceive.htm'\)) in a callback routine. The statement [WAIT FOR ASYNCHRONOUS TASKS](javascript:call_link\('abapwait_until.htm'\)) is used to wait for this routine.



**📖 Source**: [abenrfc_parameters_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_parameters_abexa.htm)

### abenrfc_exceptions_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_exceptions_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_exceptions_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Exception Handling in RFC

This example demonstrates exception handling in RFC.

Source Code

REPORT demo\_rfc\_exceptions.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA msg TYPE c LENGTH 255.
    DATA(out) = cl\_demo\_output=>new( ).
    "Classical exception handling
    CALL FUNCTION 'DEMO\_RFM\_CLASSIC\_EXCEPTION'
      DESTINATION 'NONE'
      EXCEPTIONS
        system\_failure        = 1  MESSAGE msg
        communication\_failure = 2  MESSAGE msg
        OTHERS                = 3.
    CASE sy-subrc.
      WHEN 1.
        out->write( |EXCEPTION SYSTEM\_FAILURE | && msg ).
      WHEN 2.
        out->write( |EXCEPTION COMMUNICATION\_FAILURE | && msg ).
      WHEN 3.
        out->write( |EXCEPTION OTHERS| ).
    ENDCASE.
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The DEMO\_RFM\_CLASSIC\_EXCEPTION function module triggers the non-class-based exception CLASSIC\_EXCEPTION.

When DEMO\_RFM\_CLASSIC\_EXCEPTION is called, EXCEPTIONS is specified and values for sy-subrc are assigned to the possible classic exceptions. If none of the predefined RFC interface exceptions are raised, sy-subrc is set to 3.



**📖 Source**: [abenrfc_exceptions_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_exceptions_abexa.htm)

### abenparallel_rfc_abexa.htm

> **📖 Official SAP Documentation**: [abenparallel_rfc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenparallel_rfc_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Parallel Asynchronous RFC

This example demonstrates parallel asynchronous RFC processing.

Source Code

REPORT demo\_parallel\_rfc.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: main,
                   callbback\_meth IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    TYPES: BEGIN OF task\_type,
           name TYPE string,
           dest TYPE string,
         END OF task\_type.
    CLASS-DATA: task\_list TYPE STANDARD TABLE OF task\_type,
                task\_wa   TYPE task\_type,
                rcv\_jobs  TYPE i,
                mess      TYPE c LENGTH 80.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: snd\_jobs  TYPE i,
          exc\_flag  TYPE i,
          indx      TYPE c LENGTH 4,
          name      TYPE c LENGTH 8.
    DATA(out) = cl\_demo\_output=>new( ).
    DO 10 TIMES.
      indx = sy-index.
      name = 'Task' && indx.
      CALL FUNCTION 'RFC\_SYSTEM\_INFO'
        STARTING NEW TASK name
        DESTINATION IN GROUP DEFAULT
        CALLING callbback\_meth ON END OF TASK
        EXCEPTIONS
          system\_failure        = 1 MESSAGE mess
          communication\_failure = 2 MESSAGE mess
          resource\_failure      = 3.
      CASE sy-subrc.
        WHEN 0.
          snd\_jobs = snd\_jobs + 1.
        WHEN 1 OR 2.
          out->write\_text( mess ).
        WHEN 3.
          IF snd\_jobs >= 1 AND
             exc\_flag = 0.
             exc\_flag = 1.
            WAIT UNTIL rcv\_jobs >= snd\_jobs
                 UP TO 5 SECONDS.
          ENDIF.
          IF sy-subrc = 0.
            exc\_flag = 0.
          ELSE.
            out->display( 'Resource failure' ).
          ENDIF.
        WHEN OTHERS.
          out->display( 'Other error' ).
      ENDCASE.
    ENDDO.
    WAIT UNTIL rcv\_jobs >= snd\_jobs.
    out->display( task\_list ).  ENDMETHOD.
  METHOD callbback\_meth.
    DATA info TYPE rfcsi.
    task\_wa-name = p\_task.
    rcv\_jobs = rcv\_jobs + 1.
    RECEIVE RESULTS FROM FUNCTION 'RFC\_SYSTEM\_INFO'
      IMPORTING
        rfcsi\_export = info
      EXCEPTIONS
        system\_failure        = 1 MESSAGE mess
        communication\_failure = 2 MESSAGE mess.
    IF sy-subrc = 0.
      task\_wa-dest = info-rfcdest.
    ELSE.
      task\_wa-dest = mess.
    ENDIF.
    APPEND task\_wa TO task\_list.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Parallel asynchronous processing of the function module RFC\_SYSTEM\_INFO using [asynchronous remote function calls](javascript:call_link\('abenasynchronous_rfc_glosry.htm'\) "Glossary Entry"). Ten calls with different task IDs name are made, which each run in a separate [work process](javascript:call_link\('abenwork_process_glosry.htm'\) "Glossary Entry"). The callback routine callbback\_meth counts the completed function modules and receives information about the target system.

The addition GROUP DEFAULT is used to distribute the execution across all [AS Instances](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry")s of the current AS ABAP. If no more free work processes are available after at least one successful call, the execution of the program is stopped until all function modules started up to that point have been completed. This stoppage is limited to a maximum of 5 seconds.

After all function modules have been started, the system waits until all callback routines have been executed. After that, the internal table task\_list filled there is produced. The output shows the order in which the individual tasks were completed and on which AS Instance.



**📖 Source**: [abenparallel_rfc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenparallel_rfc_abexa.htm)

### abenrfc_dynamic_dest_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_dynamic_dest_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_dynamic_dest_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Dynamic RFC Destination

This example demonstrates how [dynamic destinations](javascript:call_link\('abenrfc_destination.htm'\)) are created.

Source Code

REPORT demo\_rfc\_dynamic\_dest.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      val\_in     TYPE string VALUE \`val\_in\`,
      val\_in\_out TYPE string VALUE \`val\_in\_out\`,
      val\_out    TYPE string,
      msg        TYPE c LENGTH 80.
    IF sy-uname IS INITIAL.
      cl\_demo\_output=>display(
        |Example not possible for anonymous user| ).
      RETURN.
    ENDIF.
    DATA(in) = cl\_demo\_input=>new( ).
    DATA(client) = sy-mandt.
    in->add\_field( CHANGING field = client ).
    DATA(uname) = sy-uname.
    in->add\_field( CHANGING field = uname ).
    DATA(langu) = sy-langu.
    in->add\_field( CHANGING field = langu ).
    DATA(sysid) = sy-sysid.
    in->add\_field( CHANGING field = sysid ).
    DATA(host) = CONV rfchost( sy-host ).
    in->add\_field( CHANGING field = host ).
    DATA(group) = CONV rfcload( 'PUBLIC' ).
    in->add\_field( CHANGING field = group ).
    in->request( ).
    DATA(dest) = cl\_dynamic\_destination=>create\_rfc\_destination(
                   logon\_client   = client
                   logon\_user     = uname
                   logon\_language = langu
                   sid            = sysid
                   server         = host
                   group          = group ).
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION dest
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    cl\_demo\_output=>display( |{ val\_out }\\n{ val\_in\_out }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The method CREATE\_RFC\_DESTINATION of class CL\_DYNAMIC\_DESTINATION is used to create a [dynamic destination](javascript:call_link\('abenrfc_destination.htm'\)). Input values, whose default values are determined from system fields for the current AS ABAP, are passed as parameters. A remote-enabled function module is called using the dynamic destination. The call is only successful if the destination is created correctly.



**📖 Source**: [abenrfc_dynamic_dest_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_dynamic_dest_abexa.htm)

### abenrfc_logon_data_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_logon_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_logon_data_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Implicit Logon Data in RFC

This example demonstrates how the logon data of an RFC session is set implicitly.

Source Code

REPORT demo\_rfc\_implicit\_logon\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      BEGIN OF logon\_data,
        uname       TYPE sy-uname,
        mandt       TYPE sy-mandt,
        logon\_langu TYPE sy-langu,
        langu       TYPE sy-langu,
      END OF logon\_data.
    IF cl\_abap\_syst=>get\_logon\_language( ) <> 'E'.
      SET LOCALE LANGUAGE 'E'.
    ELSE.
      SET LOCALE LANGUAGE 'D'.
    ENDIF.
    logon\_data = VALUE #(
        uname       = sy-uname
        mandt       = sy-mandt
        logon\_langu = cl\_abap\_syst=>get\_logon\_language( )
        langu       = cl\_abap\_syst=>get\_language( ) ).
    ASSERT logon\_data-langu = sy-langu.
    DATA(out) = cl\_demo\_output=>new(
      )->next\_section( 'Parameters of Caller'
      )->write( logon\_data ).
    CALL FUNCTION 'DEMO\_RFM\_LOGON\_DATA' DESTINATION 'NONE'
      IMPORTING
        uname       = logon\_data-uname
        mandt       = logon\_data-mandt
        logon\_langu = logon\_data-logon\_langu
        langu       = logon\_data-langu.
    out->next\_section( 'Parameters of Callee'
      )->write( logon\_data )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

A remote-enabled function module DEMO\_RFM\_LOGON\_DATA is called with the destination "NONE" using the RFC interface. The logon data user name, client, and logon language of the corresponding [RFC session](javascript:call_link\('abenrfc_context.htm'\)) are provided implicitly. To demonstrate that the [logon language](javascript:call_link\('abenlogon_language_glosry.htm'\) "Glossary Entry") of the RFC session is set by the language of the [text environment](javascript:call_link\('abentext_environment_glosry.htm'\) "Glossary Entry") of the caller, this is set before the call with the statement [SET LOCALE LANGUAGE](javascript:call_link\('abapset_locale.htm'\)) to a language different from the logon language of the caller. In the called RFM the language of the text environment of the RFC session is also changed and is then different to the logon language there as well.

If the function module DEMO\_RFM\_LOGON\_DATA is called remotely again, the RFC session is reused with the existing logon data. Changing the language of the text environment again in the caller would have no effect.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / CALL FUNCTION - RFC / CALL FUNCTION - STARTING NEW TASK

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

Included pages: 6



**📖 Source**: [abenrfc_logon_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_logon_data_abexa.htm)

### abenrfc_abexas.htm

> **📖 Official SAP Documentation**: [abenrfc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) → 

Examples for Remote Function Call

Continue
![Example](exa.gif "Example") [Parameter Passing in sRFC and aRFC](javascript:call_link\('abenrfc_parameters_abexa.htm'\))
![Example](exa.gif "Example") [Exception Handling in RFC](javascript:call_link\('abenrfc_exceptions_abexa.htm'\))
![Example](exa.gif "Example") [Parallel Asynchronous RFC](javascript:call_link\('abenparallel_rfc_abexa.htm'\))
![Example](exa.gif "Example") [Dynamic RFC Destination](javascript:call_link\('abenrfc_dynamic_dest_abexa.htm'\))
![Example](exa.gif "Example") [Implicit Logon Data in RFC](javascript:call_link\('abenrfc_logon_data_abexa.htm'\))



**📖 Source**: [abenrfc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_abexas.htm)

### abenrfc_parameters_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_parameters_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_parameters_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Parameter Passing in sRFC and aRFC

This example demonstrates parameter passing in two RFC variants.

Source Code

REPORT demo\_rfc\_parameters.
CLASS demo\_rfc DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main,
      callback IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    CLASS-DATA:
      val\_in     TYPE string,
      val\_out    TYPE string,
      val\_in\_out TYPE string,
      msg        TYPE c LENGTH 80,
      out        TYPE REF TO if\_demo\_output.
ENDCLASS.
CLASS demo\_rfc IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    "Synchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    out->next\_section( 'sRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    "Asynchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      STARTING NEW TASK 'DEMO'
      CALLING demo\_rfc=>callback ON END OF TASK
      EXPORTING
        p\_in                  = val\_in
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling aRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    WAIT FOR ASYNCHRONOUS TASKS UNTIL val\_out IS NOT INITIAL
                                UP TO 10 SECONDS.
    out->next\_section( 'aRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    out->display( ).
  ENDMETHOD.
  METHOD callback.
    val\_out    = \`\`.
    val\_in\_out = \`\`.
    RECEIVE RESULTS FROM FUNCTION 'DEMO\_RFM\_PARAMETERS'
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( '|Error when receiving aRFC.\\n{ msg }|' ).
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_rfc=>main( ).

Description

The function module DEMO\_RFM\_PARAMETERS is called using [synchronous](javascript:call_link\('abapcall_function_destination.htm'\)) and [asynchronous](javascript:call_link\('abapcall_function_starting.htm'\)) RFC.

-   In synchronous calls, parameters are passed and applied directly in the statement CALL FUNCTION.

-   In asynchronous calls, parameters can only be passed in the statement CALL FUNCTION. Parameters are applied using the statement [RECEIVE](javascript:call_link\('abapreceive.htm'\)) in a callback routine. The statement [WAIT FOR ASYNCHRONOUS TASKS](javascript:call_link\('abapwait_until.htm'\)) is used to wait for this routine.



**📖 Source**: [abenrfc_parameters_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_parameters_abexa.htm)

### abenrfc_exceptions_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_exceptions_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_exceptions_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Exception Handling in RFC

This example demonstrates exception handling in RFC.

Source Code

REPORT demo\_rfc\_exceptions.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA msg TYPE c LENGTH 255.
    DATA(out) = cl\_demo\_output=>new( ).
    "Classical exception handling
    CALL FUNCTION 'DEMO\_RFM\_CLASSIC\_EXCEPTION'
      DESTINATION 'NONE'
      EXCEPTIONS
        system\_failure        = 1  MESSAGE msg
        communication\_failure = 2  MESSAGE msg
        OTHERS                = 3.
    CASE sy-subrc.
      WHEN 1.
        out->write( |EXCEPTION SYSTEM\_FAILURE | && msg ).
      WHEN 2.
        out->write( |EXCEPTION COMMUNICATION\_FAILURE | && msg ).
      WHEN 3.
        out->write( |EXCEPTION OTHERS| ).
    ENDCASE.
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The DEMO\_RFM\_CLASSIC\_EXCEPTION function module triggers the non-class-based exception CLASSIC\_EXCEPTION.

When DEMO\_RFM\_CLASSIC\_EXCEPTION is called, EXCEPTIONS is specified and values for sy-subrc are assigned to the possible classic exceptions. If none of the predefined RFC interface exceptions are raised, sy-subrc is set to 3.



**📖 Source**: [abenrfc_exceptions_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_exceptions_abexa.htm)

### abenparallel_rfc_abexa.htm

> **📖 Official SAP Documentation**: [abenparallel_rfc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenparallel_rfc_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Parallel Asynchronous RFC

This example demonstrates parallel asynchronous RFC processing.

Source Code

REPORT demo\_parallel\_rfc.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: main,
                   callbback\_meth IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    TYPES: BEGIN OF task\_type,
           name TYPE string,
           dest TYPE string,
         END OF task\_type.
    CLASS-DATA: task\_list TYPE STANDARD TABLE OF task\_type,
                task\_wa   TYPE task\_type,
                rcv\_jobs  TYPE i,
                mess      TYPE c LENGTH 80.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: snd\_jobs  TYPE i,
          exc\_flag  TYPE i,
          indx      TYPE c LENGTH 4,
          name      TYPE c LENGTH 8.
    DATA(out) = cl\_demo\_output=>new( ).
    DO 10 TIMES.
      indx = sy-index.
      name = 'Task' && indx.
      CALL FUNCTION 'RFC\_SYSTEM\_INFO'
        STARTING NEW TASK name
        DESTINATION IN GROUP DEFAULT
        CALLING callbback\_meth ON END OF TASK
        EXCEPTIONS
          system\_failure        = 1 MESSAGE mess
          communication\_failure = 2 MESSAGE mess
          resource\_failure      = 3.
      CASE sy-subrc.
        WHEN 0.
          snd\_jobs = snd\_jobs + 1.
        WHEN 1 OR 2.
          out->write\_text( mess ).
        WHEN 3.
          IF snd\_jobs >= 1 AND
             exc\_flag = 0.
             exc\_flag = 1.
            WAIT UNTIL rcv\_jobs >= snd\_jobs
                 UP TO 5 SECONDS.
          ENDIF.
          IF sy-subrc = 0.
            exc\_flag = 0.
          ELSE.
            out->display( 'Resource failure' ).
          ENDIF.
        WHEN OTHERS.
          out->display( 'Other error' ).
      ENDCASE.
    ENDDO.
    WAIT UNTIL rcv\_jobs >= snd\_jobs.
    out->display( task\_list ).  ENDMETHOD.
  METHOD callbback\_meth.
    DATA info TYPE rfcsi.
    task\_wa-name = p\_task.
    rcv\_jobs = rcv\_jobs + 1.
    RECEIVE RESULTS FROM FUNCTION 'RFC\_SYSTEM\_INFO'
      IMPORTING
        rfcsi\_export = info
      EXCEPTIONS
        system\_failure        = 1 MESSAGE mess
        communication\_failure = 2 MESSAGE mess.
    IF sy-subrc = 0.
      task\_wa-dest = info-rfcdest.
    ELSE.
      task\_wa-dest = mess.
    ENDIF.
    APPEND task\_wa TO task\_list.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Parallel asynchronous processing of the function module RFC\_SYSTEM\_INFO using [asynchronous remote function calls](javascript:call_link\('abenasynchronous_rfc_glosry.htm'\) "Glossary Entry"). Ten calls with different task IDs name are made, which each run in a separate [work process](javascript:call_link\('abenwork_process_glosry.htm'\) "Glossary Entry"). The callback routine callbback\_meth counts the completed function modules and receives information about the target system.

The addition GROUP DEFAULT is used to distribute the execution across all [AS Instances](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry")s of the current AS ABAP. If no more free work processes are available after at least one successful call, the execution of the program is stopped until all function modules started up to that point have been completed. This stoppage is limited to a maximum of 5 seconds.

After all function modules have been started, the system waits until all callback routines have been executed. After that, the internal table task\_list filled there is produced. The output shows the order in which the individual tasks were completed and on which AS Instance.



**📖 Source**: [abenparallel_rfc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenparallel_rfc_abexa.htm)

### abenrfc_dynamic_dest_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_dynamic_dest_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_dynamic_dest_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Dynamic RFC Destination

This example demonstrates how [dynamic destinations](javascript:call_link\('abenrfc_destination.htm'\)) are created.

Source Code

REPORT demo\_rfc\_dynamic\_dest.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      val\_in     TYPE string VALUE \`val\_in\`,
      val\_in\_out TYPE string VALUE \`val\_in\_out\`,
      val\_out    TYPE string,
      msg        TYPE c LENGTH 80.
    IF sy-uname IS INITIAL.
      cl\_demo\_output=>display(
        |Example not possible for anonymous user| ).
      RETURN.
    ENDIF.
    DATA(in) = cl\_demo\_input=>new( ).
    DATA(client) = sy-mandt.
    in->add\_field( CHANGING field = client ).
    DATA(uname) = sy-uname.
    in->add\_field( CHANGING field = uname ).
    DATA(langu) = sy-langu.
    in->add\_field( CHANGING field = langu ).
    DATA(sysid) = sy-sysid.
    in->add\_field( CHANGING field = sysid ).
    DATA(host) = CONV rfchost( sy-host ).
    in->add\_field( CHANGING field = host ).
    DATA(group) = CONV rfcload( 'PUBLIC' ).
    in->add\_field( CHANGING field = group ).
    in->request( ).
    DATA(dest) = cl\_dynamic\_destination=>create\_rfc\_destination(
                   logon\_client   = client
                   logon\_user     = uname
                   logon\_language = langu
                   sid            = sysid
                   server         = host
                   group          = group ).
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION dest
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    cl\_demo\_output=>display( |{ val\_out }\\n{ val\_in\_out }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The method CREATE\_RFC\_DESTINATION of class CL\_DYNAMIC\_DESTINATION is used to create a [dynamic destination](javascript:call_link\('abenrfc_destination.htm'\)). Input values, whose default values are determined from system fields for the current AS ABAP, are passed as parameters. A remote-enabled function module is called using the dynamic destination. The call is only successful if the destination is created correctly.



**📖 Source**: [abenrfc_dynamic_dest_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_dynamic_dest_abexa.htm)

### abenrfc_logon_data_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_logon_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_logon_data_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Implicit Logon Data in RFC

This example demonstrates how the logon data of an RFC session is set implicitly.

Source Code

REPORT demo\_rfc\_implicit\_logon\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      BEGIN OF logon\_data,
        uname       TYPE sy-uname,
        mandt       TYPE sy-mandt,
        logon\_langu TYPE sy-langu,
        langu       TYPE sy-langu,
      END OF logon\_data.
    IF cl\_abap\_syst=>get\_logon\_language( ) <> 'E'.
      SET LOCALE LANGUAGE 'E'.
    ELSE.
      SET LOCALE LANGUAGE 'D'.
    ENDIF.
    logon\_data = VALUE #(
        uname       = sy-uname
        mandt       = sy-mandt
        logon\_langu = cl\_abap\_syst=>get\_logon\_language( )
        langu       = cl\_abap\_syst=>get\_language( ) ).
    ASSERT logon\_data-langu = sy-langu.
    DATA(out) = cl\_demo\_output=>new(
      )->next\_section( 'Parameters of Caller'
      )->write( logon\_data ).
    CALL FUNCTION 'DEMO\_RFM\_LOGON\_DATA' DESTINATION 'NONE'
      IMPORTING
        uname       = logon\_data-uname
        mandt       = logon\_data-mandt
        logon\_langu = logon\_data-logon\_langu
        langu       = logon\_data-langu.
    out->next\_section( 'Parameters of Callee'
      )->write( logon\_data )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

A remote-enabled function module DEMO\_RFM\_LOGON\_DATA is called with the destination "NONE" using the RFC interface. The logon data user name, client, and logon language of the corresponding [RFC session](javascript:call_link\('abenrfc_context.htm'\)) are provided implicitly. To demonstrate that the [logon language](javascript:call_link\('abenlogon_language_glosry.htm'\) "Glossary Entry") of the RFC session is set by the language of the [text environment](javascript:call_link\('abentext_environment_glosry.htm'\) "Glossary Entry") of the caller, this is set before the call with the statement [SET LOCALE LANGUAGE](javascript:call_link\('abapset_locale.htm'\)) to a language different from the logon language of the caller. In the called RFM the language of the text environment of the RFC session is also changed and is then different to the logon language there as well.

If the function module DEMO\_RFM\_LOGON\_DATA is called remotely again, the RFC session is reused with the existing logon data. Changing the language of the text environment again in the caller would have no effect.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / CALL FUNCTION - RFC / CALL FUNCTION - IN BACKGROUND UNIT

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

Included pages: 6



**📖 Source**: [abenrfc_logon_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_logon_data_abexa.htm)

### abenrfc_abexas.htm

> **📖 Official SAP Documentation**: [abenrfc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) → 

Examples for Remote Function Call

Continue
![Example](exa.gif "Example") [Parameter Passing in sRFC and aRFC](javascript:call_link\('abenrfc_parameters_abexa.htm'\))
![Example](exa.gif "Example") [Exception Handling in RFC](javascript:call_link\('abenrfc_exceptions_abexa.htm'\))
![Example](exa.gif "Example") [Parallel Asynchronous RFC](javascript:call_link\('abenparallel_rfc_abexa.htm'\))
![Example](exa.gif "Example") [Dynamic RFC Destination](javascript:call_link\('abenrfc_dynamic_dest_abexa.htm'\))
![Example](exa.gif "Example") [Implicit Logon Data in RFC](javascript:call_link\('abenrfc_logon_data_abexa.htm'\))



**📖 Source**: [abenrfc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_abexas.htm)

### abenrfc_parameters_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_parameters_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_parameters_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Parameter Passing in sRFC and aRFC

This example demonstrates parameter passing in two RFC variants.

Source Code

REPORT demo\_rfc\_parameters.
CLASS demo\_rfc DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main,
      callback IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    CLASS-DATA:
      val\_in     TYPE string,
      val\_out    TYPE string,
      val\_in\_out TYPE string,
      msg        TYPE c LENGTH 80,
      out        TYPE REF TO if\_demo\_output.
ENDCLASS.
CLASS demo\_rfc IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    "Synchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    out->next\_section( 'sRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    "Asynchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      STARTING NEW TASK 'DEMO'
      CALLING demo\_rfc=>callback ON END OF TASK
      EXPORTING
        p\_in                  = val\_in
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling aRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    WAIT FOR ASYNCHRONOUS TASKS UNTIL val\_out IS NOT INITIAL
                                UP TO 10 SECONDS.
    out->next\_section( 'aRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    out->display( ).
  ENDMETHOD.
  METHOD callback.
    val\_out    = \`\`.
    val\_in\_out = \`\`.
    RECEIVE RESULTS FROM FUNCTION 'DEMO\_RFM\_PARAMETERS'
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( '|Error when receiving aRFC.\\n{ msg }|' ).
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_rfc=>main( ).

Description

The function module DEMO\_RFM\_PARAMETERS is called using [synchronous](javascript:call_link\('abapcall_function_destination.htm'\)) and [asynchronous](javascript:call_link\('abapcall_function_starting.htm'\)) RFC.

-   In synchronous calls, parameters are passed and applied directly in the statement CALL FUNCTION.

-   In asynchronous calls, parameters can only be passed in the statement CALL FUNCTION. Parameters are applied using the statement [RECEIVE](javascript:call_link\('abapreceive.htm'\)) in a callback routine. The statement [WAIT FOR ASYNCHRONOUS TASKS](javascript:call_link\('abapwait_until.htm'\)) is used to wait for this routine.



**📖 Source**: [abenrfc_parameters_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_parameters_abexa.htm)

### abenrfc_exceptions_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_exceptions_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_exceptions_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Exception Handling in RFC

This example demonstrates exception handling in RFC.

Source Code

REPORT demo\_rfc\_exceptions.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA msg TYPE c LENGTH 255.
    DATA(out) = cl\_demo\_output=>new( ).
    "Classical exception handling
    CALL FUNCTION 'DEMO\_RFM\_CLASSIC\_EXCEPTION'
      DESTINATION 'NONE'
      EXCEPTIONS
        system\_failure        = 1  MESSAGE msg
        communication\_failure = 2  MESSAGE msg
        OTHERS                = 3.
    CASE sy-subrc.
      WHEN 1.
        out->write( |EXCEPTION SYSTEM\_FAILURE | && msg ).
      WHEN 2.
        out->write( |EXCEPTION COMMUNICATION\_FAILURE | && msg ).
      WHEN 3.
        out->write( |EXCEPTION OTHERS| ).
    ENDCASE.
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The DEMO\_RFM\_CLASSIC\_EXCEPTION function module triggers the non-class-based exception CLASSIC\_EXCEPTION.

When DEMO\_RFM\_CLASSIC\_EXCEPTION is called, EXCEPTIONS is specified and values for sy-subrc are assigned to the possible classic exceptions. If none of the predefined RFC interface exceptions are raised, sy-subrc is set to 3.



**📖 Source**: [abenrfc_exceptions_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_exceptions_abexa.htm)

### abenparallel_rfc_abexa.htm

> **📖 Official SAP Documentation**: [abenparallel_rfc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenparallel_rfc_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Parallel Asynchronous RFC

This example demonstrates parallel asynchronous RFC processing.

Source Code

REPORT demo\_parallel\_rfc.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: main,
                   callbback\_meth IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    TYPES: BEGIN OF task\_type,
           name TYPE string,
           dest TYPE string,
         END OF task\_type.
    CLASS-DATA: task\_list TYPE STANDARD TABLE OF task\_type,
                task\_wa   TYPE task\_type,
                rcv\_jobs  TYPE i,
                mess      TYPE c LENGTH 80.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: snd\_jobs  TYPE i,
          exc\_flag  TYPE i,
          indx      TYPE c LENGTH 4,
          name      TYPE c LENGTH 8.
    DATA(out) = cl\_demo\_output=>new( ).
    DO 10 TIMES.
      indx = sy-index.
      name = 'Task' && indx.
      CALL FUNCTION 'RFC\_SYSTEM\_INFO'
        STARTING NEW TASK name
        DESTINATION IN GROUP DEFAULT
        CALLING callbback\_meth ON END OF TASK
        EXCEPTIONS
          system\_failure        = 1 MESSAGE mess
          communication\_failure = 2 MESSAGE mess
          resource\_failure      = 3.
      CASE sy-subrc.
        WHEN 0.
          snd\_jobs = snd\_jobs + 1.
        WHEN 1 OR 2.
          out->write\_text( mess ).
        WHEN 3.
          IF snd\_jobs >= 1 AND
             exc\_flag = 0.
             exc\_flag = 1.
            WAIT UNTIL rcv\_jobs >= snd\_jobs
                 UP TO 5 SECONDS.
          ENDIF.
          IF sy-subrc = 0.
            exc\_flag = 0.
          ELSE.
            out->display( 'Resource failure' ).
          ENDIF.
        WHEN OTHERS.
          out->display( 'Other error' ).
      ENDCASE.
    ENDDO.
    WAIT UNTIL rcv\_jobs >= snd\_jobs.
    out->display( task\_list ).  ENDMETHOD.
  METHOD callbback\_meth.
    DATA info TYPE rfcsi.
    task\_wa-name = p\_task.
    rcv\_jobs = rcv\_jobs + 1.
    RECEIVE RESULTS FROM FUNCTION 'RFC\_SYSTEM\_INFO'
      IMPORTING
        rfcsi\_export = info
      EXCEPTIONS
        system\_failure        = 1 MESSAGE mess
        communication\_failure = 2 MESSAGE mess.
    IF sy-subrc = 0.
      task\_wa-dest = info-rfcdest.
    ELSE.
      task\_wa-dest = mess.
    ENDIF.
    APPEND task\_wa TO task\_list.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Parallel asynchronous processing of the function module RFC\_SYSTEM\_INFO using [asynchronous remote function calls](javascript:call_link\('abenasynchronous_rfc_glosry.htm'\) "Glossary Entry"). Ten calls with different task IDs name are made, which each run in a separate [work process](javascript:call_link\('abenwork_process_glosry.htm'\) "Glossary Entry"). The callback routine callbback\_meth counts the completed function modules and receives information about the target system.

The addition GROUP DEFAULT is used to distribute the execution across all [AS Instances](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry")s of the current AS ABAP. If no more free work processes are available after at least one successful call, the execution of the program is stopped until all function modules started up to that point have been completed. This stoppage is limited to a maximum of 5 seconds.

After all function modules have been started, the system waits until all callback routines have been executed. After that, the internal table task\_list filled there is produced. The output shows the order in which the individual tasks were completed and on which AS Instance.



**📖 Source**: [abenparallel_rfc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenparallel_rfc_abexa.htm)

### abenrfc_dynamic_dest_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_dynamic_dest_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_dynamic_dest_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Dynamic RFC Destination

This example demonstrates how [dynamic destinations](javascript:call_link\('abenrfc_destination.htm'\)) are created.

Source Code

REPORT demo\_rfc\_dynamic\_dest.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      val\_in     TYPE string VALUE \`val\_in\`,
      val\_in\_out TYPE string VALUE \`val\_in\_out\`,
      val\_out    TYPE string,
      msg        TYPE c LENGTH 80.
    IF sy-uname IS INITIAL.
      cl\_demo\_output=>display(
        |Example not possible for anonymous user| ).
      RETURN.
    ENDIF.
    DATA(in) = cl\_demo\_input=>new( ).
    DATA(client) = sy-mandt.
    in->add\_field( CHANGING field = client ).
    DATA(uname) = sy-uname.
    in->add\_field( CHANGING field = uname ).
    DATA(langu) = sy-langu.
    in->add\_field( CHANGING field = langu ).
    DATA(sysid) = sy-sysid.
    in->add\_field( CHANGING field = sysid ).
    DATA(host) = CONV rfchost( sy-host ).
    in->add\_field( CHANGING field = host ).
    DATA(group) = CONV rfcload( 'PUBLIC' ).
    in->add\_field( CHANGING field = group ).
    in->request( ).
    DATA(dest) = cl\_dynamic\_destination=>create\_rfc\_destination(
                   logon\_client   = client
                   logon\_user     = uname
                   logon\_language = langu
                   sid            = sysid
                   server         = host
                   group          = group ).
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION dest
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    cl\_demo\_output=>display( |{ val\_out }\\n{ val\_in\_out }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The method CREATE\_RFC\_DESTINATION of class CL\_DYNAMIC\_DESTINATION is used to create a [dynamic destination](javascript:call_link\('abenrfc_destination.htm'\)). Input values, whose default values are determined from system fields for the current AS ABAP, are passed as parameters. A remote-enabled function module is called using the dynamic destination. The call is only successful if the destination is created correctly.



**📖 Source**: [abenrfc_dynamic_dest_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_dynamic_dest_abexa.htm)

### abenrfc_logon_data_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_logon_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_logon_data_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Implicit Logon Data in RFC

This example demonstrates how the logon data of an RFC session is set implicitly.

Source Code

REPORT demo\_rfc\_implicit\_logon\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      BEGIN OF logon\_data,
        uname       TYPE sy-uname,
        mandt       TYPE sy-mandt,
        logon\_langu TYPE sy-langu,
        langu       TYPE sy-langu,
      END OF logon\_data.
    IF cl\_abap\_syst=>get\_logon\_language( ) <> 'E'.
      SET LOCALE LANGUAGE 'E'.
    ELSE.
      SET LOCALE LANGUAGE 'D'.
    ENDIF.
    logon\_data = VALUE #(
        uname       = sy-uname
        mandt       = sy-mandt
        logon\_langu = cl\_abap\_syst=>get\_logon\_language( )
        langu       = cl\_abap\_syst=>get\_language( ) ).
    ASSERT logon\_data-langu = sy-langu.
    DATA(out) = cl\_demo\_output=>new(
      )->next\_section( 'Parameters of Caller'
      )->write( logon\_data ).
    CALL FUNCTION 'DEMO\_RFM\_LOGON\_DATA' DESTINATION 'NONE'
      IMPORTING
        uname       = logon\_data-uname
        mandt       = logon\_data-mandt
        logon\_langu = logon\_data-logon\_langu
        langu       = logon\_data-langu.
    out->next\_section( 'Parameters of Callee'
      )->write( logon\_data )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

A remote-enabled function module DEMO\_RFM\_LOGON\_DATA is called with the destination "NONE" using the RFC interface. The logon data user name, client, and logon language of the corresponding [RFC session](javascript:call_link\('abenrfc_context.htm'\)) are provided implicitly. To demonstrate that the [logon language](javascript:call_link\('abenlogon_language_glosry.htm'\) "Glossary Entry") of the RFC session is set by the language of the [text environment](javascript:call_link\('abentext_environment_glosry.htm'\) "Glossary Entry") of the caller, this is set before the call with the statement [SET LOCALE LANGUAGE](javascript:call_link\('abapset_locale.htm'\)) to a language different from the logon language of the caller. In the called RFM the language of the text environment of the RFC session is also changed and is then different to the logon language there as well.

If the function module DEMO\_RFM\_LOGON\_DATA is called remotely again, the RFC session is reused with the existing logon data. Changing the language of the text environment again in the caller would have no effect.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

Included pages: 6



**📖 Source**: [abenrfc_logon_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_logon_data_abexa.htm)

### abenrfc_abexas.htm

> **📖 Official SAP Documentation**: [abenrfc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) → 

Examples for Remote Function Call

Continue
![Example](exa.gif "Example") [Parameter Passing in sRFC and aRFC](javascript:call_link\('abenrfc_parameters_abexa.htm'\))
![Example](exa.gif "Example") [Exception Handling in RFC](javascript:call_link\('abenrfc_exceptions_abexa.htm'\))
![Example](exa.gif "Example") [Parallel Asynchronous RFC](javascript:call_link\('abenparallel_rfc_abexa.htm'\))
![Example](exa.gif "Example") [Dynamic RFC Destination](javascript:call_link\('abenrfc_dynamic_dest_abexa.htm'\))
![Example](exa.gif "Example") [Implicit Logon Data in RFC](javascript:call_link\('abenrfc_logon_data_abexa.htm'\))



**📖 Source**: [abenrfc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_abexas.htm)

### abenrfc_parameters_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_parameters_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_parameters_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Parameter Passing in sRFC and aRFC

This example demonstrates parameter passing in two RFC variants.

Source Code

REPORT demo\_rfc\_parameters.
CLASS demo\_rfc DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main,
      callback IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    CLASS-DATA:
      val\_in     TYPE string,
      val\_out    TYPE string,
      val\_in\_out TYPE string,
      msg        TYPE c LENGTH 80,
      out        TYPE REF TO if\_demo\_output.
ENDCLASS.
CLASS demo\_rfc IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    "Synchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    out->next\_section( 'sRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    "Asynchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      STARTING NEW TASK 'DEMO'
      CALLING demo\_rfc=>callback ON END OF TASK
      EXPORTING
        p\_in                  = val\_in
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling aRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    WAIT FOR ASYNCHRONOUS TASKS UNTIL val\_out IS NOT INITIAL
                                UP TO 10 SECONDS.
    out->next\_section( 'aRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    out->display( ).
  ENDMETHOD.
  METHOD callback.
    val\_out    = \`\`.
    val\_in\_out = \`\`.
    RECEIVE RESULTS FROM FUNCTION 'DEMO\_RFM\_PARAMETERS'
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( '|Error when receiving aRFC.\\n{ msg }|' ).
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_rfc=>main( ).

Description

The function module DEMO\_RFM\_PARAMETERS is called using [synchronous](javascript:call_link\('abapcall_function_destination.htm'\)) and [asynchronous](javascript:call_link\('abapcall_function_starting.htm'\)) RFC.

-   In synchronous calls, parameters are passed and applied directly in the statement CALL FUNCTION.

-   In asynchronous calls, parameters can only be passed in the statement CALL FUNCTION. Parameters are applied using the statement [RECEIVE](javascript:call_link\('abapreceive.htm'\)) in a callback routine. The statement [WAIT FOR ASYNCHRONOUS TASKS](javascript:call_link\('abapwait_until.htm'\)) is used to wait for this routine.



**📖 Source**: [abenrfc_parameters_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_parameters_abexa.htm)

### abenrfc_exceptions_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_exceptions_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_exceptions_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Exception Handling in RFC

This example demonstrates exception handling in RFC.

Source Code

REPORT demo\_rfc\_exceptions.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA msg TYPE c LENGTH 255.
    DATA(out) = cl\_demo\_output=>new( ).
    "Classical exception handling
    CALL FUNCTION 'DEMO\_RFM\_CLASSIC\_EXCEPTION'
      DESTINATION 'NONE'
      EXCEPTIONS
        system\_failure        = 1  MESSAGE msg
        communication\_failure = 2  MESSAGE msg
        OTHERS                = 3.
    CASE sy-subrc.
      WHEN 1.
        out->write( |EXCEPTION SYSTEM\_FAILURE | && msg ).
      WHEN 2.
        out->write( |EXCEPTION COMMUNICATION\_FAILURE | && msg ).
      WHEN 3.
        out->write( |EXCEPTION OTHERS| ).
    ENDCASE.
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The DEMO\_RFM\_CLASSIC\_EXCEPTION function module triggers the non-class-based exception CLASSIC\_EXCEPTION.

When DEMO\_RFM\_CLASSIC\_EXCEPTION is called, EXCEPTIONS is specified and values for sy-subrc are assigned to the possible classic exceptions. If none of the predefined RFC interface exceptions are raised, sy-subrc is set to 3.



**📖 Source**: [abenrfc_exceptions_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_exceptions_abexa.htm)

### abenparallel_rfc_abexa.htm

> **📖 Official SAP Documentation**: [abenparallel_rfc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenparallel_rfc_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Parallel Asynchronous RFC

This example demonstrates parallel asynchronous RFC processing.

Source Code

REPORT demo\_parallel\_rfc.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: main,
                   callbback\_meth IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    TYPES: BEGIN OF task\_type,
           name TYPE string,
           dest TYPE string,
         END OF task\_type.
    CLASS-DATA: task\_list TYPE STANDARD TABLE OF task\_type,
                task\_wa   TYPE task\_type,
                rcv\_jobs  TYPE i,
                mess      TYPE c LENGTH 80.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: snd\_jobs  TYPE i,
          exc\_flag  TYPE i,
          indx      TYPE c LENGTH 4,
          name      TYPE c LENGTH 8.
    DATA(out) = cl\_demo\_output=>new( ).
    DO 10 TIMES.
      indx = sy-index.
      name = 'Task' && indx.
      CALL FUNCTION 'RFC\_SYSTEM\_INFO'
        STARTING NEW TASK name
        DESTINATION IN GROUP DEFAULT
        CALLING callbback\_meth ON END OF TASK
        EXCEPTIONS
          system\_failure        = 1 MESSAGE mess
          communication\_failure = 2 MESSAGE mess
          resource\_failure      = 3.
      CASE sy-subrc.
        WHEN 0.
          snd\_jobs = snd\_jobs + 1.
        WHEN 1 OR 2.
          out->write\_text( mess ).
        WHEN 3.
          IF snd\_jobs >= 1 AND
             exc\_flag = 0.
             exc\_flag = 1.
            WAIT UNTIL rcv\_jobs >= snd\_jobs
                 UP TO 5 SECONDS.
          ENDIF.
          IF sy-subrc = 0.
            exc\_flag = 0.
          ELSE.
            out->display( 'Resource failure' ).
          ENDIF.
        WHEN OTHERS.
          out->display( 'Other error' ).
      ENDCASE.
    ENDDO.
    WAIT UNTIL rcv\_jobs >= snd\_jobs.
    out->display( task\_list ).  ENDMETHOD.
  METHOD callbback\_meth.
    DATA info TYPE rfcsi.
    task\_wa-name = p\_task.
    rcv\_jobs = rcv\_jobs + 1.
    RECEIVE RESULTS FROM FUNCTION 'RFC\_SYSTEM\_INFO'
      IMPORTING
        rfcsi\_export = info
      EXCEPTIONS
        system\_failure        = 1 MESSAGE mess
        communication\_failure = 2 MESSAGE mess.
    IF sy-subrc = 0.
      task\_wa-dest = info-rfcdest.
    ELSE.
      task\_wa-dest = mess.
    ENDIF.
    APPEND task\_wa TO task\_list.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Parallel asynchronous processing of the function module RFC\_SYSTEM\_INFO using [asynchronous remote function calls](javascript:call_link\('abenasynchronous_rfc_glosry.htm'\) "Glossary Entry"). Ten calls with different task IDs name are made, which each run in a separate [work process](javascript:call_link\('abenwork_process_glosry.htm'\) "Glossary Entry"). The callback routine callbback\_meth counts the completed function modules and receives information about the target system.

The addition GROUP DEFAULT is used to distribute the execution across all [AS Instances](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry")s of the current AS ABAP. If no more free work processes are available after at least one successful call, the execution of the program is stopped until all function modules started up to that point have been completed. This stoppage is limited to a maximum of 5 seconds.

After all function modules have been started, the system waits until all callback routines have been executed. After that, the internal table task\_list filled there is produced. The output shows the order in which the individual tasks were completed and on which AS Instance.



**📖 Source**: [abenparallel_rfc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenparallel_rfc_abexa.htm)

### abenrfc_dynamic_dest_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_dynamic_dest_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_dynamic_dest_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Dynamic RFC Destination

This example demonstrates how [dynamic destinations](javascript:call_link\('abenrfc_destination.htm'\)) are created.

Source Code

REPORT demo\_rfc\_dynamic\_dest.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      val\_in     TYPE string VALUE \`val\_in\`,
      val\_in\_out TYPE string VALUE \`val\_in\_out\`,
      val\_out    TYPE string,
      msg        TYPE c LENGTH 80.
    IF sy-uname IS INITIAL.
      cl\_demo\_output=>display(
        |Example not possible for anonymous user| ).
      RETURN.
    ENDIF.
    DATA(in) = cl\_demo\_input=>new( ).
    DATA(client) = sy-mandt.
    in->add\_field( CHANGING field = client ).
    DATA(uname) = sy-uname.
    in->add\_field( CHANGING field = uname ).
    DATA(langu) = sy-langu.
    in->add\_field( CHANGING field = langu ).
    DATA(sysid) = sy-sysid.
    in->add\_field( CHANGING field = sysid ).
    DATA(host) = CONV rfchost( sy-host ).
    in->add\_field( CHANGING field = host ).
    DATA(group) = CONV rfcload( 'PUBLIC' ).
    in->add\_field( CHANGING field = group ).
    in->request( ).
    DATA(dest) = cl\_dynamic\_destination=>create\_rfc\_destination(
                   logon\_client   = client
                   logon\_user     = uname
                   logon\_language = langu
                   sid            = sysid
                   server         = host
                   group          = group ).
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION dest
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    cl\_demo\_output=>display( |{ val\_out }\\n{ val\_in\_out }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The method CREATE\_RFC\_DESTINATION of class CL\_DYNAMIC\_DESTINATION is used to create a [dynamic destination](javascript:call_link\('abenrfc_destination.htm'\)). Input values, whose default values are determined from system fields for the current AS ABAP, are passed as parameters. A remote-enabled function module is called using the dynamic destination. The call is only successful if the destination is created correctly.



**📖 Source**: [abenrfc_dynamic_dest_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_dynamic_dest_abexa.htm)

### abenrfc_logon_data_abexa.htm

> **📖 Official SAP Documentation**: [abenrfc_logon_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_logon_data_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [RFC - Remote Function Call](javascript:call_link\('abenrfc.htm'\)) →  [Examples for Remote Function Call](javascript:call_link\('abenrfc_abexas.htm'\)) → 

Implicit Logon Data in RFC

This example demonstrates how the logon data of an RFC session is set implicitly.

Source Code

REPORT demo\_rfc\_implicit\_logon\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      BEGIN OF logon\_data,
        uname       TYPE sy-uname,
        mandt       TYPE sy-mandt,
        logon\_langu TYPE sy-langu,
        langu       TYPE sy-langu,
      END OF logon\_data.
    IF cl\_abap\_syst=>get\_logon\_language( ) <> 'E'.
      SET LOCALE LANGUAGE 'E'.
    ELSE.
      SET LOCALE LANGUAGE 'D'.
    ENDIF.
    logon\_data = VALUE #(
        uname       = sy-uname
        mandt       = sy-mandt
        logon\_langu = cl\_abap\_syst=>get\_logon\_language( )
        langu       = cl\_abap\_syst=>get\_language( ) ).
    ASSERT logon\_data-langu = sy-langu.
    DATA(out) = cl\_demo\_output=>new(
      )->next\_section( 'Parameters of Caller'
      )->write( logon\_data ).
    CALL FUNCTION 'DEMO\_RFM\_LOGON\_DATA' DESTINATION 'NONE'
      IMPORTING
        uname       = logon\_data-uname
        mandt       = logon\_data-mandt
        logon\_langu = logon\_data-logon\_langu
        langu       = logon\_data-langu.
    out->next\_section( 'Parameters of Callee'
      )->write( logon\_data )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

A remote-enabled function module DEMO\_RFM\_LOGON\_DATA is called with the destination "NONE" using the RFC interface. The logon data user name, client, and logon language of the corresponding [RFC session](javascript:call_link\('abenrfc_context.htm'\)) are provided implicitly. To demonstrate that the [logon language](javascript:call_link\('abenlogon_language_glosry.htm'\) "Glossary Entry") of the RFC session is set by the language of the [text environment](javascript:call_link\('abentext_environment_glosry.htm'\) "Glossary Entry") of the caller, this is set before the call with the statement [SET LOCALE LANGUAGE](javascript:call_link\('abapset_locale.htm'\)) to a language different from the logon language of the caller. In the called RFM the language of the text environment of the RFC session is also changed and is then different to the logon language there as well.

If the function module DEMO\_RFM\_LOGON\_DATA is called remotely again, the RFC session is reused with the existing logon data. Changing the language of the text environment again in the caller would have no effect.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ICF - Internet Communication Framework

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ICF - Internet Communication Framework

Included pages: 8



**📖 Source**: [abenrfc_logon_data_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_logon_data_abexa.htm)

### abenicf.htm

> **📖 Official SAP Documentation**: [abenicf.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenicf.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) → 

ICF - Internet Communication Framework

Internet Communication Framework (ICF) is a programming interface (API), based on interfaces and classes, used by ABAP programs to communicate with the Internet. ICF supports the Internet protocols HTTP, HTTPS, and SMTP. All communication between ABAP and the Internet based on these protocols takes place using ICF. ICF is a simplified technical foundation that can be used by more advanced programming interfaces. This means that ABAP programs do not usually access ICF directly and wrappers are used instead, such as [Business Server Pages](javascript:call_link\('abenbusiness_server_pages_glosry.htm'\) "Glossary Entry"), [Web Dynpro ABAP](javascript:call_link\('abenweb_dynpro_glosry.htm'\) "Glossary Entry"), Web Services ABAP, or on OData-based services like [SAPUI5](javascript:call_link\('abensapui5_glosry.htm'\) "Glossary Entry"). Wrappers like these ensure that the conventions required for external communication are met, such as the model view controller approach (MVC) in Web Dynpro and SAPUI5 or Simple Object Access Protocol (SOAP) in Web services.

To communicate with the Internet using REST principles (Representational State Transfer), the interfaces and classes in the ABAP REST Library in the package SREST should be used, since they adapt ICF accordingly.

-   [ICF Overview](#abenicf-1--------as-abap-as-an-icf-server---@ITOC@@ABENICF_2)

-   [AS ABAP as an ICF Client](#abenicf-3--------icf-security---@ITOC@@ABENICF_4)

-   [More Information](#abenicf-5---note--information-about-communications-using-the-websocket-protocol-or-tcp-can-be-found-under--abap-push-channels--javascript-call-link---abenapc-htm-------icf-overview--the-following-figure-is-a--highly-simplified--schematic-overview-of-communications-between-abap-and-the-internet-using-icf--it-uses-http-communication-as-an-example-----figure--abdoc-icf-gif---the-actual-communication-of-the--as-abap--javascript-call-link---abensap-nw-abap-glosry-htm-----glossary-entry---with-the-internet-takes-places-through-its--internet-communication-manager--javascript-call-link---abeninternet-con-man-glosry-htm-----glossary-entry----icm---the-manager-itself-communicates-with-an--as-abap--javascript-call-link---abensap-nw-abap-glosry-htm-----glossary-entry---work-process--whose-task-handler-controls-icf---communication-can-run-in-either-direction--meaning-that-as-abap-can-be-a-server-or-a-client--within-icf--this-aspect-is-implemented-using-different-branches-with-their-own-interfaces-and-classes--abap-programs-can-both-respond-to-requests-from-the-internet-and-provide-a-service-with-data-for-further-handling-and-itself-query-data-from-internet--this-is-done-by-implementing-the-appropriate-interfaces---notes------before-each-response-is-sent-in-an-as-abap-as-icf-server-or-icf-client--a--database-commit--javascript-call-link---abendatabase-commit-glosry-htm-----glossary-entry---is-executed--except-in--updates--javascript-call-link---abenupdate-glosry-htm-----glossary-entry----------requests-sent-from-icm-to-an-as-abap-open-a-separate--icf--javascript-call-link---abenicf-session-glosry-htm-----glossary-entry---session-here--where-as-abap-can-process-the-request-as-an-icf-server-------http-https-communication-is-not-bidirectional--which-means-that-one-partner-is-always-the-client-and-one-partner-is-always-the-server--bidirectional-communication-is-possible-using-the-websocket-protocol-or-tcp-with--abap-push-channels--javascript-call-link---abenapc-htm-------as-abap-as-an-icf-server--each-service-that-is-reachable-from-the-internet-and-for-which-as-abap-is-used-as-an-icf-server-must-be-created-as-a-node-in-the-service-tree-in-the-service-editor--transaction-sicf---a-service-of-this-type-is-a-transportable-repository-object-that-determines-the-properties-of-the-service---the-initial-node-of-the-service-tree-stands-for-the-as-abap-web-address-consisting-of-the-host-and-the-port--the-position-of-the-node-in-the-tree-determines-the-further-url-path-required-to-call-a-specific-service--a-url-can-contain-form-fields-after-the-actual-address-part--which-are-read-by-icf---before-a-response-can-be-made-to-a-http-request-sent-to-a-service-in-the-service-tree-in-transaction-sicf--at-least-one-global-class-must-be-assigned-to-this-service--this-class-must-implement-the-interface-if--http--extension-and-have-access-to-the-icf-infrastructure--when-a-request-is-sent-to-the-service--icf-creates-a-http-request-handler-as-an-instance-of-this-class--the-implemented-interface-has-only-one-method--handle--request--whose-input-parameter-server-is-a-reference-to-the-server-object-represented-by-if--http--server--the-attributes-and-methods-of-the-server-object-make-it-possible-to-query-properties-of-the-request--such-as-the-content-of-the-form-fields-in-the-url-and-to-pass-data-to-the-server-in-a-suitable-format--such-as-html-or-xml--the-most-important-are-the-attributes-request-and-response--which-refer-to-objects-that-implement-the-interfaces-if--http--request-or-if--http--response---an-http-https-request-in-an-http-request-handler-is-handled-as--icf-processing--javascript-call-link---abenicf-processing-glosry-htm-----glossary-entry---in-a-separate--icf-session--javascript-call-link---abenicf-session-glosry-htm-----glossary-entry----here--certain-statements--like--message--javascript-call-link---abapmessage-htm-----or--break-point--javascript-call-link---abapbreak-point-htm------are-handled-differently-than--for-example--in-dialog-processing--external-breakpoints-can-be-set-to-debug-programs-during-icf-processing---notes------special-url-form-fields--such-as-sap-user--sap-client--or-sap-language--all-start-with-the-prefix-sap--and-are-evaluated-accordingly-when-logons-are-made-to-an-icf-session-------a-special-handler-class-can-be-used-to-access-objects-from-the-mime-repository-directly-using-icf-services--see-the--executable-example--javascript-call-link---abenicf-mime-pictures-abexa-htm------------alongside-the-nodes-that-represent-http-services--the-nodes-for--abap-push-channels--javascript-call-link---abenapc-htm-----addressed-using-the-websocket-protocol-or-tcp-are-defined-in-the-service-tree-in-icf---executable-examples-------calling-an-http-service--javascript-call-link---abenicf-service-abexa-htm----------one-production-example-of-a-self-programmed-http-service-is-the-web-version-of-this-documentation-itself--as-abap-as-an-icf-client--if-the-proxy-setting-for-the-http-client-is-configured-appropriately-in-transaction-sicf--abap-programs-can-send-requests-to-the-internet-using-icf-and-receive-responses--this-is-done-using-client-objects-from-the-class-cl--http--client--which-implements-the-interface-if--http--client--a-client-object-can-be-created-using-a-factory-method-from-this-class--which-associates-it-with-a-web-address--like-a-server-object--the-attributes-request-and-response-reference-objects-that-implement-the-interfaces-if--http--request-or-if--http--response-and-that-can-be-used-to-send-requests-and-receive-responses---executable-example--abap-as--http-client--javascript-call-link---abenicf-client-abexa-htm------icf-security--the-api-of-icf-enables-virus-scans-to-be-run-using-the-virus-scan-interface--vsi---the-required-virus-scan-profile-for-the-scan-can-be-selected---if-html-pages-can-be-created-on-an-icf-server--it-may-be-possible-to-prevent--cross-side-scripting--javascript-call-link---abenxss-scrty-htm------this-is-usually-a-task-of-frameworks-based-on-icf-but-it-is-also-important-not-to-forget-this-for-directly-created-html-pages---other-security-gaps-also-need-to-be-blocked--for-example--pages-delivered-from-an-icf-server-should-be-protected-against-clickjacking-attacks--a-clickjacking-attack-integrates-a-page-into-the-framework-of-an-external-web-page-and-tricks-the-reader-into-clicking-on-malicious-links--this-can-be-prevented-in-the-http-request-handler-by-using-a-method-call--server--response--set--header--field--name----x-frame-options--value---------------provided-that-the-values--sameorigin--or--deny--can-be-passed-to-value--server-is-a-reference-variable--which-points-to-the-server-object----more-information------detailed-information-about-icf-and-icm-can-be-found-in-the-internet-communication-framework-documentation-in-sap-help-portal-------this-documentation-also-describes-communication-between-as-abap-and-the-internet--based-on-class-wrappers-or-icf-enhancements-such-as-abap-web-services-or-the-abap-rest-library---continue--icf-examples--javascript-call-link---abenicf-abexas-htm-----------abenicf-abexas-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------data-interfaces-and-communication-interfaces--javascript-call-link---abenabap-data-communication-htm---------icf---internet-communication-framework--javascript-call-link---abenicf-htm---------icf-examples--continue---example--exa-gif--example----calling-an-http-service--javascript-call-link---abenicf-service-abexa-htm-------example--exa-gif--example----calling-an-http-service-using-the-post-method--javascript-call-link---abenicf-post-service-abexa-htm-------example--exa-gif--example----abap-as-http-client--javascript-call-link---abenicf-client-abexa-htm-------example--exa-gif--example----accessing-the-mime-repository-using-icf--javascript-call-link---abenicf-mime-pictures-abexa-htm-------example--exa-gif--example----accessing-the-mime-repository-from-a-http-service--javascript-call-link---abenhttp-mime-pictures-abexa-htm-----------abenicf-service-abexa-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------data-interfaces-and-communication-interfaces--javascript-call-link---abenabap-data-communication-htm---------icf---internet-communication-framework--javascript-call-link---abenicf-htm---------icf-examples--javascript-call-link---abenicf-abexas-htm---------calling-an-http-service--this-example-demonstrates-how-an--icf--javascript-call-link---abenicf-glosry-htm-----glossary-entry---http-service-is-called-directly-using-a-web-browser---source-code--report-demo--http--service--class-demo-definition----public-section------class-methods-main------class-methods-class--constructor----private-section------class-data-icf--node-type-string--endclass--class-demo-implementation----method-main------if-icf--node-is-initial--------return------endif------data-carrid-type-spfli-carrid-value--aa-------cl--demo--input--request--changing-field---carrid--------data-url----icf--node-----------------------sap-client-------sy-mandt-----------------------sap-language-------------------------cl--i18n--languages--sap1--to--sap2--sy-langu-------------------------carrid-----------carrid------cl--demo--output--display--html----------html--------------body-------------link-to-http-service--br--br--------------a-href----url----target----blank----url----a---------------body---------------html-------endmethod----method-class--constructor------constants-path-type-string-value----sap-bc-abap-demo--------data-location----------cl--http--server--get--location--application---path--------if-location-is-not-initial--------icf--node---location----path------endif----endmethod--endclass--start-of-selection----demo--main------description--any-http-service-defined-in-the-service-transaction-sicf-can-be-tested-here--if-the-url-of-the-service-is-known--it-can-be-called-from-the-internet--for-example-by-entering-an-address-in-a-browser--in-this-example--a-service-of-this-type-is-called-using-a-generated-webpage--which-contains-a-link-to-the-url-of-the-service--the-url-is-constructed-from-the-host-and-port-of-the-current-as-instance--the-path-in-the-service-tree--and-a-form-field--the-host-and-port-are-filled-using-the-method-cl--http--server--get--location--the-form-field-carrid-is-filled-with-the-content-of-a-field-filled-previously-by-user-input--when-this-link-is-chosen--the-browser-displays-the-html-page-returned-by-the-service--the-content-of-the-form-field-carrid-can-be-modified-in-the-input-field-of-the-browser--to-display-different-data---the-called-http-service-is-defined-as-the-node--sap-bc-abap-demo-in-the-transaction-sicf--the-assigned-http-request-handler-is-the-class-cl--http--ext--service--demo--if-a-form-field------carrid------is-added-to-the-url-of-the-service--the-content-of-this-field-is-used-as-a-key-for-selecting-associated-data-from-the-database-table-spfli--this-is-achieved-by-the-class-cl--http--ext--service--demo-implementing-the-interface-if--http--extension-and-its-method-handle--request--this-method-is-called-by-icf-and-a-reference-is-passed-to-a-server-object-that-implements-the-interface-if--http--server--the-attributes-request-and-response-of-this-interface-refer-to-objects--which-are-implemented-by-the-interfaces-if--http--request-or-if--http--response--the-request-object-is-used-to-read-the-form-field--the-response-object-returns-the-result---method-if--http--extension-handle--request----select-------------from-spfli----------where-carrid---( to\_upper(
           cl\_abap\_dyn\_prg=>escape\_quotes(
             val = escape( val = server->request->get\_form\_field(
                                                    name = \`carrid\` )
                           format = cl\_abap\_format=>e\_xss\_ml ) ) ) )
         INTO TABLE @DATA(connections) ##no\_text.
  "cl\_demo\_output=>get converts ABAP data to HTML and is secure
  server->response->set\_cdata(
    data = cl\_demo\_output=>get( connections ) ).
ENDMETHOD.

The built-in function [escape](javascript:call_link\('abenescape_functions.htm'\)) and the method ESCAPE\_QUOTES of the class CL\_ABAP\_DYN\_PRG are using to prevent [cross site scripting](javascript:call_link\('abenxss_glosry.htm'\) "Glossary Entry") and [SQL injections](javascript:call_link\('abensql_injection_glosry.htm'\) "Glossary Entry"). The content of the internal table connections (filled in accordance with the passed form field) is converted to HTML using the class CL\_DEMO\_OUTPUT before it is passed to the RESPONSE object.

Note

The HTTP service must be activated in transaction SICF before the example can work.



**📖 Source**: [abenicf.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenicf.htm)

### abenicf_post_service_abexa.htm

> **📖 Official SAP Documentation**: [abenicf_post_service_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenicf_post_service_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ICF - Internet Communication Framework](javascript:call_link\('abenicf.htm'\)) →  [ICF Examples](javascript:call_link\('abenicf_abexas.htm'\)) → 

Calling an HTTP Service Using the POST Method

This example demonstrates calls of an HTTP service in [ICF](javascript:call_link\('abenicf_glosry.htm'\) "Glossary Entry") and a Web browser. The input data is passed using the POST method.

Source Code

REPORT demo\_http\_post\_service.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS class\_constructor.
  PRIVATE SECTION.
    CLASS-DATA icf\_node TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF icf\_node IS INITIAL.
      RETURN.
    ENDIF.
    DATA(url) = icf\_node &&
                \`?sap-client=\` && sy-mandt &&
                \`&sap-language=\`
                  && cl\_i18n\_languages=>sap1\_to\_sap2( sy-langu ).
    cl\_demo\_output=>display\_html(
      |<html>| &&
      |<body>| &&
      |Link to HTTP-Service:<br><br>| &&
      |<a href="{ url }" target="\_blank">{ url }</a>| &&
      |</body>| &&
      |</html>| ).  ENDMETHOD.
  METHOD class\_constructor.
    CONSTANTS path TYPE string VALUE \`/sap/bc/abap/demo\_post\`.
    DATA(location) =
      cl\_http\_server=>get\_location( application = path ).
    IF location IS NOT INITIAL.
      icf\_node = location && path.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example has the same structure as the executable example [Calling an HTTP Service](javascript:call_link\('abenicf_service_abexa.htm'\)). In this case, the method IF\_HTTP\_EXTENSION~HANDLE\_REQUEST of the class CL\_HTTP\_EXT\_SERVICE\_POST\_DEMO is used to demonstrate how user input sent by a HTML page form generated by the handler class is sent using the POST method and read using the method GET\_CDATA.

Note

The HTTP service must be activated in transaction SICF before the example can work.



**📖 Source**: [abenicf_post_service_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenicf_post_service_abexa.htm)

### abenicf_client_abexa.htm

> **📖 Official SAP Documentation**: [abenicf_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenicf_client_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ICF - Internet Communication Framework](javascript:call_link\('abenicf.htm'\)) →  [ICF Examples](javascript:call_link\('abenicf_abexas.htm'\)) → 

ABAP as HTTP Client

This example demonstrates an [ICF](javascript:call_link\('abenicf_glosry.htm'\) "Glossary Entry") client object.

Source Code

REPORT demo\_http\_client.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA query TYPE string VALUE 'SAP'.
    cl\_demo\_input=>request( CHANGING field = query ).
    cl\_http\_client=>create(
      EXPORTING
        host =    'wikipedia.org'
        service = ''
      IMPORTING
        client = DATA(client)
      EXCEPTIONS
        OTHERS = 4 ).
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    cl\_http\_utility=>set\_request\_uri(
      request = client->request
      uri     = \`/wiki/\` && query ).
    client->send(
      EXCEPTIONS
        OTHERS = 4 ).
    IF sy-subrc <> 0.
      client->get\_last\_error(
        IMPORTING message = DATA(smsg) ).
      cl\_demo\_output=>display( smsg ).
      RETURN.
    ENDIF.
    client->receive(
      EXCEPTIONS
        OTHERS = 4 ).
    IF sy-subrc <> 0.
      client->get\_last\_error(
        IMPORTING message = DATA(rmsg) ).
      cl\_demo\_output=>display( rmsg ).
      RETURN.
    ENDIF.
    DATA(html) = client->response->get\_cdata( ).
    cl\_demo\_output=>display\_html( html ).
    client->close( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The factory method CREATE of the class CL\_HTTP\_CLIENT is used to create a client object for the address wikipedia.org. The reference variable client of the type IF\_HTTP\_CLIENT points to this object. A specific request, which also contains the value of a user input, is added to the URI of the REQUEST object of the client object. The request is sent and the result is passed to the RESPONSE object of the client object. In the case in question, the HTML page produced by the requested is retrieved and displayed.

Note

The proxy setting for the HTTP client must be configured correctly in transaction SICF before this example can work.



**📖 Source**: [abenicf_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenicf_client_abexa.htm)

### abenicf_mime_pictures_abexa.htm

> **📖 Official SAP Documentation**: [abenicf_mime_pictures_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenicf_mime_pictures_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ICF - Internet Communication Framework](javascript:call_link\('abenicf.htm'\)) →  [ICF Examples](javascript:call_link\('abenicf_abexas.htm'\)) → 

Accessing the MIME Repository Using ICF

This example demonstrates how the MIME repository is accessed using a HTTP service in [ICF](javascript:call_link\('abenicf_glosry.htm'\) "Glossary Entry").

Source Code

REPORT demo\_picture\_from\_mime.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS class\_constructor.
  PRIVATE SECTION.
    CLASS-DATA icf\_node TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF icf\_node IS INITIAL.
      RETURN.
    ENDIF.
    cl\_demo\_output=>display\_html(
      \`<html><body><basefont face="arial">\`                &&
      \`Picture from MIME Repository<br><br>\`               &&
       \`<img src="\` && icf\_node
                    && \`/ABAP\_Docu\_Logo.gif?sap-client=\`
                    && sy-mandt
                    && \`">\`                                &&
       \`</body></html>\`  ).  ENDMETHOD.
  METHOD class\_constructor.
    CONSTANTS path TYPE string VALUE \`/sap/public/bc/abap/mime\_demo\`.
    DATA(location) =
      cl\_http\_server=>get\_location( application = path ).
    IF location IS NOT INITIAL.
      icf\_node = location && path.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

If a path to a HTTP service from ICF is constructed in the same way in transaction SICF as the path to a MIME repository node and the handler class CL\_HTTP\_EXT\_WEBDAV\_PUBLIC is assigned to the service, the service can be used to access the MIME objects of this node directly.

The example contains the node /sap/public/bc/abap/mime\_demo in both the transaction SICF and in the MIME repository. The image ABAP\_Docu\_Logo.gif is saved in the MIME repository under this node. The handler class CL\_HTTP\_EXT\_WEBDAV\_PUBLIC is assigned to the ICF node. The name of the image can be added to the URL of the service and used to access the image directly.

See also the [executable example](javascript:call_link\('abenmime_pictures_abexa.htm'\)) for accessing objects from the MIME repository using the associated API.



**📖 Source**: [abenicf_mime_pictures_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenicf_mime_pictures_abexa.htm)

### abenhttp_mime_pictures_abexa.htm

> **📖 Official SAP Documentation**: [abenhttp_mime_pictures_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenhttp_mime_pictures_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ICF - Internet Communication Framework](javascript:call_link\('abenicf.htm'\)) →  [ICF Examples](javascript:call_link\('abenicf_abexas.htm'\)) → 

Accessing the MIME Repository from a HTTP Service

This example demonstrates how the MIME repository is accessed using an HTTP service in [ICF](javascript:call_link\('abenicf_glosry.htm'\) "Glossary Entry").

Source Code

REPORT demo\_http\_mime.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS class\_constructor.
  PRIVATE SECTION.
    CLASS-DATA icf\_node TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF icf\_node IS INITIAL.
      RETURN.
    ENDIF.
    DATA(url) = icf\_node
                  && \`?sap-client=\`
                  && sy-mandt
                  && \`&sap-language=\`
                  && cl\_i18n\_languages=>sap1\_to\_sap2( sy-langu ).
    DATA(url\_icf) = url && \`&mime\_access=icf\`.
    DATA(url\_api) = url && \`&mime\_access=api\`.
    cl\_demo\_output=>display\_html(
     |<html>| &&
     |<body>| &&
     |Link to HTTP-Service getting picture from ICF:<br><br>| &&
     |<a href="{ url\_icf }" target="\_blank">{ url\_icf }</a><br><br>| &&
     |Link to HTTP-Service getting picture from API:<br><br>| &&
     |<a href="{ url\_api }" target="\_blank">{ url\_api }</a><br><br>| &&
     |</body>| &&
     |</html>| ).  ENDMETHOD.
  METHOD class\_constructor.
    CONSTANTS path TYPE string VALUE \`/sap/bc/abap/demo\_mime\`.
    DATA(location) =
      cl\_http\_server=>get\_location( application = path ).
    IF location IS NOT INITIAL.
      icf\_node = location && path.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The HTTP service /sap/bc/abap/demo\_mime can be called with different contents of the form field mime\_access of the URL:

-   If the form field has the value icf, the handler class CL\_HTTP\_EXT\_MIME\_DEMO creates an HTML file. This file points to an image in the MIME repository (as described in a different executable [example](javascript:call_link\('abenicf_mime_pictures_abexa.htm'\))).

-   If the form field has the value api, the handler class CL\_HTTP\_EXT\_MIME\_DEMO creates the HTML file and also the image that is referenced in the HTML file. The image is loaded and forwarded using MIME-API.



**📖 Source**: [abenhttp_mime_pictures_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenhttp_mime_pictures_abexa.htm)

### abenicf_abexas.htm

> **📖 Official SAP Documentation**: [abenicf_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenicf_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ICF - Internet Communication Framework](javascript:call_link\('abenicf.htm'\)) → 

ICF Examples

Continue
![Example](exa.gif "Example") [Calling an HTTP Service](javascript:call_link\('abenicf_service_abexa.htm'\))
![Example](exa.gif "Example") [Calling an HTTP Service Using the POST Method](javascript:call_link\('abenicf_post_service_abexa.htm'\))
![Example](exa.gif "Example") [ABAP as HTTP Client](javascript:call_link\('abenicf_client_abexa.htm'\))
![Example](exa.gif "Example") [Accessing the MIME Repository Using ICF](javascript:call_link\('abenicf_mime_pictures_abexa.htm'\))
![Example](exa.gif "Example") [Accessing the MIME Repository from a HTTP Service](javascript:call_link\('abenhttp_mime_pictures_abexa.htm'\))


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP Channels / AMC - ABAP Messaging Channels

**Files**: 7 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP Channels / APC - ABAP Push Channels / Examples of APC

Included pages: 7



**📖 Source**: [abenicf_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenicf_abexas.htm)

### abenapc_abexas.htm

> **📖 Official SAP Documentation**: [abenapc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) → 

Examples of APC

Continue
![Example](exa.gif "Example") [APC, AS ABAP as WebSocket Server](javascript:call_link\('abenapc_abexa.htm'\))
![Example](exa.gif "Example") [APC, AS ABAP as WebSocket Client](javascript:call_link\('abenapc_ws_client_abexa.htm'\))
![Example](exa.gif "Example") [APC, AS ABAP as TCP Socket Client](javascript:call_link\('abenapc_tcp_client_abexa.htm'\))
![Example](exa.gif "Example") [APC, Creating a Detached Client](javascript:call_link\('abenapc_detached_client_abexa.htm'\))
![Example](exa.gif "Example") [APC, AS ABAP as Attached Client](javascript:call_link\('abenapc_attached_client_abexa.htm'\))
![Example](exa.gif "Example") [APC, System-Wide Access](javascript:call_link\('abenapc_connect_via_handle_abexa.htm'\))



**📖 Source**: [abenapc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_abexas.htm)

### abenapc_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, AS ABAP as WebSocket Server

This example demonstrates [ABAP push channel](javascript:call_link\('abenapc_glosry.htm'\) "Glossary Entry")s in AS ABAP as a WebSocket server.

Source Code

REPORT demo\_apc\_wsp.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS class\_constructor.
  PRIVATE SECTION.
    CLASS-DATA url TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF url IS INITIAL.
      RETURN.
    ENDIF.
    DATA amc TYPE abap\_bool VALUE 'X'.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    cl\_demo\_input=>add\_line( ).
    DATA pcp TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = pcp ).
    DATA pcp\_stateful TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = pcp\_stateful ).
    cl\_demo\_input=>request( ).
    amc = to\_upper( amc ).
    cl\_demo\_output=>display\_html(
      |<html>| &&
      |<body>| &&
      |<a href="{ COND string( WHEN pcp IS INITIAL AND
                                    pcp\_stateful IS INITIAL THEN url
                               ELSE url && \`\_pcp\` )
        }?sap-client={ sy-mandt
        }&sap-language={ cl\_i18n\_languages=>sap1\_to\_sap2( sy-langu )
        }{ COND string( WHEN amc = abap\_true
             THEN \`&amc=x\`
             ELSE \`\` )
        }{ COND string( WHEN pcp\_stateful = abap\_true
             THEN \`&pcp\_stateful=x\`
             ELSE \`\` )
        }" target="\_blank">| &&
        |Open demo web page with standard browser</a><br><br>| &&
      |If your browser does not support WebSocket, | &&
      |copy the URL to another browser.| &&
      |</body>| &&
      |</html>| ).  ENDMETHOD.
  METHOD class\_constructor.
    CONSTANTS path TYPE string VALUE \`/sap/bc/abap/demo\_apc\`.
    DATA(location) =
      cl\_http\_server=>get\_location( application = path ).
    IF location IS NOT INITIAL.
      url = location && path.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example demonstrates bidirectional communication between a browser that supports the WebSocket protocol as an APC client and AS ABAP as an APC server. The example program above has the task of displaying a webpage that communicates with the current AS ABAP. It is possible to specify the following:

-   Is the APC used associated with an [ABAP messaging channel (AMC)](javascript:call_link\('abenamc.htm'\))?

-   Is an APC used together with the [Push Channel Protocol (PCP)](javascript:call_link\('abenpush_channel_protocol_glosry.htm'\) "Glossary Entry") or is an APC used without this protocol?

-   Is a stateful service used when the subprotocol PCP is used?

The Web page is provided by an [ICF](javascript:call_link\('abenicf.htm'\)) HTTP service whose URL is constructed in the program for the current AS Instance. If the standard browser called does not support communication using the WebSocket protocol, you must open the URL using a suitable browser instead.

The communication partners are:

-   The Web pages generated in the HTTP request handler CL\_HTTP\_EXT\_APC\_DEMO or CL\_HTTP\_EXT\_APC\_PCP\_DEMO. One Web page makes it possible to open a WebSocket object without Push Channel Protocol (PCP) support and the other Web page makes it possible to open a WebSocket object with the support of this protocol. Both Web pages make it possible to send messages using the object and to close the object. These tasks are performed by a JavaScript function implemented in the Web page. If PCP is used, a JavaScript file sap-pcp-websocket.js is included from the Mime repository in AS ABAP. This file provides the client-side framework for using this protocol. This API is not needed if PCP is not used. If the PCP protocol is used, it is possible to access both a stateless ABAP channel and a stateful channel.

-   The ABAP push channel DEMO\_APC, DEMO\_APC\_PCP, or DEMO\_APC\_PCP\_STATEFUL from the package SABAPDEMOS in the current AS ABAP (with the latter two supporting the Push Channel Protocol (PCP) and the latter being stateful). The URL of the service assigned to the push channel is used in the JavaScript function of the associated Web page to open the WebSocket communication of this Web page. The form field amc is passed further. The APC handler classes CL\_APC\_WS\_EXT\_DEMO\_APC and CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP implement the methods ON\_START and ON\_MESSAGE of the interface IF\_APC\_WSP\_EXTENSION for communication with and without a connection to an [AMC](javascript:call_link\('abenamc.htm'\)). The APC handler class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP\_ST demonstrates a stateful service by simply calling the identically named methods of an object of the class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP. The AMC used here is /demo\_text or /demo\_pcp from the [executable examples](javascript:call_link\('abenamc_abexas.htm'\)) for AMC. When a message is received, the method ON\_MESSAGE creates a new message with information about the received message and sends it. If PCP is not used, a text message is sent. In the version for PCP, this protocol is used. CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP demonstrates the stateful service by raising a counter whose value stays the same in stateless services.

If the ABAP push channel is opened using the form field amc=x, communication takes place using AMC. Each Web page bound to the push channel receives every message sent using AMC. In the example, this means that the message sent by ON\_MESSAGE is not just received by the Web page that sent a message. Furthermore, the Web pages bound to the push channel receive messages sent, for example, using the program DEMO\_SEND\_AMC from the executable example [Sending AMC Messages](javascript:call_link\('abenamc_send_abexa.htm'\)). Conversely, the program DEMO\_RECEIVE\_AMC receives the messages sent from the Web pages from the executable example [Receiving AMC Messages](javascript:call_link\('abenamc_receive_abexa.htm'\)).

Note

Before this example can work, the protocols WEBSOCKET and WEBSOCKETS must be specified as active services in the Services function in the transaction SMICM.



**📖 Source**: [abenapc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_abexa.htm)

### abenapc_ws_client_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_ws_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_ws_client_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, AS ABAP as WebSocket Client

This example demonstrates AS ABAP as a WebSocket client.

Source Code

REPORT demo\_apc\_client.
CLASS apc\_handler DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler\_pcp.
    DATA       message TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_open.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_message.
    TRY.
        me->message = i\_message->get\_text( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        me->message = apc\_error->get\_text( ).
      CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
        cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_close.
    me->message = 'Connection closed!'.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_error.
    cl\_demo\_output=>display( 'Error!' ).
    LEAVE PROGRAM.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA stateful\_server TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = stateful\_server ).
    DATA messages TYPE i VALUE '5'.
    cl\_demo\_input=>add\_field(  CHANGING field  = messages ).
    DATA wait TYPE i VALUE '10'.
    cl\_demo\_input=>add\_field(  CHANGING field  = wait ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Client
        DATA(client) =
          cl\_apc\_wsp\_client\_manager=>create\_by\_destination(
            i\_destination = 'NONE'
            i\_event\_handler = event\_handler
            i\_protocol =
              if\_apc\_wsp\_event\_handler\_pcp=>co\_event\_handler\_type ).
        "Server
        DATA(request) =
          client->get\_context( )->get\_initial\_request( ).
        request->set\_path\_and\_query(
          i\_relative\_uri =
            \`/sap/bc/apc/sap/demo\_apc\_pcp\` &&
            COND #(
               WHEN stateful\_server = abap\_true THEN \`\_stateful\` ) &&
            COND #(
              WHEN amc = abap\_true THEN \`?amc=x\` ) ).
        client->connect( ).
        "Sending messages
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager\_pcp(
            client->get\_message\_manager( ) ).
        DATA(message) =
          CAST if\_ac\_message\_type\_pcp(
            message\_manager->create\_message( ) ).
        TRY.
            IF amc = abap\_true.
              message->set\_field( i\_name = 'amc' i\_value = 'x' ).
            ENDIF.
            message->set\_text( msg ).
          CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
            cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
            LEAVE PROGRAM.
        ENDTRY.
        DO messages TIMES.
          message\_manager->send( message ).
        ENDDO.
        "Receiving messages
        DO wait TIMES.
          out->line( ).
          CLEAR event\_handler->message.
          WAIT FOR PUSH CHANNELS
               UNTIL event\_handler->message IS NOT INITIAL
               UP TO 1 SECONDS.
          IF sy-subrc = 4.
            out->write\_text(
              'No handler for APC messages registered' ).
          ELSEIF sy-subrc = 8.
            out->write\_text(
              'Timeout occurred!' ).
          ELSE.
            out->write\_text(
             |Received APC message: \\n\\n{
               event\_handler->message } | ).
          ENDIF.
        ENDDO.
        out->line( ).
        "Close connection
        client->close( i\_reason = 'Application closed connection!' ).
        out->display( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create an [APC client](javascript:call_link\('abenapc.htm'\)) for the WebSocket protocol.

-   The local class apc\_handler, which implements the interface IF\_APC\_WSP\_EVENT\_HANDLER\_PCP, is used as the handler class. When a message is received, the method on\_message sets its message attribute to the message text.

-   The message manager of the client object is used to create a message in [PCP format](javascript:call_link\('abenpcp.htm'\)) and send it multiple times.

-   The statement [WAIT FOR PUSH CHANNELS](javascript:call_link\('abapwait_apc.htm'\)) is then used to switch the program to a wait state so that messages sent back from the server can be handled. Here, the logical expression checks the attribute message of the handler class apc\_handler. A received text is displayed.

-   Finally, the connection is closed explicitly.

It is possible to select how many messages are sent and how often the wait state occurs.

-   If communication takes place with the stateful server, the counter level of the server is raised, indicating that multiple messages are being sent and received.

-   If the server sends its messages using ABAP messaging channels, other AMC receivers in the same messaging channel can also see the messages of the server. For example, the Web browser from the executable example [AS ABAP as WebSocket Server](javascript:call_link\('abenapc_abexa.htm'\)) can receive these messages. In the reverse direction, the APC client can then also receive those messages sent by the APC server as a response to messages from the Web browser, if they occur in one of the programmed wait periods.



**📖 Source**: [abenapc_ws_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_ws_client_abexa.htm)

### abenapc_tcp_client_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_tcp_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_tcp_client_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, AS ABAP as TCP Socket Client

This example demonstrates AS ABAP as a TCP socket client.

Source Code

REPORT demo\_apc\_tcp\_client.
CLASS apc\_handler DEFINITION FINAL .
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler.
    DATA       message TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler~on\_open.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_message.
    TRY.
        message = i\_message->get\_text( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        message = apc\_error->get\_text( ).
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_close.
    message = 'Connection closed!'.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_error.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(tcp\_server) = \`C:\\ncat\\ncat.exe\`.
    DATA(ip\_adress)  = cl\_gui\_frontend\_services=>get\_ip\_address( ).
    DATA(port)       = \`12345\`.
    DATA(terminator) = \`0A\`.
    DATA(msg)        = \`Hello TCP, answer me!\`.
    cl\_demo\_input=>new(
      )->add\_text(
         |For the TCP server, download the freely available NCAT.EXE|
      )->add\_field( CHANGING field = tcp\_server
      )->add\_field( CHANGING field = ip\_adress
      )->add\_field( CHANGING field = port
      )->add\_field( CHANGING field = terminator
      )->add\_field( CHANGING field = msg
      )->request( ).
    "Server
    IF cl\_gui\_frontend\_services=>file\_exist(
         file = tcp\_server ) IS INITIAL.
      cl\_demo\_output=>display( 'TCP Server not found!' ).
      LEAVE PROGRAM.
    ENDIF.
    cl\_gui\_frontend\_services=>execute(
    EXPORTING
      application = \`cmd.exe\`
      parameter  =  \`/c \` && tcp\_server &&
                   \` -l \` && ip\_adress && \` -p \` && port ).
    WAIT UP TO 1 SECONDS.
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Client
        DATA(client) = cl\_apc\_tcp\_client\_manager=>create(
          i\_host   = ip\_adress
          i\_port  = port
          i\_frame = VALUE apc\_tcp\_frame(
            frame\_type =
              if\_apc\_tcp\_frame\_types=>co\_frame\_type\_terminator
            terminator =
              terminator )
          i\_event\_handler = event\_handler ).
        client->connect( ).
        "Send mesasage from client
        DATA(message\_manager) = CAST if\_apc\_wsp\_message\_manager(
          client->get\_message\_manager( ) ).
        DATA(message) = CAST if\_apc\_wsp\_message(
          message\_manager->create\_message( ) ).
        DATA(binary\_terminator) = CONV xstring( terminator ).
        DATA(binary\_msg) =
          cl\_abap\_conv\_codepage=>create\_out( )->convert( msg ).
        CONCATENATE binary\_msg binary\_terminator
               INTO binary\_msg IN BYTE MODE.
        message->set\_binary( binary\_msg ).
        message\_manager->send( message ).
        "Wait for a message from server
        CLEAR event\_handler->message.
        WAIT FOR PUSH CHANNELS
             UNTIL event\_handler->message IS NOT INITIAL
             UP TO 10 SECONDS.
        IF sy-subrc = 4.
          cl\_demo\_output=>display(
            'No handler for APC messages registered!' ).
        ELSEIF sy-subrc = 8.
          cl\_demo\_output=>display(
            'Timeout occurred!' ).
        ELSE.
          cl\_demo\_output=>display(
            |TCP client received:\\n\\n{ event\_handler->message }| ).
        ENDIF.
        client->close(
          i\_reason = 'Application closed connection!' ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create an [APC client](javascript:call_link\('abenapc.htm'\)) for the TCP socket protocol. It is structured in exactly the same way as in the [executable example](javascript:call_link\('abenapc_ws_client_abexa.htm'\)) for the WebSocket client, but with the connection being made to a TCP socket server. The current front-end computer is used as the TCP socket server here and the available [Ncat](https://nmap.org/ncat/) can be downloaded to this computer.

This program requires the Ncat.exe directory and the address of the current front-end computer (proposals are made for this information). In addition, a terminator character is needed for the TCP framework structure.

When the program is executed, Ncat.exe is started and waits for messages from the APC client. Once a message is sent, this client waits for a message entered in the Ncat window and confirmed using Enter.



**📖 Source**: [abenapc_tcp_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_tcp_client_abexa.htm)

### abenapc_detached_client_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_detached_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_detached_client_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, Creating a Detached Client

This example demonstrates how a detached client is created for the WebSocket protocol.

Source Code

REPORT demo\_apc\_detached\_client.
CLASS apc\_handler DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler\_pcp.
    DATA: connection\_attach\_handle TYPE string,
          message                  TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_open.
    TRY.
        connection\_attach\_handle =
          i\_context->get\_connection\_attach\_handle(
            EXPORTING i\_connection\_security =
              i\_context->co\_con\_security\_by\_user\_id ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        me->message = apc\_error->get\_text( ).
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_message.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_close.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_error.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA stateful\_server TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = stateful\_server ).
    DATA show\_attach\_handle TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = show\_attach\_handle ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Detached client
        DATA(client\_detach) =
          cl\_apc\_wsp\_client\_conn\_manager=>create\_by\_destination(
            i\_destination = 'NONE'
            i\_application\_id = \`DEMO\_APC\_PCP\`
            i\_event\_handler = event\_handler
            i\_protocol =
              if\_apc\_wsp\_event\_handler\_pcp=>co\_event\_handler\_type ).
        "Server
        DATA(request) =
          client\_detach->get\_context( )->get\_initial\_request( ).
        request->set\_path\_and\_query(
          i\_relative\_uri =
            \`/sap/bc/apc/sap/demo\_apc\_pcp\` &&
            COND #(
               WHEN stateful\_server = abap\_true THEN \`\_stateful\` ) &&
            COND #( WHEN amc = abap\_true THEN \`?amc=x\` ) ).
        client\_detach->connect\_and\_detach( ).
        IF event\_handler->message IS NOT INITIAL.
          out->display(
            |Error during ON\_OPEN: { event\_handler->message }| ).
          LEAVE PROGRAM.
        ENDIF.
        IF show\_attach\_handle IS INITIAL.
          "Attached client
          DATA(client\_attach) =
            cl\_apc\_wsp\_client\_conn\_manager=>attach(
              event\_handler->connection\_attach\_handle ).
          DATA(message\_manager) =
            CAST if\_apc\_wsp\_message\_manager\_pcp(
              client\_attach->get\_message\_manager( ) ).
          DATA(message) = CAST if\_ac\_message\_type\_pcp(
            message\_manager->create\_message( ) ).
          TRY.
              IF amc = abap\_true.
                message->set\_field( i\_name = 'amc' i\_value = 'x' ).
              ENDIF.
              message->set\_field(
                i\_name = 'detached\_client' i\_value = 'x' ).
              message->set\_text( msg ).
            CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
              cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
              LEAVE PROGRAM.
          ENDTRY.
          message\_manager->send( message ).
          client\_attach->close(
            i\_reason = 'Application closed connection!' ).
        ELSE.
          out->display(
            |Attach Handle:\\n\\n{
            event\_handler->connection\_attach\_handle
            }\\n\\nUse as input to DEMO\_APC\_ATTACH\_CLIENT.| ).
        ENDIF.
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create a [detached APC client](javascript:call_link\('abenapc.htm'\)) for the WebSocket protocol.

-   The local class apc\_handler, which implements the interface IF\_APC\_WSP\_EVENT\_HANDLER\_PCP, is used as the handler class. The method on\_open gets a connection handle for the connection. The other methods are not needed.

-   The connection handle obtained by the method on\_open of the handler class can either be displayed or used immediately in the program to create an attached client for the detached client.

-   A displayed connection handle can be used in the program of the executable [attached client](javascript:call_link\('abenapc_attached_client_abexa.htm'\)) example.

-   If not, the method ATTACH of the class CL\_APC\_WSP\_CLIENT\_CONN\_MANAGER is used to create an attached client object for the connection handle. Its message manager is then used to create a message in [PCP format](javascript:call_link\('abenpcp.htm'\)) and send it.

A breakpoint in the method ON\_MESSAGE of the APC handler class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP can be used to monitor the arrival and processing of the message (it is not possible to respond to messages from the same class here). If the message is sent using [AMC](javascript:call_link\('abenamc.htm'\)), the response from the server is received by all associated AMC receivers. The attached client cannot itself wait for the response.



**📖 Source**: [abenapc_detached_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_detached_client_abexa.htm)

### abenapc_attached_client_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_attached_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_attached_client_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, AS ABAP as Attached Client

This example demonstrates the AS ABAP as an attached client for a detached client.

Source Code

REPORT demo\_apc\_attach\_client.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA attach\_handle TYPE string VALUE ' '.
    cl\_demo\_input=>add\_field( CHANGING field  = attach\_handle ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA close TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = close ).
    cl\_demo\_input=>request( ).
    TRY.
        "Attached client
        DATA(client\_attach) =
          cl\_apc\_wsp\_client\_conn\_manager=>attach( attach\_handle ).
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager\_pcp(
            client\_attach->get\_message\_manager( ) ).
        DATA(message) = CAST if\_ac\_message\_type\_pcp(
          message\_manager->create\_message( ) ).
        TRY.
            IF amc = abap\_true.
              message->set\_field( i\_name = 'amc' i\_value = 'x' ).
            ENDIF.
            message->set\_field(
              i\_name = 'detached\_client' i\_value = 'x' ).
            message->set\_text( msg ).
          CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
            cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
            LEAVE PROGRAM.
        ENDTRY.
        message\_manager->send( message ).
        IF close  = abap\_true.
          client\_attach->close(
            i\_reason = 'Application closed connection!' ).
        ENDIF.
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

The program expects a connection handle as input, as provided in the output of the executable [detached client](javascript:call_link\('abenapc_detached_client_abexa.htm'\)) example. The connection handle is used to create and employ an attached client object precisely as described in the detached client example. The connection handle can be reused indefinitely until the connection is closed using the method CLOSE. If the connection is not closed by mistake, this can be done later in the transaction SMWS.



**📖 Source**: [abenapc_attached_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_attached_client_abexa.htm)

### abenapc_connect_via_handle_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_connect_via_handle_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_connect_via_handle_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, System-Wide Access

This example demonstrates access to any ABAP channel using a connection handle.

Source Code

REPORT demo\_apc\_access\_connection.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA attach\_handle TYPE string VALUE ' '.
    cl\_demo\_input=>add\_field( CHANGING field  = attach\_handle ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(access\_object) =
          cl\_apc\_wsp\_client\_conn\_manager=>attach( attach\_handle ).
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager(
            access\_object->get\_message\_manager( ) ).
        DATA(message) = CAST if\_apc\_wsp\_message(
          message\_manager->create\_message( ) ).
        message->set\_text( msg ).
        message\_manager->send( message ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

The program expects a valid connection handle for a WebSocket connection as its input, creates an access objects for this handle, and uses it to send a simple text message.

An APC connection from the executable example [AS ABAP as WebSocket Server](javascript:call_link\('abenapc_abexa.htm'\)) publishes its connection handle as follows:

-   Create a WebSocket server without PCP.

-   Open the connection on the Web page.

-   Send the text message "get handle".

This message is identified in the method ON\_MESSAGE of the APC handler class CL\_APC\_WS\_EXT\_DEMO\_APC and the connection handle is fetched and sent. The Web page displays it in a form that can be copied. If the connection handle is passed to the program above while the connection is open, the message sent by the program is received and displayed by the Web page.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP Channels / APC - ABAP Push Channels / Examples of APC

**Files**: 7 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP Channels / APC - ABAP Push Channels / Examples of APC

Included pages: 7



**📖 Source**: [abenapc_connect_via_handle_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_connect_via_handle_abexa.htm)

### abenapc_abexas.htm

> **📖 Official SAP Documentation**: [abenapc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) → 

Examples of APC

Continue
![Example](exa.gif "Example") [APC, AS ABAP as WebSocket Server](javascript:call_link\('abenapc_abexa.htm'\))
![Example](exa.gif "Example") [APC, AS ABAP as WebSocket Client](javascript:call_link\('abenapc_ws_client_abexa.htm'\))
![Example](exa.gif "Example") [APC, AS ABAP as TCP Socket Client](javascript:call_link\('abenapc_tcp_client_abexa.htm'\))
![Example](exa.gif "Example") [APC, Creating a Detached Client](javascript:call_link\('abenapc_detached_client_abexa.htm'\))
![Example](exa.gif "Example") [APC, AS ABAP as Attached Client](javascript:call_link\('abenapc_attached_client_abexa.htm'\))
![Example](exa.gif "Example") [APC, System-Wide Access](javascript:call_link\('abenapc_connect_via_handle_abexa.htm'\))



**📖 Source**: [abenapc_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_abexas.htm)

### abenapc_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, AS ABAP as WebSocket Server

This example demonstrates [ABAP push channel](javascript:call_link\('abenapc_glosry.htm'\) "Glossary Entry")s in AS ABAP as a WebSocket server.

Source Code

REPORT demo\_apc\_wsp.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS class\_constructor.
  PRIVATE SECTION.
    CLASS-DATA url TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF url IS INITIAL.
      RETURN.
    ENDIF.
    DATA amc TYPE abap\_bool VALUE 'X'.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    cl\_demo\_input=>add\_line( ).
    DATA pcp TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = pcp ).
    DATA pcp\_stateful TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = pcp\_stateful ).
    cl\_demo\_input=>request( ).
    amc = to\_upper( amc ).
    cl\_demo\_output=>display\_html(
      |<html>| &&
      |<body>| &&
      |<a href="{ COND string( WHEN pcp IS INITIAL AND
                                    pcp\_stateful IS INITIAL THEN url
                               ELSE url && \`\_pcp\` )
        }?sap-client={ sy-mandt
        }&sap-language={ cl\_i18n\_languages=>sap1\_to\_sap2( sy-langu )
        }{ COND string( WHEN amc = abap\_true
             THEN \`&amc=x\`
             ELSE \`\` )
        }{ COND string( WHEN pcp\_stateful = abap\_true
             THEN \`&pcp\_stateful=x\`
             ELSE \`\` )
        }" target="\_blank">| &&
        |Open demo web page with standard browser</a><br><br>| &&
      |If your browser does not support WebSocket, | &&
      |copy the URL to another browser.| &&
      |</body>| &&
      |</html>| ).  ENDMETHOD.
  METHOD class\_constructor.
    CONSTANTS path TYPE string VALUE \`/sap/bc/abap/demo\_apc\`.
    DATA(location) =
      cl\_http\_server=>get\_location( application = path ).
    IF location IS NOT INITIAL.
      url = location && path.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example demonstrates bidirectional communication between a browser that supports the WebSocket protocol as an APC client and AS ABAP as an APC server. The example program above has the task of displaying a webpage that communicates with the current AS ABAP. It is possible to specify the following:

-   Is the APC used associated with an [ABAP messaging channel (AMC)](javascript:call_link\('abenamc.htm'\))?

-   Is an APC used together with the [Push Channel Protocol (PCP)](javascript:call_link\('abenpush_channel_protocol_glosry.htm'\) "Glossary Entry") or is an APC used without this protocol?

-   Is a stateful service used when the subprotocol PCP is used?

The Web page is provided by an [ICF](javascript:call_link\('abenicf.htm'\)) HTTP service whose URL is constructed in the program for the current AS Instance. If the standard browser called does not support communication using the WebSocket protocol, you must open the URL using a suitable browser instead.

The communication partners are:

-   The Web pages generated in the HTTP request handler CL\_HTTP\_EXT\_APC\_DEMO or CL\_HTTP\_EXT\_APC\_PCP\_DEMO. One Web page makes it possible to open a WebSocket object without Push Channel Protocol (PCP) support and the other Web page makes it possible to open a WebSocket object with the support of this protocol. Both Web pages make it possible to send messages using the object and to close the object. These tasks are performed by a JavaScript function implemented in the Web page. If PCP is used, a JavaScript file sap-pcp-websocket.js is included from the Mime repository in AS ABAP. This file provides the client-side framework for using this protocol. This API is not needed if PCP is not used. If the PCP protocol is used, it is possible to access both a stateless ABAP channel and a stateful channel.

-   The ABAP push channel DEMO\_APC, DEMO\_APC\_PCP, or DEMO\_APC\_PCP\_STATEFUL from the package SABAPDEMOS in the current AS ABAP (with the latter two supporting the Push Channel Protocol (PCP) and the latter being stateful). The URL of the service assigned to the push channel is used in the JavaScript function of the associated Web page to open the WebSocket communication of this Web page. The form field amc is passed further. The APC handler classes CL\_APC\_WS\_EXT\_DEMO\_APC and CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP implement the methods ON\_START and ON\_MESSAGE of the interface IF\_APC\_WSP\_EXTENSION for communication with and without a connection to an [AMC](javascript:call_link\('abenamc.htm'\)). The APC handler class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP\_ST demonstrates a stateful service by simply calling the identically named methods of an object of the class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP. The AMC used here is /demo\_text or /demo\_pcp from the [executable examples](javascript:call_link\('abenamc_abexas.htm'\)) for AMC. When a message is received, the method ON\_MESSAGE creates a new message with information about the received message and sends it. If PCP is not used, a text message is sent. In the version for PCP, this protocol is used. CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP demonstrates the stateful service by raising a counter whose value stays the same in stateless services.

If the ABAP push channel is opened using the form field amc=x, communication takes place using AMC. Each Web page bound to the push channel receives every message sent using AMC. In the example, this means that the message sent by ON\_MESSAGE is not just received by the Web page that sent a message. Furthermore, the Web pages bound to the push channel receive messages sent, for example, using the program DEMO\_SEND\_AMC from the executable example [Sending AMC Messages](javascript:call_link\('abenamc_send_abexa.htm'\)). Conversely, the program DEMO\_RECEIVE\_AMC receives the messages sent from the Web pages from the executable example [Receiving AMC Messages](javascript:call_link\('abenamc_receive_abexa.htm'\)).

Note

Before this example can work, the protocols WEBSOCKET and WEBSOCKETS must be specified as active services in the Services function in the transaction SMICM.



**📖 Source**: [abenapc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_abexa.htm)

### abenapc_ws_client_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_ws_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_ws_client_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, AS ABAP as WebSocket Client

This example demonstrates AS ABAP as a WebSocket client.

Source Code

REPORT demo\_apc\_client.
CLASS apc\_handler DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler\_pcp.
    DATA       message TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_open.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_message.
    TRY.
        me->message = i\_message->get\_text( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        me->message = apc\_error->get\_text( ).
      CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
        cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_close.
    me->message = 'Connection closed!'.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_error.
    cl\_demo\_output=>display( 'Error!' ).
    LEAVE PROGRAM.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA stateful\_server TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = stateful\_server ).
    DATA messages TYPE i VALUE '5'.
    cl\_demo\_input=>add\_field(  CHANGING field  = messages ).
    DATA wait TYPE i VALUE '10'.
    cl\_demo\_input=>add\_field(  CHANGING field  = wait ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Client
        DATA(client) =
          cl\_apc\_wsp\_client\_manager=>create\_by\_destination(
            i\_destination = 'NONE'
            i\_event\_handler = event\_handler
            i\_protocol =
              if\_apc\_wsp\_event\_handler\_pcp=>co\_event\_handler\_type ).
        "Server
        DATA(request) =
          client->get\_context( )->get\_initial\_request( ).
        request->set\_path\_and\_query(
          i\_relative\_uri =
            \`/sap/bc/apc/sap/demo\_apc\_pcp\` &&
            COND #(
               WHEN stateful\_server = abap\_true THEN \`\_stateful\` ) &&
            COND #(
              WHEN amc = abap\_true THEN \`?amc=x\` ) ).
        client->connect( ).
        "Sending messages
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager\_pcp(
            client->get\_message\_manager( ) ).
        DATA(message) =
          CAST if\_ac\_message\_type\_pcp(
            message\_manager->create\_message( ) ).
        TRY.
            IF amc = abap\_true.
              message->set\_field( i\_name = 'amc' i\_value = 'x' ).
            ENDIF.
            message->set\_text( msg ).
          CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
            cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
            LEAVE PROGRAM.
        ENDTRY.
        DO messages TIMES.
          message\_manager->send( message ).
        ENDDO.
        "Receiving messages
        DO wait TIMES.
          out->line( ).
          CLEAR event\_handler->message.
          WAIT FOR PUSH CHANNELS
               UNTIL event\_handler->message IS NOT INITIAL
               UP TO 1 SECONDS.
          IF sy-subrc = 4.
            out->write\_text(
              'No handler for APC messages registered' ).
          ELSEIF sy-subrc = 8.
            out->write\_text(
              'Timeout occurred!' ).
          ELSE.
            out->write\_text(
             |Received APC message: \\n\\n{
               event\_handler->message } | ).
          ENDIF.
        ENDDO.
        out->line( ).
        "Close connection
        client->close( i\_reason = 'Application closed connection!' ).
        out->display( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create an [APC client](javascript:call_link\('abenapc.htm'\)) for the WebSocket protocol.

-   The local class apc\_handler, which implements the interface IF\_APC\_WSP\_EVENT\_HANDLER\_PCP, is used as the handler class. When a message is received, the method on\_message sets its message attribute to the message text.

-   The message manager of the client object is used to create a message in [PCP format](javascript:call_link\('abenpcp.htm'\)) and send it multiple times.

-   The statement [WAIT FOR PUSH CHANNELS](javascript:call_link\('abapwait_apc.htm'\)) is then used to switch the program to a wait state so that messages sent back from the server can be handled. Here, the logical expression checks the attribute message of the handler class apc\_handler. A received text is displayed.

-   Finally, the connection is closed explicitly.

It is possible to select how many messages are sent and how often the wait state occurs.

-   If communication takes place with the stateful server, the counter level of the server is raised, indicating that multiple messages are being sent and received.

-   If the server sends its messages using ABAP messaging channels, other AMC receivers in the same messaging channel can also see the messages of the server. For example, the Web browser from the executable example [AS ABAP as WebSocket Server](javascript:call_link\('abenapc_abexa.htm'\)) can receive these messages. In the reverse direction, the APC client can then also receive those messages sent by the APC server as a response to messages from the Web browser, if they occur in one of the programmed wait periods.



**📖 Source**: [abenapc_ws_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_ws_client_abexa.htm)

### abenapc_tcp_client_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_tcp_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_tcp_client_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, AS ABAP as TCP Socket Client

This example demonstrates AS ABAP as a TCP socket client.

Source Code

REPORT demo\_apc\_tcp\_client.
CLASS apc\_handler DEFINITION FINAL .
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler.
    DATA       message TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler~on\_open.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_message.
    TRY.
        message = i\_message->get\_text( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        message = apc\_error->get\_text( ).
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_close.
    message = 'Connection closed!'.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_error.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(tcp\_server) = \`C:\\ncat\\ncat.exe\`.
    DATA(ip\_adress)  = cl\_gui\_frontend\_services=>get\_ip\_address( ).
    DATA(port)       = \`12345\`.
    DATA(terminator) = \`0A\`.
    DATA(msg)        = \`Hello TCP, answer me!\`.
    cl\_demo\_input=>new(
      )->add\_text(
         |For the TCP server, download the freely available NCAT.EXE|
      )->add\_field( CHANGING field = tcp\_server
      )->add\_field( CHANGING field = ip\_adress
      )->add\_field( CHANGING field = port
      )->add\_field( CHANGING field = terminator
      )->add\_field( CHANGING field = msg
      )->request( ).
    "Server
    IF cl\_gui\_frontend\_services=>file\_exist(
         file = tcp\_server ) IS INITIAL.
      cl\_demo\_output=>display( 'TCP Server not found!' ).
      LEAVE PROGRAM.
    ENDIF.
    cl\_gui\_frontend\_services=>execute(
    EXPORTING
      application = \`cmd.exe\`
      parameter  =  \`/c \` && tcp\_server &&
                   \` -l \` && ip\_adress && \` -p \` && port ).
    WAIT UP TO 1 SECONDS.
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Client
        DATA(client) = cl\_apc\_tcp\_client\_manager=>create(
          i\_host   = ip\_adress
          i\_port  = port
          i\_frame = VALUE apc\_tcp\_frame(
            frame\_type =
              if\_apc\_tcp\_frame\_types=>co\_frame\_type\_terminator
            terminator =
              terminator )
          i\_event\_handler = event\_handler ).
        client->connect( ).
        "Send mesasage from client
        DATA(message\_manager) = CAST if\_apc\_wsp\_message\_manager(
          client->get\_message\_manager( ) ).
        DATA(message) = CAST if\_apc\_wsp\_message(
          message\_manager->create\_message( ) ).
        DATA(binary\_terminator) = CONV xstring( terminator ).
        DATA(binary\_msg) =
          cl\_abap\_conv\_codepage=>create\_out( )->convert( msg ).
        CONCATENATE binary\_msg binary\_terminator
               INTO binary\_msg IN BYTE MODE.
        message->set\_binary( binary\_msg ).
        message\_manager->send( message ).
        "Wait for a message from server
        CLEAR event\_handler->message.
        WAIT FOR PUSH CHANNELS
             UNTIL event\_handler->message IS NOT INITIAL
             UP TO 10 SECONDS.
        IF sy-subrc = 4.
          cl\_demo\_output=>display(
            'No handler for APC messages registered!' ).
        ELSEIF sy-subrc = 8.
          cl\_demo\_output=>display(
            'Timeout occurred!' ).
        ELSE.
          cl\_demo\_output=>display(
            |TCP client received:\\n\\n{ event\_handler->message }| ).
        ENDIF.
        client->close(
          i\_reason = 'Application closed connection!' ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create an [APC client](javascript:call_link\('abenapc.htm'\)) for the TCP socket protocol. It is structured in exactly the same way as in the [executable example](javascript:call_link\('abenapc_ws_client_abexa.htm'\)) for the WebSocket client, but with the connection being made to a TCP socket server. The current front-end computer is used as the TCP socket server here and the available [Ncat](https://nmap.org/ncat/) can be downloaded to this computer.

This program requires the Ncat.exe directory and the address of the current front-end computer (proposals are made for this information). In addition, a terminator character is needed for the TCP framework structure.

When the program is executed, Ncat.exe is started and waits for messages from the APC client. Once a message is sent, this client waits for a message entered in the Ncat window and confirmed using Enter.



**📖 Source**: [abenapc_tcp_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_tcp_client_abexa.htm)

### abenapc_detached_client_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_detached_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_detached_client_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, Creating a Detached Client

This example demonstrates how a detached client is created for the WebSocket protocol.

Source Code

REPORT demo\_apc\_detached\_client.
CLASS apc\_handler DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler\_pcp.
    DATA: connection\_attach\_handle TYPE string,
          message                  TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_open.
    TRY.
        connection\_attach\_handle =
          i\_context->get\_connection\_attach\_handle(
            EXPORTING i\_connection\_security =
              i\_context->co\_con\_security\_by\_user\_id ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        me->message = apc\_error->get\_text( ).
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_message.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_close.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_error.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA stateful\_server TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = stateful\_server ).
    DATA show\_attach\_handle TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = show\_attach\_handle ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Detached client
        DATA(client\_detach) =
          cl\_apc\_wsp\_client\_conn\_manager=>create\_by\_destination(
            i\_destination = 'NONE'
            i\_application\_id = \`DEMO\_APC\_PCP\`
            i\_event\_handler = event\_handler
            i\_protocol =
              if\_apc\_wsp\_event\_handler\_pcp=>co\_event\_handler\_type ).
        "Server
        DATA(request) =
          client\_detach->get\_context( )->get\_initial\_request( ).
        request->set\_path\_and\_query(
          i\_relative\_uri =
            \`/sap/bc/apc/sap/demo\_apc\_pcp\` &&
            COND #(
               WHEN stateful\_server = abap\_true THEN \`\_stateful\` ) &&
            COND #( WHEN amc = abap\_true THEN \`?amc=x\` ) ).
        client\_detach->connect\_and\_detach( ).
        IF event\_handler->message IS NOT INITIAL.
          out->display(
            |Error during ON\_OPEN: { event\_handler->message }| ).
          LEAVE PROGRAM.
        ENDIF.
        IF show\_attach\_handle IS INITIAL.
          "Attached client
          DATA(client\_attach) =
            cl\_apc\_wsp\_client\_conn\_manager=>attach(
              event\_handler->connection\_attach\_handle ).
          DATA(message\_manager) =
            CAST if\_apc\_wsp\_message\_manager\_pcp(
              client\_attach->get\_message\_manager( ) ).
          DATA(message) = CAST if\_ac\_message\_type\_pcp(
            message\_manager->create\_message( ) ).
          TRY.
              IF amc = abap\_true.
                message->set\_field( i\_name = 'amc' i\_value = 'x' ).
              ENDIF.
              message->set\_field(
                i\_name = 'detached\_client' i\_value = 'x' ).
              message->set\_text( msg ).
            CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
              cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
              LEAVE PROGRAM.
          ENDTRY.
          message\_manager->send( message ).
          client\_attach->close(
            i\_reason = 'Application closed connection!' ).
        ELSE.
          out->display(
            |Attach Handle:\\n\\n{
            event\_handler->connection\_attach\_handle
            }\\n\\nUse as input to DEMO\_APC\_ATTACH\_CLIENT.| ).
        ENDIF.
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create a [detached APC client](javascript:call_link\('abenapc.htm'\)) for the WebSocket protocol.

-   The local class apc\_handler, which implements the interface IF\_APC\_WSP\_EVENT\_HANDLER\_PCP, is used as the handler class. The method on\_open gets a connection handle for the connection. The other methods are not needed.

-   The connection handle obtained by the method on\_open of the handler class can either be displayed or used immediately in the program to create an attached client for the detached client.

-   A displayed connection handle can be used in the program of the executable [attached client](javascript:call_link\('abenapc_attached_client_abexa.htm'\)) example.

-   If not, the method ATTACH of the class CL\_APC\_WSP\_CLIENT\_CONN\_MANAGER is used to create an attached client object for the connection handle. Its message manager is then used to create a message in [PCP format](javascript:call_link\('abenpcp.htm'\)) and send it.

A breakpoint in the method ON\_MESSAGE of the APC handler class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP can be used to monitor the arrival and processing of the message (it is not possible to respond to messages from the same class here). If the message is sent using [AMC](javascript:call_link\('abenamc.htm'\)), the response from the server is received by all associated AMC receivers. The attached client cannot itself wait for the response.



**📖 Source**: [abenapc_detached_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_detached_client_abexa.htm)

### abenapc_attached_client_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_attached_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_attached_client_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, AS ABAP as Attached Client

This example demonstrates the AS ABAP as an attached client for a detached client.

Source Code

REPORT demo\_apc\_attach\_client.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA attach\_handle TYPE string VALUE ' '.
    cl\_demo\_input=>add\_field( CHANGING field  = attach\_handle ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA close TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = close ).
    cl\_demo\_input=>request( ).
    TRY.
        "Attached client
        DATA(client\_attach) =
          cl\_apc\_wsp\_client\_conn\_manager=>attach( attach\_handle ).
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager\_pcp(
            client\_attach->get\_message\_manager( ) ).
        DATA(message) = CAST if\_ac\_message\_type\_pcp(
          message\_manager->create\_message( ) ).
        TRY.
            IF amc = abap\_true.
              message->set\_field( i\_name = 'amc' i\_value = 'x' ).
            ENDIF.
            message->set\_field(
              i\_name = 'detached\_client' i\_value = 'x' ).
            message->set\_text( msg ).
          CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
            cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
            LEAVE PROGRAM.
        ENDTRY.
        message\_manager->send( message ).
        IF close  = abap\_true.
          client\_attach->close(
            i\_reason = 'Application closed connection!' ).
        ENDIF.
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

The program expects a connection handle as input, as provided in the output of the executable [detached client](javascript:call_link\('abenapc_detached_client_abexa.htm'\)) example. The connection handle is used to create and employ an attached client object precisely as described in the detached client example. The connection handle can be reused indefinitely until the connection is closed using the method CLOSE. If the connection is not closed by mistake, this can be done later in the transaction SMWS.



**📖 Source**: [abenapc_attached_client_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_attached_client_abexa.htm)

### abenapc_connect_via_handle_abexa.htm

> **📖 Official SAP Documentation**: [abenapc_connect_via_handle_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_connect_via_handle_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP Channels](javascript:call_link\('abenabap_channels.htm'\)) →  [APC - ABAP Push Channels](javascript:call_link\('abenapc.htm'\)) →  [Examples of APC](javascript:call_link\('abenapc_abexas.htm'\)) → 

APC, System-Wide Access

This example demonstrates access to any ABAP channel using a connection handle.

Source Code

REPORT demo\_apc\_access\_connection.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA attach\_handle TYPE string VALUE ' '.
    cl\_demo\_input=>add\_field( CHANGING field  = attach\_handle ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(access\_object) =
          cl\_apc\_wsp\_client\_conn\_manager=>attach( attach\_handle ).
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager(
            access\_object->get\_message\_manager( ) ).
        DATA(message) = CAST if\_apc\_wsp\_message(
          message\_manager->create\_message( ) ).
        message->set\_text( msg ).
        message\_manager->send( message ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

The program expects a valid connection handle for a WebSocket connection as its input, creates an access objects for this handle, and uses it to send a simple text message.

An APC connection from the executable example [AS ABAP as WebSocket Server](javascript:call_link\('abenapc_abexa.htm'\)) publishes its connection handle as follows:

-   Create a WebSocket server without PCP.

-   Open the connection on the Web page.

-   Send the text message "get handle".

This message is identified in the method ON\_MESSAGE of the APC handler class CL\_APC\_WS\_EXT\_DEMO\_APC and the connection handle is fetched and sent. The Web page displays it in a form that can be copied. If the connection handle is passed to the program above while the connection is open, the message sent by the program is received and displayed by the Web page.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ADF - ABAP Daemon Framework

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ADF - ABAP Daemon Framework

Included pages: 6



**📖 Source**: [abenapc_connect_via_handle_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenapc_connect_via_handle_abexa.htm)

### abenabap_daemon.htm

> **📖 Official SAP Documentation**: [abenabap_daemon.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_daemon.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) → 

ADF - ABAP Daemon Framework

ABAP Daemon Framework (ADF for short) is an application programming interface (or API) used to create and handle [ABAP Daemons](javascript:call_link\('abenabap_daemon_glosry.htm'\) "Glossary Entry"). An ABAP Daemon is an instance of an [ABAP Daemon class](javascript:call_link\('abenabap_daemon_class_glosry.htm'\) "Glossary Entry") that is persisted in a special [ABAP Daemon session](javascript:call_link\('abenabap_daemon_session_glosry.htm'\) "Glossary Entry"). Every AS Instance in an AS ABAP has access to any of the daemons in this AS ABAP. ABAP programs themselves use [ABAP Daemon Manager](javascript:call_link\('abenabap_daemon_manager_glosry.htm'\) "Glossary Entry") to access ABAP Daemons.

The only limit on the lifetime of an ABAP Daemon not stopped explicitly using ADF methods is the lifetime of the AS Instance where it is running. An ABAP Daemon is created again automatically every time a [runtime error](javascript:call_link\('abenruntime_error_glosry.htm'\) "Glossary Entry") or a [message](javascript:call_link\('abenmessage_glosry.htm'\) "Glossary Entry") of type E, A, or X causes it to terminate a program. When the AS Instance of a daemon is shut down, the daemon can be moved to another AS Instance by creating a new daemon containing the same context information as the preceding daemon. This enables the new daemon to do the same job.

The [processing of an ABAP Daemon](javascript:call_link\('abenabap_daemon_processing_glosry.htm'\) "Glossary Entry") takes place in the background and is event-driven. Both the consumer of a daemon and the ABAP runtime environment can raise [ABAP Daemon events](javascript:call_link\('abenabap_daemon_event_glosry.htm'\) "Glossary Entry") and the daemon can respond to these events using predefined interface methods. A daemon must always be ready to respond to inbound events and this is ensured by running ABAP Daemon processing in a [non-blocking mode](javascript:call_link\('abenadf_non_blocking_model.htm'\)).

-   [ABAP Daemon Classes](#abenabap-daemon-1--------creating-and-using-abap-daemons---@ITOC@@ABENABAP_DAEMON_2)

-   [Managing ABAP Daemons](#abenabap-daemon-3--------abap-daemon-examples---@ITOC@@ABENABAP_DAEMON_4)

Notes

-   ABAP Daemons can be used as event handlers with long lifetimes, for example to respond to changes in shared internal or external AS ABAP resources.

-   More details about ABAP Daemon Framework can be found under ABAP Daemons.

ABAP Daemon Classes

An [ABAP Daemon class](javascript:call_link\('abenabap_daemon_class_glosry.htm'\) "Glossary Entry") is a global class that inherits from the abstract system class CL\_ABAP\_DAEMON\_EXT\_BASE and it must also be possible to create public instances of this daemon class. From the superclass, an ABAP Daemon class inherits the methods of the interface IF\_ABAP\_DAEMON\_EXTENSION that it uses to respond to [ABAP Daemon events](javascript:call_link\('abenabap_daemon_event_glosry.htm'\) "Glossary Entry") if they are implemented in the ABAP Daemon class.

-   ON\_ACCEPT

This method is executed before the daemon is actually started. The return value of the method has the type ABAP\_DAEMON\_SETUP\_MODE from ABAP Dictionary and must be set to a value dictated by the components of the constant structure CO\_SETUP\_MODE of the interface IF\_ABAP\_DAEMON\_EXTENSION. The daemon start is accepted or rejected using these values. The method can be implemented to decide whether the start is accepted or not. For example, user-dependent authorizations can be evaluated and the start of the daemon can be limited to specific programs. To do this, the object passed in the input parameter I\_CONTEXT\_BASE of the static type IF\_ABAP\_DAEMON\_CONTEXT\_BASE can be evaluated. Its methods, GET\_START\_PARAMETER and GET\_START\_CALLER\_INFO, return the required information. They behave in the same way as the identically named methods of a context object.

-   ON\_START

This method is executed when a daemon is started using the method START in [ABAP Daemon Managers](javascript:call_link\('abenabap_daemon_manager_glosry.htm'\) "Glossary Entry") and directly after an instance of the daemon is executed. The daemon can be initialized in its implementation in the following ways:

-   How context information is saved in [ABAP Daemon Memory](javascript:call_link\('abenabap_daemon_memory_glosry.htm'\) "Glossary Entry") or to other suitable memory areas, such as [shared memory](javascript:call_link\('abenshared_memory_glosry.htm'\) "Glossary Entry") or database tables.

-   How [ABAP Messaging Channels](javascript:call_link\('abenabap_messaging_channel_glosry.htm'\) "Glossary Entry") are bound for communication with consumers.

-   Whether an [ABAP Timer](javascript:call_link\('abenabap_timer_glosry.htm'\) "Glossary Entry") is created to limit the lifetime of the daemon if required.

-   ON\_MESSAGE

This method is executed when the daemon receives a [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") message sent using the method SEND of an [ABAP Daemon handle](javascript:call_link\('abenabap_daemon_handle_glosry.htm'\) "Glossary Entry"). To do this, the method ATTACH in [ABAP Daemon Manager](javascript:call_link\('abenabap_daemon_manager_glosry.htm'\) "Glossary Entry") returns a reference to a daemon handle. The messages in the input parameter I\_MESSAGE can be evaluated in the implementation of the method ON\_MESSAGE.

-   ON\_ERROR

This method is executed after the daemon is restarted automatically due to a [message](javascript:call_link\('abenmessage_glosry.htm'\) "Glossary Entry") of the type E, A, or X or because of a [runtime error](javascript:call_link\('abenruntime_error_glosry.htm'\) "Glossary Entry"). A runtime error closes the [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") of the daemon, deletes the associated [ABAP memory](javascript:call_link\('abenabap_memory_glosry.htm'\) "Glossary Entry"), and produces a [short dump](javascript:call_link\('abenshort_dump_glosry.htm'\) "Glossary Entry"). The automatic restart opens a new internal session. The context of the daemon can be restored in the implementation of the method by accessing context information preserved in the [ABAP Daemon memory](javascript:call_link\('abenabap_daemon_memory_glosry.htm'\) "Glossary Entry") or in another repository, The input parameter I\_CODE contains information about the source of the runtime error. Runtime errors should be avoided in the method ON\_ERROR itself If a runtime error does occur here, the execution of the next method is delayed by 30 seconds.

-   ON\_RESTART

This method is executed when the daemon is restarted using its context object or after the event ON\_BEFORE\_RESTART\_BY\_SYSTEM (see below). The context of the daemon can be restored in the implementation of the method by accessing context information preserved in the [ABAP Daemon memory](javascript:call_link\('abenabap_daemon_memory_glosry.htm'\) "Glossary Entry") or in another repository,

-   ON\_SERVER\_SHUTDOWN

This method is executed when the current AS Instance is shut down. This method can be implemented so that the daemon is moved to another free AS Instance (if available) by starting a new daemon here with the same context information. The daemon is stopped automatically after this method is executed.

-   ON\_SYSTEM\_SHUTDOWN

This method is executed when the current AS ABAP is shut down. This method can be implemented to include cleanup activities, such as deleting temporary daemon data in persistent repositories. The daemon is stopped automatically after this method is executed.

-   ON\_BEFORE\_RESTART\_BY\_SYSTEM

This method is executed when an inconsistent state is detected in the daemon. This can occur when programs used by a daemon are modified and need to be reloaded. If necessary, this method can be implemented to perform appropriate tasks, such as updating the saved context information. After this method is executed, a restart is performed automatically and the method ON\_RESTART runs.

-   ON\_STOP

This method is executed when the daemon is stopped using the method STOP in [ABAP Daemon Manager](javascript:call_link\('abenabap_daemon_manager_glosry.htm'\) "Glossary Entry") or using its context object (see below). This method can be implemented to include cleanup activities, such as deleting temporary daemon data in the relevant memory areas. In the input parameter I\_MESSAGE, the method is sent the [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") message, which can be passed when the daemon is stopped (this is optional).

Except for ON\_ACCEPT, each of these methods has an input parameter I\_CONTEXT with the static type IF\_ABAP\_DAEMON\_CONTEXT that points to a context object. The context object has interface methods that handle context information about the current daemon or that stop or restart it:

-   GET\_START\_PARAMETER

This method returns the [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") message that was passed to [ABAP Daemon Manager](javascript:call_link\('abenabap_daemon_manager_glosry.htm'\) "Glossary Entry") when the daemon was started.

-   GET\_START\_CALLER\_INFO

This method returns information about the context of the consumer of the daemon, such as the client, user name, or ABAP program in a structure of the type ABAP\_DAEMON\_START\_CALLER\_INFO.

-   GET\_INSTANCE\_ID

This method returns the unique internal ID of the current daemon.

-   SET\_APPLICATION\_PARAMETER

This method writes data to the [ABAP Daemon memory](javascript:call_link\('abenabap_daemon_memory_glosry.htm'\) "Glossary Entry") in [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") format. Here, this data is assigned to the current daemon. Here, they are preserved for the full lifetime of the daemon (including any restarts). If SET\_APPLICATION\_PARAMETER is repeated, all existing data is overwritten.

-   GET\_APPLICATION\_PARAMETER

This method reads the latest data written using SET\_APPLICATION\_PARAMETER from the [ABAP Daemon memory](javascript:call_link\('abenabap_daemon_memory_glosry.htm'\) "Glossary Entry").

-   RESTART

This method restarts the current daemon with the same internal ID. This deletes the internal session of the daemon with all associated memories, such as the [ABAP memory](javascript:call_link\('abenabap_memory_glosry.htm'\) "Glossary Entry"), and opens a new internal session. The restart raises the event ON\_RESTART.

-   STOP

This method stops the current daemon and raises the event ON\_STOP at the same time.

An ABAP Daemon class can contain further helper methods and can call any number of other procedures in its methods. The implementation of an ABAP Daemon class and the procedures it calls must be executable in [non-blocking mode](javascript:call_link\('abenadf_non_blocking_model.htm'\)) to prevent the runtime error DAEMON\_ILLEGAL\_STATEMENT in [ABAP Daemon processing](javascript:call_link\('abenabap_daemon_processing_glosry.htm'\) "Glossary Entry") and a subsequent restart of the daemon.

Notes

-   To write context information, it is advisable to create a central helper method that is called by the methods ON\_START, ON\_ERROR, and ON\_RESTART. The [ABAP Daemon memory](javascript:call_link\('abenabap_daemon_memory_glosry.htm'\) "Glossary Entry") associated with the daemon is particularly well suited for this task, although other repositories can also be used, such as the shared memory or database tables.

-   The interface IF\_ABAP\_TIMER\_HANDLER can be implemented to turn an ABAP Daemon class into an [ABAP Timer handler](javascript:call_link\('abenabap_timer_handler_glosry.htm'\) "Glossary Entry") too and hence make it able to respond to [ABAP Timer](javascript:call_link\('abenabap_timer_glosry.htm'\) "Glossary Entry") events. This makes it possible, for example, to wait for certain events or to stop the daemon after a defined period of time.

Creating and Using ABAP Daemons

ABAP Daemons are created and consumed using the static methods of the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER in ABAP Daemon Manager. The following rules apply here:

-   An ABAP Daemon can be created and used from any ABAP program.

-   An ABAP Daemon can only be used in the same AS ABAP as the program it was created by and the [ABAP Daemon session](javascript:call_link\('abenabap_daemon_session_glosry.htm'\) "Glossary Entry") always has the same [client ID](javascript:call_link\('abenclient_identifier_glosry.htm'\) "Glossary Entry") as the current [user session](javascript:call_link\('abenuser_session_glosry.htm'\) "Glossary Entry"). No predefined restrictions exist for the user who is using the program in question.

-   Only the program that created an ABAP Daemon using ABAP Daemon Manager can use this daemon in ABAP Daemon Manager. If any other programs attempt this, an exception is raised. It is also not possible for a daemon to access itself using ABAP Daemon Manager. If multiple programs need to access the same daemon, it is best to wrap these ABAP Daemon Manager reads in a class whose class pool is the only program that can access this daemon.

ABAP Daemon Manager (or the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER) has the following methods:

-   START

This method starts an ABAP Daemon of an ABAP Daemon class passed to the input parameter I\_CLASS\_NAME under a name passed to the input parameter I\_NAME. This daemon is started only when permitted by the interface method ON\_ACCEPT of the ABAP Daemon class. When the daemon is started, a new [ABAP Daemon session](javascript:call_link\('abenabap_daemon_session_glosry.htm'\) "Glossary Entry") is opened whose [client ID](javascript:call_link\('abenclient_identifier_glosry.htm'\) "Glossary Entry") is adopted by the current user session and whose [user name](javascript:call_link\('abenuser_name_glosry.htm'\) "Glossary Entry") and [logon language](javascript:call_link\('abenlogon_language_glosry.htm'\) "Glossary Entry") are determined using an [RFC destination](javascript:call_link\('abendestination_glosry.htm'\) "Glossary Entry") that can be passed to the input parameter I\_DESTINATION (this is optional). The default value is the predefined RFC destination NONE. An explicitly specified RFC destination must meet the following prerequisites:

-   It must be an internal connection to the same AS ABAP.

-   It must be an ABAP connection (with or without load distribution).

-   A client ID used in the RFC destination must be the same ID as used in the current user session.

-   An AS Instance specified as hostname\_sysid\_instnr must belong to the current AS ABAP.

The input parameter I\_PRIORITY can be used to specify a priority for the response of the daemon to [ABAP Daemon events](javascript:call_link\('abenabap_daemon_event_glosry.htm'\) "Glossary Entry"). The input parameter I\_PARAMETER can be used to pass a [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") message to the daemon as a start parameter and the daemon can access this message using its context object.

The output parameter E\_SETUP\_MODE gets the return value of the interface method ON\_ACCEPT of the ABAP Daemon class. The output parameter E\_INSTANCE\_ID gets the internal ID of the started daemon, which is used by ABAP Daemon Manager to access this daemon.

-   ATTACH

In its return value with the static type IF\_ABAP\_DAEMON\_HANDLE, this method returns a reference to an [ABAP Daemon handle](javascript:call_link\('abenabap_daemon_handle_glosry.htm'\) "Glossary Entry") for the daemon whose internal ID was passed to the input parameter I\_INSTANCE\_ID. The method SEND of the daemon handle can be used by the consumer to send [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") messages to the daemon and the daemon can handle these messages in its interface method ON\_MESSAGE.

-   STOP

This method stops the daemon whose internal ID was passed to the input parameter I\_INSTANCE\_ID. The [ABAP Daemon event](javascript:call_link\('abenabap_daemon_event_glosry.htm'\) "Glossary Entry") ON\_STOP is raised first. In the associated method, the daemon can evaluate the [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") passed to the input parameter I\_PARAMETER.

-   GET\_DAEMON\_INFO

Returns an internal table containing information about all ABAP Daemons in the current AS ABAP for the ABAP Daemon class that is passed to the input parameter I\_CLASS\_NAME.

Notes

-   It is advisable to create dedicated [RFC destinations](javascript:call_link\('abendestination_glosry.htm'\) "Glossary Entry") for ABAP Daemons with a suitable user:

-   ABAP Daemons run in the background, which means that dialog users should not be used.

-   The user in question should have precisely those authorizations required for daemon processing.

-   One consumer can create multiple ABAP Daemons of an ABAP Daemon class, which can then be distinguished by using different names. It can also be useful, however, to permit just one daemon from an ABAP Daemon class as a singleton in a single AS ABAP. The checks needed here must be provided by the consumer.

-   In most cases, a consumer does not need to know the internal ID of an ABAP Daemon. If the method calls of the ABAP Daemon handler are wrapped in a class, as recommended, this class can encapsulate them in a private attribute.

-   A consumer can communicate with an ABAP Daemon only by using [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") messages.

-   On its own, the method GET\_DAEMON\_INFO in ABAP Daemon Manager is not enough to create an ABAP Daemon as a system-wide singleton. Parallel reads can be used to start multiple daemons in the same ABAP Daemon class before they are returned by GET\_DAEMON\_INFO.

-   Internally, ABAP Daemons are handled using the [RFC interface](javascript:call_link\('abenrfc_interface_glosry.htm'\) "Glossary Entry"). Accordingly, a consumer of daemons must also have the associated [RFC authorizations](javascript:call_link\('abenrfc_authority.htm'\)).

-   The class pool of an ABAP Daemon (or the instance of an ABAP Daemon class) is always the only [ABAP session](javascript:call_link\('abenmain_session_glosry.htm'\) "Glossary Entry") program in its [ABAP Daemon session](javascript:call_link\('abenabap_daemon_session_glosry.htm'\) "Glossary Entry"), since no program calls are possible in the associated [non-blocking mode](javascript:call_link\('abenadf_non_blocking_model.htm'\)).

-   When an ABAP Daemon is stopped or restarted due to an error, its entire context is removed. The associated [ABAP Daemon session](javascript:call_link\('abenabap_daemon_session_glosry.htm'\) "Glossary Entry") is also ended and, if the daemon is restarted, a new session is started, This affects any context information in the [ABAP Daemon memory](javascript:call_link\('abenabap_daemon_memory_glosry.htm'\) "Glossary Entry"), any [ABAP Timers](javascript:call_link\('abenabap_timer_glosry.htm'\) "Glossary Entry") that were started, and all non-persistent data in the associated [ABAP session](javascript:call_link\('abenmain_session_glosry.htm'\) "Glossary Entry"). More specifically, any [SAP locks](javascript:call_link\('abensap_lock_glosry.htm'\) "Glossary Entry") that were set are released.

-   It is the task of the consumer to delete any daemon-specific data in the shared memory or other persistent repositories.

-   In cases where a daemon is moved to a different AS Instance, the consumer must also ensure that the settings in question are transferred at the same time.

Managing ABAP Daemons

The transaction SMDAEMON displays the ABAP Daemons on the current AS Instance and they can also be restarted or stopped here.

Note

User-specific [breakpoints](javascript:call_link\('abenbreakpoint_glosry.htm'\) "Glossary Entry") can be set when an ABAP Daemon is being processed (namely when the methods of the ABAP Daemon class and the procedures called here are executed) to debug the daemon.

ABAP Daemon Examples

Executable Examples

-   [ADF, Mini ABAP Daemon](javascript:call_link\('abenabap_mini_daemon_abexa.htm'\))

-   [ADF, Creating and Using an ABAP Daemon](javascript:call_link\('abenabap_daemon_abexa.htm'\))

See also the class CL\_AD\_EXT\_SIMPLE\_DAEMON, which can be used by the program RS\_ABAP\_DAEMON\_TEST. Unlike in the preceding simple examples, this example is more reliable in producing a system-wide singleton ABAP Daemon.

Continue
[ADF - Non-Blocking Mode](javascript:call_link\('abenadf_non_blocking_model.htm'\))
[Examples for ABAP Daemons](javascript:call_link\('abenabap_daemon_abexas.htm'\))



**📖 Source**: [abenabap_daemon.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_daemon.htm)

### abenadf_non_blocking_model.htm

> **📖 Official SAP Documentation**: [abenadf_non_blocking_model.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenadf_non_blocking_model.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ADF - ABAP Daemon Framework](javascript:call_link\('abenabap_daemon.htm'\)) → 

ADF - Non-Blocking Mode

[ABAP Daemon processing](javascript:call_link\('abenabap_daemon_processing_glosry.htm'\) "Glossary Entry") is event-driven To stop an [ABAP Daemon session](javascript:call_link\('abenabap_daemon_session_glosry.htm'\) "Glossary Entry") type from being blocked for inbound messages, the the session runs in [non-blocking model](javascript:call_link\('abennon_blocking_model_glosry.htm'\) "Glossary Entry"). In non-blocking mode for ADF, the following blocking statements are forbidden in ABAP Daemon processing and in the procedures called here:

-   Calls

-   [SUBMIT](javascript:call_link\('abapsubmit.htm'\))

-   [CALL TRANSACTION](javascript:call_link\('abapcall_transaction.htm'\))

-   [CALL DIALOG](javascript:call_link\('abapcall_dialog.htm'\))

-   [CALL SCREEN](javascript:call_link\('abapcall_screen.htm'\))

-   [CALL SELECTION-SCREEN](javascript:call_link\('abapcall_selection_screen.htm'\))

-   [SET SCREEN](javascript:call_link\('abapset_screen.htm'\))

-   Exit

-   [LEAVE LIST-PROCESSING](javascript:call_link\('abapleave_list-processing.htm'\))

-   [LEAVE PROGRAM](javascript:call_link\('abapleave_program.htm'\))

-   [LEAVE SCREEN](javascript:call_link\('abapleave_screen.htm'\))

-   [LEAVE TO TRANSACTION](javascript:call_link\('abapleave_to_transaction.htm'\))

-   [LEAVE TO LIST-PROCESSING](javascript:call_link\('abapleave_to_list-processing.htm'\))

-   [CHECK](javascript:call_link\('abapcheck_processing_blocks.htm'\)), [EXIT](javascript:call_link\('abapexit_processing_blocks.htm'\)), [STOP](javascript:call_link\('abapstop.htm'\)), and [REJECT](javascript:call_link\('abapreject.htm'\)) for exiting [reporting events](javascript:call_link\('abenreporting_event_glosry.htm'\) "Glossary Entry")

-   Wait

-   [WAIT UP TO](javascript:call_link\('abapwait_up_to.htm'\)), [WAIT FOR ...](javascript:call_link\('abapwait_until.htm'\))

-   [COMMUNICATION](javascript:call_link\('abapcommunication.htm'\))

Using a statement like this in non-blocking mode produces a runtime error.

Notes

-   The statement WAIT is not allowed in non-blocking mode. To be able to wait for certain events despite this restriction (such as the end of a callback routine in [aRFC](javascript:call_link\('abenarfc_glosry.htm'\) "Glossary Entry"), [ABAP Timers](javascript:call_link\('abenabap_timer_glosry.htm'\) "Glossary Entry") can be used. An ABAP Timer is created by [ABAP Timer Manager](javascript:call_link\('abenabap_timer_manager_glosry.htm'\) "Glossary Entry") and handled using [ABAP Timer handlers](javascript:call_link\('abenabap_timer_handler_glosry.htm'\) "Glossary Entry"). The associated class and interfaces are CL\_ABAP\_TIMER\_MANAGER, IF\_ABAP\_TIMER\_MANAGER, and IF\_ABAP\_TIMER\_HANDLER. ABAP Timers can only be used in non-blocking mode, namely [APC](javascript:call_link\('abenapc_session_glosry.htm'\) "Glossary Entry") and [ABAP Daemon sessions](javascript:call_link\('abenabap_daemon_session_glosry.htm'\) "Glossary Entry").

-   Unlike in [non-blocking mode](javascript:call_link\('abenapc_non_blocking_model.htm'\)) for [APC](javascript:call_link\('abenapc_glosry.htm'\) "Glossary Entry"), the statement [CALL FUNCTION DESTINATION](javascript:call_link\('abapcall_function_destination.htm'\)) for [sRFC](javascript:call_link\('abensrfc_glosry.htm'\) "Glossary Entry") is allowed in ABAP Daemon processing.



**📖 Source**: [abenadf_non_blocking_model.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenadf_non_blocking_model.htm)

### abenabap_daemon_abexas.htm

> **📖 Official SAP Documentation**: [abenabap_daemon_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_daemon_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ADF - ABAP Daemon Framework](javascript:call_link\('abenabap_daemon.htm'\)) → 

Examples for ABAP Daemons

Continue
![Example](exa.gif "Example") [ADF, Mini ABAP Daemon](javascript:call_link\('abenabap_mini_daemon_abexa.htm'\))
![Example](exa.gif "Example") [ADF, Creating and Using an ABAP Daemon](javascript:call_link\('abenabap_daemon_abexa.htm'\))



**📖 Source**: [abenabap_daemon_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_daemon_abexas.htm)

### abenabap_mini_daemon_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_mini_daemon_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_mini_daemon_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ADF - ABAP Daemon Framework](javascript:call_link\('abenabap_daemon.htm'\)) →  [Examples for ABAP Daemons](javascript:call_link\('abenabap_daemon_abexas.htm'\)) → 

ADF, Mini ABAP Daemon

This example demonstrates a mini [ABAP Daemon](javascript:call_link\('abenabap_daemon_glosry.htm'\) "Glossary Entry").

Source Code

REPORT demo\_abap\_mini\_daemon.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TRY.
        DATA(pcp) = cl\_ac\_message\_type\_pcp=>create( ).
        pcp->set\_text( \`Hello Daemon!\` ).
      CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_exc).
        cl\_demo\_output=>display( pcp\_exc->get\_text( ) ).
        RETURN.
    ENDTRY.
    TRY.
        cl\_abap\_daemon\_client\_manager=>start(
          EXPORTING
            i\_class\_name = 'CL\_DEMO\_ABAP\_MINI\_DAEMON'
            i\_name       = 'DemoMiniDaemon'
         IMPORTING
            e\_instance\_id = DATA(instance\_id) ).
        cl\_abap\_daemon\_client\_manager=>attach(
          i\_instance\_id = instance\_id )->send( pcp ).
        cl\_abap\_daemon\_client\_manager=>stop(
          i\_instance\_id = instance\_id ).
      CATCH cx\_abap\_daemon\_error INTO DATA(daemon\_exc).
        cl\_demo\_output=>display( daemon\_exc->get\_text( ) ).
        RETURN.
    ENDTRY.
    DATA msg TYPE string.
    IMPORT msg = msg FROM SHARED MEMORY demo\_indx\_blob(dm)
                     ID 'DemoMiniDaemon'.
    ASSERT msg = \`Hello Daemon!\`.
    cl\_demo\_output=>display( 'Daemon has received the message' ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The class CL\_DEMO\_ABAP\_MINI\_DAEMON used by the program above demonstrates a mini [ABAP Daemon class](javascript:call_link\('abenabap_daemon_class_glosry.htm'\) "Glossary Entry"). It implements only the following methods of the interface IF\_ABAP\_DAEMON\_EXTENSION:

-   ON\_ACCEPT

METHOD if\_abap\_daemon\_extension~on\_accept.
  TRY.
      IF i\_context\_base->get\_start\_caller\_info(
           )-program = 'DEMO\_ABAP\_MINI\_DAEMON'.
        e\_setup\_mode = co\_setup\_mode-accept.
      ENDIF.
    CATCH cx\_abap\_daemon\_error.
      RETURN.
  ENDTRY.
ENDMETHOD.

In this method, the return value E\_SETUP\_MODE must be set to ensure that the daemon is created. The method limits the creation of daemons to the program DEMO\_ABAP\_MINI\_DAEMON.

-   ON\_MESSAGE

METHOD IF\_ABAP\_DAEMON\_EXTENSION~ON\_MESSAGE.
  TRY.
      DATA(msg) = i\_message->get\_text( ).
    CATCH cx\_ac\_message\_type\_pcp\_error.
      RETURN.
  ENDTRY.
  EXPORT msg = msg TO SHARED MEMORY demo\_indx\_blob(dm)
                   ID 'DemoMiniDaemon'.
ENDMETHOD.

This method indicates that the daemon is responding to message from a program. To enable this, the message is exported to the [cross-transaction application buffer](javascript:call_link\('abencrosstrans_app_buffer_glosry.htm'\) "Glossary Entry") of the shared memory.

The program DEMO\_ABAP\_MINI\_DAEMON uses [ABAP Daemon Manager](javascript:call_link\('abenabap_daemon_manager_glosry.htm'\) "Glossary Entry") to do the following:

-   Start a daemon based on the class CL\_DEMO\_ABAP\_MINI\_DAEMON.

-   Send a [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") message using a temporary [ABAP Daemon handle](javascript:call_link\('abenabap_daemon_handle_glosry.htm'\) "Glossary Entry").

-   Stop the daemon immediately (not a typical step).

It then checks whether the daemon wrote the message to the shared memory.



**📖 Source**: [abenabap_mini_daemon_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_mini_daemon_abexa.htm)

### abenabap_daemon_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_daemon_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_daemon_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ADF - ABAP Daemon Framework](javascript:call_link\('abenabap_daemon.htm'\)) →  [Examples for ABAP Daemons](javascript:call_link\('abenabap_daemon_abexas.htm'\)) → 

ADF, Creating and Using an ABAP Daemon

This example demonstrates an [ABAP Daemon](javascript:call_link\('abenabap_daemon_glosry.htm'\) "Glossary Entry").

Source Code

REPORT demo\_abap\_daemon.
CLASS amc\_receiver DEFINITION.
  PUBLIC SECTION.
    INTERFACES
      if\_amc\_message\_receiver\_text.
    DATA msg TYPE string.
ENDCLASS.
CLASS amc\_receiver IMPLEMENTATION.
  METHOD if\_amc\_message\_receiver\_text~receive.
    msg = i\_message.
  ENDMETHOD.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA:
      start\_daemon       TYPE abap\_bool,
      get\_information    TYPE abap\_bool,
      send\_message       TYPE abap\_bool,
      trigger\_amc        TYPE abap\_bool,
      trigger\_exception  TYPE abap\_bool,
      trigger\_blocking   TYPE abap\_bool,
      trigger\_restart    TYPE abap\_bool,
      trigger\_relocation TYPE abap\_bool,
      trigger\_stop       TYPE abap\_bool,
      stop\_daemon        TYPE abap\_bool.
    CLASS-DATA:
      out TYPE REF TO if\_demo\_output.
    CLASS-METHODS:
      get\_input,
      write\_log IMPORTING msg TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DELETE FROM DATABASE demo\_indx\_blob(dm)
                ID cl\_demo\_abap\_daemon\_broker=>daemon\_log.
    COMMIT CONNECTION default.
    get\_input( ).
    out = cl\_demo\_output=>new( ).
    out->next\_section( 'ABAP Program' ).
    TRY.
        IF NOT cl\_demo\_abap\_daemon\_broker=>check\_daemon( ).
          IF start\_daemon = abap\_true.
            DATA(pcp) = cl\_ac\_message\_type\_pcp=>create( ).
            pcp->set\_field( i\_name = \`Version\`
                            i\_value = \`1\` ).
            IF cl\_demo\_abap\_daemon\_broker=>start\_daemon(
                 pcp = pcp ).
              write\_log( \`Daemon start requested\` ).
            ELSE.
              write\_log( \`Daemon not accepted\` ).
            ENDIF.
          ELSE.
            write\_log( \`Daemon not started\` ).
          ENDIF.
        ELSE.
          cl\_demo\_abap\_daemon\_broker=>attach\_daemon( ).
          CASE abap\_true.
            WHEN start\_daemon.
              write\_log( \`Daemon already started\` ).
            WHEN get\_information.
              write\_log( \`Information requested\` ).
              out->write(
                cl\_demo\_abap\_daemon\_broker=>get\_daemon\_info( ) ).
            WHEN send\_message.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`msg\` ).
              pcp->set\_text( \`Hello Daemon!\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Text message sent\` ).
            WHEN trigger\_amc.
              DATA(receiver) = NEW amc\_receiver( ).
              TRY.
                  cl\_amc\_channel\_manager=>create\_message\_consumer(
                    i\_application\_id = 'DEMO\_AMC'
                    i\_channel\_id     = '/demo\_text'
                    )->start\_message\_delivery( i\_receiver = receiver ).
                CATCH cx\_amc\_error INTO DATA(amc\_exc).
                  write\_log( \`Exception, \` && amc\_exc->get\_text( ) ).
              ENDTRY.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`amc\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`AMC message triggered\` ).
              WAIT FOR MESSAGING CHANNELS
                   UNTIL receiver->msg IS NOT INITIAL
                   UP TO 10 SECONDS.
              IF receiver->msg IS NOT INITIAL.
                write\_log( |AMC message "{ receiver->msg }" received| ).
              ELSE.
                write\_log( |No AMC message received| ).
              ENDIF.
            WHEN trigger\_exception.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`err\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Exception triggered\` ).
            WHEN trigger\_blocking.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`blk\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Blocking statement triggered\` ).
            WHEN trigger\_restart.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`rst\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Restart triggered\` ).
            WHEN trigger\_relocation.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`rlo\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Relocation triggered\` ).
            WHEN trigger\_stop.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`stp\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Stop triggered\` ).
            WHEN stop\_daemon.
              cl\_demo\_abap\_daemon\_broker=>stop\_daemon( ).
              write\_log( \`Daemon stop requested\` ).
          ENDCASE.
        ENDIF.
      CATCH cx\_abap\_daemon\_error
            cx\_ac\_message\_type\_pcp\_error INTO DATA(exc).
        write\_log( \`Exception, \` && exc->get\_text( ) ).
    ENDTRY.
    WAIT UP TO 1 SECONDS.
    out->next\_section( 'ABAP Daemon' ).
    DATA(daemon\_log) = \`\`.
    IMPORT daemon\_log = daemon\_log
           FROM DATABASE demo\_indx\_blob(dm)
           ID cl\_demo\_abap\_daemon\_broker=>daemon\_log.
    IF sy-subrc = 0.
      out->write( daemon\_log ).
    ENDIF.
    out->display( ).  ENDMETHOD.
  METHOD get\_input.
    cl\_demo\_input=>new(
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = start\_daemon
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = get\_information
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = send\_message
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_amc
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_exception
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_blocking
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_restart
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_relocation
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_stop
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = stop\_daemon
     )->request( ).
    IF start\_daemon       &&
       get\_information    &&
       send\_message       &&
       trigger\_amc        &&
       trigger\_exception  &&
       trigger\_blocking   &&
       trigger\_restart    &&
       trigger\_relocation &&
       trigger\_stop       &&
       stop\_daemon <> abap\_true.
      cl\_demo\_output=>display( \`Check exactly one box\` ).
      LEAVE PROGRAM.
    ENDIF.
  ENDMETHOD.
  METHOD write\_log.
    DATA ts TYPE timestampl.
    GET TIME STAMP FIELD ts.
    out->write( |{ ts TIMESTAMP = ISO }: { msg }| ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

It implements the most important aspects of an ABAP Daemon and contains the program above and two classes.

Program DEMO\_ABAP\_DAEMON

This program makes it possible to start an ABAP Daemon interactively and then perform various actions using the daemon. The checkboxes have the following meanings:

-   START\_DAEMON

Attempts to start an ABAP Daemon. Only one ABAP Daemon of the ABAP Daemon class in question may exist. When the program starts, a version number is passed in [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") format. If an ABAP Daemon already exists, this daemon is used.

-   GET\_INFORMATION

Gets information about the ABAP Daemon and displays it.

-   SEND\_MESSAGE

Sends a text message to the ABAP Daemon in [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") format.

-   TRIGGER\_AMC

Sends a [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") message to the ABAP Daemon instructing the daemon to send an [AMC](javascript:call_link\('abenamc_glosry.htm'\) "Glossary Entry") message. The program waits until the message arrives at a dedicated AMC receiver.

-   TRIGGER\_EXCEPTION

Sends a [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") message to the ABAP Daemon, where an exception is raised. The exception produces a [short dump](javascript:call_link\('abenshort_dump_glosry.htm'\) "Glossary Entry") that can be viewed in transaction ST22 and the ABAP Daemon is restarted automatically. This raises the version number by 1.

-   TRIGGER\_BLOCKING

Sends a [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") message to the ABAP Daemon instructing it to create a statement forbidden in [non-blocking mode](javascript:call_link\('abenadf_non_blocking_model.htm'\)). This raises an exception and [short dump](javascript:call_link\('abenshort_dump_glosry.htm'\) "Glossary Entry"), which can be viewed in transaction ST22. The ABAP Daemon is then restarted automatically. This raises the version number by 1.

-   TRIGGER\_RESTART

Sends a [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") message to the ABAP Daemon that restarts the daemon. This raises the version number by 1.

-   TRIGGER\_RELOCATION

Sends a [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") message to the ABAP Daemon instructing the daemon to create a new instance of its class on a different AS Instance and delete the previous instance.

-   TRIGGER\_STOP

Sends a [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") message to the ABAP Daemon instructing it to stop.

-   STOP\_DAEMON

Stops the daemon.

The output of the program displays the individual actions in both the program and in the ABAP Daemon. To do this, the daemon writes entries to the [export/import table](javascript:call_link\('abenexport_import_table_glosry.htm'\) "Glossary Entry") DEMO\_INDX\_BLOB, which are then read by the ABAP program after a short delay. If the system in question is slow, this delay may not be long enough to display all actions in the daemon. The ABAP Daemon on the current AS Instance can be viewed in parallel to the execution of the program using the transaction SMDAEMON.

Class CL\_ABAP\_DAEMON\_BROKER

The program DEMO\_ABAP\_DAEMON does not work directly with the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER and any reads performed on this class are wrapped in the class CL\_DEMO\_ABAP\_DAEMON\_BROKER. This is because CL\_ABAP\_DAEMON\_CLIENT\_MANAGER can only be used to access an ABAP Daemon in the program where the daemon was started. It must be possible for the daemon itself to create an instance of its class in this example, which means the reads must be moved to a program that can be accessed from both the ABAP program and the ABAP Daemon. To enable this, CL\_DEMO\_ABAP\_DAEMON\_BROKER contains the following methods:

-   CHECK\_DAEMON

METHOD check\_daemon.
  DATA(daemon\_info) =
    cl\_abap\_daemon\_client\_manager=>get\_daemon\_info(
      i\_class\_name = daemon\_class ).
  instance\_id =
     VALUE #( daemon\_info\[ name = daemon\_name \]-instance\_id
              OPTIONAL ).
  success = COND #( WHEN instance\_id IS NOT INITIAL THEN abap\_true ).
ENDMETHOD.

This method determines whether a daemon of the ABAP Daemon class CL\_DEMO\_ABAP\_DAEMON already exists and saves its ID for further use. The program DEMO\_ABAP\_DAEMON starts a daemon of the class CL\_DEMO\_ABAP\_DAEMON only if no daemon exists. The method shown here for creating an ABAP Daemon as a singleton is not, however, 100% reliable. It is possible that further daemons are created in the same class in the time between starting the daemon and its being returned by the method GET\_DAEMON\_INFO. A fully reliable program, however, would be too detailed for this simple example.

-   START\_DAEMON

METHOD start\_daemon.
  DATA stack TYPE abap\_callstack.
  CALL FUNCTION 'SYSTEM\_CALLSTACK'
    IMPORTING
      callstack = stack.
  IF VALUE #( stack\[ 2 \]-mainprogram OPTIONAL )
     <> 'DEMO\_ABAP\_DAEMON' AND
     VALUE #( stack\[ 2 \]-mainprogram OPTIONAL )
     <> 'CL\_DEMO\_ABAP\_DAEMON===========CP'.
    RETURN.
  ENDIF.
  cl\_abap\_daemon\_client\_manager=>start(
    EXPORTING
      i\_class\_name  = daemon\_class
      i\_name        = daemon\_name
      i\_parameter   = pcp
      i\_destination = destination
    IMPORTING
      e\_instance\_id = instance\_id
      e\_setup\_mode  = DATA(setup\_mode) ).
  success =
    COND #( WHEN setup\_mode =
                   if\_abap\_daemon\_extension=>co\_setup\_mode-accept
            THEN abap\_true ).
ENDMETHOD.

This method wraps the method START of the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER and starts an ABAP Daemon of the ABAP Daemon class CL\_DEMO\_ABAP\_DAEMON. Any callers are checked to ensure that the method is only used in the program DEMO\_ABAP\_DAEMON and in the ABAP Daemon class. The ID of the started daemon is saved for further use. If the ABAP Daemon class is accepted when started, the return value is not initial.

-   GET\_DAEMON\_INFO

METHOD get\_daemon\_info.
  daemon\_info =
    cl\_abap\_daemon\_client\_manager=>get\_daemon\_info(
      i\_class\_name = daemon\_class ).
ENDMETHOD.

This method wraps the identically named method of the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER and returns information about the ABAP Daemons of the ABAP Daemon class CL\_DEMO\_ABAP\_DAEMON.

-   ATTACH\_DAEMON

METHOD attach\_daemon.
  daemon\_handle = cl\_abap\_daemon\_client\_manager=>attach(
    i\_instance\_id = instance\_id ).
ENDMETHOD.

This method wraps the method ATTACH of the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER. The returned reference to the [ABAP Daemon handle](javascript:call_link\('abenabap_daemon_handle_glosry.htm'\) "Glossary Entry") is saved in the private attribute DAEMON\_HANDLE.

-   SEND\_MESSAGE

METHOD send\_message.
  IF daemon\_handle IS INITIAL.
    RAISE EXCEPTION TYPE cx\_abap\_daemon\_error
      EXPORTING
        textid = cx\_abap\_daemon\_error=>action\_not\_permitted.
  ENDIF.
  daemon\_handle->send( pcp ).
ENDMETHOD.

This method is used to send [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") messages to the ABAP Daemon. To do this, the method SEND of the [ABAP Daemon handle](javascript:call_link\('abenabap_daemon_handle_glosry.htm'\) "Glossary Entry") is used, which is referenced in the private attribute DAEMON\_HANDLE.

-   STOP\_DAEMON

METHOD stop\_daemon.
  cl\_abap\_daemon\_client\_manager=>stop(
    i\_instance\_id = instance\_id ).
ENDMETHOD.

This method wraps the method STOP of the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER and is used to stop the ABAP Daemon.

The name of the ABAP Daemon and the ABAP Daemon class are defined as constants of the class CL\_ABAP\_DAEMON\_BROKER.

Class CL\_ABAP\_DAEMON

The class CL\_DEMO\_ABAP\_DAEMON is a subclass of CL\_ABAP\_DAEMON\_EXT\_BASE and is the ABAP Daemon class for this example. It implements the most important methods of the interface IF\_ABAP\_DAEMON\_EXTENSION and further standalone helper methods. It also implements the interface IF\_ABAP\_TIMER\_HANDLER so that it can be an [ABAP Timer handler](javascript:call_link\('abenabap_timer_handler_glosry.htm'\) "Glossary Entry") for an [ABAP Timer](javascript:call_link\('abenabap_timer_glosry.htm'\) "Glossary Entry"). Although daemons should never be stopped in practice, daemons created by this example are deleted automatically after an hour (if not stopped explicitly first).

-   IF\_ABAP\_DAEMON\_EXTENSION~ON\_ACCEPT

METHOD if\_abap\_daemon\_extension~on\_accept.
  TRY.
      DATA(caller) = i\_context\_base->get\_start\_caller\_info( )-program.
      IF caller = 'CL\_DEMO\_ABAP\_DAEMON\_BROKER====CP'.
        e\_setup\_mode = co\_setup\_mode-accept.
      ENDIF.
    CATCH cx\_abap\_daemon\_error.
      RETURN.
  ENDTRY.
ENDMETHOD.

Before the daemon is started, this method checks whether the calling program is the class pool of the class CL\_DEMO\_ABAP\_DAEMON\_BROKER. Only in this case is the output parameter E\_SETUP\_MODE set so that the daemon can be started.

-   IF\_ABAP\_DAEMON\_EXTENSION~ON\_START

METHOD if\_abap\_daemon\_extension~on\_start.
  TRY.
      set\_context( context = i\_context
                   version = i\_context->get\_start\_parameter(
                                          )->get\_field(
                                             i\_name = \`Version\` ) ).
      write\_log( |Daemon started as version {
                    i\_context->get\_application\_parameter(
                       )->get\_field( i\_name = \`Version\` )
                  } on { sy-host }| ).
    CATCH cx\_ac\_message\_type\_pcp\_error
          cx\_abap\_daemon\_error
          cx\_abap\_timer\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

Directly after the daemon is started, this method calls the helper method SET\_CONTEXT, which saves context information and starts a timer. One example of context information here is the version number passed by the caller when the daemon is started.

-   IF\_ABAP\_DAEMON\_EXTENSION~ON\_MESSAGE

METHOD if\_abap\_daemon\_extension~on\_message.
  TRY.
      DATA(type) = i\_message->get\_field( i\_name = \`Type\` ).
      CASE type.
        WHEN \`msg\`.
          write\_log(
            |Message "{ i\_message->get\_text( )
              }" received on { sy-host }| ).
        WHEN \`amc\`.
          write\_log( \`Sending AMC message in daemon\` ).
          send\_amc( \`Hello from daemon\` ).
        WHEN \`err\`.
          write\_log( \`Raising exception in daemon\` ).
          MESSAGE \`Type X message in daemon\` TYPE 'X'.
        WHEN \`blk\`.
          write\_log( \`Executing blocking statement in daemon\` ).
          WAIT UP TO 1 SECONDS.
        WHEN \`rst\`.
          write\_log( \`Restarting from daemon\` ).
          i\_context->restart( ).
        WHEN \`rlo\`.
          write\_log( \`Relocating daemon\` ).
          relocate( ).
        WHEN \`stp\`.
          write\_log( \`Stopping from daemon\` ).
          i\_context->stop( ).
      ENDCASE.
    CATCH cx\_ac\_message\_type\_pcp\_error
          cx\_abap\_daemon\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

This method evaluates the inbound [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") messages and performs the actions in question directly or calls helper methods from the ABAP Daemon class.

-   IF\_ABAP\_DAEMON\_EXTENSION~ON\_ERROR

METHOD if\_abap\_daemon\_extension~on\_error.
  set\_context( i\_context ).
  TRY.
      write\_log(
        \`Daemon restarted after error and version increased to \` &&
         i\_context->get\_application\_parameter(
                      )->get\_field( i\_name = \`Version\` ) ).
    CATCH cx\_ac\_message\_type\_pcp\_error
          cx\_abap\_daemon\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

IF\_ABAP\_DAEMON\_EXTENSION~ON\_RESTART

METHOD if\_abap\_daemon\_extension~on\_restart.
  set\_context( i\_context ).
  TRY.
      write\_log(
        \`Daemon restarted and version increased to \` &&
         i\_context->get\_application\_parameter(
                      )->get\_field( i\_name = \`Version\` ) ).
    CATCH cx\_ac\_message\_type\_pcp\_error
          cx\_abap\_daemon\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

These methods call the helper method SET\_CONTEXT to set the context information again after a restart.

-   IF\_ABAP\_DAEMON\_EXTENSION~ON\_SERVER\_SHUTDOWN

METHOD if\_abap\_daemon\_extension~on\_server\_shutdown.
  relocate( ).
ENDMETHOD.

When the current AS Instance is shut down, this method calls the helper method RELOCATE to move the daemon to a different AS Instance.

-   IF\_ABAP\_TIMER\_HANDLER~ON\_TIMEOUT

METHOD if\_abap\_timer\_handler~on\_timeout.
  TRY.
      write\_log( \`Timeout reached, stopping daemon\` ).
      daemon\_context->stop( ).
    CATCH cx\_abap\_daemon\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

In the case of a timeout event of the [ABAP Timer](javascript:call_link\('abenabap_timer_glosry.htm'\) "Glossary Entry") set in SET\_CONTEXT, this method stops the daemon.

-   SET\_CONTEXT

METHOD set\_context.
  daemon\_context = context.
  TRY.
      DATA(pcp) = cl\_ac\_message\_type\_pcp=>create( ).
      pcp->set\_field(
        i\_name = \`Version\`
        i\_value = COND #(
                    WHEN version IS NOT SUPPLIED
                      THEN context->get\_application\_parameter(
                             )->get\_field( i\_name = \`Version\` ) + 1
                      ELSE version ) ).
      context->set\_application\_parameter( i\_parameter = pcp ).
      cl\_abap\_timer\_manager=>get\_timer\_manager(
        )->start\_timer(
          i\_timer\_handler = me
          i\_timeout = 3600 \* 1000 ).
      write\_log( \`Daemon timeout set to one hour\` ).
    CATCH cx\_ac\_message\_type\_pcp\_error
          cx\_abap\_daemon\_error
          cx\_abap\_timer\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

This method sets an attribute of the class to the context object and uses its method SET\_APPLICATION\_PARAMETER to save the current version number in the [ABAP Daemon memory](javascript:call_link\('abenabap_daemon_memory_glosry.htm'\) "Glossary Entry") in [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") format. If SET\_CONTEXT is called after a restart, the previous version number is fetched from the ABAP Daemon memory and raised by 1. Furthermore, SET\_CONTEXT initializes an [ABAP Timer](javascript:call_link\('abenabap_timer_glosry.htm'\) "Glossary Entry") responded to by the method IF\_ABAP\_TIMER\_HANDLER~ON\_TIMEOUT of the current daemon.

-   SEND\_AMC

METHOD send\_amc.
  TRY.
      CAST if\_amc\_message\_producer\_text(
             cl\_amc\_channel\_manager=>create\_message\_producer(
               i\_application\_id = 'DEMO\_AMC'
               i\_channel\_id     = '/demo\_text'
               i\_suppress\_echo  = 'X' )
        )->send( i\_message = msg ).
    CATCH cx\_amc\_error INTO DATA(amc\_exc).
      write\_log( \`Exception, \` && amc\_exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

This method sends an [AMC](javascript:call_link\('abenamc_glosry.htm'\) "Glossary Entry") message.

-   RELOCATE

METHOD relocate.
  DATA list TYPE TABLE OF msxxlist WITH EMPTY KEY.
  CALL FUNCTION 'TH\_SERVER\_LIST'
    TABLES
      list   = list
    EXCEPTIONS
      OTHERS = 4.
  IF sy-subrc <> 0 OR lines( list ) < 2.
    write\_log( \`No other application server available\`).
    RETURN.
  ENDIF.
  DELETE list WHERE host = sy-host.
  DATA(server) = list\[
    cl\_abap\_random\_int=>create(
      seed = CONV #( sy-uzeit )
      min  = 1
      max  = lines( list ) )->get\_next( ) \].
  TRY.
      IF cl\_demo\_abap\_daemon\_broker=>start\_daemon(
            pcp = daemon\_context->get\_application\_parameter( )
            destination = server-name ).
        write\_log( \`Daemon relocated to \` && server-host && \` \`  ).
        daemon\_context->stop( ).
      ELSE.
        write\_log( \`Daemon not accepted on \` && server-host ).
      ENDIF.
    CATCH cx\_abap\_daemon\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

This method attempts to move the current daemon to a different AS Instance. To do this, an AS Instances is selected at random from a list in the current AS ABAP. This application server is then used as a destination for starting a daemon of the current ABAP Daemon class using CL\_ABAP\_DAEMON\_BROKER. Here, the current context information from the [ABAP Daemon memory](javascript:call_link\('abenabap_daemon_memory_glosry.htm'\) "Glossary Entry") is passed directly as start parameters in [PCP](javascript:call_link\('abenpcp_glosry.htm'\) "Glossary Entry") format. The current daemon is then stopped.

-   WRITE\_LOG

METHOD write\_log.
  DATA ts TYPE timestampl.
  GET TIME STAMP FIELD ts.
  DATA(daemon\_log) = \`\`.
  IMPORT daemon\_log = daemon\_log
         FROM DATABASE demo\_indx\_blob(dm)
         ID cl\_demo\_abap\_daemon\_broker=>daemon\_log.
  daemon\_log = daemon\_log && |{ ts TIMESTAMP = ISO }: { msg }\\n|.
  EXPORT daemon\_log = daemon\_log
         TO DATABASE demo\_indx\_blob(dm)
         ID cl\_demo\_abap\_daemon\_broker=>daemon\_log.
  COMMIT CONNECTION default.
ENDMETHOD.

This method writes log entries to the [export/import table](javascript:call_link\('abenexport_import_table_glosry.htm'\) "Glossary Entry") DEMO\_INDX\_BLOB as a string. It is called by the other methods to log the actions of the daemon for the output of the program DEMO\_ABAP\_DAEMON.

In this example, the remaining methods of the interface IF\_ABAP\_DAEMON\_EXTENSION only write log entries.

Note

This simple example does not guarantee that an ABAP Daemon in the ABAP Daemon class CL\_ABAP\_DAEMON is a system-wide singleton. Any parallel reads that cause restarts can be the source of multiple unwanted daemons. This applies in particular when moving daemons to other AS Instances. A great deal more work is required to create a real singleton. See the class CL\_AD\_EXT\_SIMPLE\_DAEMON, which can be used by the program RS\_ABAP\_DAEMON\_TEST.



**📖 Source**: [abenabap_daemon_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_daemon_abexa.htm)

### abenabap_daemon_abexas.htm

> **📖 Official SAP Documentation**: [abenabap_daemon_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_daemon_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ADF - ABAP Daemon Framework](javascript:call_link\('abenabap_daemon.htm'\)) → 

Examples for ABAP Daemons

Continue
![Example](exa.gif "Example") [ADF, Mini ABAP Daemon](javascript:call_link\('abenabap_mini_daemon_abexa.htm'\))
![Example](exa.gif "Example") [ADF, Creating and Using an ABAP Daemon](javascript:call_link\('abenabap_daemon_abexa.htm'\))


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / iXML Library / iXML Library - Parsing

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abenabap_daemon_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_daemon_abexas.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / iXML Library / iXML Library - Access to DOM

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / iXML Library / iXML Library - Classes and Interfaces

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / iXML Library / iXML Library, Examples

**Files**: 20 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / sXML Library / sXML Library - Parsing

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / sXML Library / sXML Library - Rendering

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / sXML Library / sXML Library - Classes and Interfaces

**Files**: 10 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / sXML Library / sXML Library, Examples

**Files**: 13 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / XSL Transformations

**Files**: 4 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Structure of ST Programs

**Files**: 10 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Addressing ABAP Data

**Files**: 9 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Literal Template Content

**Files**: 6 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Transformation of ABAP Values / ST - tt:value, Elementary Data Objects / ST - option, Mapping Rules / ST - option, Mapping Rules for Elementary Types

**Files**: 5 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Transformation of ABAP Values / ST - tt:value, Elementary Data Objects / ST - option, Mapping Rules / ST - option, Mapping Rules for XML Fragments

**Files**: 2 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Value Assignments

**Files**: 4 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Reading and Writing Variables

**Files**: 4 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Flow Control / ST - tt:cond, Conditional Transformations

**Files**: 6 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Flow Control / ST - Flow Control with Variables

**Files**: 3 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Modularization with Subtemplates

**Files**: 3 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Reusing ST Programs

**Files**: 3 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Access to ABAP Objects from ST

**Files**: 5 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Examples

**Files**: 4 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / asXML - Canonical XML Representation / asXML - Mapping of ABAP Data Types / asXML - Mapping of Reference Variables and Objects

**Files**: 10 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / asXML - Canonical XML Representation / asXML, Examples of Mappings

**Files**: 11 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

**Files**: 7 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abencall_transformation_abexas.htm

> **📖 Official SAP Documentation**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](javascript:call_link\('abencall_trafo_sources_abexa.htm'\))
![Example](exa.gif "Example") [XML Targets of Transformations](javascript:call_link\('abencall_trafo_results_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Missing Elements](javascript:call_link\('abenabap_deserl_no_elem_abexa.htm'\))
![Example](exa.gif "Example") [Deserializing Empty Elements](javascript:call_link\('abenabap_deserl_empt_elem_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](javascript:call_link\('abencall_trafo_escaping_abexa.htm'\))
![Example](exa.gif "Example") [Transformation of XML Element Names](javascript:call_link\('abencall_trafo_upper_lower_abexa.htm'\))



**📖 Source**: [abencall_transformation_abexas.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_transformation_abexas.htm)

### abencall_trafo_sources_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.



**📖 Source**: [abencall_trafo_sources_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_sources_abexa.htm)

### abencall_trafo_results_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.



**📖 Source**: [abencall_trafo_results_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_results_abexa.htm)

### abenabap_deserl_no_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_no_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_no_elem_abexa.htm)

### abenabap_deserl_empt_elem_abexa.htm

> **📖 Official SAP Documentation**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID into [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") and [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](javascript:call_link\('abenabap_xml_libs.htm'\)) should be used.



**📖 Source**: [abenabap_deserl_empt_elem_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_deserl_empt_elem_abexa.htm)

### abencall_trafo_escaping_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.



**📖 Source**: [abencall_trafo_escaping_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_escaping_abexa.htm)

### abencall_trafo_upper_lower_abexa.htm

> **📖 Official SAP Documentation**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and XML](javascript:call_link\('abenabap_xml.htm'\)) →  [Transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) →  [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) →  [CALL TRANSFORMATION - Examples](javascript:call_link\('abencall_transformation_abexas.htm'\)) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID creates [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](javascript:call_link\('abencase_functions.htm'\)).

-   Deserializations of the transformed asXML data with the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](javascript:call_link\('abencase_functions.htm'\)). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](javascript:call_link\('abenabap_json_names_to_upper_abexa.htm'\)). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and JSON / Transformations for JSON

**Files**: 18 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and JSON / Transformations for JSON

Included pages: 18



**📖 Source**: [abencall_trafo_upper_lower_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abencall_trafo_upper_lower_abexa.htm)

### abenabap_json_trafos.htm

> **📖 Official SAP Documentation**: [abenabap_json_trafos.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_json_trafos.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) → 

Transformations for JSON

The [transformations for XML](javascript:call_link\('abenabap_xml_trafos.htm'\)) that can be called from ABAP, namely [XSL transformations](javascript:call_link\('abenxsl_transformation_1_glosry.htm'\) "Glossary Entry") and [simple transformations](javascript:call_link\('abensimple_transformation_glosry.htm'\) "Glossary Entry"), can also be used for [JSON](javascript:call_link\('abenjson_glosry.htm'\) "Glossary Entry").

-   To call a transformation for JSON data as a source, the following XML sources can be specified in the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)):

-   A string or internal table with [JSON data](javascript:call_link\('abenjson_oview.htm'\)) in character-like or byte-like representation.

-   A [JSON Reader](javascript:call_link\('abenjson_reader_glosry.htm'\) "Glossary Entry").

A JSON reader returns data in the [JSON XML](javascript:call_link\('abenjson_xml_glosry.htm'\) "Glossary Entry") format. The JSON data specified as a string or in an internal table is also handled like XML representing JSON data [JSON-XML](javascript:call_link\('abenjson_xml_glosry.htm'\) "Glossary Entry") format.

-   To call a transformation for JSON data as a target, a [JSON writer](javascript:call_link\('abenjson_writer_glosry.htm'\) "Glossary Entry") can be specified as an XML target in the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)): A JSON writer expects data in [JSON-XML](javascript:call_link\('abenjson_xml_glosry.htm'\) "Glossary Entry") format.

Any XSLT programs and ST programs can be called that can handle JSON-XML:

-   If the source is JSON data, the transformation must process JSON-XML as its input.

-   If the target is JSON data, the transformation must create JSON-XML.

Self-written transformations must be programmed accordingly. The [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID is handled appropriately internally.

-   [Self-Written Transformations](javascript:call_link\('abenabap_json_trafos_self.htm'\))

-   [Identity Transformation](javascript:call_link\('abenabap_json_trafo_id.htm'\))

Continue
[Self-Written Transformations for JSON](javascript:call_link\('abenabap_json_trafos_self.htm'\))
[Identity Transformation for JSON](javascript:call_link\('abenabap_json_trafo_id.htm'\))
[asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\))



**📖 Source**: [abenabap_json_trafos.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_json_trafos.htm)

### abenabap_json_trafos_self.htm

> **📖 Official SAP Documentation**: [abenabap_json_trafos_self.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_json_trafos_self.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) → 

Self-Written Transformations for JSON

Self-written XSLT programs and simple transformations enable the following transformations:

-   Serialization of ABAP data objects to JSON

-   An [XSL transformation](javascript:call_link\('abenabap_xslt.htm'\)) accesses the [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") representation of the connected ABAP data, created internally. Its task is to transform asXML to JSON-XML.

-   A [simple transformation](javascript:call_link\('abenabap_st.htm'\)) accesses the connected ABAP data directly. Its task is to create a valid JSON-XML representation.

-   Deserialization from JSON to ABAP data objects:

-   The task of a an [XSL transformation](javascript:call_link\('abenabap_xslt.htm'\)) is to transform JSON-XML to an [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry") representation of the connected ABAP data objects.

-   The task of a [simple transformation](javascript:call_link\('abenabap_st.htm'\)) is to process JSON-XML and write the data to the connected ABAP data objects.

-   XSL transformations between JSON and XML or between JSON and JSON.

-   Transformations can be called between JSON-XML and any XML or between JSON-XML and JSON-XML.

Executable Example

[Simple Transformation for Internal Tables](javascript:call_link\('abenabap_st_json_table_abexa.htm'\))



**📖 Source**: [abenabap_json_trafos_self.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_json_trafos_self.htm)

### abenabap_json_trafo_id.htm

> **📖 Official SAP Documentation**: [abenabap_json_trafo_id.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_json_trafo_id.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) → 

Identity Transformation for JSON

The predefined [identity transformation](javascript:call_link\('abenabap_xslt_id.htm'\)) ID is executed internally so that all requirements for [JSON transformations](javascript:call_link\('abenabap_json_trafos.htm'\)) are met. The following combinations are possible:

-   [JSON writer](javascript:call_link\('abenjson_writer_glosry.htm'\) "Glossary Entry") as XML target

-   ABAP data objects as source
    The ABAP data is serialized directly to its canonical JSON format [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry"). In this concept, the ABAP data is serialized first to its XML format [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry"). This is then transformed to an [asJSON-XML](javascript:call_link\('abenasjson_xml_glosry.htm'\) "Glossary Entry") representation and passed to the writer.

-   XML data as XML source
    The XML source must be in JSON-XML format and is passed to the writer directly.

-   JSON data or JSON reader as XML source
    The JSON-XML data is passed to the writer directly.

-   JSON data or [JSON reader](javascript:call_link\('abenjson_reader_glosry.htm'\) "Glossary Entry") as XML source

-   ABAP data objects as target
    The JSON data must be in an [asJSON](javascript:call_link\('abenasjson_glosry.htm'\) "Glossary Entry") format that matches the ABAP data objects. The JSON data is deserialized directly to the ABAP data objects. In this concept, an asJSON-XML representation of the asJSON data is edited that is first transformed to asXML and then deserialized to the ABAP data objects.

-   XML data as XML target
    The JSON-XML data is passed to the XML target directly.

-   JSON writer as XML target
    The JSON-XML data is passed to the writer directly.

When XML data is specified as an XML source or XML target, this covers all data that can be specified behind XML in CALL TRANSFORMATION, except for JSON data and JSON readers and writers.

Notes

-   If the identity transformation ID is used to serialize ABAP data to JSON and deserialize JSON data to ABAP, [asJSON, the canonical JSON representation](javascript:call_link\('abenabap_asjson.htm'\)) of ABAP data, is applied.

-   Copies of the XSL transformation ID made from the repository to other XSLT programs are not handled like ID internally and cannot be used like ID for JSON data.

Executable Examples

-   See [Identity Transformation with JSON Writer as Target](javascript:call_link\('abenjson_trafo_id_abexa.htm'\)) for the various ways of specifying JSON data as an XML source.

-   See the [asJSON](javascript:call_link\('abenabap_asjson.htm'\)) examples.



**📖 Source**: [abenabap_json_trafo_id.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_json_trafo_id.htm)

### abenabap_asjson.htm

> **📖 Official SAP Documentation**: [abenabap_asjson.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) → 

asJSON - Canonical JSON Representation

The canonical JSON representation asJSON is the format of [JSON](javascript:call_link\('abenjson_glosry.htm'\) "Glossary Entry") data that is produced by a serialization of ABAP data using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID, or that is required for a deserialization using the identity transformation.

asJSON is based closely on [asXML](javascript:call_link\('abenabap_xslt_asxml.htm'\)). From a conceptual perspective, a asJSON representation is produced by a restructuring of the asXML representation of this ABAP data to a [JSON-XML](javascript:call_link\('abenjson_xml_glosry.htm'\) "Glossary Entry") representation, while keeping all value content. This means the same basic rules apply as for asXML. In particular, XML schema data types for the mapping of ABAP data types are also used in asJSON.

Description of the asJSON format:

-   [General asJSON Format](javascript:call_link\('abenabap_asjson_general.htm'\))

-   [Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\))

Notes

-   asJSON only occurs in the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID. In particular, asJSON is not generally needed for self-written transformations for JSON; [JSON-XML](javascript:call_link\('abenjson_xml_glosry.htm'\) "Glossary Entry") is used directly instead.

-   A JSON-XML representation of asJSON is known as [asJSON-XML](javascript:call_link\('abenasjson_xml_glosry.htm'\) "Glossary Entry"). asJSON-XML is not used as an intermediate format in transformations, but the asJSON-XML associated with a asJSON representation can be created to analyze it and compare it with asXML.

Continue
[asJSON - General Format](javascript:call_link\('abenabap_asjson_general.htm'\))
[asJSON - Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\))
[asJSON - Mapping Additional XML Schema Data Types](javascript:call_link\('abenabap_asjson_schema.htm'\))



**📖 Source**: [abenabap_asjson.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson.htm)

### abenabap_asjson_general.htm

> **📖 Official SAP Documentation**: [abenabap_asjson_general.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_general.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) → 

asJSON - General Format

The following lines show the general format of the [canonical JSON representation](javascript:call_link\('abencanonical_json_represen_glosry.htm'\) "Glossary Entry"). Any line breaks and indents are included for ease or reading only.

{
  "bn1":...
  "bn2":...
   ...
  "%heap":{...}
}

The top level contains the object { }. The object components with the names bn1, bn2 ... represent the ABAP data objects specified in the addition source of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) as e1 e2 ... or in the addition result as f1 f2 ... The names of the object components bn1, bn2, ... are the names specified there in uppercase.

The values of the object components represent the content of named data object in accordance with the type-dependent mapping described in the following sections. Here, reference variables are always represented as object components whose content is objects that reference the content of referenced anonymous data objects and instances of classes in an optional object component %heap of the top object.

The same rules apply to the names of the object components bn1, bn2 ... as in [asXML](javascript:call_link\('abenabap_xslt_asxml_general.htm'\)) and replacements can be made as defined the table specified there.

Executable Example

[asJSON, General Format](javascript:call_link\('abenabap_hello_json_abexa.htm'\))



**📖 Source**: [abenabap_asjson_general.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_general.htm)

### abenabap_asjson_abap_types.htm

> **📖 Official SAP Documentation**: [abenabap_asjson_abap_types.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) → 

asJSON - Mapping of ABAP Data Types

Named data objects other than reference variables are represented in asJSON as the content of the following object components:

[“bn1":...](javascript:call_link\('abenabap_asjson_general.htm'\))
["bn1":...](javascript:call_link\('abenabap_asjson_general.htm'\))
[...](javascript:call_link\('abenabap_asjson_general.htm'\))

An additional object is implemented for the objects referenced by reference variables:

["%heap":...](javascript:call_link\('abenabap_asjson_general.htm'\))

Depending on the ABAP data type, serializations map the value of named data objects to a particular JSON representation; deserializations operate in the opposite direction:

-   [Mapping of Elementary ABAP Types](javascript:call_link\('abenabap_asjson_abap_types_elem.htm'\))

-   [Mapping of Structures](javascript:call_link\('abenabap_asjson_abap_types_struc.htm'\))

-   [Mapping of Internal Tables](javascript:call_link\('abenabap_asjson_abap_types_table.htm'\))

-   [Mapping of Enumerated Types](javascript:call_link\('abenabap_asjson_abap_types_enum.htm'\))

-   [Mapping of Reference Variables and Referenced Objects](javascript:call_link\('abenabap_asxml_references.htm'\))

Continue
[asJSON - Mapping of Elementary ABAP Types](javascript:call_link\('abenabap_asjson_abap_types_elem.htm'\))
[asJSON - Mapping of Structures](javascript:call_link\('abenabap_asjson_abap_types_struc.htm'\))
[asJSON - Mapping of Internal Tables](javascript:call_link\('abenabap_asjson_abap_types_table.htm'\))
[asJSON - Mapping of Enumerated Types](javascript:call_link\('abenabap_asjson_abap_types_enum.htm'\))
[asJSON - Mapping of Reference Variables and Objects](javascript:call_link\('abenabap_asxml_references.htm'\))



**📖 Source**: [abenabap_asjson_abap_types.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types.htm)

### abenabap_asjson_abap_types_elem.htm

> **📖 Official SAP Documentation**: [abenabap_asjson_abap_types_elem.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types_elem.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) →  [asJSON - Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\)) → 

asJSON - Mapping of Elementary ABAP Types

The values of elementary ABAP types are represented in asJSON using the [JSON representations](javascript:call_link\('abenjson_oview.htm'\)) of character-like values and number values. Representations of Boolean values and zero are not used.

-   The values of all numeric types (i, p, decfloat16, decfloat34, f) are represented directly as JSON number values.

-   The values of all other types (c, string, n, d, t, x, xstring) are represented as character-like values in quotation marks.

The type-dependent format of a value corresponds to the [asXML representation](javascript:call_link\('abenabap_xslt_asxml_named.htm'\)) of elementary types and can be taken from the tables there. The serialization and deserialization behavior noted there applies.

Note

An elementary ABAP data object that does not have an associated JSON object component in deserializations retains its previous value. To initialize the data object in this case, the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) with the value "all" can be used.

Executable Example

[asJSON for Elementary ABAP Types](javascript:call_link\('abenabap_json_asjson_elem_abexa.htm'\))



**📖 Source**: [abenabap_asjson_abap_types_elem.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types_elem.htm)

### abenabap_asjson_abap_types_struc.htm

> **📖 Official SAP Documentation**: [abenabap_asjson_abap_types_struc.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types_struc.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) →  [asJSON - Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\)) → 

asJSON - Mapping of Structures

In asJSON, an ABAP structure is represented as a [JSON object](javascript:call_link\('abenjson_oview.htm'\)) whose object components represent the structure components. The content of each object component corresponds to the canonical representation of the component value. The name of each object component is the name of the corresponding structure component. In serializations, the object components are represented in the order of the components in the structure. In deserializations of the asJSON representation of a structure, the order of the object components is not important and redundant object components are ignored. Components of the structure for which there are no object components remain unchanged.

Note

A structure that does not have an associated JSON object component in deserializations retains its previous value. A structure to which an empty object is assigned also remains unchanged, since this has the same effect on the structure components as a missing object component. To initialize the structure in these cases, the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) can be used with the value "all".

Executable Example

[asJSON for Structures](javascript:call_link\('abenabap_json_asjson_struc_abexa.htm'\))



**📖 Source**: [abenabap_asjson_abap_types_struc.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types_struc.htm)

### abenabap_asjson_abap_types_table.htm

> **📖 Official SAP Documentation**: [abenabap_asjson_abap_types_table.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types_table.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) →  [asJSON - Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\)) → 

asJSON - Mapping of Internal Tables

Internal tables are represented in asJSON as [JSON arrays](javascript:call_link\('abenjson_oview.htm'\)). The rows of the internal table are represented in their canonical representation as the components of the array. All table categories are allowed. Serializations do not pass any information about the table category to the JSON data. If the target field of a deserialization is a [sorted table](javascript:call_link\('abensorted_table_glosry.htm'\) "Glossary Entry"), the rows are sorted accordingly.

Notes

-   An internal table that does not have an associated JSON object component in deserializations retains its previous value. If an empty array is assigned to an internal table, it is set to its type-dependent initial value (which means it is emptied). To initialize the internal table in either case, the transformation option [clear](javascript:call_link\('abapcall_transformation_options.htm'\)) with the value "all" can be used.

-   Unlike in the [asXML representation](javascript:call_link\('abenabap_xslt_asxml_table.htm'\)) of internal tables, asJSON does not require a name like item for the table rows.

Executable Example

[asJSON for Internal Tables](javascript:call_link\('abenabap_json_asjson_table_abexa.htm'\))



**📖 Source**: [abenabap_asjson_abap_types_table.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types_table.htm)

### abenabap_asjson_abap_types_enum.htm

> **📖 Official SAP Documentation**: [abenabap_asjson_abap_types_enum.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types_enum.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) →  [asJSON - Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\)) → 

asJSON - Mapping of Enumerated Types

The asJSON representation of [enumerated types](javascript:call_link\('abenenumerated_type_glosry.htm'\) "Glossary Entry") corresponds to their [asXML representation](javascript:call_link\('abenabap_xslt_asxml_enum.htm'\)). That is, in asJSON the content of an [enumerated object](javascript:call_link\('abenenumerated_object_glosry.htm'\) "Glossary Entry") is represented by the name (maximum 30 characters) of the [enumerated value](javascript:call_link\('abenenumerated_value_glosry.htm'\) "Glossary Entry") in uppercase letters, and this is represented as a character-like [elementary data object](javascript:call_link\('abenabap_asjson_abap_types_elem.htm'\)).

Example

Serialization of an internal table with enumerated values by JSON.

TYPES:
  BEGIN OF ENUM color STRUCTURE col,
    red, blue, green,
  END OF ENUM color STRUCTURE col.
DATA colors TYPE SORTED TABLE OF color
            WITH UNIQUE KEY table\_line.
DO.
  ASSIGN COMPONENT sy-index OF STRUCTURE col TO FIELD-SYMBOL(<fs>).
  IF sy-subrc <> 0.
    EXIT.
  ENDIF.
  colors = VALUE #( BASE colors ( <fs> ) ).
ENDDO.
DATA(writer) = cl\_sxml\_string\_writer=>create(
     type = if\_sxml=>co\_xt\_json ).
CALL TRANSFORMATION id SOURCE colors = colors
                       RESULT XML writer.
cl\_demo\_output=>display\_json( writer->get\_output( ) ).

The output is:

{
"COLORS":
\[
  "RED",
  "BLUE",
  "GREEN"
\]
}



**📖 Source**: [abenabap_asjson_abap_types_enum.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types_enum.htm)

### abenabap_asxml_references.htm

> **📖 Official SAP Documentation**: [abenabap_asxml_references.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asxml_references.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) →  [asJSON - Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\)) → 

asJSON - Mapping of Reference Variables and Objects

A reference mechanism is used (like in [asXML](javascript:call_link\('abenabap_xslt_asxml_references.htm'\))) for the asJSON display of anonymous data objects and class instances (objects), which are addressed using references in reference variables. As [JSON](javascript:call_link\('abenjson_oview.htm'\)) does not suggest any syntax for references, an SAP-specific reference mechanism based on asXML is used.

-   Named reference variables are displayed as object components, whose content is usually a key for the referenced objects.

-   The referenced objects are stored as object components in the object [%heap](javascript:call_link\('abenabap_asjson_general.htm'\)). This name corresponds to the key.

In addition to the value, the dynamic type of the reference variables is specified in the object components of %heap when serialization takes place. This ensures that deserialization is unambiguous.

-   [Named Reference Variables](javascript:call_link\('abenabap_asjson_reference_var.htm'\))

-   [Anonymous Data Objects](javascript:call_link\('abenabap_asjson_anonym_do.htm'\))

-   [Class Instances](javascript:call_link\('abenabap_asjson_class_instances.htm'\))

Note

-   The asJSON representation of reference variables and referenced objects is only of relevance for [XSL](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") transformations and the identity transformation ID. You cannot currently use simple transformations to transform reference variables.

-   For data references, the value "embedded" can be specified for the transformation option [data\_refs](javascript:call_link\('abapcall_transformation_options.htm'\)) to define embedded storage in serializations instead of storage in the %heap object component.

Example

For information about the differences between serializing to %heap and embedded storage, see the executable example [Serializations to Heap or Embedded](javascript:call_link\('abenserialize_ref_heap_embed_abexa.htm'\)).

Continue
[asJSON - Named Reference Variables](javascript:call_link\('abenabap_asjson_reference_var.htm'\))
[asJSON - Anonymous Data Objects](javascript:call_link\('abenabap_asjson_anonym_do.htm'\))
[asXML - Instances of Classes](javascript:call_link\('abenabap_asjson_class_instances.htm'\))



**📖 Source**: [abenabap_asxml_references.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asxml_references.htm)

### abenabap_asjson_reference_var.htm

> **📖 Official SAP Documentation**: [abenabap_asjson_reference_var.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_reference_var.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) →  [asJSON - Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\)) →  [asJSON - Mapping of Reference Variables and Objects](javascript:call_link\('abenabap_asxml_references.htm'\)) → 

asJSON - Named Reference Variables

Like a regular data object, a named reference variable is represented as an object component that has special content:

"bni":{ "%ref":"#key" }

The content of the object component of a named reference variable is an object with precisely one object component, called %ref. The content of the object component %ref is a character-like value "#key", where key is the unique key of an object component in the object %heap. The object of an initial reference is empty. The key key of the ABAP runtime environment is set in serializations; in deserializations, any key can be used.

Otherwise the same rules apply to serializations and deserializations of named reference variables as to [asXML](javascript:call_link\('abenasxml_reference_variable.htm'\)) and the same special cases need to be noted.

Executable Example

[Serializing Data References](javascript:call_link\('abenserialize_dref_abexa.htm'\))



**📖 Source**: [abenabap_asjson_reference_var.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_reference_var.htm)

### abenabap_asjson_anonym_do.htm

> **📖 Official SAP Documentation**: [abenabap_asjson_anonym_do.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_anonym_do.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) →  [asJSON - Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\)) →  [asJSON - Mapping of Reference Variables and Objects](javascript:call_link\('abenabap_asxml_references.htm'\)) → 

asJSON - Anonymous Data Objects

An anonymous data object, that is a data object created using CREATE DATA or the instance operator NEW, is displayed as an object component of %heap in the form:

"key":{ "%type":"...",
        "%maxLength":...,
        "%totalDigits":...,
        "%fractionDigits":...,
        "%val":...
      }

The name key is the key used to reference the anonymous data object. The value of key is itself an object whose object components represent the type and the value of the anonymous data object.

The values of the anonymous data object is specified as content of the component %val in its canonical representation. If the anonymous data object itself is a non-initial reference variable, it references another component of %heap.

The remaining components specify the data type of the anonymous data object.

-   The same rules apply to the content of %type as to the element name type in [asXML](javascript:call_link\('abenasxml_anonymous_data_object.htm'\)).

-   The components %maxLength, %totalDigits, and %fractionDigits specify the technical attributes of the type (if required). The same rules apply to their content as to the corresponding attributes in [asXML](javascript:call_link\('abenasxml_anonymous_data_object.htm'\)).

Executable Example

[asJSON for Anonymous Data Objects](javascript:call_link\('abenabap_json_asjson_dref_abexa.htm'\)).



**📖 Source**: [abenabap_asjson_anonym_do.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_anonym_do.htm)

### abenabap_asjson_class_instances.htm

> **📖 Official SAP Documentation**: [abenabap_asjson_class_instances.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_class_instances.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) →  [asJSON - Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\)) →  [asJSON - Mapping of Reference Variables and Objects](javascript:call_link\('abenabap_asxml_references.htm'\)) → 

asXML - Instances of Classes

To transform classes to [JSON](javascript:call_link\('abenjson_glosry.htm'\) "Glossary Entry") using the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)), or to create classes from JSON data, their classes must implement the interface IF\_SERIALIZABLE\_OBJECT. The instance of a class (object) is displayed as an object component of the object %heap as follows:

"key":{ "%type":"class",
        "%val":{ "part":{ "%classVersion":"...",
                          "name":...
                          ...
                        }
                 ...
               }
      }

The name key is the key used to reference the object. The value of key is itself an object whose object components represent the class and the attributes of the referenced ABAP object.

-   The character-like value class of the component %TYPE specifies the class of the object. The same applies to class as to the element name class in [asXML](javascript:call_link\('abenasxml_class_instances.htm'\)) representation. In asJSON, the namespace that specifies where the class is defined in asXML is resolved before the class name.

-   The component %VAL represents the attribute values of the object. The value of %VAL is itself an object. The components part are objects that contain the values of the instance attributes of individual object parts. The same applies to the object parts and their names part as to the subelements <part> in [asXML](javascript:call_link\('abenasxml_class_instances.htm'\)) representation.

-   The components of an object part part represent the values of the instance attributes of the objects in their canonical representation, under their names. The same applies to the names as to the corresponding elements in [asXML](javascript:call_link\('abenasxml_class_instances.htm'\)) representation. Static attributes are ignored.

-   An optional component, %classVersion, of an object part, part, contains the version of the class of the object part in character-like representation. The same applies to the version of the class as to the attribute classVersion in [asXML](javascript:call_link\('abenasxml_class_instances.htm'\)) representation.

The [tag interface](javascript:call_link\('abentag_interface_glosry.htm'\) "Glossary Entry") IF\_SERIALIZABLE\_OBJECT has the same meaning for JSON as for [asXML](javascript:call_link\('abenasxml_class_instances.htm'\)). This means it defines which attributes of a class are serialized and helper methods can be implement that modify the behavior (see the [example](javascript:call_link\('abenserializable_object_abexa.htm'\))).

Executable Example

[asJSON for Object References](javascript:call_link\('abenabap_json_asjson_oref_abexa.htm'\))



**📖 Source**: [abenabap_asjson_class_instances.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_class_instances.htm)

### abenabap_asxml_references.htm

> **📖 Official SAP Documentation**: [abenabap_asxml_references.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asxml_references.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) →  [asJSON - Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\)) → 

asJSON - Mapping of Reference Variables and Objects

A reference mechanism is used (like in [asXML](javascript:call_link\('abenabap_xslt_asxml_references.htm'\))) for the asJSON display of anonymous data objects and class instances (objects), which are addressed using references in reference variables. As [JSON](javascript:call_link\('abenjson_oview.htm'\)) does not suggest any syntax for references, an SAP-specific reference mechanism based on asXML is used.

-   Named reference variables are displayed as object components, whose content is usually a key for the referenced objects.

-   The referenced objects are stored as object components in the object [%heap](javascript:call_link\('abenabap_asjson_general.htm'\)). This name corresponds to the key.

In addition to the value, the dynamic type of the reference variables is specified in the object components of %heap when serialization takes place. This ensures that deserialization is unambiguous.

-   [Named Reference Variables](javascript:call_link\('abenabap_asjson_reference_var.htm'\))

-   [Anonymous Data Objects](javascript:call_link\('abenabap_asjson_anonym_do.htm'\))

-   [Class Instances](javascript:call_link\('abenabap_asjson_class_instances.htm'\))

Note

-   The asJSON representation of reference variables and referenced objects is only of relevance for [XSL](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") transformations and the identity transformation ID. You cannot currently use simple transformations to transform reference variables.

-   For data references, the value "embedded" can be specified for the transformation option [data\_refs](javascript:call_link\('abapcall_transformation_options.htm'\)) to define embedded storage in serializations instead of storage in the %heap object component.

Example

For information about the differences between serializing to %heap and embedded storage, see the executable example [Serializations to Heap or Embedded](javascript:call_link\('abenserialize_ref_heap_embed_abexa.htm'\)).

Continue
[asJSON - Named Reference Variables](javascript:call_link\('abenabap_asjson_reference_var.htm'\))
[asJSON - Anonymous Data Objects](javascript:call_link\('abenabap_asjson_anonym_do.htm'\))
[asXML - Instances of Classes](javascript:call_link\('abenabap_asjson_class_instances.htm'\))



**📖 Source**: [abenabap_asxml_references.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asxml_references.htm)

### abenabap_asjson_abap_types.htm

> **📖 Official SAP Documentation**: [abenabap_asjson_abap_types.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) → 

asJSON - Mapping of ABAP Data Types

Named data objects other than reference variables are represented in asJSON as the content of the following object components:

[“bn1":...](javascript:call_link\('abenabap_asjson_general.htm'\))
["bn1":...](javascript:call_link\('abenabap_asjson_general.htm'\))
[...](javascript:call_link\('abenabap_asjson_general.htm'\))

An additional object is implemented for the objects referenced by reference variables:

["%heap":...](javascript:call_link\('abenabap_asjson_general.htm'\))

Depending on the ABAP data type, serializations map the value of named data objects to a particular JSON representation; deserializations operate in the opposite direction:

-   [Mapping of Elementary ABAP Types](javascript:call_link\('abenabap_asjson_abap_types_elem.htm'\))

-   [Mapping of Structures](javascript:call_link\('abenabap_asjson_abap_types_struc.htm'\))

-   [Mapping of Internal Tables](javascript:call_link\('abenabap_asjson_abap_types_table.htm'\))

-   [Mapping of Enumerated Types](javascript:call_link\('abenabap_asjson_abap_types_enum.htm'\))

-   [Mapping of Reference Variables and Referenced Objects](javascript:call_link\('abenabap_asxml_references.htm'\))

Continue
[asJSON - Mapping of Elementary ABAP Types](javascript:call_link\('abenabap_asjson_abap_types_elem.htm'\))
[asJSON - Mapping of Structures](javascript:call_link\('abenabap_asjson_abap_types_struc.htm'\))
[asJSON - Mapping of Internal Tables](javascript:call_link\('abenabap_asjson_abap_types_table.htm'\))
[asJSON - Mapping of Enumerated Types](javascript:call_link\('abenabap_asjson_abap_types_enum.htm'\))
[asJSON - Mapping of Reference Variables and Objects](javascript:call_link\('abenabap_asxml_references.htm'\))



**📖 Source**: [abenabap_asjson_abap_types.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_abap_types.htm)

### abenabap_asjson_schema.htm

> **📖 Official SAP Documentation**: [abenabap_asjson_schema.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_schema.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) →  [asJSON - Canonical JSON Representation](javascript:call_link\('abenabap_asjson.htm'\)) → 

asJSON - Mapping Additional XML Schema Data Types

In [asXML](javascript:call_link\('abenasxml_glosry.htm'\) "Glossary Entry"), apart from the XML schema data types needed to map elementary ABAP types, additional XML schema data types are supported by special [domains](javascript:call_link\('abenabap_xslt_asxml_schema.htm'\)) called XSD....

asJSON, which is based on asXML, also supports these domains (with the exception of XSDQNAME). In serializations and deserializations from or to ABAP data objects typed with these domains, the same applies as to [asXML](javascript:call_link\('abenabap_xslt_asxml_schema.htm'\)). Here, values from the domain XSDBOOLEAN are represented as real [Boolean JSON values](javascript:call_link\('abenjson_oview.htm'\)) in asJSON.

Note

By specifying [format](javascript:call_link\('abenst_option_format.htm'\)) in the attribute [option](javascript:call_link\('abenst_option.htm'\)) of the ST command [tt:value](javascript:call_link\('abenst_tt_value_elementary.htm'\)), formats of this type can also be applied to ABAP data objects that are not typed with a domain of this type. In JSON, furthermore, the option attribute also makes it possible to convert ABAP data fields and time stamps to UNIX time stamps (or ticks) in the JSON format for OData.

Executable Example

[asJSON for Additional XML Schema Data Types](javascript:call_link\('abenabap_json_asjson_xsd_abexa.htm'\))



**📖 Source**: [abenabap_asjson_schema.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson_schema.htm)

### abenabap_asjson.htm

> **📖 Official SAP Documentation**: [abenabap_asjson.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and JSON](javascript:call_link\('abenabap_json.htm'\)) →  [Transformations for JSON](javascript:call_link\('abenabap_json_trafos.htm'\)) → 

asJSON - Canonical JSON Representation

The canonical JSON representation asJSON is the format of [JSON](javascript:call_link\('abenjson_glosry.htm'\) "Glossary Entry") data that is produced by a serialization of ABAP data using the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID, or that is required for a deserialization using the identity transformation.

asJSON is based closely on [asXML](javascript:call_link\('abenabap_xslt_asxml.htm'\)). From a conceptual perspective, a asJSON representation is produced by a restructuring of the asXML representation of this ABAP data to a [JSON-XML](javascript:call_link\('abenjson_xml_glosry.htm'\) "Glossary Entry") representation, while keeping all value content. This means the same basic rules apply as for asXML. In particular, XML schema data types for the mapping of ABAP data types are also used in asJSON.

Description of the asJSON format:

-   [General asJSON Format](javascript:call_link\('abenabap_asjson_general.htm'\))

-   [Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\))

Notes

-   asJSON only occurs in the [identity transformation](javascript:call_link\('abenid_trafo_glosry.htm'\) "Glossary Entry") ID. In particular, asJSON is not generally needed for self-written transformations for JSON; [JSON-XML](javascript:call_link\('abenjson_xml_glosry.htm'\) "Glossary Entry") is used directly instead.

-   A JSON-XML representation of asJSON is known as [asJSON-XML](javascript:call_link\('abenasjson_xml_glosry.htm'\) "Glossary Entry"). asJSON-XML is not used as an intermediate format in transformations, but the asJSON-XML associated with a asJSON representation can be created to analyze it and compare it with asXML.

Continue
[asJSON - General Format](javascript:call_link\('abenabap_asjson_general.htm'\))
[asJSON - Mapping of ABAP Data Types](javascript:call_link\('abenabap_asjson_abap_types.htm'\))
[asJSON - Mapping Additional XML Schema Data Types](javascript:call_link\('abenabap_asjson_schema.htm'\))


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and OLE

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and OLE

Included pages: 6



**📖 Source**: [abenabap_asjson.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_asjson.htm)

### abenole2.htm

> **📖 Official SAP Documentation**: [abenole2.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenole2.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) → 

ABAP and OLE

ABAP can be used to edit automation objects whose functions are available in the presentation layer in the form of an OLE Automation server. Only automation objects for Windows are supported. Typical applications that offer an automation interface are Microsoft Office products Excel and Word, for which the published classes and their attributes and methods are found in the object directory of Visual Basic Editor called using the Macro menu option.

All automation applications that can be used by ABAP are contained in the database table TOLE, which is edited using transaction SOLE. This table contains the names of the classes and components supported by the [ABAP runtime environment](javascript:call_link\('abenabap_runtime_envir_glosry.htm'\) "Glossary Entry"). It also contains type information for adapting different data formats. The automation command set consists of the following ABAP statements:

-   [CREATE OBJECT](javascript:call_link\('abapcreate_object_ole2.htm'\))

-   [CALL METHOD](javascript:call_link\('abapcall_method_ole2.htm'\))

-   [GET PROPERTY](javascript:call_link\('abapget_property.htm'\))

-   [SET PROPERTY](javascript:call_link\('abapset_property.htm'\))

-   [FREE OBJECT](javascript:call_link\('abapfree_object.htm'\)),

where CREATE OBJECT and CALL METHOD should not be confused with the ABAP Objects statements using the same syntax.

The statements of the automation command set are passed from the ABAP runtime environment to the SAP GUI on the current presentation server responsible for the actual communication with the automation server. The statements are not passed directly and are first buffered in an automation queue and passed together to SAP GUI in a flush call. By default, a flush is triggered by the next ABAP statement that does not belong to the automation command set.

Note

For editing some of the automation objects, the more general interfaces SAP Desktop Office Integration (DOI) and Control Framework (CFW) are now available. The statements of the automation command set should be used only to access automation applications for which there is no such wrapping.

Continue
[CREATE OBJECT - OLE](javascript:call_link\('abapcreate_object_ole2.htm'\))
[CALL METHOD - OLE](javascript:call_link\('abapcall_method_ole2.htm'\))
[GET PROPERTY - OLE](javascript:call_link\('abapget_property.htm'\))
[SET PROPERTY - OLE](javascript:call_link\('abapset_property.htm'\))
[FREE OBJECT - OLE](javascript:call_link\('abapfree_object.htm'\))



**📖 Source**: [abenole2.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenole2.htm)

### abapcreate_object_ole2.htm

> **📖 Official SAP Documentation**: [abapcreate_object_ole2.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_ole2.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and OLE](javascript:call_link\('abenole2.htm'\)) → 

CREATE OBJECT - OLE

[Quick Reference](javascript:call_link\('abapcreate_object_ole_shortref.htm'\))

Syntax

CREATE OBJECT ole class *\[*NO FLUSH*\]* *\[*QUEUE-ONLY*\]*.

Extras:

[1\. ... NO FLUSH](#!ABAP_ADDITION_1@1@)
[2\. ... QUEUE-ONLY](#!ABAP_ADDITION_2@2@)

Effect

This statement creates the automation object ole of the automation class class. The object ole must be of type ole2\_object, which is defined in ABAP Dictionary in the [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") OLE2. The automation class class expects a character-like data object is expected that contains the name of the class.

The system automatically executes an authorization check if the column AUTH\_CHK in the database table TOLE contains the value "X" for the class. The authorization status can be checked with the function module AUTHORITY\_CHECK\_OLE.

System Fields

sy-subrc

Meaning

0

Automation object created.

1

Error in communication to the SAP GUI

2

Error in function call in the SAP GUI

3

Problems with memory allocation in the presentation layer.

Notes

-   For the declaration of ole, exactly the type ole2\_object must be specified. It is not sufficient to specify another type declared with a reference to ole2\_object.
    
-   An automation object ole created using CREATE OBJECT ole must also be released by using FREE OBJECT ole to avoid memory bottle necks and terminations of the application to be controlled.
    
-   CREATE OBJECT for OLE should not be confused with the statement of the same name in ABAP Objects.
    

Addition 1

... NO FLUSH

Effect

When using the addition NO FLUSH, calls from automation methods are collected in the automation buffer until the function module FLUSH (which is provided for this purpose) is called and the FREE OBJECT statement is passed or, at the most, until a change of [screen](javascript:call_link\('abenscreen_glosry.htm'\) "Glossary Entry"). They are then passed to the automation server in the current presentation layer for asynchronous execution. Without this addition, the flush is executed and the pass takes place as soon as a statement that does not belong to the automation command set is reached. Note that in the ABAP Debugger, the return values of the individual automation statements are not available until after the pass to the presentation layer.

Addition 2

... QUEUE-ONLY

Effect

The addition QUEUE-ONLY dictates that, in flushes, the new object is not passed to the specified ABAP data object rc as a return code using methods called by CALL METHOD OF. In this case, the automation buffer can only contain the statements CREATE OBJECT, CALL METHOD, and GET PROPERTY using the addition QUEUE-ONLY. When executing the program in the ABAP Debugger, the return values are passed by default.

Example

In this example, the automation object app is created, which has access to all methods and attributes of the class APPLICATION in the MS Excel Library. This class contains methods with which, for example, an Excel document can be opened or copied.

DATA app TYPE ole2\_object.
CREATE OBJECT app 'Excel.Application' NO FLUSH.



**📖 Source**: [abapcreate_object_ole2.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcreate_object_ole2.htm)

### abapcall_method_ole2.htm

> **📖 Official SAP Documentation**: [abapcall_method_ole2.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcall_method_ole2.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and OLE](javascript:call_link\('abenole2.htm'\)) → 

CALL METHOD - OLE

[Quick Reference](javascript:call_link\('abapcall_method_of_ole_shortref.htm'\))

Syntax

CALL METHOD OF ole meth *\[*\= rc*\]*
               *\[*EXPORTING p1 = f1 p2 = f2 ...*\]*
               *\[*NO FLUSH*\]* *\[*QUEUE-ONLY*\]*.

Extras:

[1.... EXPORTING p1 = f1 p2 = f2 ...](#!ABAP_ADDITION_1@1@)
[2.... NO FLUSH](#!ABAP_ADDITION_2@2@)
[3.... QUEUE-ONLY](#!ABAP_ADDITION_3@3@)

Effect

This statement calls the method meth of the automation object ole. The automation object must have been created using the special statement [CREATE OBJECT](javascript:call_link\('abapcreate_object_ole2.htm'\)) for automation objects. The name of the method has to be specified in a character-like data object meth.

The return value of the external method meth can be stored in a data object rc. This data object expects, in accordance with the called method, a character-like data type of length 8 or a data type of type ole2\_object from the [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") OLE2 to be able to accept the addressed object.

Addition 1

... EXPORTING p1 = f1 p2 = f2 ...

Effect

The addition EXPORTING can be used to assign actual parameters f1 f2 ... to the input parameters p1 p2 ... of the automation method. The data type of the data objects f1 f2 ... depends on the requirements of the automation method.

Addition 2

... NO FLUSH

Addition 3

... QUEUE-ONLY

Effect

The additions NO FLUSH and QUEUE-ONLY are described in the statement [CREATE OBJECT](javascript:call_link\('abapcreate_object_ole2.htm'\)).

System Fields

sy-subrc

Meaning

0

Method meth executed successfully.

1

Error in communication with SAP GUI.

2

Error when calling the method meth.

3

Error when setting an attribute.

4

Error when reading an attribute.

Example

Depending on the selection on the [selection screen](javascript:call_link\('abenselection_screen_glosry.htm'\) "Glossary Entry"), this source code can be used to open the Excel file Table.xls in directory C:\\temp, start the application Word, and then close both applications again. The automation methods used are listed in the following table.

Application

Method

Parameter

Function

Excel

Open

File name and path

Open

Excel

Quit

\-

Exit

Word

AppShow

\-

Start

Word

AppClose

\-

Exit

TABLES sscrfields.
DATA: excel TYPE ole2\_object,
      word  TYPE ole2\_object,
      book  TYPE ole2\_object,
      rc    TYPE c LENGTH 8.
SELECTION-SCREEN:
  BEGIN OF SCREEN 100 AS WINDOW TITLE title,
    BEGIN OF LINE,
      PUSHBUTTON  2(12) button\_1
                  USER-COMMAND word\_start,
      PUSHBUTTON  20(12) button\_2
                  USER-COMMAND excel\_start,
    END OF LINE,
    BEGIN OF LINE,
      PUSHBUTTON  2(12) button\_3
                  USER-COMMAND word\_stop,
      PUSHBUTTON  20(12) button\_4
                  USER-COMMAND excel\_stop,
    END OF LINE,
  END OF SCREEN 100.
START-OF-SELECTION.
  button\_1 = 'Start Word'.
  button\_2 = 'Start Excel'.
  button\_3 = 'Stop  Word'.
  button\_4 = 'Stop  Excel'.
  CALL SELECTION-SCREEN 100 STARTING AT 10 10.
AT SELECTION-SCREEN.
  CASE sscrfields-ucomm.
    WHEN 'WORD\_START'.
      CHECK word-handle <> -1.
      CHECK word-header = space.
      CREATE OBJECT   word  'Word.Basic'.
      CALL METHOD  OF word  'AppShow'.
    WHEN 'EXCEL\_START'.
      CHECK excel-handle = 0.
      CHECK excel-header = space.
      CREATE OBJECT   excel 'Excel.Application'.
      SET PROPERTY OF excel 'Visible' = 1.
      GET PROPERTY OF excel 'Workbooks' = book.
      CALL METHOD  OF book  'Open' = rc
        EXPORTING #1 = 'C:\\temp\\Table.xls'.
    WHEN 'WORD\_STOP'.
      CALL METHOD OF word 'AppClose'.
      FREE OBJECT word.
      CLEAR: word-handle, word-header.
    WHEN 'EXCEL\_STOP'.
      CALL METHOD OF  excel 'Quit'.
      FREE OBJECT excel.
      CLEAR: excel-handle, excel-header.
    WHEN OTHERS.
      LEAVE PROGRAM.
  ENDCASE.



**📖 Source**: [abapcall_method_ole2.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcall_method_ole2.htm)

### abapget_property.htm

> **📖 Official SAP Documentation**: [abapget_property.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_property.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and OLE](javascript:call_link\('abenole2.htm'\)) → 

GET PROPERTY - OLE

[Quick Reference](javascript:call_link\('abapget_property_shortref.htm'\))

Syntax

GET PROPERTY OF ole attr = dobj *\[*NO FLUSH*\]* *\[*QUEUE-ONLY*\]*
                                *\[*EXPORTING p1 = f1 p2 = f2 ...*\]*.

Extras:

[1\. ... NO FLUSH](#!ABAP_ADDITION_1@1@)
[2\. ... QUEUE-ONLY](#!ABAP_ADDITION_2@2@)
[3\. ... EXPORTING p1 = f1 p2 = f2 ...](#!ABAP_ADDITION_3@3@)

Effect

Assigns the content of the attribute attr of an automation object ole to the data object dobj. The automation object must have been created using the special statement [CREATE OBJECT](javascript:call_link\('abapcreate_object_ole2.htm'\)) for automation objects. For the [typing](javascript:call_link\('abentyping_glosry.htm'\) "Glossary Entry") of ole, the description of the statement CREATE OBJECT applies. The typing of the data object dobj depends on the properties of the automation attribute attr.

System Fields

sy-subrc

Meaning

0

Object attributes passed successfully.

1

Error in communication with SAP GUI.

2

Error in function call in SAP GUI.

3

Error when setting an attribute.

4

Error when reading an attribute.

Addition 1

... NO FLUSH

Addition 2

... QUEUE-ONLY

Effect

For the description of the NO FLUSH and QUEUE-ONLY additions, refer to the description of the statement [CREATE OBJECT](javascript:call_link\('abapcreate_object_ole2.htm'\)).

Addition 3

... EXPORTING p1 = f1 p2 = f2 ...

Effect

The addition EXPORTING can be assigned to the parameters p1 p2 ... of the actual parameters f1 f2 ... of the attribute, where the data type of the data objects f1 f2 ... depends on the requirements of the attribute.

Example

This example reads the attribute "Visible" of an Excel table created at runtime. This attribute specifies whether the table processing is visible or runs in the background. The variable vis is typed as an integer, because Excel passes an integer value.

DATA: vis TYPE i,
      app TYPE ole2\_object.
CREATE OBJECT app 'Excel.Application'.
GET PROPERTY OF app 'Visible' = vis.



**📖 Source**: [abapget_property.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_property.htm)

### abapset_property.htm

> **📖 Official SAP Documentation**: [abapset_property.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_property.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and OLE](javascript:call_link\('abenole2.htm'\)) → 

SET PROPERTY - OLE

[Quick Reference](javascript:call_link\('abapset_property_shortref.htm'\))

Syntax

SET PROPERTY OF ole attr = dobj *\[*NO FLUSH*\]*
                                *\[*EXPORTING p1 = f1 p2 = f2 ...*\]*.

Extras:

[1\. ... NO FLUSH](#!ABAP_ADDITION_1@1@)
[2\. ... EXPORTING p1 = f1 p2 = f2 ...](#!ABAP_ADDITION_2@2@)

Effect

The attribute attr of an automation object ole is set in accordance with the content of the data object dobj. The automation object must have been created using the special statement [CREATE OBJECT](javascript:call_link\('abapcreate_object_ole2.htm'\)) for automation objects. For the [typing](javascript:call_link\('abentyping_glosry.htm'\) "Glossary Entry") of ole, the description of the statement CREATE OBJECT applies. The typing of the data object dobj depends on the properties of the automation attribute attr.

System Fields

sy-subrc

Meaning

0

Object attributes passed successfully.

1

Error in communication with SAP GUI.

2

Error in function call in SAP GUI.

3

Error when setting an attribute.

4

Error when reading an attribute.

Addition 1

... NO FLUSH

Effect

The meaning of the addition NO FLUSH is included in the description of the statement [CREATE OBJECT](javascript:call_link\('abapcreate_object_ole2.htm'\)).

Addition 2

... EXPORTING p1 = f1 p2 = f2 ...

Effect

The addition EXPORTING can be assigned to the parameters p1 p2 ... of the actual parameters f1 f2 ... of the attribute, where the data type of the data objects f1 f2 ... depends on the requirements of the attribute.

Example

Calls the Office application Excel and displays an empty Excel table by assigning the value 1 to the attribute "Visible".

DATA app TYPE ole2\_object.
CREATE OBJECT app 'Excel.Application'.
SET PROPERTY OF app 'Visible' = 1.



**📖 Source**: [abapset_property.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_property.htm)

### abapfree_object.htm

> **📖 Official SAP Documentation**: [abapfree_object.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapfree_object.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and OLE](javascript:call_link\('abenole2.htm'\)) → 

FREE OBJECT - OLE

[Quick Reference](javascript:call_link\('abapfree_object_shortref.htm'\))

Syntax

FREE OBJECT ole *\[*NO FLUSH*\]*.

Addition:

[... NO FLUSH](#!ABAP_ONE_ADD@1@)

Effect

This statement releases the memory occupied by the object ole on the current [AS Instance](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry"). The automation object must have been created using the special statement [CREATE OBJECT](javascript:call_link\('abapcreate_object_ole2.htm'\)) for automation objects. After the release, the object is still available on the current automation server, but can no longer be processed in the ABAP program. For the [typing](javascript:call_link\('abentyping_glosry.htm'\) "Glossary Entry") of ole, the description of the statement CREATE OBJECT applies.

When the statement FREE OBJECT is passed to the presentation layer, the entire automation queue collected using the addition NO FLUSH is passed.

System Fields

sy-subrc

Meaning

0

Memory released successfully.

1

Error in communication with SAP GUI.

2

Error in function call in SAP GUI.

Note

An automation object ole created using CREATE OBJECT must also be released using FREE OBJECT to avoid memory bottlenecks and terminations of the application.

Addition

... NO FLUSH

Effect

The meaning of the addition NO FLUSH is included in the description of the statement [CREATE OBJECT](javascript:call_link\('abapcreate_object_ole2.htm'\)).

Example

Releases an Excel object.

DATA app TYPE ole2\_object.
CREATE OBJECT app 'Excel.Application' NO FLUSH.
...
FREE OBJECT app NO FLUSH.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and Operating System Statements

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and Operating System Statements

Included pages: 6



**📖 Source**: [abapfree_object.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapfree_object.htm)

### abenabap_system_commands.htm

> **📖 Official SAP Documentation**: [abenabap_system_commands.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) → 

ABAP and Operating System Statements

Operating system statements or system commands execute statements or programs directly on the operating system of the host computer of an AS Instance or of a presentation server. Executing operating system statements from ABAP programs should be the exception not the rule, however it may become necessary in system or administration programs to call operating system functions that cannot be accessed by ABAP statements. In certain circumstances, input from external sources may need to be passed to the operating system.

-   [Operating System Statements of the Host Computer](javascript:call_link\('abenabap_system_commands_appl.htm'\))

-   [Operating System Statements of the Presentation Server](javascript:call_link\('abenabap_system_commands_pres.htm'\))

Security Note

Using input from external sources in operating system statements incurs the risk of [system command injections](javascript:call_link\('abensys_comm_injections_scrty.htm'\)).

Continue
[Operating System Statements of the Host Computer](javascript:call_link\('abenabap_system_commands_appl.htm'\))
[Operating System Statements of the Presentation Server](javascript:call_link\('abenabap_system_commands_pres.htm'\))



**📖 Source**: [abenabap_system_commands.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands.htm)

### abenabap_system_commands_appl.htm

> **📖 Official SAP Documentation**: [abenabap_system_commands_appl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands_appl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and Operating System Statements](javascript:call_link\('abenabap_system_commands.htm'\)) → 

Operating System Statements of the Host Computer

There is one recommended framework when executing operating system statements on the [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") of the current [AS Instance](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry") and two unwanted methods:

-   [SXPG Framework for Operating System Statements](javascript:call_link\('abenabap_system_commands_appl_sxpg.htm'\))

-   [Unwanted Calls of Operating System Statements](javascript:call_link\('abenabap_system_commands_appl_depr.htm'\))

Continue
[SXPG Framework for Operating System Statements](javascript:call_link\('abenabap_system_commands_appl_sxpg.htm'\))
[Unwanted Calls of Operating System Statements](javascript:call_link\('abenabap_system_commands_appl_depr.htm'\))



**📖 Source**: [abenabap_system_commands_appl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands_appl.htm)

### abenabap_system_commands_appl_sxpg.htm

> **📖 Official SAP Documentation**: [abenabap_system_commands_appl_sxpg.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands_appl_sxpg.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and Operating System Statements](javascript:call_link\('abenabap_system_commands.htm'\)) →  [Operating System Statements of the Host Computer](javascript:call_link\('abenabap_system_commands_appl.htm'\)) → 

SXPG Framework for Operating System Statements

The only recommended method for executing operating system statements from ABAP on the operating system of the [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") of the current AS Instance or another server is to use the SXPG framework. This framework is based on a list of permitted operating system statements that can be called using function modules in the function group SXPG.

The list of permitted operating system statements is defined by the system administrator in transaction SM69. Here, the platform-dependent physical operating system statements are assigned to a logical command name used to address them in ABAP. When one of these logical command names is passed to one of the function modules listed below, the operating system statement appropriate for the platform in question is executed. Logical command names assigned to an operating system command used by all platforms can be flagged with the operating system ANYOS. Static parameters can be assigned to any operating system statement and further parameters can be specified for when the statement is called. When an operating system statement is called using a logical command name, implicit authorization checks are performed, accompanied by extra self-defined checks. SAP provides a range of predefined logical command names with the type SAP. Logical command names created by customers have the type KUNDE.

If they have the right authorizations, developers can view the list of operating system statements in transaction SM49 and execute them from here. The following function modules can be called from ABAP programs:

These function modules can also be called remotely.

Note

For more information, see the Documentation Programming with External Commands in [SAP Help Portal](http://help.sap.com).

Example

Calls the operating system statement ping for the central database server of the system on the host computer of the current AS Instance using the logical command name PING defined by SAP. The result of the call is passed to the internal table result. The function module SXPG\_CALL\_SYSTEM can raise more specific exceptions than those handled explicitly here.

DATA dbserver TYPE c LENGTH 255.
CALL 'C\_SAPGPARAM' ID 'NAME'  FIELD 'SAPDBHOST'
                   ID 'VALUE' FIELD  dbserver.
DATA parameters TYPE sxpgcolist-parameters.
parameters = |-c1 { dbserver }|.
DATA result TYPE TABLE OF btcxpm WITH EMPTY KEY.
CALL FUNCTION 'SXPG\_CALL\_SYSTEM'
  EXPORTING
    commandname           = 'PING'
    additional\_parameters = parameters
  TABLES
    exec\_protocol         = result
  EXCEPTIONS
    no\_permission         = 1
    command\_not\_found     = 2
    security\_risk         = 3
    OTHERS                = 4.
IF sy-subrc = 0.
  cl\_demo\_output=>display( result ).
ELSE.
  cl\_demo\_output=>display( |Error, return code { sy-subrc }| ).
ENDIF.



**📖 Source**: [abenabap_system_commands_appl_sxpg.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands_appl_sxpg.htm)

### abenabap_system_commands_appl_depr.htm

> **📖 Official SAP Documentation**: [abenabap_system_commands_appl_depr.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands_appl_depr.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and Operating System Statements](javascript:call_link\('abenabap_system_commands.htm'\)) →  [Operating System Statements of the Host Computer](javascript:call_link\('abenabap_system_commands_appl.htm'\)) → 

Unwanted Calls of Operating System Statements

Alongside calls of function modules in the [SXPG framework](javascript:call_link\('abenabap_system_commands_appl_sxpg.htm'\)), operating system statements for the [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") of the current AS Instance can be executed in ABAP programs as follows:

-   The addition [FILTER](javascript:call_link\('abapopen_dataset_os_addition.htm'\)) of the statement [OPEN DATASET](javascript:call_link\('abapopen_dataset.htm'\)) used for executing operating system statements using pipes.

-   The internal statement [CALL](javascript:call_link\('abapcall-.htm'\)) used to call a special system function (SYSTEM), which can be used to execute operating system statements.

Neither of these options should be used for common execution of operating system statements in ABAP programs.

-   The addition [FILTER](javascript:call_link\('abapopen_dataset_os_addition.htm'\)) of [OPEN DATASET](javascript:call_link\('abapopen_dataset.htm'\)) should only be used (if at all) for operating system statements required for data handling.

-   Calls of the system function SYSTEM with the internal statement [CALL](javascript:call_link\('abapcall-.htm'\)) should never be made and can be deactivated using the [profile parameter](javascript:call_link\('abenprofile_parameter_glosry.htm'\) "Glossary Entry") rdisp/call\_system. If called, it then raises a non-handleable exception.

Both statements cause the following problems:

-   There are no central authorization checks.

-   The platform dependency of the operating system statements must be handled in the ABAP program itself.

-   Errors and exceptions cannot be handled specifically.

-   If input from external sources is used, it must be checked thoroughly and filtered to prevent [system command injections](javascript:call_link\('abensys_comm_injections_scrty.htm'\)) on any platform.

If possible, the [SXPG framework](javascript:call_link\('abenabap_system_commands_appl_sxpg.htm'\)) should be used instead of these two options.

Note

Before the statements CALL 'SYSTEM' is deactivated using the [profile parameter](javascript:call_link\('abenprofile_parameter_glosry.htm'\) "Glossary Entry") rdisp/call\_system, it must be ensured that it is no longer used in any programs. Any programs that still use CALL 'SYSTEM' must first be switched to use of the [SXPG frameworks](javascript:call_link\('abenabap_system_commands_appl_sxpg.htm'\)) before the unwanted statement can be deactivated. The options in the SXPG frameworks generally cover all requirements when calling operating system statements.

Example

Calls the operating system statement ping for the central database server of the system on the [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") of the current AS Instance using the addition FILTER of the statement OPEN DATASET. The output of the operating system statement is written to the opened file and can be read from there.

DATA dbserver TYPE c LENGTH 255.
CALL 'C\_SAPGPARAM' ID 'NAME'  FIELD 'SAPDBHOST'
                   ID 'VALUE' FIELD  dbserver.
DATA(command) = |ping -c1 { dbserver }|.
DATA(fname) = 'result.dat'.
OPEN DATASET fname FOR OUTPUT IN BINARY MODE FILTER command.
CLOSE DATASET fname.
OPEN DATASET fname FOR INPUT IN BINARY MODE.
DATA result TYPE xstring.
READ DATASET fname INTO result.
CLOSE DATASET fname.
cl\_demo\_output=>display(
  cl\_abap\_conv\_codepage=>create\_in( )->convert( result ) ).

Example

Calls the operating system statement ping for the central database server of the system on the [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") of the current AS Instance using the addition SYSTEM. The result of the call is passed to the internal table result. This example can only be executed if the [profile parameter](javascript:call_link\('abenprofile_parameter_glosry.htm'\) "Glossary Entry") rdisp/call\_system permits the call.

TYPES char255 TYPE c LENGTH 255.
DATA dbserver TYPE char255.
CALL 'C\_SAPGPARAM' ID 'NAME'  FIELD 'SAPDBHOST'
                   ID 'VALUE' FIELD  dbserver.
DATA command TYPE char255.
command = |ping -c1 { dbserver }|.
DATA result  TYPE TABLE OF char255 WITH EMPTY KEY.
CALL 'SYSTEM' ID 'COMMAND' FIELD command
              ID 'TAB'     FIELD result.
cl\_demo\_output=>display( result ).



**📖 Source**: [abenabap_system_commands_appl_depr.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands_appl_depr.htm)

### abenabap_system_commands_appl.htm

> **📖 Official SAP Documentation**: [abenabap_system_commands_appl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands_appl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and Operating System Statements](javascript:call_link\('abenabap_system_commands.htm'\)) → 

Operating System Statements of the Host Computer

There is one recommended framework when executing operating system statements on the [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry") of the current [AS Instance](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry") and two unwanted methods:

-   [SXPG Framework for Operating System Statements](javascript:call_link\('abenabap_system_commands_appl_sxpg.htm'\))

-   [Unwanted Calls of Operating System Statements](javascript:call_link\('abenabap_system_commands_appl_depr.htm'\))

Continue
[SXPG Framework for Operating System Statements](javascript:call_link\('abenabap_system_commands_appl_sxpg.htm'\))
[Unwanted Calls of Operating System Statements](javascript:call_link\('abenabap_system_commands_appl_depr.htm'\))



**📖 Source**: [abenabap_system_commands_appl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands_appl.htm)

### abenabap_system_commands_pres.htm

> **📖 Official SAP Documentation**: [abenabap_system_commands_pres.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands_pres.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [ABAP and Operating System Statements](javascript:call_link\('abenabap_system_commands.htm'\)) → 

Operating System Statements of the Presentation Server

The method EXECUTE of the class [CL\_GUI\_FRONTEND\_SERVICES](javascript:call_link\('abenfrontend_services.htm'\)) can be used to call operating system statements of the presentation server. To make this possible, however, the current ABAP program must be executed in [dialog](javascript:call_link\('abendialog_processing_glosry.htm'\) "Glossary Entry") and from SAP GUI.

Note

The method EXECUTE of the class CL\_GUI\_FRONTEND\_SERVICES replaces the obsolete function module WS\_EXECUTE.

Example

Calls the command line window in MS Windows.

cl\_gui\_frontend\_services=>execute(
   EXPORTING
     application           = 'cmd.exe'
    default\_directory      = 'C:\\'
  EXCEPTIONS
    cntl\_error = 1
    error\_no\_gui           = 2
    bad\_parameter          = 3
    file\_not\_found   = 4
    path\_not\_found         = 5
    file\_extension\_unknown = 6
    error\_execute\_failed   = 7
    synchronous\_failed     = 8
    not\_supported\_by\_gui   = 9
    OTHERS = 10 ).
IF sy-subrc <> 0.
  ...
ENDIF.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / Internal Statement for System Function Call

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / Internal Statement for System Function Call

Included pages: 2



**📖 Source**: [abenabap_system_commands_pres.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_system_commands_pres.htm)

### abendata_communication_internal.htm

> **📖 Official SAP Documentation**: [abendata_communication_internal.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendata_communication_internal.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) → 

Internal Statement for System Function Call

This statement is for internal use only.
It must not be used in application programs.

-   [CALL cfunc](javascript:call_link\('abapcall-.htm'\))

Continue
[CALL - System Function Call](javascript:call_link\('abapcall-.htm'\))



**📖 Source**: [abendata_communication_internal.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendata_communication_internal.htm)

### abapcall-.htm

> **📖 Official SAP Documentation**: [abapcall-.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcall-.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Data Interfaces and Communication Interfaces](javascript:call_link\('abenabap_data_communication.htm'\)) →  [Internal Statement for System Function Call](javascript:call_link\('abendata_communication_internal.htm'\)) → 

CALL - System Function Call

This statement is for internal use only.
It must not be used in application programs.

Syntax

CALL cfunc.

Addition:

[... ID id1 FIELD f1 ... ID idn FIELD fn](#!ABAP_ONE_ADD@1@)

Effect

Calls the system function cfunc. A flat character-like data object containing the name of the function can be specified for cfunc. The function must be entered in the file sapactab.h. Modifying a function or creating a new function requires the ABAP kernel to be compiled again and linked. This requires the C source code files.

System Fields

The CALL statement itself does not set any system fields. Whether system fields such as sy-subrc are set depends on the system function called.

Notes

-   If possible, use [kernel methods](javascript:call_link\('abenkernel_methods.htm'\)) instead of system functions.
    
-   External programs should be called using the RFC mechanism: [CALL FUNCTION ... DESTINATION](javascript:call_link\('abapcall_function_destination.htm'\)).
    
-   With some critical C functions, the system performs an authorization check automatically. If the user does not have the appropriate authorization, a runtime error occurs. The authorization can be checked using the function module AUTHORITY\_CHECK\_C\_FUNCTION.
    
-   The use of the system function SYSTEM, which can be used to execute operating system statements of the current [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry"), is not recommended and can be deactivated using the [profile parameter](javascript:call_link\('abenprofile_parameter_glosry.htm'\) "Glossary Entry") rdisp/call\_system. If called, it then raises a non-handleable exception. If absolutely necessary, operating system statements can be called using the function modules in the [SXPG framework](javascript:call_link\('abenabap_system_commands_appl_sxpg.htm'\)). This addresses specific statements using logical command names created by the system administrator in the transaction SM68. See also [Unwanted Calls of Operating System Statements](javascript:call_link\('abenabap_system_commands_appl_depr.htm'\)).
    

Security Note

Calls of system functions whose names or parameters are injected into the program from outside present a serious security risk. The values from outside must be checked thoroughly before being used. See [System Command Injections](javascript:call_link\('abensys_comm_injections_scrty.htm'\)).

Addition

... ID id1 FIELD f1 ... ID idn FIELD fn

Effect

Passes fields to the called program using pass by reference. ID id1 is used to specify the name of a formal parameter and FIELD f1 is used to specify the associated field from the ABAP program. If a formal parameter expects an internal table, the latter is passed in the form FIELD tab\[\].

Example

Query of the current database server.

DATA dbserver TYPE c LENGTH 255.
CALL 'C\_SAPGPARAM' ID 'NAME'  FIELD 'SAPDBHOST'
                   ID 'VALUE' FIELD  dbserver.

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Non-Handleable Exceptions

-   Cause: No authorization to call this C function.
    Runtime error: CALL\_C\_FUNCTION\_NO\_AUTHORITY
    
-   Cause: The system function specified is unknown.
    Runtime error: CALL\_C\_FUNCTION\_NOT\_FOUND
    
-   Cause: The system function SYSTEM is disabled.
    Runtime error: CALL\_SYSTEM\_DISABLED


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Dynpros / User Interface

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Dynpros / User Interface

Included pages: 2



**📖 Source**: [abapcall-.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcall-.htm)

### abenabap_dynpros_gui.htm

> **📖 Official SAP Documentation**: [abenabap_dynpros_gui.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_dynpros_gui.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Dynpros](javascript:call_link\('abenabap_dynpros.htm'\)) → 

User Interface

For the execution of user dialogs, input and output services are required that can be accessed through a user interface (UI). A user interface is used for the interaction between a user and a program. If parts of the user interface are displayed in the GUI window on the screen, this is a graphical user interface (GUI). The SAP-specific implementation for the execution of dialog-based applications with [dynpros](javascript:call_link\('abensap_nw_abap_glosry.htm'\) "Glossary Entry") is SAP GUI, which is installed as a component of the [AS ABAP](javascript:call_link\('abensap_nw_abap_glosry.htm'\) "Glossary Entry") [presentation layer](javascript:call_link\('abenpresentation_layer_glosry.htm'\) "Glossary Entry") on the presentation servers. It contains all the control elements that are required for execution of dialogs between the user and the program. The operating elements of the SAP GUI are represented schematically in the following diagram:

![Figure](abdoc_gui.gif)

On the screen, SAP GUI presents the [screen](javascript:call_link\('abenscreen_glosry.htm'\) "Glossary Entry") of a dynpro (dynamic program) in a GUI window. The screen can contain screen elements for displaying contents or for receiving user actions. The screen and its screen elements are processed using [Layout Editor](javascript:call_link\('abenlayout_editor_glosry.htm'\) "Glossary Entry") in the Screen Painter tool. Each screen element has properties that are statically predefined in [Screen Painter](javascript:call_link\('abenscreen_painter_glosry.htm'\) "Glossary Entry") and, in part, can be modified dynamically in the ABAP program.

As a further part of the graphical user interface, each standard window contains a menu bar, a standard toolbar, and an application toolbar. GUI windows that are displayed as a modal dialog box contain only an application toolbar. The bars are standalone components of the ABAP program and are grouped together in a GUI status. Also, they are assigned to a dynpro when the GUI status is set. In addition to the graphical elements, the function keys are part of the user interface. They are defined as an independent component of the ABAP program and therefore part of a GUI status. The components of the GUI status and the GUI status itself are processed using the Menu Painter tool. For the most part, the control elements presented by the user interface are linked with the function codes, which can be evaluated in the ABAP program. The description of the current GUI status can be found in the system field sy-pfkey.

A GUI window in SAP GUI is complete when it has a title bar and a status bar. The title bar, which is also edited using Menu Painter, contains the heading of the GUI window. The status bar displays information that can be transmitted, among other things, during the execution of an ABAP program using the [MESSAGE](javascript:call_link\('abapmessage.htm'\)) statement. In addition, it contains system information that can be displayed or hidden through an icon on the right-hand side of the bar.

Continue
![Example](exa.gif "Example") [Dynpros, GUI Status, and Function Codes](javascript:call_link\('abendynpro_gui_status_abexa.htm'\))



**📖 Source**: [abenabap_dynpros_gui.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_dynpros_gui.htm)

### abendynpro_gui_status_abexa.htm

> **📖 Official SAP Documentation**: [abendynpro_gui_status_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendynpro_gui_status_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Dynpros](javascript:call_link\('abenabap_dynpros.htm'\)) →  [User Interface](javascript:call_link\('abenabap_dynpros_gui.htm'\)) → 

Dynpros, GUI Status, and Function Codes

This example demonstrates how to set the GUI status and evaluate function codes.

Source Code

PROGRAM demo\_dynpro\_gui\_status.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok LIKE ok\_code,
      output  LIKE ok\_code.
CALL SCREEN 100.
MODULE init\_screen\_0100 OUTPUT.
  SET PF-STATUS 'STATUS\_100'.
  SET TITLEBAR '100'.
ENDMODULE.
MODULE user\_command\_0100 INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  CASE save\_ok.
    WHEN 'BACK' OR 'EXIT' OR 'CANCEL'.
      LEAVE PROGRAM.
    WHEN OTHERS.
      output = save\_ok.
  ENDCASE.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The screen field of output is defined as not ready for input in Screen Painter. The module init\_screen\_0100 sets the GUI status status\_0100 and the title 100 in the PBO event. All function codes exist as menu entries, but not all of them are assigned to function keys. The function codes in the standard toolbar activate the icons and are automatically assigned to their function keys. Some of the additional function keys are assigned to the application toolbar. The module user\_command\_0100 first assigns the contents of the field ok\_code to the helper variable save\_ok and initializes ok\_code. This procedure is always recommended since it makes sure that the dynpro field ok\_code is also reinitialized in the PBO event and does not contain any unwanted values. Then the function code chosen is assigned to the field output and displayed in the corresponding screen field, except for BACK, EXIT, and CANCEL. The latter exits the program. The function code SELE can be passed to the ABAP program in the following ways:

-   Choosing Choose in the Edit menu

-   Choosing the Choose pushbutton in the application toolbar

-   Choosing F2 on the keyboard

-   Pressing the right mouse button and choosing Choose

-   Double-clicking the screen field of output

-   Entering SELE in the command field and choosing ENTER

The other function codes are passed in accordance with their definition, but without the double-click function.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / WRITE / WRITE - ext_format_options

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / WRITE / WRITE - list_elements

Included pages: 2



**📖 Source**: [abendynpro_gui_status_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendynpro_gui_status_abexa.htm)

### abapwrite_list_elements.htm

> **📖 Official SAP Documentation**: [abapwrite_list_elements.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapwrite_list_elements.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Creating Lists](javascript:call_link\('abenabap_lists.htm'\)) →  [WRITE](javascript:call_link\('abapwrite-.htm'\)) → 

WRITE - list\_elements

[Quick Reference](javascript:call_link\('abapwrite_shortref.htm'\))

Syntax

... *{*AS CHECKBOX*}*
  *|* *{*AS ICON*}*
  *|* *{*AS SYMBOL*}*
  *|* *{*AS LINE*}* ...

Alternatives:

[1\. ... AS CHECKBOX](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... AS ICON](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... AS SYMBOL](#!ABAP_ALTERNATIVE_3@3@)
[4\. ... AS LINE](#!ABAP_ALTERNATIVE_4@4@)

Effect

These additions are used to represent special list elements.

The data object dobj in the output must have certain properties. The additions cannot be used together. If they are used with the additions for [internal formats](javascript:call_link\('abapwrite_int_options.htm'\)) and [external formats](javascript:call_link\('abapwrite_ext_options.htm'\)), they can only be used to a limited extent.

Alternative 1

... AS CHECKBOX

Effect

The output of this addition is a single-character checkbox that is ready for input. dobj expects a character-like data type of length 1. If the first character in dobj is "X" or "x", the checkbox is shown as selected. If the first character is not "X" or "x", the checkbox is shown as empty. If dobj is an empty data object of the type string, the checkbox is not in the output.

The user can select and deselect the checkbox in the list displayed on the screen. If the user selects the checkbox, the first character of the assigned field in the list is set to "X". If the user deselects it, it is set to blank. The change is stored in the list buffer and can be evaluated during a list event.

If the addition AS CHECKBOX is used, no list output len is allowed after AT. Except for INPUT, NO-GAP, and UNDER, the other additions specified at the same time for [internal formats](javascript:call_link\('abapwrite_int_options.htm'\)) and [external formats](javascript:call_link\('abapwrite_ext_options.htm'\)) are ignored.

The addition AS CHECKBOX has the same effect as specifying the addition INPUT ON simultaneously. The standard settings or a format INPUT OFF set by a FORMAT statement are overridden for the current WRITE statement. To make the checkbox not ready for input, the addition INPUT OFF must be used simultaneously.

Notes

-   If a list line contains only a checkbox with a blank, it is displayed only if the statement SET BLANK LINES ON is executed beforehand.
    
-   By default, addition [HOTSPOT ON](javascript:call_link\('abapformat.htm'\)) has no effect on a checkbox. [HOTSPOT ON](javascript:call_link\('abapformat.htm'\)) only has an effect, if INPUT OFF is deactivated.
    

Example

Displays two checkbox fields and evaluates the user input in the event AT LINE-SELECTION.

REPORT test NO STANDARD PAGE HEADING.
DATA: check1 TYPE c LENGTH 1 VALUE 'X',
      check2 TYPE c LENGTH 1 VALUE ' '.
START-OF-SELECTION.
  WRITE: / check1 AS CHECKBOX, 'Checkbox 1',
         / check2 AS CHECKBOX, 'Checkbox 2'.
AT LINE-SELECTION.
  READ: LINE 1 FIELD VALUE check1,
        LINE 2 FIELD VALUE check2.

Alternative 2

... AS ICON

Effect

This addition produces icons. Be aware that not all icons are suitable for spool lists. dobj expects data objects of the type c whose initial characters can be interpreted as the internal ID of an icon by the runtime environment.

In the [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") ICON, a constant is declared for each icon that can be displayed. The names of the constants can be taken from the type group or the output of the SHOWICON program. This program also shows the corresponding output length and whether an icon can be spooled or not.

If the content of dobj cannot be interpreted as an icon or the content is changed by concurrent use of other additions for [internal formats](javascript:call_link\('abapwrite_int_options.htm'\)) or [external formats](javascript:call_link\('abapwrite_ext_options.htm'\)), blanks are produced instead of icons.

Notes

-   None of the additions from the [internal formats](javascript:call_link\('abapwrite_int_options.htm'\)) and [external formats](javascript:call_link\('abapwrite_ext_options.htm'\)) are forbidden. When using these additions, care must be taken that the content of dobj can be interpreted as an icon.
    
-   The [output length](javascript:call_link\('abenwrite_output_length.htm'\)) is determined, as usual, either implicitly using the data type of dobj or by being specified explicitly. Characters in the output area that do not have the icon are set to blanks.
    
-   The program SHOWICON shows two internal IDs for each icon:
    

-   A two-digit hexadecimal number as the key.

-   A six-character string composed of uppercase letters and any underscores as the internal name.

If a character string that is output using WRITE has an internal ID of this type between two "@" characters at the start, this is represented as an icon in the list output, even without the addition AS ICON. This can lead to unwanted of icons and unexpected effects in terms of the output length. By default, the output length is determined by the length of the character string. However, this attribute can also be exploited, for example, to use icons at the start of [text symbols](javascript:call_link\('abentext_symbol_glosry.htm'\) "Glossary Entry"). IDs that are not at the start are not represented as icons.

Example

Displays a traffic light icon.

WRITE icon\_green\_light AS ICON.

Example

Displaying traffic light icons using their internal IDs (key and internal name). The IDs that are not at the start of the character string are not converted.

WRITE: / 'xxx', '@08@xxx    ', 'xxx@08@xxx'.
WRITE: / 'xxx', '@S\_TL\_G@xxx', 'xxx@S\_TL\_G@xxx'.

Alternative 3

... AS SYMBOL

Effect

This addition produces all the characters of the data object dobj as symbols. The [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") SYM declares constants with a length of 1 for each character that can be displayed as a symbol, and whose name reflects the meaning of the symbol. The names of the constants and the meaning and length of the symbols can be taken from the type group or from the output of the program SHOWSYMB.

Note

The [output length](javascript:call_link\('abenwrite_output_length.htm'\)) is determined, as usual, either implicitly using the data type of dobj or by being specified explicitly.

Example

Displays a hand symbol.

WRITE sym\_left\_hand AS SYMBOL.

Alternative 4

... AS LINE

Effect

This addition produces [line elements](javascript:call_link\('abenline_element_glosry.htm'\) "Glossary Entry") with the output length 1. Line elements are corners, crosses, lines, and T sections. dobj expects data objects of the type c whose content can be interpreted as line elements by the runtime environment. The [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") LINE declares the line element constants displayed in the following table.

Constant

Meaning

line\_space

Blank

line\_top\_left\_corner

Top left corner

line\_bottom\_left\_corner

Bottom left corner

line\_top\_right\_corner

Top right corner

line\_bottom\_right\_corner

Bottom right corner

line\_horizontal\_line

Horizontal line

line\_vertical\_line

Vertical line

line\_left\_middle\_corner

T section turned to the left

line\_right\_middle\_corner

T section turned to the right

line\_bottom\_middle\_corner

Reversed T section

line\_top\_middle\_corner

T section

line\_cross

Cross

If dobj has different content or the content is changed by concurrent use of other additions for [internal formats](javascript:call_link\('abapwrite_int_options.htm'\)), a blank is produced instead of a line element. The addition FRAMES OFF must not be specified simultaneously. The other additions for [external formats](javascript:call_link\('abapwrite_ext_options.htm'\)) and QUICKINFO are ignored in the output of line elements.

Notes

-   The characters "-" and "|" and produced using ULINE are [joined with each other](javascript:call_link\('abenwrite_lines.htm'\)) by default, if no other characters exist between them. Here the system replaces the characters by the above line elements. A standalone character "|" is always replaced by a vertical line. The "-" characters from sy-uline are always replaced by a horizontal line. The default behavior can be switched off using the addition [FRAMES OFF](javascript:call_link\('abapformat.htm'\)).
    
-   The addition AS LINE produces line elements in the exact way they are defined. Links are produced only where line elements actually meet each other. The system does not, however, create any automatic extensions between the characters "-" or "|" and line elements produced explicitly using AS LINE.
    

Example

Produces four adjoining rectangles.

WRITE: /10 line\_top\_left\_corner      AS LINE NO-GAP,
           line\_top\_middle\_corner    AS LINE NO-GAP,
           line\_top\_right\_corner     AS LINE,
       /10 line\_left\_middle\_corner   AS LINE NO-GAP,
           line\_cross                AS LINE NO-GAP,
           line\_right\_middle\_corner  AS LINE,
       /10 line\_bottom\_left\_corner   AS LINE NO-GAP,
           line\_bottom\_middle\_corner AS LINE NO-GAP,
           line\_bottom\_right\_corner  AS LINE.

Continue
![Example](exa.gif "Example") [Lists, Line Elements](javascript:call_link\('abenlist_line_elements_abexa.htm'\))



**📖 Source**: [abapwrite_list_elements.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapwrite_list_elements.htm)

### abenlist_line_elements_abexa.htm

> **📖 Official SAP Documentation**: [abenlist_line_elements_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_line_elements_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Creating Lists](javascript:call_link\('abenabap_lists.htm'\)) →  [WRITE](javascript:call_link\('abapwrite-.htm'\)) →  [WRITE - list\_elements](javascript:call_link\('abapwrite_list_elements.htm'\)) → 

Lists, Line Elements

This example demonstrates line elements on lists.

Source Code

REPORT demo\_list\_line\_elements NO STANDARD PAGE HEADING LINE-SIZE 60.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA: x TYPE i,
                y TYPE i.
    CLASS-METHODS pos.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: x0 TYPE i VALUE 10,
          y0 TYPE i VALUE 10,
          n  TYPE i VALUE 16,
          i  TYPE i VALUE 0.
    x = x0.
    y = y0.
    pos( ).
    WHILE i LE n.
      WRITE line\_bottom\_left\_corner AS LINE.
      x = x + 1. pos( ).
      ULINE AT x(i).
      x = x + i. pos( ).
      WRITE line\_bottom\_right\_corner AS LINE.
      y = y - 1. pos( ).
      DO i TIMES.
        WRITE '|'.
        y = y - 1. pos( ).
      ENDDO.
      WRITE line\_top\_right\_corner AS LINE.
      i = i + 1.
      x = x - i. pos( ).
      ULINE AT x(i).
      x = x - 1. pos( ).
      WRITE line\_top\_left\_corner AS LINE.
      y = y + 1. pos( ).
      DO i TIMES.
        WRITE '|'.
        y = y + 1. pos( ).
      ENDDO.
      i = i + 1.
    ENDWHILE.  ENDMETHOD.
  METHOD pos.
    SKIP TO LINE y.
    POSITION x.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Displays a spiral using line elements and joins these automatically in a list.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / WRITE / WRITE - list_elements

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / WRITE / WRITE - list_elements

Included pages: 2



**📖 Source**: [abenlist_line_elements_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_line_elements_abexa.htm)

### abapwrite_list_elements.htm

> **📖 Official SAP Documentation**: [abapwrite_list_elements.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapwrite_list_elements.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Creating Lists](javascript:call_link\('abenabap_lists.htm'\)) →  [WRITE](javascript:call_link\('abapwrite-.htm'\)) → 

WRITE - list\_elements

[Quick Reference](javascript:call_link\('abapwrite_shortref.htm'\))

Syntax

... *{*AS CHECKBOX*}*
  *|* *{*AS ICON*}*
  *|* *{*AS SYMBOL*}*
  *|* *{*AS LINE*}* ...

Alternatives:

[1\. ... AS CHECKBOX](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... AS ICON](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... AS SYMBOL](#!ABAP_ALTERNATIVE_3@3@)
[4\. ... AS LINE](#!ABAP_ALTERNATIVE_4@4@)

Effect

These additions are used to represent special list elements.

The data object dobj in the output must have certain properties. The additions cannot be used together. If they are used with the additions for [internal formats](javascript:call_link\('abapwrite_int_options.htm'\)) and [external formats](javascript:call_link\('abapwrite_ext_options.htm'\)), they can only be used to a limited extent.

Alternative 1

... AS CHECKBOX

Effect

The output of this addition is a single-character checkbox that is ready for input. dobj expects a character-like data type of length 1. If the first character in dobj is "X" or "x", the checkbox is shown as selected. If the first character is not "X" or "x", the checkbox is shown as empty. If dobj is an empty data object of the type string, the checkbox is not in the output.

The user can select and deselect the checkbox in the list displayed on the screen. If the user selects the checkbox, the first character of the assigned field in the list is set to "X". If the user deselects it, it is set to blank. The change is stored in the list buffer and can be evaluated during a list event.

If the addition AS CHECKBOX is used, no list output len is allowed after AT. Except for INPUT, NO-GAP, and UNDER, the other additions specified at the same time for [internal formats](javascript:call_link\('abapwrite_int_options.htm'\)) and [external formats](javascript:call_link\('abapwrite_ext_options.htm'\)) are ignored.

The addition AS CHECKBOX has the same effect as specifying the addition INPUT ON simultaneously. The standard settings or a format INPUT OFF set by a FORMAT statement are overridden for the current WRITE statement. To make the checkbox not ready for input, the addition INPUT OFF must be used simultaneously.

Notes

-   If a list line contains only a checkbox with a blank, it is displayed only if the statement SET BLANK LINES ON is executed beforehand.
    
-   By default, addition [HOTSPOT ON](javascript:call_link\('abapformat.htm'\)) has no effect on a checkbox. [HOTSPOT ON](javascript:call_link\('abapformat.htm'\)) only has an effect, if INPUT OFF is deactivated.
    

Example

Displays two checkbox fields and evaluates the user input in the event AT LINE-SELECTION.

REPORT test NO STANDARD PAGE HEADING.
DATA: check1 TYPE c LENGTH 1 VALUE 'X',
      check2 TYPE c LENGTH 1 VALUE ' '.
START-OF-SELECTION.
  WRITE: / check1 AS CHECKBOX, 'Checkbox 1',
         / check2 AS CHECKBOX, 'Checkbox 2'.
AT LINE-SELECTION.
  READ: LINE 1 FIELD VALUE check1,
        LINE 2 FIELD VALUE check2.

Alternative 2

... AS ICON

Effect

This addition produces icons. Be aware that not all icons are suitable for spool lists. dobj expects data objects of the type c whose initial characters can be interpreted as the internal ID of an icon by the runtime environment.

In the [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") ICON, a constant is declared for each icon that can be displayed. The names of the constants can be taken from the type group or the output of the SHOWICON program. This program also shows the corresponding output length and whether an icon can be spooled or not.

If the content of dobj cannot be interpreted as an icon or the content is changed by concurrent use of other additions for [internal formats](javascript:call_link\('abapwrite_int_options.htm'\)) or [external formats](javascript:call_link\('abapwrite_ext_options.htm'\)), blanks are produced instead of icons.

Notes

-   None of the additions from the [internal formats](javascript:call_link\('abapwrite_int_options.htm'\)) and [external formats](javascript:call_link\('abapwrite_ext_options.htm'\)) are forbidden. When using these additions, care must be taken that the content of dobj can be interpreted as an icon.
    
-   The [output length](javascript:call_link\('abenwrite_output_length.htm'\)) is determined, as usual, either implicitly using the data type of dobj or by being specified explicitly. Characters in the output area that do not have the icon are set to blanks.
    
-   The program SHOWICON shows two internal IDs for each icon:
    

-   A two-digit hexadecimal number as the key.

-   A six-character string composed of uppercase letters and any underscores as the internal name.

If a character string that is output using WRITE has an internal ID of this type between two "@" characters at the start, this is represented as an icon in the list output, even without the addition AS ICON. This can lead to unwanted of icons and unexpected effects in terms of the output length. By default, the output length is determined by the length of the character string. However, this attribute can also be exploited, for example, to use icons at the start of [text symbols](javascript:call_link\('abentext_symbol_glosry.htm'\) "Glossary Entry"). IDs that are not at the start are not represented as icons.

Example

Displays a traffic light icon.

WRITE icon\_green\_light AS ICON.

Example

Displaying traffic light icons using their internal IDs (key and internal name). The IDs that are not at the start of the character string are not converted.

WRITE: / 'xxx', '@08@xxx    ', 'xxx@08@xxx'.
WRITE: / 'xxx', '@S\_TL\_G@xxx', 'xxx@S\_TL\_G@xxx'.

Alternative 3

... AS SYMBOL

Effect

This addition produces all the characters of the data object dobj as symbols. The [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") SYM declares constants with a length of 1 for each character that can be displayed as a symbol, and whose name reflects the meaning of the symbol. The names of the constants and the meaning and length of the symbols can be taken from the type group or from the output of the program SHOWSYMB.

Note

The [output length](javascript:call_link\('abenwrite_output_length.htm'\)) is determined, as usual, either implicitly using the data type of dobj or by being specified explicitly.

Example

Displays a hand symbol.

WRITE sym\_left\_hand AS SYMBOL.

Alternative 4

... AS LINE

Effect

This addition produces [line elements](javascript:call_link\('abenline_element_glosry.htm'\) "Glossary Entry") with the output length 1. Line elements are corners, crosses, lines, and T sections. dobj expects data objects of the type c whose content can be interpreted as line elements by the runtime environment. The [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") LINE declares the line element constants displayed in the following table.

Constant

Meaning

line\_space

Blank

line\_top\_left\_corner

Top left corner

line\_bottom\_left\_corner

Bottom left corner

line\_top\_right\_corner

Top right corner

line\_bottom\_right\_corner

Bottom right corner

line\_horizontal\_line

Horizontal line

line\_vertical\_line

Vertical line

line\_left\_middle\_corner

T section turned to the left

line\_right\_middle\_corner

T section turned to the right

line\_bottom\_middle\_corner

Reversed T section

line\_top\_middle\_corner

T section

line\_cross

Cross

If dobj has different content or the content is changed by concurrent use of other additions for [internal formats](javascript:call_link\('abapwrite_int_options.htm'\)), a blank is produced instead of a line element. The addition FRAMES OFF must not be specified simultaneously. The other additions for [external formats](javascript:call_link\('abapwrite_ext_options.htm'\)) and QUICKINFO are ignored in the output of line elements.

Notes

-   The characters "-" and "|" and produced using ULINE are [joined with each other](javascript:call_link\('abenwrite_lines.htm'\)) by default, if no other characters exist between them. Here the system replaces the characters by the above line elements. A standalone character "|" is always replaced by a vertical line. The "-" characters from sy-uline are always replaced by a horizontal line. The default behavior can be switched off using the addition [FRAMES OFF](javascript:call_link\('abapformat.htm'\)).
    
-   The addition AS LINE produces line elements in the exact way they are defined. Links are produced only where line elements actually meet each other. The system does not, however, create any automatic extensions between the characters "-" or "|" and line elements produced explicitly using AS LINE.
    

Example

Produces four adjoining rectangles.

WRITE: /10 line\_top\_left\_corner      AS LINE NO-GAP,
           line\_top\_middle\_corner    AS LINE NO-GAP,
           line\_top\_right\_corner     AS LINE,
       /10 line\_left\_middle\_corner   AS LINE NO-GAP,
           line\_cross                AS LINE NO-GAP,
           line\_right\_middle\_corner  AS LINE,
       /10 line\_bottom\_left\_corner   AS LINE NO-GAP,
           line\_bottom\_middle\_corner AS LINE NO-GAP,
           line\_bottom\_right\_corner  AS LINE.

Continue
![Example](exa.gif "Example") [Lists, Line Elements](javascript:call_link\('abenlist_line_elements_abexa.htm'\))



**📖 Source**: [abapwrite_list_elements.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapwrite_list_elements.htm)

### abenlist_line_elements_abexa.htm

> **📖 Official SAP Documentation**: [abenlist_line_elements_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_line_elements_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Creating Lists](javascript:call_link\('abenabap_lists.htm'\)) →  [WRITE](javascript:call_link\('abapwrite-.htm'\)) →  [WRITE - list\_elements](javascript:call_link\('abapwrite_list_elements.htm'\)) → 

Lists, Line Elements

This example demonstrates line elements on lists.

Source Code

REPORT demo\_list\_line\_elements NO STANDARD PAGE HEADING LINE-SIZE 60.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA: x TYPE i,
                y TYPE i.
    CLASS-METHODS pos.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: x0 TYPE i VALUE 10,
          y0 TYPE i VALUE 10,
          n  TYPE i VALUE 16,
          i  TYPE i VALUE 0.
    x = x0.
    y = y0.
    pos( ).
    WHILE i LE n.
      WRITE line\_bottom\_left\_corner AS LINE.
      x = x + 1. pos( ).
      ULINE AT x(i).
      x = x + i. pos( ).
      WRITE line\_bottom\_right\_corner AS LINE.
      y = y - 1. pos( ).
      DO i TIMES.
        WRITE '|'.
        y = y - 1. pos( ).
      ENDDO.
      WRITE line\_top\_right\_corner AS LINE.
      i = i + 1.
      x = x - i. pos( ).
      ULINE AT x(i).
      x = x - 1. pos( ).
      WRITE line\_top\_left\_corner AS LINE.
      y = y + 1. pos( ).
      DO i TIMES.
        WRITE '|'.
        y = y + 1. pos( ).
      ENDDO.
      i = i + 1.
    ENDWHILE.  ENDMETHOD.
  METHOD pos.
    SKIP TO LINE y.
    POSITION x.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Displays a spiral using line elements and joins these automatically in a list.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / FORMAT

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / FORMAT

Included pages: 2



**📖 Source**: [abenlist_line_elements_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_line_elements_abexa.htm)

### abapformat.htm

> **📖 Official SAP Documentation**: [abapformat.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapformat.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Creating Lists](javascript:call_link\('abenabap_lists.htm'\)) → 

FORMAT

[Quick Reference](javascript:call_link\('abapformat_shortref.htm'\))

Syntax

FORMAT *\[*COLOR       *{**\[*\=*\]**{*color *\[*ON*\]**}**|*OFF*}**|**{*\= col*}**\]*
       *\[*INTENSIFIED *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]**\]*
       *\[*INVERSE     *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]**\]*
       *\[*HOTSPOT     *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]**\]*
       *\[*INPUT       *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]**\]*
       *\[*FRAMES      *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]**\]*
       *\[*RESET*\]*.

Extras:

[1\. ... COLOR *{**\[*\=*\]**{*color *\[*ON*\]**}**|*OFF*}**|**{*\= col*}*](#!ABAP_ADDITION_1@1@)
[2\. ... INTENSIFIED *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*](#!ABAP_ADDITION_2@2@)
[3\. ... INVERSE *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*](#!ABAP_ADDITION_3@3@)
[4\. ... HOTSPOT *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*](#!ABAP_ADDITION_4@4@)
[5\. ... INPUT *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*](#!ABAP_ADDITION_5@5@)
[6\. ... FRAMES *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*](#!ABAP_ADDITION_6@6@)
[7\. ... RESET](#!ABAP_ADDITION_7@7@)

Effect

The settings defined using FORMAT apply from the current position of the [list cursor](javascript:call_link\('abenlist_cursor_glosry.htm'\) "Glossary Entry") for all of the following output statements ([WRITE](javascript:call_link\('abapwrite-.htm'\)) and, with restrictions, [ULINE](javascript:call_link\('abapuline.htm'\))) until they are redefined by a new FORMAT statement. Within a line, the areas between the individual output and between the start of the line and the first output are formatted. Blank lines created using [SKIP](javascript:call_link\('abapskip.htm'\)) are not formatted, however.

The individual additions change the associated setting only and leave the others unchanged, with the exception of the addition RESET, which can change all settings.

At the start of the program, standard settings are defined for the settings that can be defined using FORMAT. These are set automatically for each [reporting event](javascript:call_link\('abenreporting_event_glosry.htm'\) "Glossary Entry") and [list event](javascript:call_link\('abenlist_event_glosry.htm'\) "Glossary Entry") (with the exception of the attribute set by FRAMES). A table of the standard settings is in the description of the addition RESET.

For each individual WRITE output, the settings can be overridden using the same additions in the addition WRITE. The settings that are defined using FORMAT or the standard settings then apply again.

Note

Alongside the statement FORMAT, [obsolete formats](javascript:call_link\('abenformat_obsolete.htm'\)) also exist that are replaced by FORMAT.

Addition 1

... COLOR *{**\[*\=*\]**{*color *\[*ON*\]**}**|*OFF*}**|**{*\= col*}*

Effect

This addition sets the color of the output. If the attribute INVERSE is set to OFF (default setting), this sets the background color of the output. If the attribute INVERSE is set to ON, this sets the foreground color of the output.

The color can be specified either statically using color, or dynamically using col.

-   color expects syntax taken directly from the following table. ON does not need to be specified. The optional equals sign \= in front of color or OFF can be specified only if the addition ON is not specified.
    
-   A data object of type i, containing one of the values from the following table, can be specified for col. If col contains a different value, this is handled like the value 0. The equals sign \= must be used if the data object col is not specified directly as a number.
    

Syntax of color

Value in col

Color

*{* COL\_BACKGROUND *}*

0

GUI-dependent

*{* 1 *|* COL\_HEADING *}*

1

Gray-blue

*{* 2 *|* COL\_NORMAL *}*

2

Light gray

*{* 3 *|* COL\_TOTAL *}*

3

Yellow

*{* 4 *|* COL\_KEY *}*

4

Blue-green

*{* 5 *|* COL\_POSITIVE *}*

5

Green

*{* 6 *|* COL\_NEGATIVE *}*

6

Red

*{* 7 *|* COL\_GROUP *}*

7

Purple

The addition OFF has the same effect as COL\_BACKGROUND or the value 0 in col and is the default setting. In this setting, the color of the background corresponds to a list line of the background color of the GUI window.

The addition COLOR does not affect lines made of [line elements](javascript:call_link\('abenline_element_glosry.htm'\) "Glossary Entry"), or on GUI windows that are ready for input. The latter can be overridden by the other additions.

Addition 2

... INTENSIFIED *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*

Effect

This addition defines the intensity of the background color. flag expects a data object of type i. If ON is specified or if the content of flag is not equal to 0, an intensified background color is used (default setting). If OFF is specified or if the content of flag is equal to 0, a non-intensified background color is used. An exception to this is the background color COL\_BACKGROUND used by INTENSIFIED ON to control the foreground color. If none of ON, OFF, or flag are specified after INTENSIFIED, the addition ON is applied.

At the same time, if the INPUT ON attribute is set, the addition INTENSIFIED OFF changes the foreground color of fields that are ready for input. If the INVERSE ON setting is made at the same time, the INTENSIFIED OFF setting is ignored (with the exception of COL\_BACKGROUND).

Addition 3

... INVERSE *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*

Effect

This addition defines whether the addition COLOR sets the background color or the foreground color. flag expects a data object of type i. If ON is specified or the content of flag is not equal to 0, the foreground (the output) is displayed in the selected color. An exception to this is the COL\_BACKGROUND color, used to display the foreground in white. If OFF is specified or if the content of flag is equal to 0, the background is displayed in the selected color (default setting). If none of ON, OFF, or flag are specified after INVERSE, the addition ON is applied.

At the same time, if the attribute INPUT ON is set, the addition INVERSE ON changes the background and foreground color of fields that are ready for input.

Example

Demonstrates different combinations of the additions COLOR, INTENSIFIED, and INVERSE. The program SHOWCOLO produces a similar result.

DATA col TYPE i VALUE 0.
DO 8 TIMES.
  col = sy-index - 1.
  FORMAT COLOR = col.
  WRITE: /  col              COLOR OFF,
           'INTENSIFIED ON'  INTENSIFIED ON,
           'INTENSIFIED OFF' INTENSIFIED OFF,
           'INVERSE ON'      INVERSE ON.
ENDDO.

Addition 4

... HOTSPOT *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*

Effect

This addition influences the display of the mouse pointer and the function of the mouse in the list displayed on the screen. flag expects a data object of type i. If ON is specified or if the content of flag is not equal to 0, it changes its appearance to a hand when the mouse pointer is positioned on a list area that is formatted accordingly (hotspot) and a single click has the same effect as a double-click (that is, selecting the function key F2). If OFF is specified or if the content of flag is equal to 0, the function of the mouse does not change (default setting). If none of ON, OFF, or flag are specified after HOTSPOT, the addition ON is applied.

If the attribute INPUT ON is set, the addition HOTSPOT ON is ignored and is also ignored by [line elements](javascript:call_link\('abenline_element_glosry.htm'\) "Glossary Entry").

Note

By default, INPUT ON is set for a checkbox defined with [AS CHECKBOX](javascript:call_link\('abapwrite_list_elements.htm'\)) and the addition HOTSPOT ON is ignored. However, HOTSPOT ON does have an effect on a non-input-ready checkbox.

Example

Demonstration of a Hotspot Clicking the output once creates a details list.

START-OF-SELECTION.
  FORMAT HOTSPOT.
  WRITE 'Click me!' COLOR 5.
  FORMAT HOTSPOT OFF.
AT LINE-SELECTION.
  WRITE 'Yeah!' COLOR 3.

Addition 5

... INPUT *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*

Effect

This addition makes list areas ready for input. flag expects a data object of type i. If ON is specified or the content of flag is not equal to 0, the relevant list area is displayed with a different foreground and background color than the rest of the list, and the user can overwrite the output. The screen cursor is positioned in the first field that is ready for input. If OFF is specified or the content of flag is equal to 0, the output is not made ready for input (default setting). If none of ON, OFF, or flag are specified after INPUT, the addition ON is applied.

Within an area that is ready for input, icons are displayed empty and symbols are displayed as characters according to the [code page](javascript:call_link\('abencodepage_glosry.htm'\) "Glossary Entry"). [Line elements](javascript:call_link\('abenline_element_glosry.htm'\) "Glossary Entry") are not made ready for input. In list areas that are ready for input, however, the characters "-" and "|", are not transformed into line elements and are not displayed as being ready for input. In particular, the latter also applies to the statement ULINE.

The width of the list area that is ready for input is defined by the [output length](javascript:call_link\('abenwrite_output_length.htm'\)). If the display of contents from the list buffer in a list area that is ready for input results in truncation, the indicator is placed outside the area. The number of characters that can be entered is limited by the output length. The content cannot be moved. The number of characters that can be entered depends on the space that the individual characters require.

The entries made by the user are saved in the list buffer and can be evaluated during a list event. If characters were truncated in the list, then they will also be lost in the list buffer.

Note

If a list line contains an input field with only blanks, it is not displayed if the statement SET BLANK LINES ON was not executed beforehand.

Example

Displays a field that is ready for input and evaluates it in the event AT LINE-SELECTION. The evaluation is performed only if the user clicks the hotspot below the line that is ready for input.

DATA: input\_field TYPE c LENGTH 100,
      line\_num TYPE i.
START-OF-SELECTION.
  WRITE 'Input text:'.
  SET BLANK LINES ON.
  FORMAT INPUT.
  WRITE / input\_field.
  FORMAT INPUT OFF.
  WRITE / '>>> OK <<<' COLOR 5 HOTSPOT.
AT LINE-SELECTION.
  IF sy-lisel = '>>> OK <<<'.
    line\_num = sy-lilli - 1.
    READ LINE line\_num FIELD VALUE input\_field.
    WRITE:   'The input was:',
           /  input\_field.
  ENDIF.

Addition 6

... FRAMES *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*

Effect

This addition defines whether the "-" and "|" characters are transformed to [line elements](javascript:call_link\('abenline_element_glosry.htm'\) "Glossary Entry"). flag expects a data object of type i. If ON is specified or if the content of flag is not equal to 0, the characters are transformed in the relevant list area (default setting). If OFF is specified or if the content of flag is not equal to 0, the characters are not transformed. If none of ON, OFF, or flag are specified after FRAMES, the addition ON is applied.

In the FRAMES ON setting, the following points apply:

-   If the "-" and "|" characters are displayed directly next to each other or above each other, they are replaced by line elements, producing continuous lines (frames). This applies particularly to the output of lines using ULINE.
    
-   A solitary "|" character is always replaced by a vertical line.
    
-   Line elements that are displayed explicitly by the addition AS LINE are not replaced by other line elements and they do not influence "-" and "|" characters that are next to each other.
    

In the FRAMES OFF setting, the "-" and "|" are not converted into line elements. Line elements can be displayed explicitly using the addition AS LINE.

Note

The addition FRAMES OFF is suitable for preventing unwanted results in spool lists. This applies particularly to lists that are intended for archiving.

Example

Displays a frame with the characters "-" and "|" joined/not joined.

CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS frame.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    FORMAT FRAMES ON.
    frame( ).
    FORMAT FRAMES OFF.
    frame( ).
  ENDMETHOD.
  METHOD frame.
    SKIP.
    WRITE: / '----',
           / '|  |',
           / '----'.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Addition 7

... RESET

Effect

This addition sets all formatting settings for which the corresponding addition is not specified in the same FORMAT statement to the state OFF, apart from the setting of the addition FRAMES, which is set to ON. For settings whose addition is also specified, the addition RESET is ignored.

The following table shows the effect of RESET compared with the default settings (the setting when the program starts and the setting that is made for reporting and list events).

Addition

State After RESET

State After Program Start

State After Reporting Event/List Event

COLOR

OFF

OFF

OFF

INTENSIFIED

OFF

ON

ON

INVERSE

OFF

OFF

OFF

HOTSPOT

OFF

OFF

OFF

INPUT

OFF

OFF

OFF

FRAMES

ON

ON

No change

Example

This FORMAT statement creates the default setting after the program starts.

FORMAT RESET
       INTENSIFIED ON.

Continue
![Example](exa.gif "Example") [Lists, Supported Colors](javascript:call_link\('abenlist_format_color2_abexa.htm'\))



**📖 Source**: [abapformat.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapformat.htm)

### abenlist_format_color2_abexa.htm

> **📖 Official SAP Documentation**: [abenlist_format_color2_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_format_color2_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Creating Lists](javascript:call_link\('abenabap_lists.htm'\)) →  [FORMAT](javascript:call_link\('abapformat.htm'\)) → 

Lists, Supported Colors

This example demonstrates which colors are available for list formatting.

Source Code

REPORT demo\_list\_format\_color\_1 .
DATA i TYPE i VALUE 0.
DATA col(15) TYPE c.
WHILE i < 8.
  CASE i.
    WHEN 0. col = 'COL\_BACKGROUND '.
    WHEN 1. col = 'COL\_HEADING    '.
    WHEN 2. col = 'COL\_NORMAL     '.
    WHEN 3. col = 'COL\_TOTAL      '.
    WHEN 4. col = 'COL\_KEY        '.
    WHEN 5. col = 'COL\_POSITIVE   '.
    WHEN 6. col = 'COL\_NEGATIVE   '.
    WHEN 7. col = 'COL\_GROUP      '.
  ENDCASE.
  FORMAT INTENSIFIED COLOR = i.
  WRITE: /(4) i, AT 7            sy-vline,
            col,                 sy-vline,
            col INTENSIFIED OFF, sy-vline,
            col INVERSE.
  i = i + 1.
ENDWHILE.

Description

In the statement FORMAT, the COLOR option for subsequent WRITE statements is set at runtime. The other options are set individually for each WRITE statement in the program.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / NEW-PAGE

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / NEW-PAGE

Included pages: 3



**📖 Source**: [abenlist_format_color2_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_format_color2_abexa.htm)

### abapnew-page.htm

> **📖 Official SAP Documentation**: [abapnew-page.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapnew-page.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Creating Lists](javascript:call_link\('abenabap_lists.htm'\)) → 

NEW-PAGE

[Quick Reference](javascript:call_link\('abapnew-page_shortref.htm'\))

Syntax

NEW-PAGE *\[*[page\_options](javascript:call_link\('abapnew-page_options.htm'\))*\]* *\[* [spool\_options](javascript:call_link\('abapnew-page_print.htm'\))*\]*.

Effect

This statement creates a new page in the current list and writes the subsequent list output into a spool list. The additions [page\_options](javascript:call_link\('abapnew-page_options.htm'\)) determine general properties of the new page. The additions [spool\_options](javascript:call_link\('abapnew-page_print.htm'\)) control the spool list output.

The statement NEW-PAGE completes the current page. If output was created by [WRITE](javascript:call_link\('abapwrite-.htm'\)) or [ULINE](javascript:call_link\('abapuline.htm'\)) on the current page, a new page is created and the value in sy-pagno is increased by 1. An empty line is inserted between the individual pages. The [list cursor](javascript:call_link\('abenlist_cursor_glosry.htm'\) "Glossary Entry") is set to the first position of the first line under the standard page header of the new page.

The new page is created independently of the current list cursor position underneath the last line of the current page in which output was created.

Notes

-   The statement NEW-PAGE cannot be used to create empty pages.
    
-   The list event [END-OF-PAGE](javascript:call_link\('abapend-of-page.htm'\)) is not triggered. The event [TOP-OF-PAGE](javascript:call_link\('abaptop-of-page.htm'\)) is triggered before the first output on the new page.
    

Continue
[NEW-PAGE - page\_options](javascript:call_link\('abapnew-page_options.htm'\))
[NEW-PAGE - spool\_options](javascript:call_link\('abapnew-page_print.htm'\))



**📖 Source**: [abapnew-page.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapnew-page.htm)

### abapnew-page_options.htm

> **📖 Official SAP Documentation**: [abapnew-page_options.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapnew-page_options.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Creating Lists](javascript:call_link\('abenabap_lists.htm'\)) →  [NEW-PAGE](javascript:call_link\('abapnew-page.htm'\)) → 

NEW-PAGE - page\_options

[Quick Reference](javascript:call_link\('abapnew-page_shortref.htm'\))

Syntax

... *\[*WITH-TITLE*|*NO-TITLE*\]*
    *\[*WITH-HEADING*|*NO-HEADING*\]*
    *\[*LINE-COUNT page\_lines*\]*
    *\[*LINE-SIZE width*\]*
    *\[*NO-TOPOFPAGE*\]* ...

Extras:

[1\. ... WITH-TITLE*|*NO-TITLE](#!ABAP_ADDITION_1@1@)
[2\. ... WITH-HEADING*|*NO-HEADING](#!ABAP_ADDITION_2@2@)
[3\. ... LINE-COUNT page\_lines](#!ABAP_ADDITION_3@3@)
[4\. ... LINE-SIZE width](#!ABAP_ADDITION_4@4@)
[5\. ... NO-TOPOFPAGE](#!ABAP_ADDITION_5@5@)

Effect

These additions set properties of the list for all subsequent pages of the current list level, until they are set again in another NEW-PAGE statement. The additions override additions of the same name in the introductory program statement.

Addition 1

... WITH-TITLE*|*NO-TITLE

Addition 2

... WITH-HEADING*|*NO-HEADING

Effect

These additions specify which components of the standard page header are output for the subsequent pages of the current list level. The standard page header consists of a standard title and column headings.

The additions WITH-TITLE and NO-TITLE switch the output of the standard title on or off for the subsequent pages. The predefined default setting for basic lists is WITH-TITLE, and for details lists is NO-TITLE.

The additions WITH-HEADING and NO-HEADING switch the output of the column headings on or off for all subsequent pages. The predefined default setting for basic lists is WITH-HEADING, and for details lists is NO-HEADING.

Note

For basic lists, these additions override the setting made in the introductory program statement. The addition NO STANDARD PAGE HEADING used there functions in the same way as when NO-TITLE and NO-HEADING are used simultaneously, with the exception that the latter do not have an impact on the system field sy-wtitl.

Addition 3

... LINE-COUNT page\_lines

Effect

This addition sets the page length of the subsequent pages of the current list level to the value in page\_lines and sets sy-linct to this value. page\_lines expects a data object of type i. If the value of page\_lines is less than or equal to 0 or greater than 60000, the page length is set to 60000. For the basic list, the addition overrides the page length specified in the introductory program statement.

The page length determines how many lines including [page header](javascript:call_link\('abenpage_header_glosry.htm'\) "Glossary Entry") and [page footer](javascript:call_link\('abenpage_footer_glosry.htm'\) "Glossary Entry") can be written to a list page. If output is written to a line outside the current page length or in the area reserved for the page footer of a basic list, a new page is created automatically.

Notes

The lines reserved in the introductory program statement for the page footer of the basic list cannot be changed with the addition LINE-COUNT of the statement NEW-PAGE. For details lists, you cannot create a page footer.

-   The default value should be used for screen lists since, as a rule, page breaks specified using LINE-COUNT are not adjusted to the window size.
    
-   The default value should also be used for spool lists, so that the page size can be selected on a printer-specific basis. A spool list should be created in such a way that it provides satisfactory results for any page size.
    
-   Specifying a fixed line count is only useful for form-like lists with a fixed page layout. Here, however, it is always advisable to check whether these forms can be created by other means. This can be done, for example, by searching [SAP Help Portal](http://help.sap.com) for the term "form".
    

Example

The following code demonstrates automatic page breaks in a basic list. The pages have two-line page headers and page footers defined after [TOP-OF-PAGE](javascript:call_link\('abaptop-of-page.htm'\)) and [END-OF-PAGE](javascript:call_link\('abapend-of-page.htm'\)). The page length is specified after NEW-PAGE. The program displays five pages.

REPORT NO STANDARD PAGE HEADING LINE-COUNT 0(2).
TOP-OF-PAGE.
  WRITE sy-pagno.
  ULINE.
END-OF-PAGE.
  ULINE.
  WRITE 'Footer'.
START-OF-SELECTION.
  NEW-PAGE LINE-COUNT 6.
  DO 10 TIMES.
    WRITE / sy-index.
  ENDDO.

Addition 4

... LINE-SIZE width

Effect

This addition sets the page width of the current list level to the value in width and sets sy-linsz to this value. The line width determines the number of characters in the line buffer as well as the number of columns in the list displayed. width expects a data object of type i. The value of width must not be negative. If the value of width is equal to 0 or greater than 1023, the line width is set to a default width, which is based on the window width of the current [dynpro](javascript:call_link\('abendynpro_glosry.htm'\) "Glossary Entry") (sy-scols), but is at least as wide as the width of a standard sized GUI window. For the basic list, the addition overrides the page width specified in the introductory program statement.

The addition has an effect only if no output has yet been sent to the current list level. The page width of a list that has already been written cannot be changed.

Note

The current maximum line width is stored in the constants slist\_max\_linesize of the [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") SLIST. A type slist\_max\_listline of type c and length slist\_max\_linesize is also defined there.

Example

Creates a basic list and details lists with various page widths. Only the standard title of the standard page header is displayed.

REPORT demo NO STANDARD PAGE HEADING.
START-OF-SELECTION.
  NEW-PAGE WITH-TITLE LINE-SIZE 40.
  WRITE 'Basic list'.
AT LINE-SELECTION.
  NEW-PAGE WITH-TITLE LINE-SIZE 20.
  WRITE 'Secondary list'.

Addition 5

... NO-TOPOFPAGE

Effect

This addition suppresses the event [TOP-OF-PAGE](javascript:call_link\('abaptop-of-page.htm'\)) on the new page and on all automatically created pages of the current list level up to the next statement NEW-PAGE. If the addition NO-TOPOFPAGE is not specified, the event TOP-OF-PAGE is raised before the output is sent to a new page.

Example

The following program generates six pages. The event TOP-OF-PAGE is raised only on the first page.

REPORT demo NO STANDARD PAGE HEADING.
START-OF-SELECTION.
  ULINE.
  NEW-PAGE NO-TOPOFPAGE LINE-COUNT 2.
  DO 10 TIMES.
    WRITE / sy-index.
  ENDDO.
TOP-OF-PAGE.
  WRITE 'Basic list'.



**📖 Source**: [abapnew-page_options.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapnew-page_options.htm)

### abapnew-page_print.htm

> **📖 Official SAP Documentation**: [abapnew-page_print.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapnew-page_print.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Creating Lists](javascript:call_link\('abenabap_lists.htm'\)) →  [NEW-PAGE](javascript:call_link\('abapnew-page.htm'\)) → 

NEW-PAGE - spool\_options

[Quick Reference](javascript:call_link\('abapnew-page_shortref.htm'\))

Syntax

... *{* PRINT ON *\[*NEW-SECTION*\]* PARAMETERS pri\_params
                             *\[*ARCHIVE PARAMETERS arc\_params*\]*
                             NO DIALOG *}*
  *|* *{* PRINT OFF *}* ...

Extras:

[1\. ... PRINT ON *\[*NEW-SECTION*\]*](#!ABAP_ADDITION_1@1@)
[2\. ... PARAMETERS pri\_params](#!ABAP_ADDITION_2@2@)
[3\. ... ARCHIVE PARAMETERS arc\_params](#!ABAP_ADDITION_3@3@)
[4\. ... NO DIALOG](#!ABAP_ADDITION_4@4@)
[5\. ... PRINT OFF](#!ABAP_ADDITION_5@5@)

Effect

The addition PRINT ON writes all subsequent output statements to a [spool list](javascript:call_link\('abenprint.htm'\)). The additions *\[*ARCHIVE*\]* PARAMETERS are used to define the spool parameters and the archiving parameters of the [spool request](javascript:call_link\('abenspool_request_glosry.htm'\) "Glossary Entry"). The addition PRINT OFF closes a spool list that has been started with the addition PRINT ON.

Addition 1

... PRINT ON *\[*NEW-SECTION*\]*

Effect

The addition PRINT ON creates a new [spool list level](javascript:call_link\('abenprint_list_level_glosry.htm'\) "Glossary Entry"). The first output statement after NEW-PAGE PRINT ON opens a new [spool request](javascript:call_link\('abenspool_request_glosry.htm'\) "Glossary Entry") and writes to a [spool list](javascript:call_link\('abenprint_list_glosry.htm'\) "Glossary Entry") in the [SAP spool system](javascript:call_link\('abensap_spool_system_glosry.htm'\) "Glossary Entry"). The number of the spool request is passed to sy-spono by the first output statement. While it is being created, the spool list is sent page by page to the SAP spool system.

-   If the current list is a screen list, its creation is interrupted and the new spool list level is stacked in it.
    
-   If the current list is a [spool list](javascript:call_link\('abenprint.htm'\)) not created with NEW-PAGE PRINT ON, its creation is interrupted and the new spool list level is stacked in it.
    
-   If the current list is a [spool list](javascript:call_link\('abenprint.htm'\)) created using NEW-PAGE PRINT ON and the addition NEW-SECTION is not used, a handleable exception of the class CX\_SY\_NESTED\_PRINT\_ON is raised.
    
-   If the current list is a [spool list](javascript:call_link\('abenprint.htm'\)) created using NEW-PAGE PRINT ON, the addition NEW-SECTION is used, the specified spool parameters match those of the new list, and the spool parameter PRNEW in the structure pri\_params is initial, no new spool request is opened and the output is written to the current spool list. If the spool parameters define the output of a cover sheet, the cover sheet is printed again before the following output as a spacer sheet.
    
-   If the current list is a [spool list](javascript:call_link\('abenprint.htm'\)) created using NEW-PAGE PRINT ON, the addition NEW-SECTION is used, and the specified spool parameters do not match those of the new list or the spool parameter PRNEW in structure pri\_params is not initial, the current spool request is closed implicitly by NEW-PAGE PRINT OFF and a new spool request is created.
    

It is not possible to use NEW-PAGE PRINT ON to stack another spool list level directly on to a spool list level created using NEW-PAGE PRINT ON.

A spool list level created using NEW-PAGE PRINT ON can be closed by either NEW-PAGE PRINT OFF, NEW-PAGE PRINT ON NEW-SECTION, the end of the program, or by leaving a dynpro sequence.

Notes

-   Each statement NEW-PAGE PRINT ON should be closed explicitly using NEW-PAGE PRINT OFF before the program end or before leaving a dynpro sequence.
    
-   The addition NEW-SECTION can be used to avoid the exception CX\_SY\_NESTED\_PRINT\_ON. When using NEW-SECTION, the output can also be continued into the previous spool list, which is not possible when an exception is handled with CATCH.
    
-   As well as the addition NEW-SECTION, the obsolete statement [NEW-SECTION](javascript:call_link\('abapnew-section.htm'\)) can also be used outside of classes. However it does not enable spool parameters to be specified.
    

Executable Example

[Lists, Spooling](javascript:call_link\('abenprint_list_abexa.htm'\)).

Addition 2

... PARAMETERS pri\_params

Addition 3

... ARCHIVE PARAMETERS arc\_params

Addition 4

... NO DIALOG

Effect

These additions provide the spool request with [spool parameters and archiving parameters](javascript:call_link\('abenprint_parameters.htm'\)). The latter are necessary if the spool list is archived using [ArchiveLink](javascript:call_link\('abensap_archivelink_glosry.htm'\) "Glossary Entry").

The addition PARAMETERS passes the spool parameters in a structure pri\_params of data type PRI\_PARAMS from ABAP Dictionary. If archiving is specified in pri\_params, archiving parameters must be passed using the addition ARCHIVE PARAMETERS in a structure arc\_params of data type ARC\_PARAMS from ABAP Dictionary.

Structures of data types PRI\_PARAMS and ARC\_PARAMS must be filled by the function module [GET\_PRINT\_PARAMETERS](javascript:call_link\('abenprint_parameters_function.htm'\)). When the function module is called, either individual spool parameters or all spool parameters can be set in the program and/or a spool dialog window displayed. The function module creates a set of valid spool and archiving parameters for use as pri\_params and arc\_params and adds these to its output parameters.

If the structures pri\_params or arc\_params are initial, the spool parameters or archiving parameters created by a call of the function modules GET\_PRINT\_PARAMETERS with initial input values are used.

The addition NO DIALOG suppresses the spool dialog window that by default appears when using the addition PRINT ON.

Notes

-   These additions must always be used as indicated here. It is particularly important that the standard spool dialog box be suppressed. When using the default spool dialog window, the Back function is not available because the system cannot return to a point before a statement after spooling has been switched on by such a statement. Printing can only be exited using Exit, which ends the entire program. If the user exits the GUI window by choosing Cancel, inconsistent spool parameters can be produced. Instead, the spool dialog window can be displayed by calling the function module [GET\_PRINT\_PARAMETERS](javascript:call_link\('abenprint_parameters_function.htm'\)). This function module has an output parameter VALID that indicates the consistency of the spool parameters created.
    
-   The use of the addition NO DIALOG without simultaneously passing spool parameters is allowed only outside of ABAP Objects and produces a warning in the syntax check. In other objects, the spool parameters are derived from the user master record, if possible.
    
-   As well as the additions shown here, there is a range of other additions for an [obsolete specification of spool parameters](javascript:call_link\('abapnew-page_print_obsolete.htm'\)), which should no longer be used.
    

Example

Creates spool lists during the list event [AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\)). The spool parameters are defined by the function module GET\_PRINT\_PARAMETERS before the basic list is created.

REPORT demo NO STANDARD PAGE HEADING.
DATA: spfli\_wa TYPE spfli,
      sflight\_wa TYPE sflight.
DATA: print\_parameters TYPE pri\_params,
      valid\_flag       TYPE c LENGTH 1.
START-OF-SELECTION.
  CALL FUNCTION 'GET\_PRINT\_PARAMETERS'
    IMPORTING
      out\_parameters       = print\_parameters
      valid                = valid\_flag
    EXCEPTIONS
      invalid\_print\_params = 2
      OTHERS               = 4.
  IF valid\_flag = 'X' AND sy-subrc = 0.
    SELECT carrid, connid
           FROM spfli
           INTO CORRESPONDING FIELDS OF @spfli\_wa.
      WRITE: / spfli\_wa-carrid, spfli\_wa-connid.
      HIDE:    spfli\_wa-carrid, spfli\_wa-connid.
    ENDSELECT.
  ELSE.
    ...
  ENDIF.
AT LINE-SELECTION.
  NEW-PAGE PRINT ON PARAMETERS print\_parameters
                    NO DIALOG.
  SELECT \*
         FROM sflight
         WHERE carrid = @spfli\_wa-carrid AND
               connid = @spfli\_wa-connid
         INTO @sflight\_wa.
    WRITE: / sflight\_wa-carrid, sflight\_wa-connid,
             sflight\_wa-fldate ...
  ENDSELECT.
  NEW-PAGE PRINT OFF.

Addition 5

... PRINT OFF

Effect

The addition PRINT OFF closes a [spool list level](javascript:call_link\('abenprint_list_level_glosry.htm'\) "Glossary Entry") created using NEW-PAGE PRINT ON, sends the current page to the SAP spool system, and releases the associated spool request. Output statements that follow NEW-PAGE PRINT OFF write to the screen list or spool list where the spool list level closed by PRINT OFF was [stacked](javascript:call_link\('abenprint_spool.htm'\)). When the system returns to the print list, the system field sy-spono is switched to the number of the associated spool request directly when the statement NEW-PAGE PRINT OFF is executed.

NEW-PAGE PRINT OFF is ignored by spool list levels not been created using NEW-PAGE PRINT ON.

Note

At the end of the program and at every list event [AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\)), [AT PFnn](javascript:call_link\('abapat_pfnn.htm'\)), and [AT USER-COMMAND](javascript:call_link\('abapat_user-command.htm'\)), the statement NEW-PAGE PRINT OFF is executed implicitly.

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Handleable Exceptions

CX\_SY\_NESTED\_PRINT\_ON

-   Cause: Stacked NEW-PAGE PRINT ON.
    Runtime error: NESTED\_PRINT\_ON


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / HIDE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / HIDE

Included pages: 2



**📖 Source**: [abapnew-page_print.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapnew-page_print.htm)

### abaphide.htm

> **📖 Official SAP Documentation**: [abaphide.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abaphide.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Creating Lists](javascript:call_link\('abenabap_lists.htm'\)) → 

HIDE

[Quick Reference](javascript:call_link\('abaphide_shortref.htm'\))

Syntax

HIDE dobj.

Effect

This statement stores the content of a variable dobj together with the current list line whose line number is contained in sy-linno in the [hide area](javascript:call_link\('abenhide_area_glosry.htm'\) "Glossary Entry") of the current list level. The data type of the variable dobj must be [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") and no field symbols or components of [boxed components](javascript:call_link\('abenboxed_component_glosry.htm'\) "Glossary Entry") can be specified that point to rows of internal tables, and no class attributes can be specified. The saved values can be read as followed:

-   Any user action on a displayed screen list that causes a list event assigns all values saved using HIDE to the relevant variables.
    
-   If a list line of a list level is read or modified using the statements [READ LINE](javascript:call_link\('abapread_line.htm'\)) or [MODIFY LINE](javascript:call_link\('abapmodify_line.htm'\)), all the values of this line saved using HIDE are assigned to the relevant variables.
    

Notes

-   The HIDE statement works independently of whether the [list cursor](javascript:call_link\('abenlist_cursor_glosry.htm'\) "Glossary Entry") was set. In particular, variables for empty list lines can be stored (that is, lines in which the list cursor was positioned using statements like [SKIP](javascript:call_link\('abapskip.htm'\))).
    
-   The HIDE statement should be executed directly in the statement that has set the list cursor in the line.
    
-   Using the HIDE statement on a field symbol can cause runtime errors. The syntax check displays a warning.
    

Example

Saving square numbers and cubic numbers for a list of numbers. The example shows that any variable can be stored independently of the row content. In the real world, one would more likely save only the number and execute the calculation, when required, in the the event block for [AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\)).

REPORT ...
DATA: square TYPE i,
      cube   TYPE i.
START-OF-SELECTION.
  FORMAT HOTSPOT.
  DO 10 TIMES.
    square = sy-index \*\* 2.
    cube   = sy-index \*\* 3.
    WRITE / sy-index.
    HIDE: square, cube.
  ENDDO.
AT LINE-SELECTION.
  WRITE: square, cube.

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Non-Handleable Exceptions

-   Cause: The field is too long for HIDE.
    Runtime error: HIDE\_FIELD\_TOO\_LARGE
    
-   Cause: HIDE in a table row or a component in a table row is not possible.
    Runtime error: HIDE\_ILLEGAL\_ITAB\_SYMBOL
    
-   Cause: HIDE in a local field is not possible.
    Runtime error: HIDE\_NO\_LOCAL: HIDE
    
-   Cause: HIDE is not possible on an empty page.
    Runtime error: HIDE\_ON\_EMPTY\_PAGE
    
-   Cause: Illegal field
    Runtime error: HIDE\_NOT\_GLOBAL
    
-   Cause: Permitted number of HIDE statements per list line exceeded
    Runtime error: HIDE\_TOO\_MANY\_HIDES
    

Continue
![Example](exa.gif "Example") [Lists, HIDE Technique](javascript:call_link\('abenlist_hide_abexa.htm'\))



**📖 Source**: [abaphide.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abaphide.htm)

### abenlist_hide_abexa.htm

> **📖 Official SAP Documentation**: [abenlist_hide_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_hide_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Creating Lists](javascript:call_link\('abenabap_lists.htm'\)) →  [HIDE](javascript:call_link\('abaphide.htm'\)) → 

Lists, HIDE Technique

This example demonstrates how to implement program-driven data passes for lists to the ABAP program using HIDE.

Source Code

REPORT demo\_list\_hide NO STANDARD PAGE HEADING.
TABLES: spfli, sbook.
DATA: num TYPE i,
      dat TYPE d.
START-OF-SELECTION.
  num = 0.
  SET PF-STATUS 'FLIGHT'.
GET spfli.
  num = num + 1.
  WRITE: / spfli-carrid, spfli-connid,
           spfli-cityfrom, spfli-cityto.
  HIDE:    spfli-carrid, spfli-connid, num.
END-OF-SELECTION.
  CLEAR num.
TOP-OF-PAGE.
  WRITE 'List of Flights'.
  ULINE.
  WRITE 'CA  CONN FROM                 TO'.
  ULINE.
TOP-OF-PAGE DURING LINE-SELECTION.
  CASE sy-pfkey.
    WHEN 'BOOKING'.
      WRITE sy-lisel.
      ULINE.
    WHEN 'WIND'.
      WRITE:  'Booking', sbook-bookid,
           /  'Date   ', sbook-fldate.
      ULINE.
  ENDCASE.
AT USER-COMMAND.
  CASE sy-ucomm.
    WHEN 'SELE'.
      IF num NE 0.
        SET PF-STATUS 'BOOKING'.
        CLEAR dat.
        SELECT \* FROM sbook WHERE carrid = spfli-carrid
                            AND   connid = spfli-connid.
          IF sbook-fldate NE dat.
            dat = sbook-fldate.
            SKIP.
            WRITE / sbook-fldate.
            POSITION 16.
          ELSE.
            NEW-LINE.
            POSITION 16.
          ENDIF.
          WRITE sbook-bookid.
          HIDE: sbook-bookid, sbook-fldate, sbook-custtype,
                sbook-smoker, sbook-luggweight, sbook-class.
        ENDSELECT.
        IF sy-subrc NE 0.
          WRITE / 'No bookings for this flight'.
        ENDIF.
        num = 0.
        CLEAR sbook-bookid.
      ENDIF.
    WHEN 'INFO'.
      IF NOT sbook-bookid IS INITIAL.
        SET PF-STATUS 'WIND'.
        SET TITLEBAR 'BKI'.
        WINDOW STARTING AT 30 5 ENDING AT  60 10.
        WRITE: 'Customer type   :', sbook-custtype,
             / 'Smoker          :', sbook-smoker,
             / 'Luggage weigtht :', sbook-luggweight UNIT 'KG',
             / 'Class           :', sbook-class.
      ENDIF.
  ENDCASE.

Description

At START-OF-SELECTION time, the status FLIGHT is set for the basic list. In the status FLIGHT, the function key F2 and a pushbutton are assigned the function code SELE (text SELECT). This means the event AT USER-COMMAND is triggered when the user double-clicks, presses F2, or chooses the pushbutton SELECT.

The three fields spfli-carrid, spfli-connid, and num are written to the [Hide](javascript:call_link\('abenhide_area_glosry.htm'\) "Glossary Entry") area while the basic list is created. After a line is selected, the details list defined for the function code SELE in AT USER-COMMAND is displayed. After the AT USER-COMMAND event, all fields of the selected line that were stored in the Hide area are loaded again. num is used to check whether a line from the actual list was selected. The details list is given the status BOOKING, where F2 is assigned the function code INFO (with the text Booking Information) The details list displays data which can be selected using the Hide fields of the basic list. For each list line displayed, the system stores additional information in the [Hide](javascript:call_link\('abenhide_area_glosry.htm'\) "Glossary Entry") area.

If the user selects a line of the details list, the system displays the stored information in a dialog box with the status WIND. For the WIND status, the default values are applied when the list status is synchronized. sbook-bookid is used to check whether a valid line was selected.

The program itself sets all page headers and the title bar of the dialog box.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Processing Lists in the List Buffer

**Files**: 14 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Processing Lists in the List Buffer

Included pages: 14



**📖 Source**: [abenlist_hide_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_hide_abexa.htm)

### abenabap_lists_complex.htm

> **📖 Official SAP Documentation**: [abenabap_lists_complex.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_lists_complex.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) → 

Processing Lists in the List Buffer

The following statements edit lists that are already saved as [screen lists](javascript:call_link\('abenscreen_list_glosry.htm'\) "Glossary Entry") in the list buffers:

-   [READ LINE](javascript:call_link\('abapread_line.htm'\)),

-   [MODIFY LINE](javascript:call_link\('abapmodify_line.htm'\)),

-   [SCROLL LIST](javascript:call_link\('abapscroll.htm'\)), and

-   [DESCRIBE LIST](javascript:call_link\('abapdescribe_list.htm'\))

[Spool lists](javascript:call_link\('abenprint_list_glosry.htm'\) "Glossary Entry") that are sent page by page to the SAP spool system cannot be edited in this manner.

Continue
[READ LINE](javascript:call_link\('abapread_line.htm'\))
[MODIFY LINE](javascript:call_link\('abapmodify_line.htm'\))
[SCROLL LIST](javascript:call_link\('abapscroll.htm'\))
[DESCRIBE LIST](javascript:call_link\('abapdescribe_list.htm'\))



**📖 Source**: [abenabap_lists_complex.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_lists_complex.htm)

### abapread_line.htm

> **📖 Official SAP Documentation**: [abapread_line.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapread_line.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) → 

READ LINE

[Quick Reference](javascript:call_link\('abapread_line_shortref.htm'\))

Syntax

READ *{* *{*LINE line *\[**{*OF PAGE page*}**|**{*OF CURRENT PAGE*}**\]*
                   *\[*INDEX idx*\]**}*
     *|* *{*CURRENT LINE*}* *}*
     *\[*[result](javascript:call_link\('abapread_line_result.htm'\))*\]*.

Extras:

[1\. ... LINE line *\[**{*OF PAGE page *}**|**{*OF CURRENT PAGE*}**\]* *\[*INDEXidx*\]*](#!ABAP_ADDITION_1@1@)
[2\. ... CURRENT LINE](#!ABAP_ADDITION_2@2@)

Effect

This statement assigns the content of a line stored in the list buffer to the system field sy-lisel, and allows other target fields to be specified in [result](javascript:call_link\('abapread_line_result.htm'\)). In addition, all values for this line saved using [HIDE](javascript:call_link\('abaphide.htm'\)) are assigned to the respective variables.

The line read is specified using the addition LINE or using CURRENT LINE.

System Fields

sy-subrc

Meaning

0

The specified line exists and was read.

Not 0

The specified line does not exist.

Addition 1

... LINE line *\[**{*OF PAGE page *}**|**{*OF CURRENT PAGE*}**\]* *\[*INDEX idx*\]*

Effect

In the addition LINE, line expects a data object of the type i, which contains the line number based on the list page of a list level.

The list level can be specified with the addition INDEX, where idx expects a data object (which contains the list index) of type i. The value of idx must be greater than or equal to 0. If the addition INDEX is not specified, the list level 0 (the basic list itself) is selected when the basic list is created and the list level at which the event was raised (sy-listi) is selected when a list event is processed.

The list page can be specified either with PAGE page or with CURRENT PAGE. page expects a data object of the type i that contains the page number of an existing page of the list level. No line is selected if no line is found for the specified values in line, idx and page. CURRENT PAGE indicates the topmost displayed page of the list, on which the last list event has taken place. No line is selected while creating the basic list. If no addition is specified for the page, the current page (sy-pagno) is selected when the basic list is created, and the page on which the event was raised (sy-cpage) is selected during the processing of a list event.

Addition 2

... CURRENT LINE

Effect

For the addition CURRENT LINE, the line on which the screen cursor was positioned during a preceding list event (sy-lilli), or the last line read with a preceding READ LINE statement, is selected. No line is selected while creating the basic list.

Example

This example reads all lines of the basic list after selecting a line. The content of the checkbox is assigned to the output data object flag. A target field wa with length 10 is used for the date, since this is the length of the output area and contains separators. If an assignment was made to the output field date, the area length would be reduced. The checked data is displayed in the details list.

DATA: date TYPE d,
      flag TYPE c LENGTH 1,
      wa   TYPE c LENGTH 10.
START-OF-SELECTION.
  date = sy-datum.
  DO 10 TIMES.
    date = date + sy-index.
    WRITE: / flag AS CHECKBOX, (10) date.
  ENDDO.
AT LINE-SELECTION.
  DO.
    READ LINE sy-index FIELD VALUE flag
                                   date INTO wa.
    IF sy-subrc <> 0.
      EXIT.
    ELSEIF flag = 'X'.
      WRITE / wa.
    ENDIF.
  ENDDO.

Continue
[READ LINE - result](javascript:call_link\('abapread_line_result.htm'\))



**📖 Source**: [abapread_line.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapread_line.htm)

### abapread_line_result.htm

> **📖 Official SAP Documentation**: [abapread_line_result.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapread_line_result.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) →  [READ LINE](javascript:call_link\('abapread_line.htm'\)) → 

READ LINE - result

[Quick Reference](javascript:call_link\('abapread_line_shortref.htm'\))

Syntax

... *\[*LINE VALUE INTO wa*\]*
    *\[*FIELD VALUE dobj1 *\[*INTO wa1*\]* dobj2 *\[*INTO wa2*\]* ...*\]*.

Extras:

[1\. ... LINE VALUE INTO wa](#!ABAP_ADDITION_1@1@)
[2\. ... FIELD VALUE dobj1 *\[*INTO wa1*\]* dobj2 *\[*INTO wa2*\]* ...](#!ABAP_ADDITION_2@2@)

Effect

Specifies target fields for READ LINE.

Addition 1

... LINE VALUE INTO wa

Effect

The addition LINE VALUE assigns the formatted content of the complete list line in the list buffer to the data object wa.

Addition 2

... FIELD VALUE dobj1 *\[*INTO wa1*\]* dobj2 *\[*INTO wa2*\]* ...

Effect

The addition FIELD VALUE assigns the output areas
of single data objects dobj1 dobj2... (which have been output to the list buffer) to these data objects, or (if specified) to the data objects wa1 wa2 .... wa or wa1 wa2 ... expects data objects whose data type is covered by the generic type [simple](javascript:call_link\('abenbuilt_in_types_generic.htm'\)), except for [enumerated objects](javascript:call_link\('abenenumerated_object_glosry.htm'\) "Glossary Entry"). The list line or data objects dobj1 dobj2 ... are handled as if they have the data type c, which means that trailing blanks are ignored.

If data objects dobj1 dobj2... appear more than once in a line with the same name, only the first object is read. If a data object dobj1 dobj2 ... is not found at all, the specification is ignored.

If the output area of a data object addressed in the [WRITE](javascript:call_link\('abapwrite-.htm'\)) statement using a field symbol needs to be read, and the same data object is no longer assigned to the field symbol, the name of the data object must be specified and not the name of the field symbol.

Notes

-   No [conversion routine](javascript:call_link\('abenconversion_routine_glosry.htm'\) "Glossary Entry") is executed when an output area is read.
    
-   The content of the line or of the individual output areas in the list is character-like and formatted according to the rules for the WRITE statement. If the line or area is assigned to a data object, the conversion rules apply as with a [source field of type c](javascript:call_link\('abenconversion_type_c.htm'\)). This can lead to incompatibilities with the target fields dobj1 dobj2 ... or wa1 wa2 ... , especially if these are numeric and the output contains separators. Due to this, use of READ LINE is mainly recommended for the evaluation of fields that are ready for input. For other evaluations, [HIDE](javascript:call_link\('abaphide.htm'\)) can be used to save values in a type-friendly way.



**📖 Source**: [abapread_line_result.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapread_line_result.htm)

### abapread_line.htm

> **📖 Official SAP Documentation**: [abapread_line.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapread_line.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) → 

READ LINE

[Quick Reference](javascript:call_link\('abapread_line_shortref.htm'\))

Syntax

READ *{* *{*LINE line *\[**{*OF PAGE page*}**|**{*OF CURRENT PAGE*}**\]*
                   *\[*INDEX idx*\]**}*
     *|* *{*CURRENT LINE*}* *}*
     *\[*[result](javascript:call_link\('abapread_line_result.htm'\))*\]*.

Extras:

[1\. ... LINE line *\[**{*OF PAGE page *}**|**{*OF CURRENT PAGE*}**\]* *\[*INDEXidx*\]*](#!ABAP_ADDITION_1@1@)
[2\. ... CURRENT LINE](#!ABAP_ADDITION_2@2@)

Effect

This statement assigns the content of a line stored in the list buffer to the system field sy-lisel, and allows other target fields to be specified in [result](javascript:call_link\('abapread_line_result.htm'\)). In addition, all values for this line saved using [HIDE](javascript:call_link\('abaphide.htm'\)) are assigned to the respective variables.

The line read is specified using the addition LINE or using CURRENT LINE.

System Fields

sy-subrc

Meaning

0

The specified line exists and was read.

Not 0

The specified line does not exist.

Addition 1

... LINE line *\[**{*OF PAGE page *}**|**{*OF CURRENT PAGE*}**\]* *\[*INDEX idx*\]*

Effect

In the addition LINE, line expects a data object of the type i, which contains the line number based on the list page of a list level.

The list level can be specified with the addition INDEX, where idx expects a data object (which contains the list index) of type i. The value of idx must be greater than or equal to 0. If the addition INDEX is not specified, the list level 0 (the basic list itself) is selected when the basic list is created and the list level at which the event was raised (sy-listi) is selected when a list event is processed.

The list page can be specified either with PAGE page or with CURRENT PAGE. page expects a data object of the type i that contains the page number of an existing page of the list level. No line is selected if no line is found for the specified values in line, idx and page. CURRENT PAGE indicates the topmost displayed page of the list, on which the last list event has taken place. No line is selected while creating the basic list. If no addition is specified for the page, the current page (sy-pagno) is selected when the basic list is created, and the page on which the event was raised (sy-cpage) is selected during the processing of a list event.

Addition 2

... CURRENT LINE

Effect

For the addition CURRENT LINE, the line on which the screen cursor was positioned during a preceding list event (sy-lilli), or the last line read with a preceding READ LINE statement, is selected. No line is selected while creating the basic list.

Example

This example reads all lines of the basic list after selecting a line. The content of the checkbox is assigned to the output data object flag. A target field wa with length 10 is used for the date, since this is the length of the output area and contains separators. If an assignment was made to the output field date, the area length would be reduced. The checked data is displayed in the details list.

DATA: date TYPE d,
      flag TYPE c LENGTH 1,
      wa   TYPE c LENGTH 10.
START-OF-SELECTION.
  date = sy-datum.
  DO 10 TIMES.
    date = date + sy-index.
    WRITE: / flag AS CHECKBOX, (10) date.
  ENDDO.
AT LINE-SELECTION.
  DO.
    READ LINE sy-index FIELD VALUE flag
                                   date INTO wa.
    IF sy-subrc <> 0.
      EXIT.
    ELSEIF flag = 'X'.
      WRITE / wa.
    ENDIF.
  ENDDO.

Continue
[READ LINE - result](javascript:call_link\('abapread_line_result.htm'\))



**📖 Source**: [abapread_line.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapread_line.htm)

### abapmodify_line.htm

> **📖 Official SAP Documentation**: [abapmodify_line.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapmodify_line.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) → 

MODIFY LINE

[Quick Reference](javascript:call_link\('abapmodify_line_shortref.htm'\))

Syntax

MODIFY *{* *{*LINE line *\[*OF *{*PAGE page*}**|**{*CURRENT PAGE*}**\]*
                     *\[*INDEX idx*\]**}*
       *|* *{*CURRENT LINE*}* *}*
       *\[*[source](javascript:call_link\('abapmodify_line_modification.htm'\))*\]*.

Extras:

[1\. ... LINE line *\[**{*OF PAGE page *}**|**{*OF CURRENT PAGE*}**\]* *\[*INDEXidx*\]*](#!ABAP_ADDITION_1@1@)
[2\. ... CURRENT LINE](#!ABAP_ADDITION_2@2@)

Effect

This statement overwrites a line saved in the list buffer with the content of the sy-lisel system field and permits additional modifications as specified in [source](javascript:call_link\('abapmodify_line_modification.htm'\)). In addition, all values for this line saved using HIDE are assigned to the respective variables.

The first output of a data object in the list buffer with the statement [WRITE](javascript:call_link\('abapwrite-.htm'\)) defines the output length, which cannot be changed by the MODIFY statement. The statement MODIFY ignores any output [alignments](javascript:call_link\('abenalignment_glosry.htm'\) "Glossary Entry") that are specified for the output with WRITE and [CENTERED, RIGHT-JUSTIFIED](javascript:call_link\('abapwrite_to_options.htm'\)).

System Fields

sy-subrc

Meaning

0

The specified line exists and was changed.

Not 0

The specified line does not exist.

Notes

-   It is recommended that the system field sy-lisel is filled with the content of the list line to be changed before the statement MODIFY LINE is executed, and that the line is modified exclusively using the information in [source](javascript:call_link\('abapmodify_line_modification.htm'\)), not by changing sy-lisel. The sy-lisel system field is filled either using list events or with the statement [READ LINE](javascript:call_link\('abapread_line.htm'\)).
    
-   The function modules LIST\_ICON\_PREPARE\_FOR\_MODIFY and LIST\_MODIFY\_QUICKINFO can be used to modify icons and tooltips in list lines.
    

Addition 1

... LINE line *\[**{*OF PAGE page*}**|**{*OF CURRENT PAGE*}**\]* *\[*INDEX idx*\]*

Addition 2

... CURRENT LINE

Effect

The line to be changed is specified using the addition LINE or CURRENT LINE. The syntax and description of the additions are the same as for the statement [READ LINE](javascript:call_link\('abapread_line.htm'\)).

Example

When a line in the basic list is double-clicked, the background of the number displayed becomes yellow, and the background of the remaining line becomes green.

START-OF-SELECTION.
  DO 10 TIMES.
    WRITE / sy-index.
  ENDDO.
AT LINE-SELECTION.
  MODIFY CURRENT LINE FIELD FORMAT sy-index COLOR 3
                      LINE FORMAT COLOR 5.

Continue
[MODIFY LINE - source](javascript:call_link\('abapmodify_line_modification.htm'\))



**📖 Source**: [abapmodify_line.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapmodify_line.htm)

### abapmodify_line_modification.htm

> **📖 Official SAP Documentation**: [abapmodify_line_modification.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapmodify_line_modification.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) →  [MODIFY LINE](javascript:call_link\('abapmodify_line.htm'\)) → 

MODIFY LINE - source

[Quick Reference](javascript:call_link\('abapmodify_line_shortref.htm'\))

Syntax

... *\[*LINE VALUE FROM wa*\]*
    *\[*FIELD VALUE dobj1 *\[*FROM wa1*\]*
                 dobj2 *\[*FROM wa2*\]* ...*\]*
    *\[*LINE FORMAT ext\_format\_options*\]*
    *\[*FIELD FORMAT dobj1 ext\_format\_options1
                  dobj2 ext\_format\_options2 ...*\]*.

Extras:

[1\. ... LINE VALUE FROM wa](#!ABAP_ADDITION_1@1@)
[2\. ... FIELD VALUE dobj1 *\[*FROM wa1*\]* dobj2 *\[*FROM wa2*\]* ...](#!ABAP_ADDITION_2@2@)
[3\. ... LINE FORMAT ext\_format\_options](#!ABAP_ADDITION_3@3@)
[4\. ... FIELD FORMAT dobj1 ext\_format\_options1 ...](#!ABAP_ADDITION_4@4@)

Effect

Specifies source fields for MODIFY LINE. Additions modify the list line once this has been overwritten with the content of the sy-lisel system field.

Addition 1

... LINE VALUE FROM wa

Effect

The addition LINE VALUE overwrites the whole list line with the content of wa.

Addition 2

... FIELD VALUE dobj1 *\[*FROM wa1*\]* dobj2 *\[*FROM wa2*\]* ...

Effect

The addition FIELD VALUE overwrites the output areas of individual dobj1 dobj2 ... data objects that are shown in the list line with the current content of these objects, or (if specified) the content of the data objects wa1 wa2 .... wa or wa1 wa2 ... expect character-like data objects, which are truncated if they are too long. For data objects that are too short, the line or the output areas are padded from the right with blanks. If specified, FIELD VALUE overrides LINE VALUE.

If data objects dobj1 dobj2... appear more than once in a line with the same name, only the first object is edited. If a data object dobj1 dobj2 ... is not found at all, it is ignored.

Addition 3

... LINE FORMAT ext\_format\_options

Addition 4

... FIELD FORMAT dobj1 ext\_format\_options1 ...

Effect

For ext\_format\_options, one or more additions of the statement [FORMAT](javascript:call_link\('abapformat.htm'\)) can be specified. The addition FRAMES cannot be used. The addition LINE FORMAT formats the whole list line accordingly; FIELD FORMAT formats only the output areas of the dobj1 dobj2 ... data objects displayed in the list line. If specified, FIELD FORMAT overrides LINE FORMAT.

If data objects dobj1 dobj2... appear more than once in a line with the same name, only the first object is edited. If a data object dobj1 dobj2 ... is not found at all, it is ignored.



**📖 Source**: [abapmodify_line_modification.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapmodify_line_modification.htm)

### abapmodify_line.htm

> **📖 Official SAP Documentation**: [abapmodify_line.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapmodify_line.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) → 

MODIFY LINE

[Quick Reference](javascript:call_link\('abapmodify_line_shortref.htm'\))

Syntax

MODIFY *{* *{*LINE line *\[*OF *{*PAGE page*}**|**{*CURRENT PAGE*}**\]*
                     *\[*INDEX idx*\]**}*
       *|* *{*CURRENT LINE*}* *}*
       *\[*[source](javascript:call_link\('abapmodify_line_modification.htm'\))*\]*.

Extras:

[1\. ... LINE line *\[**{*OF PAGE page *}**|**{*OF CURRENT PAGE*}**\]* *\[*INDEXidx*\]*](#!ABAP_ADDITION_1@1@)
[2\. ... CURRENT LINE](#!ABAP_ADDITION_2@2@)

Effect

This statement overwrites a line saved in the list buffer with the content of the sy-lisel system field and permits additional modifications as specified in [source](javascript:call_link\('abapmodify_line_modification.htm'\)). In addition, all values for this line saved using HIDE are assigned to the respective variables.

The first output of a data object in the list buffer with the statement [WRITE](javascript:call_link\('abapwrite-.htm'\)) defines the output length, which cannot be changed by the MODIFY statement. The statement MODIFY ignores any output [alignments](javascript:call_link\('abenalignment_glosry.htm'\) "Glossary Entry") that are specified for the output with WRITE and [CENTERED, RIGHT-JUSTIFIED](javascript:call_link\('abapwrite_to_options.htm'\)).

System Fields

sy-subrc

Meaning

0

The specified line exists and was changed.

Not 0

The specified line does not exist.

Notes

-   It is recommended that the system field sy-lisel is filled with the content of the list line to be changed before the statement MODIFY LINE is executed, and that the line is modified exclusively using the information in [source](javascript:call_link\('abapmodify_line_modification.htm'\)), not by changing sy-lisel. The sy-lisel system field is filled either using list events or with the statement [READ LINE](javascript:call_link\('abapread_line.htm'\)).
    
-   The function modules LIST\_ICON\_PREPARE\_FOR\_MODIFY and LIST\_MODIFY\_QUICKINFO can be used to modify icons and tooltips in list lines.
    

Addition 1

... LINE line *\[**{*OF PAGE page*}**|**{*OF CURRENT PAGE*}**\]* *\[*INDEX idx*\]*

Addition 2

... CURRENT LINE

Effect

The line to be changed is specified using the addition LINE or CURRENT LINE. The syntax and description of the additions are the same as for the statement [READ LINE](javascript:call_link\('abapread_line.htm'\)).

Example

When a line in the basic list is double-clicked, the background of the number displayed becomes yellow, and the background of the remaining line becomes green.

START-OF-SELECTION.
  DO 10 TIMES.
    WRITE / sy-index.
  ENDDO.
AT LINE-SELECTION.
  MODIFY CURRENT LINE FIELD FORMAT sy-index COLOR 3
                      LINE FORMAT COLOR 5.

Continue
[MODIFY LINE - source](javascript:call_link\('abapmodify_line_modification.htm'\))



**📖 Source**: [abapmodify_line.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapmodify_line.htm)

### abapscroll.htm

> **📖 Official SAP Documentation**: [abapscroll.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapscroll.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) → 

SCROLL LIST

[Quick Reference](javascript:call_link\('abapscroll_shortref.htm'\))

Syntax

SCROLL LIST *\[*[horizontal](javascript:call_link\('abapscroll_list_horizontal.htm'\))*\]*
            *\[*[vertical](javascript:call_link\('abapscroll_list_vertical.htm'\))*\]*
            *\[*INDEX idx*\]*.

Addition:

[... INDEX idx](#!ABAP_ONE_ADD@1@)

Effect

This statement scrolls the display area of a list stored in the list buffer to the position specified in [horizontal](javascript:call_link\('abapscroll_list_horizontal.htm'\)) and/or [vertical](javascript:call_link\('abapscroll_list_vertical.htm'\)). At least one of these additions must be specified, in which all horizontal specifications refer to the columns of a displayed list. The corresponding section is displayed when the list is next displayed.

If the SCROLL statement is not used, a list is displayed during the initial display, starting from the first column of the first line. If the user navigates from a details list back to a lower list level, the list is displayed with the section in which it was last displayed. The SCROLL statement sets a new first column, a new first line, or both. Each SCROLL statement sets only the size specified in it, without changing the other positions.

Addition

... INDEX idx

Effect

The list level can be specified with the addition INDEX, where idx expects a data object (which contains the list index) of type i. The value of idx must be greater than or equal to 0. If the addition INDEX is not specified, the list level 0 (the basic list itself) is selected when the basic list is created and the list level at which the event was raised (sy-listi) is selected when a list event is processed. If the list level specified in idx is not available, sy-subrc is set to the value 8.

System Fields

sy-subrc

Meaning

0

Screen section was scrolled.

4

Complete scrolling not possible because the list margin was reached.

8

Scrolling not possible because the specified list level does not exist.

Note

While scrolling through the list that is being created (sy-lsind), it should be noted that a SCROLL statement is ignored prior to the first output statement, since the list does not yet exist in the list buffer.

Example

By double-clicking the basic list, it is possible to scroll down this list in the event block [AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\)) to the page entered in a [selection screen](javascript:call_link\('abenselection_screen_glosry.htm'\) "Glossary Entry"). The lines on the page retain their original position with reference to the [page header](javascript:call_link\('abenpage_header_glosry.htm'\) "Glossary Entry") by using sy-staro. However, it is not necessary to set the column to sy-staco explicitly, since this position is retained during vertical scrolling.

REPORT LINE-COUNT 100 LINE-SIZE 100
       NO STANDARD PAGE HEADING.
SELECTION-SCREEN BEGIN OF SCREEN 500 AS WINDOW.
PARAMETERS page TYPE i.
SELECTION-SCREEN END OF SCREEN 500.
START-OF-SELECTION.
  DO 10000 TIMES.
    WRITE sy-index.
  ENDDO.
TOP-OF-PAGE.
  ULINE.
  WRITE sy-pagno.
  ULINE.
AT LINE-SELECTION.
  CALL SELECTION-SCREEN 500 STARTING AT 10 10.
  SCROLL LIST TO COLUMN sy-staco
              TO PAGE page LINE sy-staro.

Continue
[SCROLL LIST - horizontal](javascript:call_link\('abapscroll_list_horizontal.htm'\))
[SCROLL LIST - vertical](javascript:call_link\('abapscroll_list_vertical.htm'\))



**📖 Source**: [abapscroll.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapscroll.htm)

### abapscroll_list_horizontal.htm

> **📖 Official SAP Documentation**: [abapscroll_list_horizontal.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapscroll_list_horizontal.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) →  [SCROLL LIST](javascript:call_link\('abapscroll.htm'\)) → 

SCROLL LIST - horizontal

[Quick Reference](javascript:call_link\('abapscroll_shortref.htm'\))

Syntax

... *{*TO COLUMN col*}*
  *|* *{**{*LEFT*|*RIGHT*}* *\[*BY n PLACES*\]**}* ...

Alternatives:

[1\. ... TO COLUMN col](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LEFT *\[*BY n PLACES*\]*](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... RIGHT *\[*BY n PLACES*\]*](#!ABAP_ALTERNATIVE_3@3@)

Effect

These additions are used to scroll horizontally in the list.

Note

When scrolling horizontally using the statement SCROLL, only the upper or lower limit of data objects displayed should be displayed. This is because the positions in the list buffer and in the list displayed only match for these limit values.

Alternative 1

... TO COLUMN col

Effect

The addition TO COLUMN specifies the value from col for the first column in the screen segment; col expects a data object of type i. If the value in col is less than or equal to 0, it is processed as 1; if it is greater than the current line width, it is processed as if it was the same as the line width and a value of 4 is set for sy-subrc.

Alternative 2

... LEFT *\[*BY n PLACES*\]*

Effect

The addition LEFT without BY n PLACES enters a value of 1 for the first column in the screen segment. The addition LEFT with BY n PLACES enters the current first column (sy-staco) minus the value in n as the first column in the display segment; n expects a data object of type i. If the result is less than or equal to 0, it is processed as 1 and a value of 4 is set for sy-subrc.

Alternative 3

... RIGHT *\[*BY n PLACES*\]*

Effect

The addition RIGHT without BY n PLACES enters the line length (sy-linsz) minus the window width (sy-scols minus 2) for the first column in the screen segment. If the result is less than or equal to 0, it is processed as 1. The addition RIGHT with BY n PLACES enters the current first column (sy-staco) plus the value in n for the first column in the display segment; n expects a data object of type i. If the result is greater than the current line length, it is processed as if it were the same as the line length and a value of 4 is set for sy-subrc.



**📖 Source**: [abapscroll_list_horizontal.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapscroll_list_horizontal.htm)

### abapscroll_list_vertical.htm

> **📖 Official SAP Documentation**: [abapscroll_list_vertical.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapscroll_list_vertical.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) →  [SCROLL LIST](javascript:call_link\('abapscroll.htm'\)) → 

SCROLL LIST - vertical

[Quick Reference](javascript:call_link\('abapscroll_shortref.htm'\))

Syntax

... *{*TO *{**{*FIRST PAGE*}**|**{*LAST PAGE*}**|**{*PAGE pag*}**}* *\[*LINE lin*\]**}*
  *|* *{**{*FORWARD*|*BACKWARD*}* *\[*n PAGES*\]**}* ...

Alternatives:

[1\. ... TO FIRST PAGE](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... TO LAST PAGE](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... TO PAGE pag](#!ABAP_ALTERNATIVE_3@3@)
[4\. ... *{*FORWARD*|*BACKWARD*}* *\[*n PAGES*\]*](#!ABAP_ALTERNATIVE_4@4@)

Addition:

[... LINE lin](#!ABAP_ONE_ADD@1@)

Effect

These additions are used to scroll vertically in the list.

Alternative 1

... TO FIRST PAGE

Effect

The addition TO FIRST PAGE defines the top page in the screen segment on the first page in the list.

Alternative 2

... TO LAST PAGE

Effect

The addition TO LAST PAGE defines the top page in the screen segment on the last page in the list.

Alternative 3

... TO PAGE pag

Effect

The addition TO PAGE pag defines the top page in the screen segment on the page specified in pag; pag expects a data object of type i. If the value in pag is 0 or less, it is processed as 1; if it is greater than the number of pages, it is processed as if it were the number of pages a value of 4 is set for sy-subrc.

Addition

... LINE lin

Effect

The addition LINE specifies which line is displayed first on the pages selected using PAGE. If the addition LINE is not used, the list is displayed starting with the first line on the selected page. If the addition LINE is specified, the line on the selected page specified in lin is displayed under the [page header](javascript:call_link\('abenpage_header_glosry.htm'\) "Glossary Entry"), not counting the page header. lin expects a data object of type i. If the value in lin is 0 or less, it is processed as 1; if it is greater than the page length, it is processed as if it were the same as the page length and a value of 4 is set for sy-subrc.

Alternative 4

... *{*FORWARD*|*BACKWARD*}* *\[*n PAGES*\]*

Effect

The additions FORWARD and BACKWARD without n PAGES move the current screen segment up or down by the current number of lines in the GUI window (sy-srows). The [page header](javascript:call_link\('abenpage_header_glosry.htm'\) "Glossary Entry") of the top page displayed is always displayed first.

The additions FORWARD and BACKWARD with n PAGES define the top page in the screen segment on the page derived by adding or subtracting the value in n from the current top page; n expects a data object of type i. If the resulting value is less than or equal to 0 is greater than the number of pages, it is processed as 1 or as if it were the same as the number of pages and a value of 4 is set for sy-subrc. The resulting page is displayed starting with the first line.



**📖 Source**: [abapscroll_list_vertical.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapscroll_list_vertical.htm)

### abapscroll.htm

> **📖 Official SAP Documentation**: [abapscroll.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapscroll.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) → 

SCROLL LIST

[Quick Reference](javascript:call_link\('abapscroll_shortref.htm'\))

Syntax

SCROLL LIST *\[*[horizontal](javascript:call_link\('abapscroll_list_horizontal.htm'\))*\]*
            *\[*[vertical](javascript:call_link\('abapscroll_list_vertical.htm'\))*\]*
            *\[*INDEX idx*\]*.

Addition:

[... INDEX idx](#!ABAP_ONE_ADD@1@)

Effect

This statement scrolls the display area of a list stored in the list buffer to the position specified in [horizontal](javascript:call_link\('abapscroll_list_horizontal.htm'\)) and/or [vertical](javascript:call_link\('abapscroll_list_vertical.htm'\)). At least one of these additions must be specified, in which all horizontal specifications refer to the columns of a displayed list. The corresponding section is displayed when the list is next displayed.

If the SCROLL statement is not used, a list is displayed during the initial display, starting from the first column of the first line. If the user navigates from a details list back to a lower list level, the list is displayed with the section in which it was last displayed. The SCROLL statement sets a new first column, a new first line, or both. Each SCROLL statement sets only the size specified in it, without changing the other positions.

Addition

... INDEX idx

Effect

The list level can be specified with the addition INDEX, where idx expects a data object (which contains the list index) of type i. The value of idx must be greater than or equal to 0. If the addition INDEX is not specified, the list level 0 (the basic list itself) is selected when the basic list is created and the list level at which the event was raised (sy-listi) is selected when a list event is processed. If the list level specified in idx is not available, sy-subrc is set to the value 8.

System Fields

sy-subrc

Meaning

0

Screen section was scrolled.

4

Complete scrolling not possible because the list margin was reached.

8

Scrolling not possible because the specified list level does not exist.

Note

While scrolling through the list that is being created (sy-lsind), it should be noted that a SCROLL statement is ignored prior to the first output statement, since the list does not yet exist in the list buffer.

Example

By double-clicking the basic list, it is possible to scroll down this list in the event block [AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\)) to the page entered in a [selection screen](javascript:call_link\('abenselection_screen_glosry.htm'\) "Glossary Entry"). The lines on the page retain their original position with reference to the [page header](javascript:call_link\('abenpage_header_glosry.htm'\) "Glossary Entry") by using sy-staro. However, it is not necessary to set the column to sy-staco explicitly, since this position is retained during vertical scrolling.

REPORT LINE-COUNT 100 LINE-SIZE 100
       NO STANDARD PAGE HEADING.
SELECTION-SCREEN BEGIN OF SCREEN 500 AS WINDOW.
PARAMETERS page TYPE i.
SELECTION-SCREEN END OF SCREEN 500.
START-OF-SELECTION.
  DO 10000 TIMES.
    WRITE sy-index.
  ENDDO.
TOP-OF-PAGE.
  ULINE.
  WRITE sy-pagno.
  ULINE.
AT LINE-SELECTION.
  CALL SELECTION-SCREEN 500 STARTING AT 10 10.
  SCROLL LIST TO COLUMN sy-staco
              TO PAGE page LINE sy-staro.

Continue
[SCROLL LIST - horizontal](javascript:call_link\('abapscroll_list_horizontal.htm'\))
[SCROLL LIST - vertical](javascript:call_link\('abapscroll_list_vertical.htm'\))



**📖 Source**: [abapscroll.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapscroll.htm)

### abapdescribe_list.htm

> **📖 Official SAP Documentation**: [abapdescribe_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_list.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) → 

DESCRIBE LIST

[Quick Reference](javascript:call_link\('abapdescribe_list_shortref.htm'\))

Syntax

DESCRIBE LIST *{* *{*NUMBER OF  *{*LINES*|*PAGES*}* n*}*
              *|* *{*LINE linno PAGE page*}*
              *|* *{*PAGE pagno [page\_properties](javascript:call_link\('abapdescribe_list_page_properties.htm'\))*}* *}*
              *\[*INDEX idx*\]*.

Alternatives:

[1\. ... NUMBER OF *{*LINES*|*PAGES*}* n](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LINE linno PAGE page](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... PAGE pagno page\_properties](#!ABAP_ALTERNATIVE_3@3@)

Addition:

[... INDEX idx](#!ABAP_ONE_ADD@1@)

Effect

This statement assigns the properties of a list stored in a list buffer to the variables n, page, or the variables specified in [page\_properties](javascript:call_link\('abapdescribe_list_page_properties.htm'\)).

System Fields

sy-subrc

Meaning

0

The list property was successfully specified.

4

The line specified in linno or page specified in pagno cannot be found.

8

The list level specified in idx cannot be found.

Note

The statement DESCRIBE LIST should only be used for completed lists, because not all properties can be read in a list during its creation process.

Addition

... INDEX idx

Effect

The list level can be specified with the addition INDEX, where idx expects a data object (which contains the list index) of type i. The value of idx must be greater than or equal to 0. If the addition INDEX is not specified, the list level 0 (the basic list itself) is selected when the basic list is created and the list level at which the event was raised (sy-listi) is selected when a list event is processed. If the list level specified in idx does not exist, the variables are not changed and sy-subrc is set to the value 8.

Alternative 1

... NUMBER OF *{*LINES*|*PAGES*}* n

Effect

If specified, LINES expects the number of lines, PAGES expects the number of pages in the list saved in n. n expects a data object of the type i. The number of lines is counted from the first to the last line described by an output statement and contains the page headers and page footers. The empty lines inserted automatically between the list pages are not counted.

Alternative 2

... LINE linno PAGE page

Effect

The corresponding page for the line number specified in linno is determined and stored in page. linno and page expect data objects of the type i. If the line specified in linno does not exist, page is not changed and sy-subrc is set to 4. The page headers and page footers are included in the line count, but not the empty lines inserted automatically between the list pages.

Alternative 3

... PAGE pagno page\_properties

Effect

Various properties [page\_properties](javascript:call_link\('abapdescribe_list_page_properties.htm'\)) for the page number specified in pagno are determined and passed to the specified variables. At least one addition must be specified after pagno. pagno expects the data type i. If the page specified in pagno does not exist, the variables are not changed and sy-subrc is set to the value 4.

Example

Determines some properties of the last page of the list currently displayed using two DESCRIBE statements during a list event.

DATA: last\_page  TYPE i,
      lines      TYPE i,
      first\_line TYPE i,
      top\_lines  TYPE i.
...
AT LINE-SELECTION.
  DESCRIBE LIST: NUMBER OF PAGES last\_page,
                 PAGE last\_page LINES lines
                                FIRST-LINE first\_line
                                TOP-LINES  top\_lines.

Continue
[DESCRIBE LIST - page\_properties](javascript:call_link\('abapdescribe_list_page_properties.htm'\))



**📖 Source**: [abapdescribe_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_list.htm)

### abapdescribe_list_page_properties.htm

> **📖 Official SAP Documentation**: [abapdescribe_list_page_properties.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_list_page_properties.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) →  [DESCRIBE LIST](javascript:call_link\('abapdescribe_list.htm'\)) → 

DESCRIBE LIST - page\_properties

[Quick Reference](javascript:call_link\('abapdescribe_list_shortref.htm'\))

Syntax

... *\[*LINE-SIZE width*\]*
    *\[*LINE-COUNT page\_lines*\]*
    *\[*LINES lines*\]*
    *\[*FIRST-LINE first\_line*\]*
    *\[*TOP-LINES top\_lines*\]*
    *\[*TITLE-LINES title\_lines*\]*
    *\[*HEAD-LINES header\_lines*\]*
    *\[*END-LINES footer\_lines*\]* ...

Extras:

[1\. ... LINE-SIZE width](#!ABAP_ADDITION_1@1@)
[2\. ... LINE-COUNT page\_lines](#!ABAP_ADDITION_2@2@)
[3\. ... LINES lines](#!ABAP_ADDITION_3@3@)
[4\. ... FIRST-LINE first\_line](#!ABAP_ADDITION_4@4@)
[5\. ... TOP-LINES top\_lines](#!ABAP_ADDITION_5@5@)
[6\. ... TITLE-LINES title\_lines](#!ABAP_ADDITION_6@6@)
[7\. ... HEAD-LINES header\_lines](#!ABAP_ADDITION_7@7@)
[8\. ... END-LINES footer\_lines](#!ABAP_ADDITION_8@8@)

Effect

Determines the properties of pages using DESCRIBE LIST. The data type i is expected for all target fields.

Addition 1

... LINE-SIZE width

Effect

Inserts the line length of the page defined using the addition LINE-SIZE of the statement at the start of the program or of [NEW-PAGE](javascript:call_link\('abapnew-page.htm'\)) after width.

Addition 2

... LINE-COUNT page\_lines

Effect

Inserts the page length defined using the addition LINE-COUNT of the statement at the start of the program or of NEW-PAGE after page\_lines.

Addition 3

... LINES lines

Effect

Inserts the number of lines shown on the page including the [page header](javascript:call_link\('abenpage_header_glosry.htm'\) "Glossary Entry") and [page footer](javascript:call_link\('abenpage_footer_glosry.htm'\) "Glossary Entry") after lines.

Addition 4

... FIRST-LINE first\_line

Effect

Inserts the line number of the first line of the page, with respect to the whole list, after first\_line. The [page headers](javascript:call_link\('abenpage_header_glosry.htm'\) "Glossary Entry") and [page footers](javascript:call_link\('abenpage_footer_glosry.htm'\) "Glossary Entry") are included in the line count, but not the empty lines inserted automatically between the list pages.

Addition 5

... TOP-LINES top\_lines

Effect

Inserts the number of lines of the [page header](javascript:call_link\('abenpage_header_glosry.htm'\) "Glossary Entry") of the page after top\_lines. The standard page header and the lines shown by the event TOP-OF-PAGE are included in the count.

Addition 6

... TITLE-LINES title\_lines

Effect

Inserts the number of lines of the standard title of the [standard page header](javascript:call_link\('abenstandard_page_header_glosry.htm'\) "Glossary Entry") of the page after title\_lines.

Addition 7

... HEAD-LINES header\_lines

Effect

Inserts the number of lines of the column headers of the [standard page header](javascript:call_link\('abenstandard_page_header_glosry.htm'\) "Glossary Entry") of the page after header\_lines.

Addition 8

... END-LINES footer\_lines

Effect

Inserts the number of lines reserved by the addition LINE-COUNT of the statement at the start of the program for the [page footer](javascript:call_link\('abenpage_footer_glosry.htm'\) "Glossary Entry") after footer\_lines.



**📖 Source**: [abapdescribe_list_page_properties.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_list_page_properties.htm)

### abapdescribe_list.htm

> **📖 Official SAP Documentation**: [abapdescribe_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_list.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Processing Lists in the List Buffer](javascript:call_link\('abenabap_lists_complex.htm'\)) → 

DESCRIBE LIST

[Quick Reference](javascript:call_link\('abapdescribe_list_shortref.htm'\))

Syntax

DESCRIBE LIST *{* *{*NUMBER OF  *{*LINES*|*PAGES*}* n*}*
              *|* *{*LINE linno PAGE page*}*
              *|* *{*PAGE pagno [page\_properties](javascript:call_link\('abapdescribe_list_page_properties.htm'\))*}* *}*
              *\[*INDEX idx*\]*.

Alternatives:

[1\. ... NUMBER OF *{*LINES*|*PAGES*}* n](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LINE linno PAGE page](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... PAGE pagno page\_properties](#!ABAP_ALTERNATIVE_3@3@)

Addition:

[... INDEX idx](#!ABAP_ONE_ADD@1@)

Effect

This statement assigns the properties of a list stored in a list buffer to the variables n, page, or the variables specified in [page\_properties](javascript:call_link\('abapdescribe_list_page_properties.htm'\)).

System Fields

sy-subrc

Meaning

0

The list property was successfully specified.

4

The line specified in linno or page specified in pagno cannot be found.

8

The list level specified in idx cannot be found.

Note

The statement DESCRIBE LIST should only be used for completed lists, because not all properties can be read in a list during its creation process.

Addition

... INDEX idx

Effect

The list level can be specified with the addition INDEX, where idx expects a data object (which contains the list index) of type i. The value of idx must be greater than or equal to 0. If the addition INDEX is not specified, the list level 0 (the basic list itself) is selected when the basic list is created and the list level at which the event was raised (sy-listi) is selected when a list event is processed. If the list level specified in idx does not exist, the variables are not changed and sy-subrc is set to the value 8.

Alternative 1

... NUMBER OF *{*LINES*|*PAGES*}* n

Effect

If specified, LINES expects the number of lines, PAGES expects the number of pages in the list saved in n. n expects a data object of the type i. The number of lines is counted from the first to the last line described by an output statement and contains the page headers and page footers. The empty lines inserted automatically between the list pages are not counted.

Alternative 2

... LINE linno PAGE page

Effect

The corresponding page for the line number specified in linno is determined and stored in page. linno and page expect data objects of the type i. If the line specified in linno does not exist, page is not changed and sy-subrc is set to 4. The page headers and page footers are included in the line count, but not the empty lines inserted automatically between the list pages.

Alternative 3

... PAGE pagno page\_properties

Effect

Various properties [page\_properties](javascript:call_link\('abapdescribe_list_page_properties.htm'\)) for the page number specified in pagno are determined and passed to the specified variables. At least one addition must be specified after pagno. pagno expects the data type i. If the page specified in pagno does not exist, the variables are not changed and sy-subrc is set to the value 4.

Example

Determines some properties of the last page of the list currently displayed using two DESCRIBE statements during a list event.

DATA: last\_page  TYPE i,
      lines      TYPE i,
      first\_line TYPE i,
      top\_lines  TYPE i.
...
AT LINE-SELECTION.
  DESCRIBE LIST: NUMBER OF PAGES last\_page,
                 PAGE last\_page LINES lines
                                FIRST-LINE first\_line
                                TOP-LINES  top\_lines.

Continue
[DESCRIBE LIST - page\_properties](javascript:call_link\('abapdescribe_list_page_properties.htm'\))


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Displaying Lists

**Files**: 15 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Displaying Lists

Included pages: 15



**📖 Source**: [abapdescribe_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdescribe_list.htm)

### abenlists_displayed.htm

> **📖 Official SAP Documentation**: [abenlists_displayed.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlists_displayed.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) → 

Displaying Lists

A basic list is either displayed automatically or in a program-driven way. A details list is always displayed automatically:

-   In [executable programs](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") called using [SUBMIT](javascript:call_link\('abapsubmit.htm'\)), the basic list created up to that point is displayed automatically after the event [END-OF-SELECTION](javascript:call_link\('abapend-of-selection.htm'\)). At the start of the program, the [standard list status](javascript:call_link\('abenstandard_list_status_glosry.htm'\) "Glossary Entry") is set automatically, which can be replaced by another GUI status in the program using [SET PF-STATUS](javascript:call_link\('abapset_pf-status_list.htm'\)).
    
-   In any program that can contain dynpros as components, a display of the current basic list can be called during processing of a [dynpro sequence](javascript:call_link\('abendynpro_sequence_glosry.htm'\) "Glossary Entry") (program-driven).
    
-   In any program that can contain dynpros as components, the details list created in a processing block is displayed automatically when the processing block is terminated after [AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\)), [AT USER-COMMAND](javascript:call_link\('abapat_user-command.htm'\)), or [AT PFnn](javascript:call_link\('abapat_pfnn.htm'\)). If no details list is created, the previous list level is displayed.
    

The following sections cover the statements

-   [LEAVE TO LIST-PROCESSING](javascript:call_link\('abapleave_to_list-processing.htm'\))
    
-   [LEAVE LIST-PROCESSING](javascript:call_link\('abapleave_list-processing.htm'\))
    

used to call the basic list during a dynpro sequence, the statements

-   [WINDOW](javascript:call_link\('abapwindow.htm'\))
    
-   [SET PF-STATUS](javascript:call_link\('abapset_pf-status_list.htm'\))
    
-   [SET TITLEBAR](javascript:call_link\('abapset_titlebar_list.htm'\))
    
-   [SET CURSOR](javascript:call_link\('abapset_cursor_list.htm'\))
    

used to determine properties of the called list, and the statement

-   [GET CURSOR](javascript:call_link\('abapget_cursor_list.htm'\))
    

used to read a displayed list.

Continue
[LEAVE TO LIST-PROCESSING](javascript:call_link\('abapleave_to_list-processing.htm'\))
[LEAVE LIST-PROCESSING](javascript:call_link\('abapleave_list-processing.htm'\))
[WINDOW](javascript:call_link\('abapwindow.htm'\))
[SET PF-STATUS - List](javascript:call_link\('abapset_pf-status_list.htm'\))
[SET TITLEBAR - List](javascript:call_link\('abapset_titlebar_list.htm'\))
[SET CURSOR - List](javascript:call_link\('abapset_cursor_list.htm'\))
[GET CURSOR - List](javascript:call_link\('abapget_cursor_list.htm'\))



**📖 Source**: [abenlists_displayed.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlists_displayed.htm)

### abapleave_to_list-processing.htm

> **📖 Official SAP Documentation**: [abapleave_to_list-processing.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapleave_to_list-processing.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) → 

LEAVE TO LIST-PROCESSING

[Quick Reference](javascript:call_link\('abapleave_to_list-process_shortref.htm'\))

Syntax

LEAVE TO LIST-PROCESSING *\[*AND RETURN TO SCREEN dynnr*\]*.

Addition:

[... AND RETURN TO SCREEN dynnr](#!ABAP_ONE_ADD@1@)

Effect

This statement can be executed during [PBO](javascript:call_link\('abenpbo_glosry.htm'\) "Glossary Entry") and [PAI](javascript:call_link\('abenpai_glosry.htm'\) "Glossary Entry") processing. After the current dynpro is processed, this statement interrupts the current [dynpro sequence](javascript:call_link\('abendynpro_sequence_glosry.htm'\) "Glossary Entry"), starts the list processor, and displays the basic list. The basic list consists of any list output of all PBO and PAI modules of the dynpro sequence executed to this point. The statement is ignored in the event blocks for [reporting events](javascript:call_link\('abenreporting_event_glosry.htm'\) "Glossary Entry") and [list events](javascript:call_link\('abenlist_event_glosry.htm'\) "Glossary Entry").

The [screen](javascript:call_link\('abenscreen_glosry.htm'\) "Glossary Entry") of the [list dynpro](javascript:call_link\('abenlist_dynpro_glosry.htm'\) "Glossary Entry") of the list processor replaces the screen shown in the [popup level](javascript:call_link\('abenpop-up_level_glosry.htm'\) "Glossary Entry") 0. Any modal dialog windows stacked above this are hidden while the list is being displayed. The GUI status set in the dynpro sequence is used. Any list events triggered by user actions in the GUI window of the list dynpro call the event blocks of the current [main program](javascript:call_link\('abenmain_program_glosry.htm'\) "Glossary Entry"). Any details lists created there are displayed by the list processor in the GUI window of the basic list (unless the statement [WINDOW](javascript:call_link\('abapwindow.htm'\)) is used).

The user can exit the list processor or list display by selecting the functions Back, Exit, or Cancel in the display for list level 0, or by means of a program that uses the [LEAVE LIST-PROCESSING](javascript:call_link\('abapleave_list-processing.htm'\)) statement. By default, the interrupted dynpro sequence resumes in both cases with the PBO processing of the dynpro in which the list processor was called.

Addition

... AND RETURN TO SCREEN dynnr

Effect

Using the addition AND RETURN TO SCREEN, another dynpro can be specified in dynnr for continuing PBO processing. dynnr expects a character-like data object that contains the number of a dynpro in the current main program.

Notes

-   If the current dynpro is displayed in a dialog box, the list processor also displays the lists in this window.
    
-   If the value 0 is specified in dynnr, the current dynpro sequence is closed after the list processor is exited.
    

Executable Example

[Calling Lists from Dynpro Processing](javascript:call_link\('abenleave_to_list_proc_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Calling Lists from Dynpro Processing](javascript:call_link\('abenleave_to_list_proc_abexa.htm'\))



**📖 Source**: [abapleave_to_list-processing.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapleave_to_list-processing.htm)

### abenleave_to_list_proc_abexa.htm

> **📖 Official SAP Documentation**: [abenleave_to_list_proc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenleave_to_list_proc_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) →  [LEAVE TO LIST-PROCESSING](javascript:call_link\('abapleave_to_list-processing.htm'\)) → 

Calling Lists from Dynpro Processing

This example shows how to switch from dynpro processing to list processing.

Source Code

REPORT demo\_leave\_to\_list\_processing .
TABLES demo\_conn.
DATA: wa\_spfli TYPE spfli,
      flightdate TYPE sflight-fldate.
CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command\_0100.
  CALL SCREEN 500.
  SET SCREEN 100.
ENDMODULE.
MODULE call\_list\_500 OUTPUT.
  LEAVE TO LIST-PROCESSING AND RETURN TO SCREEN 0.
  SET PF-STATUS space.
  SUPPRESS DIALOG.
  SELECT  carrid, connid, cityfrom, cityto
    FROM  spfli
    WHERE carrid = @demo\_conn-carrid
    INTO  CORRESPONDING FIELDS OF @wa\_spfli.
    WRITE: / wa\_spfli-carrid, wa\_spfli-connid,
             wa\_spfli-cityfrom, wa\_spfli-cityto.
    HIDE: wa\_spfli-carrid, wa\_spfli-connid.
  ENDSELECT.
  CLEAR wa\_spfli-carrid.
ENDMODULE.
TOP-OF-PAGE.
  WRITE text-001 COLOR COL\_HEADING.
  ULINE.
TOP-OF-PAGE DURING LINE-SELECTION.
  WRITE sy-lisel COLOR COL\_HEADING.
  ULINE.
AT LINE-SELECTION.
  CHECK NOT wa\_spfli-carrid IS INITIAL.
  SELECT  fldate
    FROM  sflight
    WHERE carrid = @wa\_spfli-carrid AND
          connid = @wa\_spfli-connid
    INTO  @flightdate.
    WRITE / flightdate.
  ENDSELECT.
  CLEAR wa\_spfli-carrid.

Description

This example switches to list processing while processing dynpro 100. The screen layout of dynpro 100 has a single input field, the component CARRID of the structure SDYN\_CONN from ABAP Dictionary. The flow logic of dynpro 100 is:

PROCESS BEFORE OUTPUT.
  MODULE status\_0100.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE user\_command\_0100.

In the PAI module user\_command\_0100, CALL SCREEN is used to call dynpro 500. Dynpro 500 encapsulates a basic list. It has the following flow logic:

PROCESS BEFORE OUTPUT.
  MODULE call\_list\_500.
PROCESS AFTER INPUT.

The module call\_list\_500 defines the basic list and switches to list processing. After returning from the list display, the system branches to the next dynpro 0, which means that dynpro 500 represents a dynpro sequence with only one dynpro. When list processing is complete, the system goes back to a point after the call point in user\_command\_0100.

If the user selects a line on the basic list, a details list appears. This is done using the event block AT LINE-SELECTION. The program also contains event blocks for TOP-OF-PAGE and TOP-OF-PAGE DURING LINE-SELECTION, which define page headers for both the basic list and details list.

Since there is only one list system in this program, there is no need for case distinctions within the list events.



**📖 Source**: [abenleave_to_list_proc_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenleave_to_list_proc_abexa.htm)

### abapleave_to_list-processing.htm

> **📖 Official SAP Documentation**: [abapleave_to_list-processing.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapleave_to_list-processing.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) → 

LEAVE TO LIST-PROCESSING

[Quick Reference](javascript:call_link\('abapleave_to_list-process_shortref.htm'\))

Syntax

LEAVE TO LIST-PROCESSING *\[*AND RETURN TO SCREEN dynnr*\]*.

Addition:

[... AND RETURN TO SCREEN dynnr](#!ABAP_ONE_ADD@1@)

Effect

This statement can be executed during [PBO](javascript:call_link\('abenpbo_glosry.htm'\) "Glossary Entry") and [PAI](javascript:call_link\('abenpai_glosry.htm'\) "Glossary Entry") processing. After the current dynpro is processed, this statement interrupts the current [dynpro sequence](javascript:call_link\('abendynpro_sequence_glosry.htm'\) "Glossary Entry"), starts the list processor, and displays the basic list. The basic list consists of any list output of all PBO and PAI modules of the dynpro sequence executed to this point. The statement is ignored in the event blocks for [reporting events](javascript:call_link\('abenreporting_event_glosry.htm'\) "Glossary Entry") and [list events](javascript:call_link\('abenlist_event_glosry.htm'\) "Glossary Entry").

The [screen](javascript:call_link\('abenscreen_glosry.htm'\) "Glossary Entry") of the [list dynpro](javascript:call_link\('abenlist_dynpro_glosry.htm'\) "Glossary Entry") of the list processor replaces the screen shown in the [popup level](javascript:call_link\('abenpop-up_level_glosry.htm'\) "Glossary Entry") 0. Any modal dialog windows stacked above this are hidden while the list is being displayed. The GUI status set in the dynpro sequence is used. Any list events triggered by user actions in the GUI window of the list dynpro call the event blocks of the current [main program](javascript:call_link\('abenmain_program_glosry.htm'\) "Glossary Entry"). Any details lists created there are displayed by the list processor in the GUI window of the basic list (unless the statement [WINDOW](javascript:call_link\('abapwindow.htm'\)) is used).

The user can exit the list processor or list display by selecting the functions Back, Exit, or Cancel in the display for list level 0, or by means of a program that uses the [LEAVE LIST-PROCESSING](javascript:call_link\('abapleave_list-processing.htm'\)) statement. By default, the interrupted dynpro sequence resumes in both cases with the PBO processing of the dynpro in which the list processor was called.

Addition

... AND RETURN TO SCREEN dynnr

Effect

Using the addition AND RETURN TO SCREEN, another dynpro can be specified in dynnr for continuing PBO processing. dynnr expects a character-like data object that contains the number of a dynpro in the current main program.

Notes

-   If the current dynpro is displayed in a dialog box, the list processor also displays the lists in this window.
    
-   If the value 0 is specified in dynnr, the current dynpro sequence is closed after the list processor is exited.
    

Executable Example

[Calling Lists from Dynpro Processing](javascript:call_link\('abenleave_to_list_proc_abexa.htm'\))

Continue
![Example](exa.gif "Example") [Calling Lists from Dynpro Processing](javascript:call_link\('abenleave_to_list_proc_abexa.htm'\))



**📖 Source**: [abapleave_to_list-processing.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapleave_to_list-processing.htm)

### abapleave_list-processing.htm

> **📖 Official SAP Documentation**: [abapleave_list-processing.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapleave_list-processing.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) → 

LEAVE LIST-PROCESSING

[Quick Reference](javascript:call_link\('abapleave_list-processing_shortref.htm'\))

Syntax

LEAVE LIST-PROCESSING.

Effect

This statement immediately exits the list processor. The runtime environment continues processing with the [PBO](javascript:call_link\('abenpbo_glosry.htm'\) "Glossary Entry") event of the dynpro from which the list processor was called using [LEAVE TO LIST-PROCESSING](javascript:call_link\('abapleave_to_list-processing.htm'\)) or the dynpro that was set using the addition [AND RETURN TO SCREEN](javascript:call_link\('abapleave_to_list-processing.htm'\)) of this statement.

If the statement is not executed when the list is displayed by the list processor, it is ignored, except in the event blocks for [reporting events](javascript:call_link\('abenreporting_event_glosry.htm'\) "Glossary Entry"). Here, the processor branches to the end of the program and continues in accordance with the [process flow](javascript:call_link\('abenreporting_process.htm'\)) for executable programs.

When the list processor is exited, the list buffer of the [dynpro sequence](javascript:call_link\('abendynpro_sequence_glosry.htm'\) "Glossary Entry") is initialized. New output statements describe a new basic list.

Example

This example shows the recommended procedure for displaying lists during dynpro sequences. A separate dynpro 500 is defined for calling the list processor. The [screen](javascript:call_link\('abenscreen_glosry.htm'\) "Glossary Entry") of this dynpro does not contain any screen elements and calls a single PBO module call\_list but no [PAI](javascript:call_link\('abenpai_glosry.htm'\) "Glossary Entry") modules. The full basic list, including the GUI status, is defined in the PBO module. When the dynpro is exited using LEAVE SCREEN, its processing is stopped and the list processor is started. The list events are handled in the same program. When the list processor is exited, the dynpro sequence of dynpro 500 is ended, because the [next dynpro](javascript:call_link\('abennext_dynpro_glosry.htm'\) "Glossary Entry") 0 is specified when the list processor is called.

PROGRAM demo NO STANDARD PAGE HEADING.
...
MODULE call\_list OUTPUT.
  SET PF-STATUS space.
  WRITE 'Basic List'.
  LEAVE TO LIST-PROCESSING AND RETURN TO SCREEN 0.
  LEAVE SCREEN.
ENDMODULE.
TOP-OF-PAGE.
  WRITE 'Header' COLOR COL\_HEADING.
  ULINE.
TOP-OF-PAGE DURING LINE-SELECTION.
  WRITE sy-lsind COLOR COL\_HEADING.
  ULINE.
AT LINE-SELECTION.
  WRITE 'Secondary List'.
  IF sy-lsind = 20.
    LEAVE LIST-PROCESSING.
  ENDIF.



**📖 Source**: [abapleave_list-processing.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapleave_list-processing.htm)

### abapwindow.htm

> **📖 Official SAP Documentation**: [abapwindow.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapwindow.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) → 

WINDOW

[Quick Reference](javascript:call_link\('abapwindow_shortref.htm'\))

Syntax

WINDOW STARTING AT col1 lin1
       *\[*ENDING  AT col2 lin2*\]*.

Effect

This statement initiates the display of the current details list in a dialog box. It only works in the event blocks for an interactive list event. If there are multiple WINDOW statements in an event block, the last one is valid.

The upper left corner is determined for the column and the row by the values in col1 and lin1. The values are based on the GUI window of the basic list. The lower right corner is set automatically. The maximum lower right corner can either be specified in col2 and lin2 or is specified using the lower right corner of the GUI window where the list event took place.

col1, lin1, col2, and lin2 expect data objects of the type i. The values of all data objects should lie within the GUI window of the basic list and the values of col1 and lin1 should be less than those of col2 and lin2. If not, the behavior is undefined.

If no GUI status is set using [SET PF-STATUS](javascript:call_link\('abapset_pf-status_list.htm'\)) and an event block is defined using [AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\)) or [AT PFnn](javascript:call_link\('abapat_pfnn.htm'\)), the system automatically uses a [standard list status](javascript:call_link\('abenstandard_list_status_glosry.htm'\) "Glossary Entry") suitable for the dialog box without a [menu bar](javascript:call_link\('abenmenu_bar_glosry.htm'\) "Glossary Entry") and [system toolbar](javascript:call_link\('abenstandard_toolbar_glosry.htm'\) "Glossary Entry"). This includes pushbuttons for the predefined function codes "PICK" (only for AT LINE-SELECTION), "PRI", "%SC", "%SC+", and "RW" in the [application toolbar](javascript:call_link\('abenapplication_toolbar_glosry.htm'\) "Glossary Entry").

Note

If a GUI status is set using SET PF-STATUS, this should be created in [Menu Painter](javascript:call_link\('abenmenu_painter_glosry.htm'\) "Glossary Entry") as a dialog box status; the list template should also be included.

Example

Displays the details of an airline in a dialog box after a row is selected.

DATA: scarr\_wa TYPE scarr,
      col      TYPE i,
      lin      TYPE i.
START-OF-SELECTION.
   SELECT carrid
          FROM scarr
          INTO scarr\_wa-carrid.
    WRITE / scarr\_wa-carrid.
    HIDE  scarr\_wa-carrid.
  ENDSELECT.
  CLEAR scarr\_wa-carrid.
AT LINE-SELECTION.
  col = sy-cucol + 40.
  lin = sy-curow + 2.
  WINDOW STARTING AT sy-cucol sy-curow
         ENDING   AT col lin.
  IF sy-lsind = 1 AND
     scarr\_wa-carrid IS NOT INITIAL.
    SELECT SINGLE carrname, url
           FROM scarr
           WHERE carrid = @scarr\_wa-carrid
           INTO (@scarr\_wa-carrname, @scarr\_wa-url).
    WRITE: scarr\_wa-carrname, / scarr\_wa-url.
  ENDIF.

Continue
![Example](exa.gif "Example") [Lists, Dialog Boxes](javascript:call_link\('abenlist_window_abexa.htm'\))



**📖 Source**: [abapwindow.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapwindow.htm)

### abenlist_window_abexa.htm

> **📖 Official SAP Documentation**: [abenlist_window_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_window_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) →  [WINDOW](javascript:call_link\('abapwindow.htm'\)) → 

Lists, Dialog Boxes

The example shows how to display a details list in the dialog box.

Source Code

REPORT demo\_list\_window NO STANDARD PAGE HEADING.
START-OF-SELECTION.
  SET PF-STATUS 'BASIC'.
  WRITE 'Select line for a demonstration of windows'.
AT USER-COMMAND.
  CASE sy-ucomm.
    WHEN 'SELE'.
      IF sy-lsind = 1.
        SET PF-STATUS 'DIALOG'.
        SET TITLEBAR 'WI1'.
        WINDOW STARTING AT 5 3 ENDING AT 40 10.
        WRITE 'Select line for a second window'.
      ELSEIF sy-lsind = 2.
        SET PF-STATUS 'DIALOG' EXCLUDING 'SELE'.
        SET TITLEBAR 'WI2'.
        WINDOW STARTING AT 45 10 ENDING AT 60 12.
        WRITE 'Last window'.
      ENDIF.
  ENDCASE.

Description

This program sets status BASIC for the basic list. In the status BASIC, the default function code PICK for the key F2 is replaced by the user-defined function code SELE (text SELECT) and SELE is inserted in the application toolbar.

For this reason, SELECT, F2, and double-clicking with the mouse all raise the event AT USER-COMMAND. In the corresponding processing block, list levels 1 and 2 have the status DIALOG and appear as a dialog box. Like in the status BASIC, the default function code PICK is replaced in the status DIALOG by the function code SELE which is inserted in the application toolbar after Cancel.

Titles WI1 and WI2 are defined for the dialog boxes. In the second dialog box, the function code SELE has been disabled using the addition EXCLUDING in the statement SET PF-STATUS.

The system displays horizontal scroll bars in the dialog boxes since the list width of the dialog boxes is not adjusted and therefore corresponds to the standard width of the basic list.



**📖 Source**: [abenlist_window_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_window_abexa.htm)

### abapwindow.htm

> **📖 Official SAP Documentation**: [abapwindow.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapwindow.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) → 

WINDOW

[Quick Reference](javascript:call_link\('abapwindow_shortref.htm'\))

Syntax

WINDOW STARTING AT col1 lin1
       *\[*ENDING  AT col2 lin2*\]*.

Effect

This statement initiates the display of the current details list in a dialog box. It only works in the event blocks for an interactive list event. If there are multiple WINDOW statements in an event block, the last one is valid.

The upper left corner is determined for the column and the row by the values in col1 and lin1. The values are based on the GUI window of the basic list. The lower right corner is set automatically. The maximum lower right corner can either be specified in col2 and lin2 or is specified using the lower right corner of the GUI window where the list event took place.

col1, lin1, col2, and lin2 expect data objects of the type i. The values of all data objects should lie within the GUI window of the basic list and the values of col1 and lin1 should be less than those of col2 and lin2. If not, the behavior is undefined.

If no GUI status is set using [SET PF-STATUS](javascript:call_link\('abapset_pf-status_list.htm'\)) and an event block is defined using [AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\)) or [AT PFnn](javascript:call_link\('abapat_pfnn.htm'\)), the system automatically uses a [standard list status](javascript:call_link\('abenstandard_list_status_glosry.htm'\) "Glossary Entry") suitable for the dialog box without a [menu bar](javascript:call_link\('abenmenu_bar_glosry.htm'\) "Glossary Entry") and [system toolbar](javascript:call_link\('abenstandard_toolbar_glosry.htm'\) "Glossary Entry"). This includes pushbuttons for the predefined function codes "PICK" (only for AT LINE-SELECTION), "PRI", "%SC", "%SC+", and "RW" in the [application toolbar](javascript:call_link\('abenapplication_toolbar_glosry.htm'\) "Glossary Entry").

Note

If a GUI status is set using SET PF-STATUS, this should be created in [Menu Painter](javascript:call_link\('abenmenu_painter_glosry.htm'\) "Glossary Entry") as a dialog box status; the list template should also be included.

Example

Displays the details of an airline in a dialog box after a row is selected.

DATA: scarr\_wa TYPE scarr,
      col      TYPE i,
      lin      TYPE i.
START-OF-SELECTION.
   SELECT carrid
          FROM scarr
          INTO scarr\_wa-carrid.
    WRITE / scarr\_wa-carrid.
    HIDE  scarr\_wa-carrid.
  ENDSELECT.
  CLEAR scarr\_wa-carrid.
AT LINE-SELECTION.
  col = sy-cucol + 40.
  lin = sy-curow + 2.
  WINDOW STARTING AT sy-cucol sy-curow
         ENDING   AT col lin.
  IF sy-lsind = 1 AND
     scarr\_wa-carrid IS NOT INITIAL.
    SELECT SINGLE carrname, url
           FROM scarr
           WHERE carrid = @scarr\_wa-carrid
           INTO (@scarr\_wa-carrname, @scarr\_wa-url).
    WRITE: scarr\_wa-carrname, / scarr\_wa-url.
  ENDIF.

Continue
![Example](exa.gif "Example") [Lists, Dialog Boxes](javascript:call_link\('abenlist_window_abexa.htm'\))



**📖 Source**: [abapwindow.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapwindow.htm)

### abapset_pf-status_list.htm

> **📖 Official SAP Documentation**: [abapset_pf-status_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_pf-status_list.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) → 

SET PF-STATUS - List

[Quick Reference](javascript:call_link\('abapset_pf-status_shortref.htm'\))

Syntax

SET PF-STATUS status *\[*OF PROGRAM prog*\]* *\[*EXCLUDING fcode*\]*
                     *\[*IMMEDIATELY*\]*.

Extras:

[1\. ... OF PROGRAM prog](#!ABAP_ADDITION_1@1@)
[2\. ... EXCLUDING fcode](#!ABAP_ADDITION_2@2@)
[3\. ... IMMEDIATELY](#!ABAP_ADDITION_3@3@)

Effect

In list processing, this statement sets the GUI status specified in status for the display window of the current list, and all subsequent list levels until the next SET PF-STATUS statement. The statement mostly has the same function as for [dynpros](javascript:call_link\('abapset_pf-status_dynpro.htm'\)).

Unlike the [screen layouts](javascript:call_link\('abenscreen_glosry.htm'\) "Glossary Entry") of dynpros, however, every list level is automatically associated with the GUI status that is set for it. If the system returns from displaying a higher list level to a lower list level, the latter is displayed again with the GUI status that was set for it.

If the status of the data object is initial, the standard list status is set and the additions OF PROGRAM and EXCLUDING are ignored. The [standard list status](javascript:call_link\('abenstandard_list_status_glosry.htm'\) "Glossary Entry") contains predefined list-specific functions whose functions are handled by the runtime environment when a screen list is displayed, and do produce calls of event blocks in the ABAP program. If event blocks are also defined with AT LINE-SELECTION or AT PFnn, further function keys are automatically assigned function codes in the standard list status:

-   If [AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\)) is used, the F2 key and the double-click function of the mouse is assigned the function code "PICK" and the function text Select. This function is then also automatically displayed in the [application toolbar](javascript:call_link\('abenapplication_toolbar_glosry.htm'\) "Glossary Entry").
    
-   If [AT PFnn](javascript:call_link\('abapat_pfnn.htm'\)) is used, all the Fnn functions of the keyboard that are not handled by the runtime environment are assigned the function codes "PFnn", where "nn" is a number between 01 and 24.
    

If the standard list status is set, sy-pfkey is assigned the value "STLI".

Note

When setting the GUI status for the [list dynpro](javascript:call_link\('abenlist_dynpro_glosry.htm'\) "Glossary Entry"), it is best to set a GUI status for which a list status has been included as a template status in [Menu Painter](javascript:call_link\('abenmenu_painter_glosry.htm'\) "Glossary Entry"). Including this type of template status passes the list-specific functions of the standard list status to a self-defined GUI status.

Addition 1

... OF PROGRAM prog

Addition 2

... EXCLUDING fcode

Effect

As for [dynpros](javascript:call_link\('abapset_pf-status_dynpro.htm'\)).

Addition 3

... IMMEDIATELY

Effect

The addition IMMEDIATELY only has an effect if it is used when creating a details list, that is, within an event block following an interactive list event. The effect of this addition is that SET PF-STATUS has an effect on the current displayed list (sy-listi) and all subsequent list levels, and not only starting from the current details list (sy-lsind).

Example

In the following program segment, it is only possible to select a single line from the basic list by double-clicking the mouse or using the function key F2. This function is then deactivated for the basic list and all subsequent list levels.

START-OF-SELECTION.
  SET PF-STATUS 'BASIC'.
  WRITE / \`Pick me!\`.
AT LINE-SELECTION.
  SET PF-STATUS 'BASIC' EXCLUDING 'PICK' IMMEDIATELY.
  WRITE / \`Don't pick me!\`.



**📖 Source**: [abapset_pf-status_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_pf-status_list.htm)

### abapset_titlebar_list.htm

> **📖 Official SAP Documentation**: [abapset_titlebar_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_titlebar_list.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) → 

SET TITLEBAR - List

[Quick Reference](javascript:call_link\('abapset_titlebar_shortref.htm'\))

Syntax

SET TITLEBAR title *\[*OF PROGRAM prog*\]*
                   *\[*WITH text1 ... text9*\]*.

Extras:

[1\. ... OF PROGRAM prog](#!ABAP_ADDITION_1@1@)
[2\. ... WITH text1 ... text9](#!ABAP_ADDITION_2@2@)

Effect

In list processing, this statement sets the GUI title specified in title for the display window of the current list level and all following list levels up to the next statement SET TITLEBAR. The statement has mostly the same syntax and semantics as for [dynpros](javascript:call_link\('abapset_titlebar_dynpro.htm'\)).

Unlike in [screens](javascript:call_link\('abenscreen_glosry.htm'\) "Glossary Entry") of dynpros, each list level remains automatically associated with the title set for it. When the display of a higher list level is switched to the display of a lower list level, the latter is displayed with the title that was set for it.

Addition 1

...  OF PROGRAM prog

Addition 2

... WITH text1 ... text9

Effect

As for [dynpros](javascript:call_link\('abapset_titlebar_dynpro.htm'\)).



**📖 Source**: [abapset_titlebar_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_titlebar_list.htm)

### abapset_cursor_list.htm

> **📖 Official SAP Documentation**: [abapset_cursor_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_cursor_list.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) → 

SET CURSOR - List

[Quick Reference](javascript:call_link\('abapset_cursor_shortref.htm'\))

Syntax

SET CURSOR *{* *{* FIELD field LINE line
                     *\[**\[*DISPLAY*|*MEMORY*\]* OFFSET off*\]* *}*
           *|* *{* LINE  line *\[**\[*DISPLAY*|*MEMORY*\]* OFFSET off*\]* *}*
           *|* *{* col lin *}* *}*.

Alternatives:

[1\. ... FIELD field LINE line *\[**\[*DISPLAY*|*MEMORY*\]* OFFSET off*\]*](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LINE line *\[**\[*DISPLAY*|*MEMORY*\]* OFFSET off*\]*](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... col lin](#!ABAP_ALTERNATIVE_3@3@)

Effect

In list processing, this statement positions the cursor in the next list displayed on the screen. This is either the current list or, if no details list is created in an event block after an interactive event, the previous list. The cursor can be positioned by entering a field after FIELD or a line after LINE, or by entering a specific position using col and lin.

If the statement SET CURSOR is not specified, the cursor is positioned by default in the first field in the list that is ready for input or in the command field in the [standard toolbar](javascript:call_link\('abenstandard_toolbar_glosry.htm'\) "Glossary Entry").

The statement is ignored if the specified position is outside the display area of the list, or if it points to [line elements](javascript:call_link\('abenline_element_glosry.htm'\) "Glossary Entry").

Note

The exact position of the cursor is only visible in output areas that are ready for input. Otherwise the whole area in which the cursor is positioned is selected.

Alternative 1

... FIELD field LINE line *\[**\[*DISPLAY*|*MEMORY*\]* OFFSET off*\]*

Effect

The cursor is positioned in the list line specified in line in the output area of the data object whose name is contained in field. The entry is not case-sensitive.

-   If OFFSET is not specified, the cursor is positioned in the first column of the output area.
    
-   If OFFSET is specified without an addition, or with the addition DISPLAY, the cursor is positioned in the column of the output area entered in off.
    
-   If OFFSET is specified with the addition MEMORY, the cursor is positioned on the character in the output area that is specified in off in the list buffer in the output of the data object in field. If this character is cut off in the list display, the cursor is positioned on the corresponding indicator (< or >).
    

The data object field must be character-like and [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry"). line and off expect data objects of type i.

If the data object specified in field was contained in the output more than once in the visible area of the line, the cursor is positioned in the first output area. If the data object specified in field does not occur in the visible area of the line, the specification is ignored.

If the cursor is to be positioned in the output area of a data object addressed in the WRITE statement using a field symbol, and the same data object is no longer assigned to the field symbol, the name of the data object must be contained in field, and not the name of the field symbol.

Example

In the following output, the cursor is positioned in the output area ready for input of the field input. Without the SET CURSOR statement, the cursor would be positioned on the previous checkbox.

DATA: flag TYPE c LENGTH 1,
      inp  TYPE c LENGTH 10.
SET BLANK LINES ON.
WRITE: / flag AS CHECKBOX, inp INPUT.
SET CURSOR FIELD 'inp' LINE sy-linno.

Alternative 2

... LINE line *\[**\[*DISPLAY*|*MEMORY*\]* OFFSET off*\]*

Effect

The cursor is positioned in the list line specified in line.

-   If OFFSET is not specified, the cursor is positioned in the first column of the row.
    
-   If OFFSET is specified without an addition, or with the addition DISPLAY, the cursor is positioned in the column entered in off.
    
-   If OFFSET is specified with the addition MEMORY, the cursor is positioned on the character in the position specified in off in the list buffer. If this character is cut off in the list display, the cursor is positioned on the corresponding indicator (< or >).
    

line and off expect data objects of type i.

Note

This variant of the SET CURSOR statement does not work in [screen layouts](javascript:call_link\('abenscreen_glosry.htm'\) "Glossary Entry").

Alternative 3

... col lin

Effect

The cursor is positioned in the column specified in col and the line specified in lin in the list window. col and lin expect data objects of the type i. Column numbering begins at 2.



**📖 Source**: [abapset_cursor_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_cursor_list.htm)

### abapget_cursor_list.htm

> **📖 Official SAP Documentation**: [abapget_cursor_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_cursor_list.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) → 

GET CURSOR - List

[Quick Reference](javascript:call_link\('abapget_cursor_shortref.htm'\))

Syntax

GET CURSOR *{* *{*FIELD field *\[* [field\_properties](javascript:call_link\('abapget_cursor_list_field.htm'\))*\]**}*
           *|* *{*LINE line *\[* [line\_properties](javascript:call_link\('abapget_cursor_list_field.htm'\))*\]**}* *}*.

Variants:

[1\. GET CURSOR FIELD field *\[*field\_properties*\]*.](#!ABAP_VARIANT_1@1@)
[2\. GET CURSOR LINE line *\[*line\_properties*\]*.](#!ABAP_VARIANT_2@2@)

Effect

If this statement is specified in list processing, it passes the name of the output field or the number of the list line on which the screen cursor in the displayed list is positioned (after the user action) to the variables field or line, depending on how FIELD or LINE is specified. Further information on the cursor position can be read if required.

System Fields

sy-subrc

Meaning

0

The cursor is on a field or a list line and the statement was executed successfully.

4

The cursor is not on any field or any list line.

Variant 1

GET CURSOR FIELD field *\[*field\_properties*\]*.

Effect

Returns the name of the displayed field in field after a user action. This name is where the cursor is positioned in the currently displayed list. field expects a character-like variable. The addition [field\_properties](javascript:call_link\('abapget_cursor_list_field.htm'\)) can be used to read further information about the cursor position.

If the screen cursor is on a subarea displayed using an [offset/length](javascript:call_link\('abenoffset_length.htm'\)) of a structure, the following rules apply:

-   The subarea of the structure has been displayed using the name of the structure:
    

-   If the subarea includes the entire structure, the name of the structure is returned.

-   If the subarea only includes a part of the structure, the name of the component is returned in which the subarea begins.

-   The subarea of the structure has been displayed using the name of a component of the structure:
    

-   The name of the component is returned in which the subarea begins.

These rules also apply to substructures.

The addition FIELD can only be used to determine the names of global data objects of the ABAP program. If the cursor is positioned on the output of a data object that is not visible in the current context or a literal, field is initialized. This has no influence on the other additions or on sy-subrc.

If the cursor is on the output area of a data object that was accessed in the WRITE statement using a field symbol, the name of the data object is returned and not the name of the field symbol.

Variant 2

GET CURSOR LINE line *\[*line\_properties*\]*.

Effect

Returns the number of the list line in line after a user action. This line is where the cursor is positioned in the currently displayed list. line expects a variable of type i. The addition [line\_properties](javascript:call_link\('abapget_cursor_list_line.htm'\)) can be used to read further information about the cursor position.

Continue
[GET CURSOR - field\_properties](javascript:call_link\('abapget_cursor_list_field.htm'\))
[GET CURSOR - line\_properties](javascript:call_link\('abapget_cursor_list_line.htm'\))



**📖 Source**: [abapget_cursor_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_cursor_list.htm)

### abapget_cursor_list_field.htm

> **📖 Official SAP Documentation**: [abapget_cursor_list_field.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_cursor_list_field.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) →  [GET CURSOR - List](javascript:call_link\('abapget_cursor_list.htm'\)) → 

GET CURSOR - field\_properties

[Quick Reference](javascript:call_link\('abapget_cursor_shortref.htm'\))

Syntax

... *\[*VALUE val*\]* *\[*LENGTH len*\]*
    *\[**\[*DISPLAY*|*MEMORY*\]* OFFSET off*\]* *\[*LINE lin*\]*.

Extras:

[1\. ... VALUE val](#!ABAP_ADDITION_1@1@)
[2\. ... LENGTH len](#!ABAP_ADDITION_2@2@)
[3\. ... *\[*DISPLAY*|*MEMORY*\]* OFFSET off](#!ABAP_ADDITION_3@3@)
[4\. ... LINE lin](#!ABAP_ADDITION_4@4@)

Effect

Using these additions, further information about the cursor position can be read during list processing with the addition FIELD of the [GET CURSOR](javascript:call_link\('abapget_cursor_list.htm'\)) statement.

Addition 1

... VALUE val

Effect

The addition VALUE assigns the formatted content of the output area on which the cursor is positioned to the data object val. val expects a character-like variable.

Addition 2

... LENGTH len

Effect

The addition LENGTH assigns the length of the output area on which the cursor is positioned to the data object len. len expects a variable of the type i.

Addition 3

... *\[*DISPLAY*|*MEMORY*\]* OFFSET off

Effect

The addition OFFSET without an addition or with the addition DISPLAY assigns the position of the cursor in the output area on which it is positioned to the data object off. off expects a variable of the type i. Counting begins at 0.

The addition OFFSET with the addition MEMORY assigns the offset of the character in the area of the data object in the list buffer (on whose output the cursor is positioned) to the data object off. If the cursor is on one of the characters < or > for characters cut off in the display, the position of the character in the list buffer that is overwritten by the character is assigned. off expects a variable of the type i.

Note

If [Subfields](javascript:call_link\('abenoffset_length.htm'\)) is displayed in lists, the returned offset is counted starting from the offset of the subfield.

Addition 4

... LINE lin

Effect

The addition LINE assigns the number of the list line on which the cursor is positioned to the data object lin. lin expects a variable of the type i.



**📖 Source**: [abapget_cursor_list_field.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_cursor_list_field.htm)

### abapget_cursor_list_line.htm

> **📖 Official SAP Documentation**: [abapget_cursor_list_line.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_cursor_list_line.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) →  [GET CURSOR - List](javascript:call_link\('abapget_cursor_list.htm'\)) → 

GET CURSOR - line\_properties

[Quick Reference](javascript:call_link\('abapget_cursor_shortref.htm'\))

Syntax

... *\[*VALUE val*\]* *\[*LENGTH len*\]* *\[**\[*DISPLAY*|*MEMORY*\]* OFFSET off*\]*.

Extras:

[1\. ... VALUE val](#!ABAP_ADDITION_1@1@)
[2\. ... LENGTH len](#!ABAP_ADDITION_2@2@)
[3\. ... *\[*DISPLAY*|*MEMORY*\]* OFFSET off](#!ABAP_ADDITION_3@3@)

Effect

Using these additions, further information about the cursor position can be read using the addition LINE of the statement [GET CURSOR](javascript:call_link\('abapget_cursor_list.htm'\)).

Addition 1

... VALUE val

Effect

The addition VALUE assigns the formatted content of the list line on which the cursor is positioned to the data object val. val expects a character-like variable.

Addition 2

... LENGTH len

Effect

The addition LENGTH assigns the line length set using the addition LINE-SIZE of the statement introducing the program or using NEW-PAGE (this is the line on which the cursor is positioned) to the data object len. len expects a variable of the type i.

Addition 3

... *\[*DISPLAY*|*MEMORY*\]* OFFSET off

Effect

The addition OFFSET without an addition or with the addition DISPLAY assigns the position of the cursor in the displayed line on which it is positioned to the data object off. off expects a variable of the type i.

The addition OFFSET with the addition MEMORY assigns the position of the character in the list buffer line (on whose output the cursor is currently positioned) to the data object off. If the cursor is on one of the characters < or > for characters cut off in the display, the position of the character in the list buffer that is overwritten by the character is assigned. off expects a variable of the type i.



**📖 Source**: [abapget_cursor_list_line.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_cursor_list_line.htm)

### abapget_cursor_list.htm

> **📖 Official SAP Documentation**: [abapget_cursor_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_cursor_list.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Displaying Lists](javascript:call_link\('abenlists_displayed.htm'\)) → 

GET CURSOR - List

[Quick Reference](javascript:call_link\('abapget_cursor_shortref.htm'\))

Syntax

GET CURSOR *{* *{*FIELD field *\[* [field\_properties](javascript:call_link\('abapget_cursor_list_field.htm'\))*\]**}*
           *|* *{*LINE line *\[* [line\_properties](javascript:call_link\('abapget_cursor_list_field.htm'\))*\]**}* *}*.

Variants:

[1\. GET CURSOR FIELD field *\[*field\_properties*\]*.](#!ABAP_VARIANT_1@1@)
[2\. GET CURSOR LINE line *\[*line\_properties*\]*.](#!ABAP_VARIANT_2@2@)

Effect

If this statement is specified in list processing, it passes the name of the output field or the number of the list line on which the screen cursor in the displayed list is positioned (after the user action) to the variables field or line, depending on how FIELD or LINE is specified. Further information on the cursor position can be read if required.

System Fields

sy-subrc

Meaning

0

The cursor is on a field or a list line and the statement was executed successfully.

4

The cursor is not on any field or any list line.

Variant 1

GET CURSOR FIELD field *\[*field\_properties*\]*.

Effect

Returns the name of the displayed field in field after a user action. This name is where the cursor is positioned in the currently displayed list. field expects a character-like variable. The addition [field\_properties](javascript:call_link\('abapget_cursor_list_field.htm'\)) can be used to read further information about the cursor position.

If the screen cursor is on a subarea displayed using an [offset/length](javascript:call_link\('abenoffset_length.htm'\)) of a structure, the following rules apply:

-   The subarea of the structure has been displayed using the name of the structure:
    

-   If the subarea includes the entire structure, the name of the structure is returned.

-   If the subarea only includes a part of the structure, the name of the component is returned in which the subarea begins.

-   The subarea of the structure has been displayed using the name of a component of the structure:
    

-   The name of the component is returned in which the subarea begins.

These rules also apply to substructures.

The addition FIELD can only be used to determine the names of global data objects of the ABAP program. If the cursor is positioned on the output of a data object that is not visible in the current context or a literal, field is initialized. This has no influence on the other additions or on sy-subrc.

If the cursor is on the output area of a data object that was accessed in the WRITE statement using a field symbol, the name of the data object is returned and not the name of the field symbol.

Variant 2

GET CURSOR LINE line *\[*line\_properties*\]*.

Effect

Returns the number of the list line in line after a user action. This line is where the cursor is positioned in the currently displayed list. line expects a variable of type i. The addition [line\_properties](javascript:call_link\('abapget_cursor_list_line.htm'\)) can be used to read further information about the cursor position.

Continue
[GET CURSOR - field\_properties](javascript:call_link\('abapget_cursor_list_field.htm'\))
[GET CURSOR - line\_properties](javascript:call_link\('abapget_cursor_list_line.htm'\))


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Spooling Lists

**Files**: 14 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Spooling Lists

Included pages: 14



**📖 Source**: [abapget_cursor_list.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapget_cursor_list.htm)

### abenprint.htm

> **📖 Official SAP Documentation**: [abenprint.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenprint.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) → 

Spooling Lists

The "spooling" of lists means the list output is not put in the [list buffer](javascript:call_link\('abenlist_buffer_glosry.htm'\) "Glossary Entry") for [screen lists](javascript:call_link\('abenscreen_list_glosry.htm'\) "Glossary Entry"), instead it is passed, page by page, to the [SAP spool system](javascript:call_link\('abensap_spool_system_glosry.htm'\) "Glossary Entry"). After a page has been passed, it is deleted from the ABAP runtime environment and only exists in the SAP spool system.

The size of a spool list is therefore only limited by the intake capacity of the spool system, and can be very large. On the other hand, when spool lists are created, it is not possible to refer to previous pages.

Each spooling of list output is associated with a [spool request](javascript:call_link\('abenspool_request_glosry.htm'\) "Glossary Entry"). The list pages that are passed to a spool request comprise a [spool list](javascript:call_link\('abenprint_list_glosry.htm'\) "Glossary Entry"). The spool list of a spool request can be

-   kept in the spool system,

-   printed on a printer, or

-   archived using [ArchiveLink](javascript:call_link\('abensap_archivelink_glosry.htm'\) "Glossary Entry").

For the spooling of lists, both the activation and deactivation of spooling and the association with spool requests are important.

-   [Switching Spooling On and Off](javascript:call_link\('abenprint_on_off.htm'\))

-   [Spool List Levels and Spool Requests](javascript:call_link\('abenprint_spool.htm'\))

The following topics also play a role in spooling lists:

-   [Spool Parameters](javascript:call_link\('abenprint_parameters.htm'\))

-   [Spool Control](javascript:call_link\('abenprint_control.htm'\))

-   [Spooling Screen Lists](javascript:call_link\('abenprint_screen.htm'\))

Note

Separate solutions are provided for form-based output of data, instead of spool lists. For example, search the [SAP Help Portal](http://help.sap.com) for the term "form".

Continue
[Switching Spooling On and Off](javascript:call_link\('abenprint_on_off.htm'\))
[Spool List Levels and Spool Requests](javascript:call_link\('abenprint_spool.htm'\))
[spool parameter](javascript:call_link\('abenprint_parameters.htm'\))
[Spool Control](javascript:call_link\('abenprint_control.htm'\))
[Spooling Screen Lists](javascript:call_link\('abenprint_screen.htm'\))
![Example](exa.gif "Example") [Spooling Lists](javascript:call_link\('abenprint_list_abexa.htm'\))



**📖 Source**: [abenprint.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenprint.htm)

### abenprint_on_off.htm

> **📖 Official SAP Documentation**: [abenprint_on_off.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenprint_on_off.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Spooling Lists](javascript:call_link\('abenprint.htm'\)) → 

Switching Spooling On and Off

As long as spooling is switched off, all list output is written to the list buffer for the current screen list. When spooling is switched on, a spool list is created. Spooling can be switched on as follows:

-   Use the statement [NEW-PAGE PRINT ON](javascript:call_link\('abapnew-page_print.htm'\)).

-   Choose the function Execute + Print on the [standard selection screen](javascript:call_link\('abenstandard_selscreen_glosry.htm'\) "Glossary Entry") of an executable program.

-   Call an executable program with the addition [TO SAP-SPOOL](javascript:call_link\('abapsubmit_list_options.htm'\)) of the statement [SUBMIT](javascript:call_link\('abapsubmit.htm'\)).

-   Schedule an executable program in a background job using the additions [VIA JOB](javascript:call_link\('abapsubmit_via_job.htm'\)) and [TO SAP-SPOOL](javascript:call_link\('abapsubmit_list_options.htm'\)) of the statement [SUBMIT](javascript:call_link\('abapsubmit.htm'\)).

If NEW-PAGE PRINT ON is used, spooling is switched on explicitly in the program. With the other three options, spooling is switched on from the start of execution of an executable program. Switching on spooling opens a new [spool list level](javascript:call_link\('abenprint_list_level_glosry.htm'\) "Glossary Entry").

Only spooling switched on with NEW-PAGE PRINT ON can be switched off again using NEW-PAGE PRINT OFF. Spooling that is switched on at the start of a program cannot be switched off within this same program. In particular, spooling is always switched on when executing a program in [background processing](javascript:call_link\('abenbackround_processing_glosry.htm'\) "Glossary Entry").

Examples

Switches on spooling explicitly

DATA: params TYPE pri\_params,
      valid  TYPE c.
CALL FUNCTION 'GET\_PRINT\_PARAMETERS'
  IMPORTING out\_parameters        = params
            valid                 = valid.
IF valid <> space.
  NEW-PAGE PRINT ON PARAMETERS params NO DIALOG.
  WRITE / ...
  NEW-PAGE PRINT OFF.
ENDIF.

Switches on optical archiving explicitly

DATA: pri\_params TYPE pri\_params,
      arc\_params TYPE arc\_params,
      valid  TYPE c.
CALL FUNCTION 'GET\_PRINT\_PARAMETERS'
  IMPORTING out\_parameters         = pri\_params
            out\_archive\_parameters = arc\_params
            valid                 = valid.
IF valid <> space.
  NEW-PAGE PRINT ON PARAMETERS         pri\_params
                    ARCHIVE PARAMETERS arc\_params NO DIALOG.
  PRINT-CONTROL INDEX-LINE '   '.
  WRITE / ....
  NEW-PAGE PRINT OFF.
ENDIF.

Calls a program

DATA: params TYPE pri\_params,
      valid  TYPE c.
CALL FUNCTION 'GET\_PRINT\_PARAMETERS'
  IMPORTING out\_parameters        = params
            valid                 = valid.
IF valid <> space.
  SUBMIT myreport TO SAP-SPOOL WITHOUT SPOOL DYNPRO
                  SPOOL PARAMETERS params.
ENDIF.

Schedules a background job

DATA: params TYPE pri\_params,
      valid  TYPE c.
CALL FUNCTION 'GET\_PRINT\_PARAMETERS'
  EXPORTING mode                  = 'BATCH'
            report                = 'MYREPORT'
  IMPORTING out\_parameters        = params
            valid                 = valid.
IF valid <> space.
  CALL FUNCTION 'JOB\_OPEN' ....  EXPORTING jobcount ...
  SUBMIT myreport VIA JOB 'MY\_JOB' NUMBER jobcount
         TO SAP-SPOOL WITHOUT SPOOL DYNPRO
            SPOOL PARAMETERS params.
  CALL FUNCTION 'JOB\_CLOSE' ...
ENDIF.



**📖 Source**: [abenprint_on_off.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenprint_on_off.htm)

### abenprint_spool.htm

> **📖 Official SAP Documentation**: [abenprint_spool.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenprint_spool.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Spooling Lists](javascript:call_link\('abenprint.htm'\)) → 

Spool List Levels and Spool Requests

Every output to a spool list is assigned to exactly one spool request. For every spool request, [spool parameters](javascript:call_link\('abenprint_parameters.htm'\)) have been specified that can no longer be changed. Spool lists can be stacked in spool list levels. A spool list level always has exactly one spool request assigned to it.

-   [Spool List Levels](#abenprint-spool-1--------open-spool-requests---@ITOC@@ABENPRINT_SPOOL_2)

-   [Close Spool Requests](#abenprint-spool-3---spool-list-levels--the-following-operations-create-a-new-spool-list-level-------choose-execute---print-on-the-selection-screen------call-program-with--submit-to-sap-spool--javascript-call-link---abapsubmit-list-options-htm----------execute-a-program-in-a-background-job-------dynpro-sequence--javascript-call-link---abendynpro-sequence-glosry-htm-----glossary-entry---call-using--call-screen--javascript-call-link---abapcall-screen-htm------when-a-spool-request-is-already-open-------execute-the-statement--new-page-print-on--javascript-call-link---abapnew-page-print-htm------this-statement--however--does-not-create-a-randomly-stackable-spool-list-level-------in-a-spool-list-level-created-with-new-page-print-on--no-other-spool-list-level-can-be-created-with-new-page-print-on--however--the-other-operations-for-creating-spool-list-levels-are-still-valid--if-the-addition-new-section-is-used-in-new-page-print-on--the-existing-request-is-used-further-or-it-is-closed-implicitly-before-a-new-one-is-opened-------in-a-spool-list-level-not-created-with-new-page-print-on-or-while-creating-a-screen-list--no-more-than-one-spool-list-level-can-be-created-using-new-page-print-on---a-spool-list-level-created-with-new-page-print-on-can-thus-be-stacked-only-upon-a-spool-list-level-that-has-not-been-created-with-new-page-print-on-or-into-the-creation-of-a-screen-list---up-to-20-spool-list-levels-can-be-stacked---open-spool-requests--the-first-output-statement-within-a-spool-list-level-opens-a-new-spool-request--whose-number-is-placed-into-system-field-sy-spono--if-another-spool-request-is-already-open--it-remains-open-and-is-used-further-after-the-spool-list-level-has-been-left--in-a-spool-list-level-that-has-been-created-by-calling-a-dynpro-sequence--the-spool-request-inherits-the-spool-parameters-of-the-preceding-spool-request--in-all-other-cases--the-explicitly-specified-spool-parameters-apply---close-spool-requests--when-leaving-a-spool-list-level-that-was-not-opened-with-new-page-print-on--i-e--at-the-end-of-the-program-or-when-leaving-a-dynpro-sequence--the-spool-request-associated-with-the-spool-list-level-is-closed--if-a-spool-request-stacked-upon-the-spool-list-level-with-new-page-print-on-has-not-yet-been-closed-using-new-page-print-off--it-will-also-be-closed--subsequent-output-statements-continue-to-write-to-the-spool-list-of-the-previous-spool-request-or-to-the-current-screen-list---the-statement-new-page-print-off-closes-only-spool-requests-for-which-spooling-was-activated-using-new-page-print-on--if-after-that-no-previous-spool-request-is-open--spooling-is-switched-off-again--i-e--subsequent-output-statements-continue-to-write-to-the-screen-list--if-a-previous-spool-request-existed--spooling-remains-activated-and-the-output-is-again-written-into-its-spool-list--new-page-print-off-is-ignored-by-spool-requests-not-opened-using-new-page-print-on---after-closing-a-spool-request--the-number-of-the-closed-spool-request-remains-in-system-field-sy-spono-until-an-output-statement-again-writes-into-a-spool-list--this-may-be-a-new-spool-list-or-the-list-of-a-previous-spool-request--if-after-closing-a-spool-request-a-previous-spool-request-exists--the-number-in-sy-spono-differs-from-the-number-of-that-request-until-another-output-into-its-spool-list-is-performed---note--it-is-best-always-to-close-a-spool-request-that-was-opened-using-new-page-print-on-explicitly-using-new-page-print-off--before-it-is-closed-implicitly-at-the-end-of-the-program-or-when-leaving-a-dynpro-sequence---executable-example---lists--spooling--javascript-call-link---abenprint-list-abexa-htm------------abenprint-parameters-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------spooling-lists--javascript-call-link---abenprint-htm---------spool-parameter--for-every--spool-request--javascript-call-link---abenprint-spool-htm------spool-parameters-must-be-defined-that-are-used-to-format-the-spool-list-when-the-list-is-created--and-to-control-the-request---in-the-abap-statements--new-page-print-on--javascript-call-link---abapnew-page-print-htm-----and--submit-to-sap-spool--javascript-call-link---abapsubmit-print-parameters-htm-----the-spool-parameters-are-specified-in-a-structure-of-type-pri--params-from-abap-dictionary--spool-parameters-can-be-enhanced-by-archiving-parameters-if-the-data-of-the-spool-request-is-to-be-archived-using-archivelink--to-do-this--optical-archiving-using--archivelink--javascript-call-link---abensap-archivelink-glosry-htm-----glossary-entry---is-switched-on--archiving-mode-2-or-3--in-the-spool-parameters--archiving-parameters-are-specified-in-a-structure-of-type-arc--params-from-the-abap-dictionary---the-spool-parameters-are-specified-either-explicitly-or-implicitly--the-end-user-can-set-them-directly-in-the-spool-dialog-box-or-the-spool-parameters-can-be-set-in-the-program-code--------spool-dialog-box--javascript-call-link---abenprint-parameters-window-htm-----------setting-program-driven-spool-parameters--javascript-call-link---abenprint-parameters-function-htm-----------overview-of-all-spool-parameters--javascript-call-link---abenprint-parameters-overview-htm------note--the-content-of-the-structures-pri--params-and-arc--params-cannot-be-modified-directly-in-programs--only-the-function-module-get--print--parameters-can-be-used-for-this---continue--spool-dialog-box--javascript-call-link---abenprint-parameters-window-htm------setting-program-driven-spool-parameters--javascript-call-link---abenprint-parameters-function-htm------overview-of-all-spool-parameters--javascript-call-link---abenprint-parameters-overview-htm-----------abenprint-parameters-window-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------spooling-lists--javascript-call-link---abenprint-htm---------spool-parameter--javascript-call-link---abenprint-parameters-htm---------spool-dialog-box--the-spool-dialog-box-makes-it-possible-to-interactively-determine-all-spool-parameters-and-checks-the-input-values-for-consistency-and-completeness--the-call-is-either-automatic-or-program-controlled-------the-spool-dialog-box-appears-automatically-if-a-user-chooses-execute-and-print-on-the-selection-screen--and-also-when--spooling-screen-lists--javascript-call-link---abenprint-screen-htm------in-these-cases--the-spool-dialog-box-cannot-be-suppressed-------the-get--print--parameters-function-module-can-be-used-to-call-the-spool-dialog-box-in-a-program---when-the-spool-dialog-box-is-called-automatically--the-set--print--parameters-function-module-can-be-used-to-set-standard-values--the-set--print--parameters-function-module-mainly-has-the-same-import-parameters-as-the-get--print--parameters-function-module--refer-to--overview-of-all-spool-parameters--javascript-call-link---abenprint-parameters-overview-htm------and-no-export-parameters--an-additional-input-parameter-called-foot--line-is-used-when--spooling-a-screen-list--javascript-call-link---abenprint-screen-htm-----and-defines-that-a-footer-is-printed--it-is-only-respected-here---notes------displaying-the-spool-dialog-box-using-get--print--parameters-is-the-recommended-method-for-program-driven-spooling--and-thereby-decouples-the-dialog-from-the-statements--new-page-print-on--javascript-call-link---abapnew-page-print-htm-----and--submit-to-sap-spool--javascript-call-link---abapsubmit-list-options-htm------it-is-still-possible-to-call-the-spool-dialog-box-with-the-latter--however--the-functions-back-or-cancel-cannot-be-processed-properly-------the-standard-values-for-the-spool-dialog-box-must-be-set-before-sending-the-selection-screen-or-list-to-the-screen-when-the-spool-dialog-box-is-called-automatically--it-is-recommended-that-set--print--parameters-only-be-used-at-the--initialization--javascript-call-link---abapinitialization-htm-----event-of-an-executable-program-------using-set--print--parameters-only-allows-the-setting-those-spool-parameters-that-are-stored-in-components-of-the-pri--params-structure--------abenprint-parameters-function-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------spooling-lists--javascript-call-link---abenprint-htm---------spool-parameter--javascript-call-link---abenprint-parameters-htm---------setting-program-driven-spool-parameters--spool-and-archiving-parameters-can-only-be-set-in-a-program-using-the-following-function-module--get--print--parameters--if-the-corresponding-structure-is-changed-directly-and-then-the-parameters-in-question-used-in-new-page-print-on-or-submit-to-sap-spool--a-runtime-error-occurs--the-get--print--parameters-function-module-can-be-used-to-execute-the-following-functions-------creating-a-complete-set-of-spool-and-archiving-parameters-------determining-the-spool-parameters-that-are-currently-valid-during-spooling------changing-individual-spool-parameters------interactive-querying-of-the-spool-parameters-in-the-spool-dialog-box--the-interface-parameters-for-the-function-module-are-listed-in--overview-of-all-spool-parameters--javascript-call-link---abenprint-parameters-overview-htm-------the--spool-dialog-box--javascript-call-link---abenprint-parameters-window-htm-----is-displayed-by-default-and-can-be-switched-off-using-the-parameter-no--dialog--the-values-passed-to-the-function-module-are-used-as-the-default-values-in-the-spool-dialog-box-and-can-be-overwritten-there---the-function-module-gets-all-parameters-that-have-not-been-set-from-the-system--taking-some-values-from-the-user-master-record--dependent-parameters-are-set-automatically--if-the-function-module-is-unable-to-create-a-record-with-valid-spool-and-archiving-parameters--it-raises-an-exception--the-new-records-are-either-complete-or-empty--the-export-parameter-valid--if-the-spool-dialog-box-is-being-used--indicates-whether-a-complete-record-could-be-created---notes------for-get--print--parameters--the-completeness-of-the-parameter-records-and-the-run-capability-of-the-spool-request-are-of-primary-importance--the-function-module-does-not-carry-out-a-complete-consistency-test-like-the-spool-dialog-box--consistency-is-only-established-in-cases-where-it-is-significant-for-the-run-capability-of-the-spool-request--inconsistent-entries-are-partly-ignored--partly-replaced--for-example-------the-input-parameter-line--size-or-line--count-can-be-used-to-set-values-that-are-not-compatible-with-the-parameter-layout-and-produce-truncated-output--such-inconsistencies-are-recognized-in-the-spool-dialog-box-------even-if-invalid-values-are-passed-to-destination--it-is-still-possible-to-set-immediately-to--x---the-function-module-replaces-the-output-device-with-a-standard-value--lp01--and-initializes-immediately--this-causes-the-spool-system-to-store-the-request-using-the-settings-that-go-with-the-default-printer-------the-get--print--parameters-function-module-can-be-called-multiple-times-consecutively--for-example--the-spool-dialog-box-can-be-called-at-the-start-of-a-program-if-the-user-enters-the-basic-setting--when-it-is-called-again--the-parameter-records-created-in-this-way-can-be-passed-collectively-to-the-import-parameters-pri--params-and-arc--params-of-the-function-module-and-overwritten-there--this-enables-the-spooling-of-wide-lists-in-landscape-format-or-narrow-lists-in-portrait-format-with-otherwise-unchanged-settings--------abenprint-parameters-overview-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------spooling-lists--javascript-call-link---abenprint-htm---------spool-parameter--javascript-call-link---abenprint-parameters-htm---------overview-of-all-spool-parameters-------spool-parameters---@ITOC@@ABENPRINT_PARAMETERS_OVERVIEW_1)

-   [Archiving Parameters](#abenprint-parameters-overview-2--------control-parameters---@ITOC@@ABENPRINT_PARAMETERS_OVERVIEW_3)

-   [Output Parameters of GET\_PRINT\_PARAMETERS](#abenprint-parameters-overview-4---spool-parameters--the-following-table-lists-all-spool-parameters-by-their-associated-input-parameters-in-the-function-modules--get--print--parameters--javascript-call-link---abenprint-parameters-function-htm-----and--set--print--parameters---javascript-call-link---abenprint-parameters-window-htm-----the-second-column-shows-the-label-in-the-spool-dialog-window--the-third-column-contains-the-name-of-the-component-in-the-structure-pri--params-whose-content--however--cannot-be-modified-directly-in-a-program---input-parameter--dialog-field--component--meaning--in--parameters----------full-structure-of-type-pri--params--any-single-values-passed-in-parallel-overwrite-the-associated-component---archive--mode--archive-mode--armod--if--1--print-only--default---if--2--archive-only--if--3--print-and-archive---authority--authorization--prber--authorization-value-for-authorization-object-s--spo--act--this-can-be-used-to-check-whether-or-not-a-user-is-allowed-to-carry-out-certain-actions-on-the-spool-request---copies--number-of-copies--prcop--number-or-printouts--default-1---cover--page--selection-cover-page--if--paramsel--passed-to-mode---prbig--if--x---a-cover-page-with-the-input-values-of-the-selection-layout-is-printed--default-------data--set------prdsn--template-for-the-name-of-the-spool-file--default-is-empty---default--spool--size--get--print--parameters-only---spool-request-has-a-width-of-maximum-255-characters------if--x---line-break-forced-after-the-255th-column--default-------department--department--prabt--department-name-for-the-sap-cover-page--default-taken-from-user-address---destination--output-device--pdest--name-of-a-printer-or-fax-machine--default-taken-from-user-master-data---draft--get--print--parameters-only---text-only------if--x--only-text-is-printed--default-is-------expiration--retention-period--pexpi--number-of-days-for-which-the-spool-request-is-retained-by-the-spool-system--default-is-8---foot--line--set--print--parameters-only-------footl--if--x--footer-printed--only-if-spooling-screen-lists--whose-content-can-be-modified-in-the-spool-dialog-window-under-parameters--default-is-empty---host--coverpage--os-cover-page--prunx--if--x--the-operating-system-cover-page-is-printed--default-is-------immediately--time-of-printing--primm--if--x--the-spool-request-is-sent-immediately--if--a--the-spool-request-is-printed-at-a-later-time--only-for-non-front-end-printers---if-----the-spool-request-must-be-printed-manually--default-taken-from-user-master-data---layout--formatting--paart--page-format--depending-on-the-output-device--different-formats-with-different-maximum-page-lengths-and-widths-can-be-specified--default-defined-internally---line--count--lines--subproperty-of-formatting---linct--number-of-lines-per-page--works-like-the-addition-line-count-in-an-introductory-statement--0--unlimited-number-of-lines--is-not-possible--the-maximum-number-depends-on-layout--default-defined-internally--overwritten-by-report-if-the-value--batch--is-passed-for-mode---line--size--columns--subproperty-of-formatting---linsz--characters-per-list-line--works-like-the-addition-line-size-in-an-introductory-statement--maximum-depends-on-layout--default-defined-internally--overwritten-by-report-if-the-value--batch--is-passed-for-mode---list--name--name--plist--the-name-of-the-spool-request-if-not-printed-immediately--default-is-a-combination-of-the-start-of-the-program-name-from-the-parameter-report-and-the-user-name--list--text--title--prtxt--description-text-for-the-spool-request--appears-on-the-default-cover-page-and-is-displayed-in-the-output-controller-instead-of-list--name--default-is-empty---new--list--id--new-spool-request--prnew--if--x---default--a-new-spool-request-is-created--otherwise-the-system-attempts-to-attach-the-spool-request-to-an-existing-request--works-only-if-list--name--destination--copies--and-layout-match-and-protect--list-is-empty---no--frames--get--print--parameters-only---no-frame-characters------if--x--no-frame-characters-are-printed--default-is-------priority--print-priority--priot---1---high--to--9---low---default-is--1----protect--list--get--print--parameters-only---protection-from-attachments------if--x--no-further-requests-can-be-attached-to-the-spool-request--default-is-------receiver--recipient--prrec--recipient-name-for-the-sap-cover-page--default-taken-from-user-address---release--delete-immediately-after-printing--prrel--if--x--spool-request-is-deleted-immediately-after-printing--otherwise-after-expiration--default-taken-from-user-master-data---report--get--print--parameters-only-----------if-mode-is-the-same-as--batch---the-name-of-the-program-to-be-started-must-be-entered-in-report--the-list-lines-per-page--line--count--and-the-characters-per-list-line--line--size--are-then-taken-from-the-introductory-program-statement-of-the-specified-program--still-the-default-for-the-first-part-of-the-name-of-the-spool-request-overwritten-by-list--name--the-default-for-this-is-sy-repid----sap--cover--page--sap-cover-sheet--prsap--if--x--a-standard-cover-page-with-standard-information-is-created--if--d---default--the-cover-page-printed-depends-on-the-settings-of-the-printer--if-----no-cover-page-is-created---suppress--shading--get--print--parameters-only---colors-shading-suppressed-in-the-printout------if--x--colors-shading-are-suppressed-in-the-printout--default-is-------type------ptype--type-of-the-spool-request---uc--display--mode--get--print--parameters-only---character-format------unicode-spool-output--if--1--characters-are-printed-with-the-output-length-one--if--2--all-characters-are-printed-in-their-own-output-lengths--if--3--all-characters-are-printed-with-the-length-two---with--structure--get--print--parameters-only---spool-list-with-structure-information------if--x--structure-information-is-also-printed--for-acc-and-rtl-output---default-is-----------print-all--print-from-page-----to------restricts-the-number-of-pages-printed--default-is-print-all---notes------the-input-parameters-of-get--print--parameters-that-do-not-have-a-component-in-the-structure-pri--params-are-not-passed-to-a-spool-request-explicitly-during-new-page-print-on-and-submit-to-sap-spool-and-are-defined-internally-by-the-function-module-instead-------using-set--print--parameters-only-allows-the-setting-those-spool-parameters-that-are-stored-in-components-of-the-pri--params-structure-------the-spool-parameters-line--count-and-line--size-do-not-overwrite-the-additions-line-count-and-line-size-of-the-introductory-statement-of-a-program-specified-using-report-if-the-value--batch--is-passed-to-the-parameter-mode--in-this-case--the-corresponding-input-fields-in-the-spool-dialog-box-are-not-ready-for-input--if-these-values-exceed-the-maximum-values-defined-by-layout--the-list-cannot-be-spooled-------the-values-of-the-components-of-the-structure-pri--params-are-usually-intended-for-internal-use-only-and-do-not-always-match-the-values-specified-directly--such-as-in-the-addition-line-size---archiving-parameters--the-following-table-lists-all-archiving-parameters-by-their-associated-input-parameters-in-the-function-modules-get--print--parameters-and-set--print--parameters--the-second-column-shows-the-label-in-the-spool-dialog-window--the-third-column-contains-the-name-of-the-component-in-the-structure-arc--params-whose-content--however--cannot-be-modified-directly-in-a-program---input-parameter--dialog-field--component--meaning--in--archive--parameters----------full-structure-of-type-arc--params--any-single-values-passed-in-parallel-overwrite-the-associated-component---ar--object--document-type--ar--object--document-type-of-the-archiving-object---archive--id------archive--id--target-archive-of-the-archiving-request---archive--info--information--info--information-id-for-the-archiving-request---archive--text--text--arctext--description-text-of-the-archiving-request---sap--object--object-type--sap--object--object-type-of-the-sap-object---notes------requests-can-be-archived-only-if-these-parameters-are-specified-consistently-and-in-full--archiving-works-across-all-applications--with-the-exception-of-certain-basic-settings--no-other-actions-are-required--if-spool-lists-need-to-be-saved-specific-to-an-application--some-special-actions-must-be-taken--for-more-information--see-the-archivelink-documentation-on--sap-help-portal--http---help-sap-com--------when-archiving-long-lists--it-may-be-useful-to-write-index-information-to-the-list-using--print-control-index-line--javascript-call-link---abapprint-control-htm------this-makes-it-easier-to-search-the-archived-list-at-a-later-date---control-parameters--the-following-table-lists-the-control-parameters-of-the-function-module-get--print--parameters---input-parameter--meaning--mode--possible-values--batch----current----defvals----display----params----paramsel---see-below---no--dialog--if--x--no-spool-dialog-window-is-displayed--the-following-table-shows-the-values-that-can-be-passed-to-mode---mode--effect---batch---the-function-module-gets-spool-parameters-for-a-background-request--the-executable-program-to-be-started-must-be-specified-in-the-import-parameter-report--if-this-executable-program-contains-the-additions-line-count-or-line-size-in-the-report-statement--they-are-used-as-non-modifiable-values-in-the-spool-dialog-window--the-function-save-is-displayed-on-the-spool-dialog-window-instead-of-print----current---the-function-module-is-used-to-determine-the-current-spool-parameters-after-spooling-has-been-activated--if-nothing-is-being-spooled--the-default-values-are-used----defvals---always-gets-the-default-values----display---the-spool-parameters-are-displayed-in-the-spool-dialog-box-but-cannot-be-changed----params---standard-setting--the-user-can-choose-print-or-cancel-on-the-spool-dialog-window----paramsel---like--params---however-the-additional-checkbox-selection-cover-page-appears-on-the-spool-dialog-window---output-parameters-of-get--print--parameters--the-following-table-lists-the-output-parameters-of-the-function-module-get--print--parameters---output-parameter--meaning--out--parameters--set-of-spool-parameters-in-a-structure-of-the-type-pri--params--either-complete-or-empty---out--archive--parameters--set-of-archiving-parameters-in-a-structure-of-the-type-arc--params--either-complete-or-empty---valid--if--x---all-spool-parameters-or-archiving-parameters-are-present-and-printing-or-archiving-is-possible--if------the-structures-are-empty-and-printing-or-archiving-is-not-possible--valid-is-----if-cancel-is-used-to-exit-the-spool-dialog-window---valid--for--spool--creation--if--x---enough-spool-parameters-are-available-to-create-a-spool-request--there-is-no-guarantee--however--that-this-request-can-be-printed-or-archived--if------the-structures-are-empty-and-a-spool-request-cannot-be-created--this-is-different-from-valid-only-if-the-spool-dialog-box-is-not-displayed--if-the-spool-dialog-box-is-displayed--valid--for--spool--creation-is-filled-just-like-valid----------source-----abenprint-spool-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenprint-spool-htm-------abenprint-parameters-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------spooling-lists--javascript-call-link---abenprint-htm---------spool-parameter--for-every--spool-request--javascript-call-link---abenprint-spool-htm------spool-parameters-must-be-defined-that-are-used-to-format-the-spool-list-when-the-list-is-created--and-to-control-the-request---in-the-abap-statements--new-page-print-on--javascript-call-link---abapnew-page-print-htm-----and--submit-to-sap-spool--javascript-call-link---abapsubmit-print-parameters-htm-----the-spool-parameters-are-specified-in-a-structure-of-type-pri--params-from-abap-dictionary--spool-parameters-can-be-enhanced-by-archiving-parameters-if-the-data-of-the-spool-request-is-to-be-archived-using-archivelink--to-do-this--optical-archiving-using--archivelink--javascript-call-link---abensap-archivelink-glosry-htm-----glossary-entry---is-switched-on--archiving-mode-2-or-3--in-the-spool-parameters--archiving-parameters-are-specified-in-a-structure-of-type-arc--params-from-the-abap-dictionary---the-spool-parameters-are-specified-either-explicitly-or-implicitly--the-end-user-can-set-them-directly-in-the-spool-dialog-box-or-the-spool-parameters-can-be-set-in-the-program-code--------spool-dialog-box--javascript-call-link---abenprint-parameters-window-htm-----------setting-program-driven-spool-parameters--javascript-call-link---abenprint-parameters-function-htm-----------overview-of-all-spool-parameters--javascript-call-link---abenprint-parameters-overview-htm------note--the-content-of-the-structures-pri--params-and-arc--params-cannot-be-modified-directly-in-programs--only-the-function-module-get--print--parameters-can-be-used-for-this---continue--spool-dialog-box--javascript-call-link---abenprint-parameters-window-htm------setting-program-driven-spool-parameters--javascript-call-link---abenprint-parameters-function-htm------overview-of-all-spool-parameters--javascript-call-link---abenprint-parameters-overview-htm-------------source-----abenprint-parameters-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenprint-parameters-htm-------abenprint-control-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------spooling-lists--javascript-call-link---abenprint-htm---------spool-control--configuring-the-upper-and-left-margins--the-statement--set-margin--javascript-call-link---abapset-margin-htm-----can-be-used-to-define-the-upper-and-left-margins-of-a-spool-list---archiving-information-in-spool-lists--when-spooling-is-active--the-statement--print-control--javascript-call-link---abapprint-control-htm-----can-be-used-to-write-formatting-information-for-optical-archiving-to-the-spool-system---obsolete-formatting-of-spool-lists--when-spooling-is-active--an--obsolete-variant--javascript-call-link---abapprint-control-obsolete-htm-----of-the-statement-print-control-can-be-used-to-write-control-statements-for-output-devices--printers--to-the-spool-system---continue--set-margin--javascript-call-link---abapset-margin-htm------print-control--javascript-call-link---abapprint-control-htm-------------source-----abenprint-control-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenprint-control-htm-------abapset-margin-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------spooling-lists--javascript-call-link---abenprint-htm---------spool-control--javascript-call-link---abenprint-control-htm---------set-margin---quick-reference--javascript-call-link---abapset-margin-shortref-htm------syntax--set-margin-macol-----marow-------effect--this-statement-defines-the-left-margin-of-a-spool-list-as-the-columns-specified-in-macol--and-the-upper-margin-as-the-rows-specified-in-marow--and-sets-the-system-fields-sy-macol-and-sy-marow-to-these-values--macol-and-marow-expect-data-objects-with-the-type-i--with-values-within-the-current-page-width-and-page-length--if-macol-or-marow-contain-invalid-values--the-associated-operand-is-ignored---the-set-values-apply-to-the-current-page-and-all-subsequent-pages-until-the-next-set-margin-statement--if-more-than-one-set-margin-statement-is-specified-on-a-page--the-last-one-is-used---set-margin-is-ignored-when-screen-lists-are-displayed--the-set-margins-are-only-inserted-in-the-list-as-blanks-or-empty-lines-if-a-list-page-is-sent-to-the-sap-spool-system--this-applies-to-spool-lists-created-using--new-page-print-on--javascript-call-link---abapnew-page-print-htm-------submit-to-sap-spool--javascript-call-link---abapsubmit-list-options-htm------and-by-the-selection-of-execute-and-print-on-the--selection-screen--javascript-call-link---abenselection-screen-glosry-htm-----glossary-entry----set-margin-also-applies-if-a-screen-list-is-spooled-while-it-is-being-displayed--when-print--function-code--pri---is-selected---note--for-printers-with-an-active-list-driver--margins-can-be-defined-in-millimeters-in-the-spool-dialog--when-pages-are-sent-from-the-spool-system-to-the-printer--the-pages--including-the-margins-set-using-set-margin--are-positioned-within-these-margins----------source-----abapset-margin-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abapset-margin-htm-------abapprint-control-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------spooling-lists--javascript-call-link---abenprint-htm---------spool-control--javascript-call-link---abenprint-control-htm---------print-control---quick-reference--javascript-call-link---abapprint-control-shortref-htm------syntax--print-control-index-line-index--line---effect--in-spool-lists--this-statement-creates-index-entries-for-optical-archiving-using--archivelink--javascript-call-link---abensap-archivelink-glosry-htm-----glossary-entry----this-applies-only-to-spool-lists-created-using--new-page-print-on--javascript-call-link---abapnew-page-print-htm-------submit-to-sap-spool--javascript-call-link---abapsubmit-list-options-htm------and-when-selecting-execute-and-print-on-the--selection-screen--javascript-call-link---abenselection-screen-glosry-htm-----glossary-entry----it-does-not-work-for-screen-lists-spooled-from-the-display-by-selecting-print--function-code--pri-----this-statement-inserts-the-content-of-the-data-object-index--line-into-the-current-spool-list-as-an-index-line--index--line-must-be-a-flat-character-like-data-object--if-the--list-cursor--javascript-call-link---abenlist-cursor-glosry-htm-----glossary-entry---of-an-output-statement-has-been-set-in-the-current-list-line--the-index-line-is-inserted-after-the-end-of-the-line--index-lines-can-be-used-for-the-following-purposes-------as-dain-lines-whose-structure-is-defined-dkey--here--they-improve-the-performance-of-searches-in-archived-spool-lists-----------as-darc-lines--they-enable-hypertext-links-to-other-archived-objects--------an-index-line-is-sent-to-the-spool-system-as-a-part-of-the-spool-list-and-is-displayed-there--although-not-included-in-the-print-output--when-a-list-is-archived-using--archivelink--javascript-call-link---abensap-archivelink-glosry-htm-----glossary-entry----the-spool-system-divides-it-into-a-data-file-and-a-description-file--the-data-file-contains-the-actual-spool-lists--and-the-description-file-contains-the-index-lines---note--to-enable-the-associated-archivelink-search-function-to-be-used-when-an-archived-spool-list-is-displayed-or-for-the-links-to-work--the-index-lines-must-contain-certain-information--this-information-must-follow-a-fixed-naming-convention-and-must-be-described-in-the--sap-help-portal--http---help-sap-com--in-the-archivelink-documentation---example--inserting-index-lines-in-a-list-of-square-numbers--after-every-hundredth-line--index-lines-for-archiving-are-created--dain-lines--using-the-statement-print-control--the-structure-of-the-dain-lines-is-defined-at-the-start-of-the-list-in-two-additional-index-lines--dkey-lines---if-the-user-selects-execute-and-print-on-the--selection-screen--javascript-call-link---abenselection-screen-glosry-htm-----glossary-entry---and-archives-the-list-in-the-spool-dialog--the-archived-list-can-be-searched-for-the-indexes--for-more-information--see-the-archivelink-documentation-on-the--sap-help-portal--http---help-sap-com----parameters-number-type-i--data--index--type-i--------square-type-decfloat16--------numb---type-i--------num----type-c-length-4--------dkey---type-c-length-100--------dain---type-c-length-100--dkey---dkeyindex---dkey-44----0---dkey-47----3---print-control-index-line-dkey--clear-dkey--dkey---dkeynumber---dkey-44----3---dkey-47----4---print-control-index-line-dkey--index---0--do-number-times----index---index---1----if-index---100------numb---sy-index---100------write-numb-to-num-left-justified------dain----dain------idx-----num------print-control-index-line-dain------index---0----endif----square---sy-index------2----write----sy-index--square-style-cl--abap--math--scientific--enddo----------source-----abapprint-control-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abapprint-control-htm-------abenprint-control-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------spooling-lists--javascript-call-link---abenprint-htm---------spool-control--configuring-the-upper-and-left-margins--the-statement--set-margin--javascript-call-link---abapset-margin-htm-----can-be-used-to-define-the-upper-and-left-margins-of-a-spool-list---archiving-information-in-spool-lists--when-spooling-is-active--the-statement--print-control--javascript-call-link---abapprint-control-htm-----can-be-used-to-write-formatting-information-for-optical-archiving-to-the-spool-system---obsolete-formatting-of-spool-lists--when-spooling-is-active--an--obsolete-variant--javascript-call-link---abapprint-control-obsolete-htm-----of-the-statement-print-control-can-be-used-to-write-control-statements-for-output-devices--printers--to-the-spool-system---continue--set-margin--javascript-call-link---abapset-margin-htm------print-control--javascript-call-link---abapprint-control-htm-------------source-----abenprint-control-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenprint-control-htm-------abenprint-screen-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------spooling-lists--javascript-call-link---abenprint-htm---------spooling-screen-lists--as-well-as-creating-spool-lists--screen-lists-can-also-be-sent-to-the-sap-spool-system--to-do-this--use-the-print-function-in-the-list-display--this-function-transforms-the-screen-list-into-a-spool-list--where-the-spool-format-specified-in-the--spool-parameters--javascript-call-link---abenprint-parameters-htm-----is-used-to-split-the-list-and-shorten-it--if-necessary--however--this-usually-results-in-the-following-problems-------a-list-that-has-been-formatted-as-a-screen-list-is-not-appropriate-for-spool-output--because-------a-screen-list-usually-consists-of-one-logical-page--this-logical-page-must-be-divided-into-multiple-physical-spool-pages-for-the-spooling-process--since-the-screen-list-contains-only-one--page-header--javascript-call-link---abenpage-header-glosry-htm-----glossary-entry----this-page-header-is-used-as-the-page-header-of-every-spool-page--if-it-contains-page-numbering--every-spool-page-has-the-same-page-number--usually-1--------screen-lists-are-usually-very-wide----130-columns---a-normal-printer-can-print-these-lists-only-by-truncating-the-lines-------a-screen-list-does-not-support-any-special-print-control-sequences-as-they-appear--for-example--in-the-statement--print-control--javascript-call-link---abapprint-control-htm-------notes------for-the-reasons-mentioned-this-type-of-spooling-should-not-be-used-for-production-purposes--it-is-designed-only-as-a-way-of-capturing-a-screen-for-testing-purposes-------a-screen-list-cannot-contain-any-index-lines-created-using--print-control--javascript-call-link---abapprint-control-htm------indexed-searches-are-not-possible-in-an-archived-screen-list----------source-----abenprint-screen-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenprint-screen-htm-------abenprint-list-abexa-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------spooling-lists--javascript-call-link---abenprint-htm---------spooling-lists--the-example-demonstrates-how-to-spool-lists-and-how-to-stack-spool-list-levels---source-code--report-demo--list--print-line-count-10-line-size-50--data-params-like-pri--params--data-valid--type-c-length-1--parameters-para-type-c-length-1--class-print--demo-definition----public-section------class-methods-print-importing-text-type-string--endclass--initialization----call-function--get--print--parameters------exporting-------destination-------locl--------immediately----------------no--dialog---------x--------line--count-------10-------line--size--------50-----importing-------out--parameters---params-------valid------------valid----if-valid-----x-------leave-program----endif----params-prtxt----parameter-1-----call-function--set--print--parameters------exporting-------in--parameters---params--start-of-selection----write----aaaa-----params-prtxt----parameter-2-----new-page-print-on-parameters-params-no-dialog----write----bbbb-----call-screen-100----write----gggg-----new-page-print-off----write----hhhh---module-status--0100-output----suppress-dialog----leave-to-list-processing-and-return-to-screen-0----write----cccc-----params-prtxt----parameter-3-----new-page-print-on-parameters-params-no-dialog----write----dddd-----print--demo--print---eeee-------new-page-print-off----write----ffff---endmodule--class-print--demo-implementation----method-print------params-prtxt----parameter-4-------try----------new-page-print-on-parameters-params-no-dialog--------catch-cx--sy--nested--print--on----------new-page-print-on-parameters-params-no-dialog-new-section------endtry------write---text------new-page-print-off----endmethod--endclass---description--the-program-creates-five-lists--if-the-user-chooses-execute-on-the-selection-screen--one-screen-list-and-four-spool-lists-are-created--if-the-user-chooses-execute---print-on-the-selection-screen--five-spool-lists-are-created---in-the-event-block-initialization--by-calling-function-module-get--print--parameters--the-spool-parameters-are-placed-into-the-structure-params--by-passing-the-initial-value-to-parameter-immediately--the-spool-requests-are-stored-in-the-spool-system--but-not-spooled-immediately--function-module-set--print--parameters-is-used-to-pre-fill-the-input-fields-of-the-spool-dialog-window-of-the-selection-screen---the-spool-requests-created-and-the-content-of-the-spool-lists-can-be-displayed-by-choosing-system---own-spool-requests-------depending-on-the-user-action--the-first-list-on-the-selection-screen-is-either-a-two-page-screen-list--basic-list--or-a-two-page-spool-list-with-the-title--parameter-1---the-first-page-contains-a-line--aaaa---the-second-page-contains-a-line--hhhh--------the-second-list-is-a-one-page-spool-list-created-explicitly-using-new-page-print-on-and-carries-the-title--parameter-2---it-contains-the-lines--bbbb--and--gggg---its-spool-list-level-is-stacked-upon-the-screen-list-or-upon-the-spool-list-level-with-the-title--parameter-1--------the-third-list-is-a-two-page-spool-list-created-implicitly-by-calling-a-dynpro-sequence-using-call-screen-and-carries-the-title--parameter-2---the-first-page-contains-a-line--cccc---the-second-page-contains-a-line--ffff---its-spool-list-level-is-stacked-upon-the-spool-list-level-of-the-previous-spool-list-with-the-title--parameter-2---from-which-the-spool-parameters-are-also-taken-------the-fourth-list-is-a-one-page-spool-list-created-explicitly-using-new-page-print-on-and-carries-the-title--parameter-3---it-contains-the-line--dddd---its-spool-list-level-is-stacked-upon-the-spool-list-level-of-the-previous-spool-list-with-the-title--parameter-2--------the-fifth-list-is-a-one-page-spool-list-created-explicitly-using-new-page-print-on-and-carries-the-title--parameter-4---it-contains-the-line--eeee---its-spool-list-level-is-stacked-upon-the-spool-list-level-of-the-previous-spool-list-with-the-title--parameter-2----the-fifth-list-is-created-in-the-static-method-print-of-class-print--demo--the-first-attempt-to-create-a-new-spool-list-with-the-title--parameter-4--raises-the-exception-cx--sy--nested--print--on--because-the-spool-list-created-with-new-page-print-on-and-carrying-the-title--parameter-3--is-still-open--when-the-exception-is-handled--a-new-spool-list-is-opened-using-the-addition-new-section--since-the-spool-parameters-used-are-different--the-opened-spool-list-is-closed-and-a-new-spool-list-is-opened--no-longer-raising-an-exception--if-identical-spool-parameters-are-used--the-output-is-appended-to-the-existing-spool-list--because-the-spool-list-opened-using-new-page-print-on-is-closed-already-in-the-method--the-statement-new-page-print-off-in-the-dialog-module-status--0100-no-longer-has-an-effect-------------abap-keyword-documentation---abap---reference---sap-gui-user-dialogs---classic-lists---event-blocks-for-lists----files----10-----difficulty----intermediate----abap-keyword-documentation---abap---reference---sap-gui-user-dialogs---classic-lists---event-blocks-for-lists--included-pages--10---------source-----abenprint-list-abexa-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenprint-list-abexa-htm-------abenabap-lists-interactive-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------event-blocks-for-lists--list-events-appear-during-the-creation-of-a-list--and-following-certain-user-actions-on-a-displayed-list--they-used-to-process-lists-in-the-abap-program--we-differentiate-between-events-during-list-creation--and-interactive-list-events-for-processing-user-actions-in-a-displayed-list---the-events-during-list-creation--------top-of-page--javascript-call-link---abaptop-of-page-htm-----------end-of-page--javascript-call-link---abapend-of-page-htm------make-it-possible-to-define-page-headers-and-footers-independently-of-the-actual-page-length--which-is-particularly-helpful-for-the-output-of-spool-lists-on-different-paper-formats---the-events-following-user-actions-on-displayed-lists--------at-line-selection--javascript-call-link---abapat-line-selection-htm-----------at-user-command--javascript-call-link---abapat-user-command-htm-----------at-pfnn--javascript-call-link---abapat-pfnn-htm--------enable-you-to-create-details-lists---the-following-statement-can-be-used-to-trigger-a-list-event-in-a-program-controlled-manner--------set-user-command--javascript-call-link---abapset-user-command-htm------notes------after-the-execution-of-each-event-block-for-lists--the-statement--new-line--javascript-call-link---abapnew-line-htm-----is-executed-implicitly-as-in-every--event-block--javascript-call-link---abenevent-blocks-htm-----------list-events-can-be-raised-as-program-driven-events-using-the-statement--set-user-command--javascript-call-link---abapset-user-command-htm------instead-of-by-user-action-on-a-displayed-list---continue--top-of-page--javascript-call-link---abaptop-of-page-htm------end-of-page--javascript-call-link---abapend-of-page-htm------at-list--event--javascript-call-link---abapat-list-event-htm------set-user-command--javascript-call-link---abapset-user-command-htm-------------source-----abenabap-lists-interactive-htm--https---help-sap-com-doc-abapdocu-753-index-htm-7-53-en-us-abenabap-lists-interactive-htm-------abaptop-of-page-htm-------------as-abap-release-753---copyright-2019-sap-ag--all-rights-reserved----abap-keyword-documentation--javascript-call-link---abenabap-htm---------abap---reference--javascript-call-link---abenabap-reference-htm---------sap-gui-user-dialogs--javascript-call-link---abenabap-screens-htm---------classic-lists--javascript-call-link---abenabap-dynpro-list-htm---------event-blocks-for-lists--javascript-call-link---abenabap-lists-interactive-htm---------top-of-page---quick-reference--javascript-call-link---abaptop-of-page-shortref-htm------syntax--top-of-page-----during-line-selection-------addition--------during-line-selection----abap-one-add1@)

Effect

This statement defines an event block whose event is raised by the [ABAP runtime environment](javascript:call_link\('abenabap_runtime_envir_glosry.htm'\) "Glossary Entry") when a list is created. This occurs when a new page begins (that is, immediately before the first line on a new page is produced). All list output produced in the event block is placed below the standard page header of the list. It is not possible to produce lines than are available on the page within the event block. The statement [NEW-PAGE](javascript:call_link\('abapnew-page.htm'\)) is ignored within this event block.

The entire output written to the list in the event block is part of the [page header](javascript:call_link\('abenpage_header_glosry.htm'\) "Glossary Entry") of the current list page. The top page header cannot be moved when scrolling vertically in a list displayed on the screen.

For each TOP-OF-PAGE event, the placeholders "&1" - "&9" are replaced by the content of the system fields sy-tvar0 - sy-tvar9 in the standard heading and the column headings of the standard page header when a basic list is created. Values can be assigned to these system fields in the program.

Addition

... DURING LINE-SELECTION

Effect

If no addition is specified, an event block is raised for the event TOP-OF-PAGE when a basic list is created. If the addition DURING LINE-SELECTION is specified, an event block is raised for the events in question when details lists are created. System fields like sy-lsind must be used to distinguish between the individual details lists.

Continue
![Example](exa.gif "Example") [Lists, Page Header](javascript:call_link\('abenlist_top_of_page_abexa.htm'\))



**📖 Source**: [abaptop-of-page.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abaptop-of-page.htm)

### abenlist_top_of_page_abexa.htm

> **📖 Official SAP Documentation**: [abenlist_top_of_page_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_top_of_page_abexa.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Event Blocks for Lists](javascript:call_link\('abenabap_lists_interactive.htm'\)) →  [TOP-OF-PAGE](javascript:call_link\('abaptop-of-page.htm'\)) → 

Lists, Page Header

The example shows how to define the page header at the TOP-OF-PAGE event.

Source Code

REPORT demo\_list\_top\_of\_page NO STANDARD PAGE HEADING
                             LINE-SIZE 80 LINE-COUNT 7.
DATA: h1(10) TYPE c VALUE '    Number',
      h2(10) TYPE c VALUE '    Square',
      h3(10) TYPE c VALUE '      Cube',
      n1 TYPE i, n2 TYPE i, n3 TYPE i,
      x TYPE i.
TOP-OF-PAGE.
  x = sy-colno + 8.  POSITION x. WRITE h1.
  x = sy-colno + 8.  POSITION x. WRITE h2.
  x = sy-colno + 8.  POSITION x. WRITE h3.
  x = sy-colno + 16. POSITION x. WRITE sy-pagno.
  ULINE.
START-OF-SELECTION.
  DO 10 TIMES.
    n1 = sy-index. n2 = sy-index \*\* 2. n3 = sy-index \*\* 3.
    NEW-LINE.
    WRITE: n1 UNDER h1,
           n2 UNDER h2,
           n3 UNDER h3.
  ENDDO.

Description

This program creates a two-page list. In the user-defined page header, column titles are placed in relative position to each other using the system field sy-colno and the POSITION statement. The actual list output is positioned under the fields of the header line using the addition UNDER of the WRITE statement. The line feeds are made using NEW-LINE.

The different output positions of the individual fields result from the ABAP default of representing character strings as left-justified and numeric fields as right-justified. The alignment can be adjusted using the formatting options LEFT-JUSTIFIED, RIGHT-JUSTIFIED, and CENTERED of the WRITE statement (see [WRITE - format\_options](javascript:call_link\('abapwrite_to_options.htm'\))).



**📖 Source**: [abenlist_top_of_page_abexa.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_top_of_page_abexa.htm)

### abaptop-of-page.htm

> **📖 Official SAP Documentation**: [abaptop-of-page.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abaptop-of-page.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Event Blocks for Lists](javascript:call_link\('abenabap_lists_interactive.htm'\)) → 

TOP-OF-PAGE

[Quick Reference](javascript:call_link\('abaptop-of-page_shortref.htm'\))

Syntax

TOP-OF-PAGE *\[*DURING LINE-SELECTION*\]*.

Addition:

[... DURING LINE-SELECTION](#!ABAP_ONE_ADD@1@)

Effect

This statement defines an event block whose event is raised by the [ABAP runtime environment](javascript:call_link\('abenabap_runtime_envir_glosry.htm'\) "Glossary Entry") when a list is created. This occurs when a new page begins (that is, immediately before the first line on a new page is produced). All list output produced in the event block is placed below the standard page header of the list. It is not possible to produce lines than are available on the page within the event block. The statement [NEW-PAGE](javascript:call_link\('abapnew-page.htm'\)) is ignored within this event block.

The entire output written to the list in the event block is part of the [page header](javascript:call_link\('abenpage_header_glosry.htm'\) "Glossary Entry") of the current list page. The top page header cannot be moved when scrolling vertically in a list displayed on the screen.

For each TOP-OF-PAGE event, the placeholders "&1" - "&9" are replaced by the content of the system fields sy-tvar0 - sy-tvar9 in the standard heading and the column headings of the standard page header when a basic list is created. Values can be assigned to these system fields in the program.

Addition

... DURING LINE-SELECTION

Effect

If no addition is specified, an event block is raised for the event TOP-OF-PAGE when a basic list is created. If the addition DURING LINE-SELECTION is specified, an event block is raised for the events in question when details lists are created. System fields like sy-lsind must be used to distinguish between the individual details lists.

Continue
![Example](exa.gif "Example") [Lists, Page Header](javascript:call_link\('abenlist_top_of_page_abexa.htm'\))



**📖 Source**: [abaptop-of-page.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abaptop-of-page.htm)

### abapend-of-page.htm

> **📖 Official SAP Documentation**: [abapend-of-page.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapend-of-page.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Event Blocks for Lists](javascript:call_link\('abenabap_lists_interactive.htm'\)) → 

END-OF-PAGE

[Quick Reference](javascript:call_link\('abapend-of-page_shortref.htm'\))

Syntax

END-OF-PAGE.

Effect

This statement defines an event block triggered by the [ABAP runtime environment](javascript:call_link\('abenabap_runtime_envir_glosry.htm'\) "Glossary Entry") when a basic list is created, if a line reservation was made in the addition LINE-COUNT of the introductory statement for a [page footer](javascript:call_link\('abenpage_footer_glosry.htm'\) "Glossary Entry") reached by a write operation on this page. List output made in the event block is placed in this area. Output statements that exceed the reserved area are ignored.

Example

This program displays a list of flights and creates a page for each connection with a header line and footer line.

REPORT demo\_page\_header\_footer NO STANDARD PAGE HEADING
                               LINE-COUNT 0(1).
TYPES: BEGIN OF sflight\_tab\_type,
         carrid TYPE sflight-carrid,
         connid TYPE sflight-connid,
         fldate TYPE sflight-fldate,
       END OF sflight\_tab\_type.
PARAMETERS p\_carrid TYPE sflight-carrid.
DATA: sflight\_tab TYPE TABLE OF sflight\_tab\_type,
      sflight\_wa  LIKE LINE OF sflight\_tab.
DATA lines TYPE i.
TOP-OF-PAGE.
  WRITE: / sflight\_wa-carrid, sflight\_wa-connid.
  ULINE.
END-OF-PAGE.
  ULINE.
START-OF-SELECTION.
  SELECT carrid, connid, fldate
         FROM sflight
         WHERE carrid = @p\_carrid
         ORDER BY carrid, connid
         INTO CORRESPONDING FIELDS OF TABLE @sflight\_tab.
  LOOP AT sflight\_tab INTO sflight\_wa.
    AT NEW connid.
      SELECT COUNT( DISTINCT fldate )
             FROM sflight
             WHERE carrid = @sflight\_wa-carrid AND
                   connid = @sflight\_wa-connid
             INTO @lines.
      lines = lines + 3.
      NEW-PAGE LINE-COUNT lines.
    ENDAT.
    WRITE / sflight\_wa-fldate.
  ENDLOOP.



**📖 Source**: [abapend-of-page.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapend-of-page.htm)

### abapat_list_event.htm

> **📖 Official SAP Documentation**: [abapat_list_event.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapat_list_event.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Event Blocks for Lists](javascript:call_link\('abenabap_lists_interactive.htm'\)) → 

AT list\_event

Syntax

AT  [LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\))
  *|* [USER-COMMAND](javascript:call_link\('abapat_user-command.htm'\))
  *|* [PFnn](javascript:call_link\('abapat_pfnn.htm'\)).

Effect

Defines event blocks for interactive list processing. The associated events occur if the screen cursor is positioned on a line in a displayed list and the user chooses an appropriate function. Each interactive list event increases the system field sy-lsind by one.

If the cursor is positioned on a line in a list displayed on the screen in an interactive list event, all the values stored using [HIDE](javascript:call_link\('abaphide.htm'\)) and belonging to the line in question are assigned the respective variables and the following system fields are filled with data:

System Field

Meaning

sy-cpage

Page number of the first displayed page of the list from which the event was raised

sy-cucol

Position of the column in the GUI window from which the event was raised (counting starts with 2)

sy-curow

Position of the line in the GUI window from which the event was raised (counting starts with 1)

sy-lilli

Number of the line from which the event was raised

sy-lisel

Content of the line that raised the event (is limited to the first 255 characters)

sy-listi

Index of the list from which the event was raised

sy-lsind

Index of the list level that was created in the event block

sy-staco

Number of the first column displayed in the list from which the event was raised (counting starts with 1)

sy-staro

Number of the first line of the first page displayed of the list from which the event was raised (counting starts with 1)

sy-ucomm

Function code to which the user action that raised the event is assigned

After each list event AT LINE-SELECTION, AT PFnn, and AT USER-COMMAND, the statement [NEW-PAGE PRINT OFF](javascript:call_link\('abapnew-page_print.htm'\)) is executed explicitly.

Note

The list event [AT PFnn](javascript:call_link\('abapat_pfnn.htm'\)) is obsolete and the other two list events (preferably [AT USER-COMMAND](javascript:call_link\('abapat_user-command.htm'\))) should be used instead.

Continue
[AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\))
[AT USER-COMMAND](javascript:call_link\('abapat_user-command.htm'\))



**📖 Source**: [abapat_list_event.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapat_list_event.htm)

### abapat_line-selection.htm

> **📖 Official SAP Documentation**: [abapat_line-selection.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapat_line-selection.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Event Blocks for Lists](javascript:call_link\('abenabap_lists_interactive.htm'\)) →  [AT list\_event](javascript:call_link\('abapat_list_event.htm'\)) → 

AT LINE-SELECTION

[Quick Reference](javascript:call_link\('abapat_line-selection_shortref.htm'\))

Syntax

AT LINE-SELECTION.

Effect

This statement defines an event block whose event is raised by the [ABAP runtime environment](javascript:call_link\('abenabap_runtime_envir_glosry.htm'\) "Glossary Entry") when a screen list is displayed. This is provided the screen cursor is a list line and a function is selected using the function code PICK. By defining this event block, the [standard list status](javascript:call_link\('abenstandard_list_status_glosry.htm'\) "Glossary Entry") is enhanced automatically in such a way that the function code F2 and, with it, the double-click mouse function is associated with the function code PICK.

Note

If the function key F2 is associated with a function code other than PICK, each double click raises its event, usually AT USER-COMMAND, and not AT LINE-SELECTION.

Example

This program works with the standard list status. Selecting a line with the left mouse key raises the event AT LINE-SELECTION and creates details lists.

REPORT demo\_at\_line\_selection.
START-OF-SELECTION.
  WRITE 'Click me!' COLOR = 5 HOTSPOT.
AT LINE-SELECTION.
  WRITE: / 'You clicked list', sy-listi,
         / 'You are on list', sy-lsind.
  IF sy-lsind < 20.
    SKIP.
    WRITE: 'More ...' COLOR = 5 HOTSPOT.
  ENDIF.



**📖 Source**: [abapat_line-selection.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapat_line-selection.htm)

### abapat_user-command.htm

> **📖 Official SAP Documentation**: [abapat_user-command.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapat_user-command.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Event Blocks for Lists](javascript:call_link\('abenabap_lists_interactive.htm'\)) →  [AT list\_event](javascript:call_link\('abapat_list_event.htm'\)) → 

AT USER-COMMAND

[Quick Reference](javascript:call_link\('abapat_user-command_shortref.htm'\))

Syntax

AT USER-COMMAND.

Effect

This statement defines an event block whose event is raised by the [ABAP runtime environment](javascript:call_link\('abenabap_runtime_envir_glosry.htm'\) "Glossary Entry") if, when a screen is displayed, a function with a self-defined function code is chosen. The function code is available in the system field sy-ucomm when processing starts.

Self-defined function codes are all those that include character combinations, except for the following:

-   The function codes "PICK" and "PFnn" ("nn" stands for 01 to 24) do not raise the event AT USER-COMMAND, but the events AT LINE-SELECTION and AT PFnn instead.
    
-   All function codes that start with the character "%" are interpreted as system functions and do not raise the event AT USER-COMMAND. The system functions for lists are listed in the following table 1.
    
-   The function codes in the following table 2, likewise, do not raise the event AT USER-COMMAND, but are handled by the list processor.
    

Table 1

Function Code

Function

%CTX

Calls a context menu

%EX

Exit

%PC

Save to file

%PRI

Spool

%SC

Search for ...

%SC+

Find next

%SL

Save in Office

%ST

Save in report tree

Table 2

Function Code

Function

BACK

Back

P-

Scroll to previous page

P--

Scroll to first page

P+

Scroll to next page

P++

Scroll to last page

PFILE name

Saves list lines in a [text file](javascript:call_link\('abenfile_glosry.htm'\) "Glossary Entry") named "abap.lst" in standard character format in the standard directory on the [AS Instance](javascript:call_link\('abenapplication_server_glosry.htm'\) "Glossary Entry") [host computer](javascript:call_link\('abenhost_computer_glosry.htm'\) "Glossary Entry"). If a name is entered using name, this is converted to lowercase letters and used as the file name.

PL-

Scroll to first line of the page

PL-n

Scroll back n lines

PL+

Scroll to last line of the page

PL+n

Scroll forward n lines

PNOP

None

PP-

Scroll back one page

PP-n

Scroll back n pages

PP+

Scroll forward one page

PP+n

Scroll forward n pages

PPn

Scroll to beginning of page n

PRI, PRINT

Spool

PS--

Scroll to first column

PS++

Scroll to last column

PS-

Scroll one column to the left

PS-n

Scroll n columns to the left

PS+

Scroll one column to the right

PS+n

Scroll n columns to the right

PSn

Scroll to column n

PZn

Scroll to line n

RW

Cancel

Example

This program works with a self-defined GUI status MYLIST. The function associated there with the function code MY\_SELECTION raises the event AT USER-COMMAND when the list is displayed and also creates details lists.

REPORT demo\_at\_user\_command.
START-OF-SELECTION.
  SET PF-STATUS 'MYLIST'.
  WRITE 'List line'.
AT USER-COMMAND.
  IF sy-lsind = 20.
    SET PF-STATUS 'MYLIST' EXCLUDING 'MY\_SELECTION'.
  ENDIF.
  CASE sy-ucomm.
    WHEN 'MY\_SELECTION'.
      WRITE: / 'You worked on list', sy-listi,
             / 'You are on list', sy-lsind.
    ...
  ENDCASE.



**📖 Source**: [abapat_user-command.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapat_user-command.htm)

### abapat_list_event.htm

> **📖 Official SAP Documentation**: [abapat_list_event.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapat_list_event.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Event Blocks for Lists](javascript:call_link\('abenabap_lists_interactive.htm'\)) → 

AT list\_event

Syntax

AT  [LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\))
  *|* [USER-COMMAND](javascript:call_link\('abapat_user-command.htm'\))
  *|* [PFnn](javascript:call_link\('abapat_pfnn.htm'\)).

Effect

Defines event blocks for interactive list processing. The associated events occur if the screen cursor is positioned on a line in a displayed list and the user chooses an appropriate function. Each interactive list event increases the system field sy-lsind by one.

If the cursor is positioned on a line in a list displayed on the screen in an interactive list event, all the values stored using [HIDE](javascript:call_link\('abaphide.htm'\)) and belonging to the line in question are assigned the respective variables and the following system fields are filled with data:

System Field

Meaning

sy-cpage

Page number of the first displayed page of the list from which the event was raised

sy-cucol

Position of the column in the GUI window from which the event was raised (counting starts with 2)

sy-curow

Position of the line in the GUI window from which the event was raised (counting starts with 1)

sy-lilli

Number of the line from which the event was raised

sy-lisel

Content of the line that raised the event (is limited to the first 255 characters)

sy-listi

Index of the list from which the event was raised

sy-lsind

Index of the list level that was created in the event block

sy-staco

Number of the first column displayed in the list from which the event was raised (counting starts with 1)

sy-staro

Number of the first line of the first page displayed of the list from which the event was raised (counting starts with 1)

sy-ucomm

Function code to which the user action that raised the event is assigned

After each list event AT LINE-SELECTION, AT PFnn, and AT USER-COMMAND, the statement [NEW-PAGE PRINT OFF](javascript:call_link\('abapnew-page_print.htm'\)) is executed explicitly.

Note

The list event [AT PFnn](javascript:call_link\('abapat_pfnn.htm'\)) is obsolete and the other two list events (preferably [AT USER-COMMAND](javascript:call_link\('abapat_user-command.htm'\))) should be used instead.

Continue
[AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\))
[AT USER-COMMAND](javascript:call_link\('abapat_user-command.htm'\))



**📖 Source**: [abapat_list_event.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapat_list_event.htm)

### abapset_user-command.htm

> **📖 Official SAP Documentation**: [abapset_user-command.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_user-command.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [SAP GUI User Dialogs](javascript:call_link\('abenabap_screens.htm'\)) →  [Classic Lists](javascript:call_link\('abenabap_dynpro_list.htm'\)) →  [Event Blocks for Lists](javascript:call_link\('abenabap_lists_interactive.htm'\)) → 

SET USER-COMMAND

[Quick Reference](javascript:call_link\('abapset_user-command_shortref.htm'\))

Syntax

SET USER-COMMAND fcode.

Effect

Raises a list event with a function code specified in fcode. fcode must be a [character-like data object](javascript:call_link\('abencharlike_data_object_glosry.htm'\) "Glossary Entry"). This statement can be used when creating a list. After completion, but before display of the current list, the runtime environment responds as if a user action were performed in the displayed list using the function code specified in fcode.

The assignment of list events to function codes corresponds to the description under [AT USER-COMMAND](javascript:call_link\('abapat_user-command.htm'\)):

-   The predefined function codes of the tables specified under AT USER-COMMAND are caught by the runtime environment
    
-   The function codes "PICK" and "PFnn" raise the events [AT LINE-SELECTION](javascript:call_link\('abapat_line-selection.htm'\)) or [AT PFnn](javascript:call_link\('abapat_pfnn.htm'\))
    
-   all other functions raise the event [AT USER-COMMAND](javascript:call_link\('abapat_user-command.htm'\))
    

If the corresponding event block is implemented, the value of sy-lsind is increased by one and the event block is executed.

If multiple SET USER-COMMAND statements are used when creating a list, all are ignored except the last one.

Notes

-   The function code "PICK" only raises an event if the cursor is positioned on a list line.
    
-   If a function code is assigned to the Return key in the current [GUI status](javascript:call_link\('abengui_status_glosry.htm'\) "Glossary Entry"), this function code is used instead of the one specified in fcode.
    

Example

Creates (program-driven) one basic list and two details lists and displays a search dialog box in the second details list using the predefined function code "%SC". The statement SET CURSOR is used to position the cursor in a list line in the event block AT LINE-SELECTION to enable the function code "PICK".

START-OF-SELECTION.
  SET USER-COMMAND 'MYCOMM'.
  WRITE 'Basic List'.
AT USER-COMMAND.
  CASE sy-ucomm.
    WHEN 'MYCOMM'.
      WRITE 'Details List from USER-COMMAND,'.
      WRITE: 'SY-LSIND', sy-lsind.
      SET CURSOR LINE 1.
      SET USER-COMMAND 'PICK'.
  ENDCASE.
AT LINE-SELECTION.
  WRITE 'Details List from LINE-SELECTION,'.
  WRITE: 'SY-LSIND', sy-lsind.
  SET USER-COMMAND '%SC'.


---


## ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Built-In Data Objects

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Built-In Data Objects

Included pages: 3



**📖 Source**: [abapset_user-command.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapset_user-command.htm)

### abenbuilt_in_obsolete.htm

> **📖 Official SAP Documentation**: [abenbuilt_in_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenbuilt_in_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) → 

Obsolete Built-In Data Objects

-   [Obsolete System Fields](javascript:call_link\('abensystem_fields_obsolete.htm'\))

-   [The Built-In Structure screen](javascript:call_link\('abenscreen_structure_obsolete.htm'\))

Continue
[Obsolete System Fields](javascript:call_link\('abensystem_fields_obsolete.htm'\))
[The Built-In Structure screen](javascript:call_link\('abenscreen_structure_obsolete.htm'\))



**📖 Source**: [abenbuilt_in_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenbuilt_in_obsolete.htm)

### abensystem_fields_obsolete.htm

> **📖 Official SAP Documentation**: [abensystem_fields_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abensystem_fields_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Built-In Data Objects](javascript:call_link\('abenbuilt_in_obsolete.htm'\)) → 

Obsolete System Fields

-   [Former System Fields](#abensystem-fields-obsolete-1--------spool-parameters---@ITOC@@ABENSYSTEM_FIELDS_OBSOLETE_2)

Former System Fields

The following [system fields](javascript:call_link\('abensystem_field_glosry.htm'\) "Glossary Entry") are obsolete and should no longer be used. Many originate from the R/2 era. The transition from R/2 to R/3 retained some system fields which are no longer provided with data.

Name

Type

Length

Content

sy-appli

x

2

In R/2, ID for which SAP applications are installed. No longer filled.

sy-batzd

c

1

In R/2, ID for daily background scheduling. No longer filled.

sy-batzm

c

1

In R/2, ID for monthly background scheduling. No longer filled.

sy-batzo

c

1

In R/2, ID for single background scheduling. No longer filled.

sy-batzs

c

1

In R/2, ID for immediate background scheduling. No longer filled.

sy-batzw

c

1

In R/2, ID for weekly background scheduling. No longer filled.

sy-brep4

c

4

In R/2, ID for immediate spool output for background processing. No longer filled.

sy-bspld

c

1

In R/2, ID for immediate spool output for background processing. No longer filled.

sy-ccurs

p

9

In R/2, rate specification / result field from CURRENCY CONVERSION. No longer filled.

sy-ccurt

p

9

In R/2, table rate from CURRENCY CONVERSION. No longer filled.

sy-cdate

d

\-

In R/2, rate date from CURRENCY CONVERSION. No longer filled.

sy-ctabl

c

4

In R/2, rate table from CURRENCY CONVERSION. No longer filled.

sy-ctype

c

1

In R/2, rate type from CURRENCY CONVERSION. No longer filled.

sy-dcsys

c

4

Dialog system of the R/2 system. No longer filled.

sy-fmkey

c

3

Former function code menu. No longer filled.

sy-locdb

c

1

Local database (not implemented).

sy-locop

c

1

Local database operation (not implemented).

sy-lstat

c

16

Program-driven name for list levels. Can be provided with values when lists are created by the ABAP program. The value that applies when a list is completed is saved with the list. After an interactive list event, sy-lstat is set to the value assigned to it when the list where the event occurred was created. sy-lstat is no longer defined and should therefore no longer be used.

sy-macdb

c

4

Previously, name of file for matchcode access. No longer filled.

sy-marky

c

1

Current line letter for the obsolete statement MARK from the R/2 system.

sy-msgli

c

60

Not documented. No longer filled.

sy-pagct

i

\-

In R/2, maximum number of pages per list. No longer filled.

sy-prefx

c

3

Prefix for background jobs. No longer filled.

sy-sfnam

c

30

Not documented.

sy-sponr

n

10

In R/2, spool files were edited using the statement TRANSFER, which also set sy-sponr. No longer filled.

sy-tfdsn

c

8

Former name of the external repository file for extracts. No longer filled.

sy-tmaxl

i

\-

Former maximum number of entries in an internal table. No longer filled.

sy-tname

c

12

Former name of an internal table after a read/write. No longer filled.

sy-toccu

i

\-

In the statements DESCRIBE TABLE, LOOP AT, and READ TABLE, sy-toccu was formerly given the value for the initial main memory requirements of the addressed internal table. No longer filled.

sy-tpagi

i

\-

Previously, ID whether an internal table is stored in the paging area. No longer filled.

sy-ttabc

i

\-

Former index of the last row read from an internal table. No longer filled.

sy-ttabi

i

\-

Former offset of internal tables in the program memory. No longer filled.

sy-waers

c

5

Former company code currency after posting segment is read. No longer filled.

sy-willi

i

\-

In R/2, number of the selected row of a list in details lists in a GUI window. Use sy-lilli instead.

sy-winco

i

\-

In R/2, cursor position in details lists in a GUI window. Use sy-cucol instead.

sy-windi

i

\-

In R/2, index of the list in details lists in a GUI window. Use sy-lsind instead.

sy-winro

i

\-

In R/2, cursor position in details lists in a GUI window. Use sy-curow instead.

sy-winsl

c

79

In R/2, content of the selected row in details lists in a GUI window. Use sy-lisel instead.

sy-winx1

i

\-

In R/2, window coordinates in details lists in a GUI window. No longer used.

sy-winx2

i

\-

In R/2, window coordinates in details lists in a GUI window. No longer used.

sy-winy1

i

\-

In R/2, window coordinates in details lists in a GUI window. No longer used.

sy-winy2

i

\-

In R/2, window coordinates in details lists in a GUI window. No longer used.

Spool Parameters

[Spool parameters](javascript:call_link\('abenprint_parameters.htm'\)) are passed from the runtime environment to the spool system in a structure of type PRI\_PARAMS. Before this structure was introduced, [system fields](javascript:call_link\('abensystem_field_glosry.htm'\) "Glossary Entry") were used. When spooling is activated today, a subset of the structure PRI\_PARAMS is still written to system fields of the same name. This information is redundant and should not be used.

Name

Type

Length

Content

sy-paart

c

16

[Formatting](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-pdest

c

4

[Output device](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-pexpi

n

1

[Retention period](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-plist

c

12

[Name of spool request](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-prabt

c

12

[Department name](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-prbig

c

1

[Cover sheet](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-prcop

n

3

[Number of copies](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-prdsn

c

6

[Name of the spool file](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-primm

c

1

[Print now](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-prnew

c

1

[New spool request](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-prrec

c

12

[Recipient name](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-prrel

c

1

[Delete now](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-prtxt

c

68

[Description text](javascript:call_link\('abenprint_parameters_overview.htm'\))

sy-rtitl

c

70

[Title of the spooler program](javascript:call_link\('abenprint_parameters_overview.htm'\))



**📖 Source**: [abensystem_fields_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abensystem_fields_obsolete.htm)

### abenscreen_structure_obsolete.htm

> **📖 Official SAP Documentation**: [abenscreen_structure_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenscreen_structure_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Built-In Data Objects](javascript:call_link\('abenbuilt_in_obsolete.htm'\)) → 

The Built-In Structure screen

In [dynpro](javascript:call_link\('abendynpro_glosry.htm'\) "Glossary Entry") processing in dialog modules, the built-in data object screen of the data type SCREEN from ABAP Dictionary is available. It can be addressed explicitly there and implicitly in obsolete short forms.

-   [LOOP AT SCREEN](javascript:call_link\('abenloop_at_screen_obsolete.htm'\))

-   [MODIFY SCREEN](javascript:call_link\('abenmodify_screen_obsolete.htm'\))

can be used. A data object screen declared explicitly in the current context obscures the built-in structure.

Notes

-   Instead of the built-in structure screen, use explicitly declared work areas of the type SCREEN in the long forms of the statements above.

-   LOOP AT SCREEN INTO screen or MODIFY SCREEN FROM screen should not be used to access the obsolete built-in structure, even in the long forms.


---


## ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Declarations / Data Types and Data Objects

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Declarations / Data Types and Data Objects

Included pages: 4



**📖 Source**: [abenscreen_structure_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenscreen_structure_obsolete.htm)

### abentypes_data_obsolete.htm

> **📖 Official SAP Documentation**: [abentypes_data_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentypes_data_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Declarations](javascript:call_link\('abenobsolete_declarations.htm'\)) → 

Data Types and Data Objects

-   [TYPES - implicit](javascript:call_link\('abaptypes_implicit.htm'\))

-   [Unnecessary Length Specifications](javascript:call_link\('abendeclaration_wrong_length.htm'\))

-   [Anonymous Components](javascript:call_link\('abenanonymous_components.htm'\))

This translation does not reflect the current version of the documentation.
Continue
[TYPES - implicit](javascript:call_link\('abaptypes_implicit.htm'\))
[Wrong Lengths](javascript:call_link\('abendeclaration_wrong_length.htm'\))
[Anonymous Components](javascript:call_link\('abenanonymous_components.htm'\))



**📖 Source**: [abentypes_data_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentypes_data_obsolete.htm)

### abaptypes_implicit.htm

> **📖 Official SAP Documentation**: [abaptypes_implicit.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abaptypes_implicit.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Declarations](javascript:call_link\('abenobsolete_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_data_obsolete.htm'\)) → 

TYPES - implicit

[Quick Reference](javascript:call_link\('abaptypes_shortref.htm'\))

Obsolete Syntax

TYPES *{* dtype *}*
    *|* *{* dtype(len) *}*
    *|* *{* dtype LENGTH len *}*
    *|* *{* dtype TYPE c*|*n*|*p*|*x *}*
    *|* *{* dtype(len) TYPE p*}*
    *|* *{* dtype TYPE p LENGTH len*}*
    *|* *{* dtype TYPE p DECIMALS dec*}*.

Effect

Obsolete short forms of the statement [TYPES](javascript:call_link\('abaptypes.htm'\)) with reference to a built-in elementary type [abap\_type](javascript:call_link\('abaptypes_simple.htm'\)).

-   If TYPE abap\_type is not specified, the type is set implicitly to the standard type c.
    
-   If len or dec is not specified for the ABAP types c, n, p, and x, the length is set to the [type-friendly standard length](javascript:call_link\('abenbuilt_in_types_complete.htm'\)). No decimal places are set for p. This is only permitted outside of classes or interfaces.
    

Note

All additions should be specified in full, to make them easier to read.

Bad Example

TYPES: t1,
       t2 TYPE p.

Good Example

TYPES: t1 TYPE c LENGTH 1,
       t2 TYPE p LENGTH 8 DECIMALS 0.



**📖 Source**: [abaptypes_implicit.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abaptypes_implicit.htm)

### abendeclaration_wrong_length.htm

> **📖 Official SAP Documentation**: [abendeclaration_wrong_length.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclaration_wrong_length.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Declarations](javascript:call_link\('abenobsolete_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_data_obsolete.htm'\)) → 

Wrong Lengths

Obsolete Syntax

... dtype(len)*|*dobj(len) TYPE d*|*f*|*i*|*t ...

Effect

Lengths specified in [declarations](javascript:call_link\('abenabap_declarations.htm'\)) using the statements TYPES, DATA, STATICS, and CONSTANTS and the built-in ABAP types d, f, i, and t are ignored. Only the predefined [fixed lengths](javascript:call_link\('abenbuilt_in_types_complete.htm'\)) can be specified. Lengths specified in this way produce syntax errors in classes and interfaces and syntax warnings elsewhere.

Note

This obsolete length specification is only possible with the obsolete parenthesis syntax and not with the recommended addition LENGTH.

Bad Example

DATA: f1(8) TYPE d,
      f2(4) TYPE i.

Good Example

DATA: f1 TYPE d,
      f2 TYPE i.



**📖 Source**: [abendeclaration_wrong_length.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclaration_wrong_length.htm)

### abenanonymous_components.htm

> **📖 Official SAP Documentation**: [abenanonymous_components.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenanonymous_components.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Declarations](javascript:call_link\('abenobsolete_declarations.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abentypes_data_obsolete.htm'\)) → 

Anonymous Components

Obsolete Syntax

DATA: BEGIN OF struc,
        ...
        '...',
        ...
        space(len) *\[*TYPE c*\]*,
        ...
      END OF struc.

Effect

If [text field literals](javascript:call_link\('abentext_field_literal_glosry.htm'\) "Glossary Entry") or the constant [space](javascript:call_link\('abenspace.htm'\)) (the latter also with a length specified in parentheses) are specified within the [definition of a structure](javascript:call_link\('abapdata_struc.htm'\)) using DATA, CONSTANTS, or STATICS, nameless text fields are included at this position as anonymous components. For literals, the initial value and the length of these components correspond to the content. If space is specified, a text field filled with blanks is created. These anonymous text fields cannot be addressed explicitly in programs. In particular, structures never contain components with the name space. Anonymous components can only be accessed using the structure name and by specifying appropriate offsets/lengths.

Notes

-   Anonymous components must not be specified in classes or interfaces.

-   These anonymous components can be replaced easily by named components. Named components increase the function of anonymous components by allowing them to be accessed explicitly, without limiting their role as, for example, filler fields.


---


## ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Declarations / Interface Work Areas

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Declarations / Interface Work Areas

Included pages: 3



**📖 Source**: [abenanonymous_components.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenanonymous_components.htm)

### abeninterface_areas_obsolete.htm

> **📖 Official SAP Documentation**: [abeninterface_areas_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterface_areas_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Declarations](javascript:call_link\('abenobsolete_declarations.htm'\)) → 

Interface Work Areas

Interface work areas are created only once for each [program group](javascript:call_link\('abenprogram_group_glosry.htm'\) "Glossary Entry") and shared by the [main program](javascript:call_link\('abenmain_program_glosry.htm'\) "Glossary Entry") and its additional loaded programs. The assignment of programs to program groups can be dependent on user actions, field contents, and switches, which means that interface work areas are extremely error-prone, with respect to their functions and to their maintainability. The only interface work areas that can still be used for special purposes are [table work areas](javascript:call_link\('abentable_work_area_glosry.htm'\) "Glossary Entry") declared using [TABLES](javascript:call_link\('abaptables.htm'\)). The following declarations are completely obsolete:

-   [DATA - COMMON PART](javascript:call_link\('abapdata_common.htm'\))

-   [TABLES \*](javascript:call_link\('abaptables_asterisk.htm'\))

The statement [NODES](javascript:call_link\('abapnodes.htm'\)) (once required for interface work areas between logical databases and executable programs) is also no longer required if logical databases are no longer used.

Continue
[DATA - COMMON PART](javascript:call_link\('abapdata_common.htm'\))
[TABLES \*](javascript:call_link\('abaptables_asterisk.htm'\))



**📖 Source**: [abeninterface_areas_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterface_areas_obsolete.htm)

### abapdata_common.htm

> **📖 Official SAP Documentation**: [abapdata_common.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdata_common.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Declarations](javascript:call_link\('abenobsolete_declarations.htm'\)) →  [Interface Work Areas](javascript:call_link\('abeninterface_areas_obsolete.htm'\)) → 

DATA - COMMON PART

[Quick Reference](javascript:call_link\('abapdata_common_part_shortref.htm'\))

Obsolete Syntax

DATA BEGIN OF COMMON PART *\[*name*\]*.
  ...
  DATA ...
  ...
DATA END OF COMMON PART *\[*name*\]*.

Effect

This variant of the statement [DATA](javascript:call_link\('abapdata.htm'\)) with the additions BEGIN OF COMMON PART and END OF COMMON PART defines a global [interface work area](javascript:call_link\('abeninterface_work_area_glosry.htm'\) "Glossary Entry"), that can be used jointly by the programs of a [program group](javascript:call_link\('abenprogram_group_glosry.htm'\) "Glossary Entry"). All data objects declared between these statements using DATA are part of this [common area](javascript:call_link\('abencommon_area_glosry.htm'\) "Glossary Entry").

The addition COMMON PART can only be used in the global declaration part of an ABAP program. Multiple common [data areas](javascript:call_link\('abendata_area_glosry.htm'\) "Glossary Entry") can be declared in a program, but they cannot be nested. Every common data area must be given a unique name using the name addition. The addition name can be omitted only if there is just one common data area in a program.

The following rules apply:

-   In all programs in a program group that declare common data areas with the same name, these areas must have identical layouts. Common data areas are hence viewed as structures whose [structure fragment view](javascript:call_link\('abenunicode_fragment_view_glosry.htm'\) "Glossary Entry") must be identical and whose deep components must be compatible (pairwise). If not, the runtime error LOAD\_COMMON\_PART\_STRUCT occurs.
    
-   In common data areas it is not possible to declare [object reference variables](javascript:call_link\('abenobject_refer_variable_glosry.htm'\) "Glossary Entry") with the static type of program-local classes and interfaces, nor is it possible to declare [data reference variables](javascript:call_link\('abendata_reference_variable_glosry.htm'\) "Glossary Entry") with the static type of program-local structured types.
    

Notes

-   The use of common data areas in otherwise independent programs can be very problematic, with regard to both the maintainability and the functions. Therefore, common data areas should no longer be used. The parameter interfaces of [procedures](javascript:call_link\('abenprocedure_glosry.htm'\) "Glossary Entry") are available for exchanging data between programs.
    
-   Common data areas for various programs are generally declared in an [include program](javascript:call_link\('abeninclude_program_glosry.htm'\) "Glossary Entry") that is embedded in all programs involved. However, multiple use of include programs is no longer recommended.
    
-   For more information about issues related to interface work areas, see [Program Groups in External Procedure Calls](javascript:call_link\('abenprogram_groups.htm'\)).
    

Example

In this example, a common data area struc is declared in the include program part. By incorporating the include program, the three programs param, sum and dis have shared access to the data area struc if they are part of a program group. The latter is accomplished by loading the programs sum and disp into the program group of param using external subroutine calls. The subroutine display in the program disp outputs the input values to the program param and the result of the summation in the subroutine summing.

\* INCLUDE part.
DATA: BEGIN OF COMMON PART struc,
        f1 TYPE i,
        f2 TYPE i,
        s  TYPE i,
      END OF COMMON PART struc.
PROGRAM param.
INCLUDE part.
PARAMETERS:
  p1 TYPE i DEFAULT 20,
  p2 TYPE i DEFAULT 90.
f1 = p1.
f2 = p2.
PERFORM summming IN PROGRAM sum.
PROGRAM sum.
INCLUDE part.
FORM summing.
  s = f1 + f2.
  PERFORM display IN PROGRAM disp.
ENDFORM.
PROGRAM disp.
INCLUDE part.
FORM display.
  WRITE: / f1, f2, s.
ENDFORM.



**📖 Source**: [abapdata_common.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapdata_common.htm)

### abaptables_asterisk.htm

> **📖 Official SAP Documentation**: [abaptables_asterisk.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abaptables_asterisk.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Declarations](javascript:call_link\('abenobsolete_declarations.htm'\)) →  [Interface Work Areas](javascript:call_link\('abeninterface_areas_obsolete.htm'\)) → 

TABLES \*

[Quick Reference](javascript:call_link\('abaptables_plus_shortref.htm'\))

Obsolete Syntax

TABLES \*table\_wa.

Effect

This statement declares an additional [table work area](javascript:call_link\('abentable_work_area_glosry.htm'\) "Glossary Entry") \*table\_wa, whose data type, like that of the regular [TABLES](javascript:call_link\('abaptables.htm'\)) statement with its [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") structured data type table\_wa, is taken from ABAP Dictionary.

The additional table work area can be used just like the regular table work area. This applies in particular to obsolete [database accesses](javascript:call_link\('abendatabase_access_obsolete.htm'\)).

Note

The statement TABLES cannot be used in classes. The addition TYPE can be used to reference the data types in ABAP Dictionary and declare any number of separate work areas.

Bad Example

Declaration of a regular and additional table work area and their use in obsolete short forms of the SELECT statement.

TABLES: scarr, \*scarr.
SELECT SINGLE \*
       FROM scarr
       WHERE carrid = 'LH'.
SELECT SINGLE \*
       FROM \*scarr
       WHERE carrid = 'UA'.

Good Example

Declares two work areas using DATA and how they are used in the INTO clause of the SELECT statement.

DATA: scarr1 TYPE scarr,
      scarr2 TYPE scarr.
SELECT SINGLE \*
       FROM scarr
       WHERE carrid = 'LH'
       INTO @scarr1.
SELECT SINGLE \*
       FROM scarr
       WHERE carrid = 'UA'
       INTO @scarr2.


---


## ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Object Creation

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Object Creation

Included pages: 2



**📖 Source**: [abaptables_asterisk.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abaptables_asterisk.htm)

### abenassign_obsolete.htm

> **📖 Official SAP Documentation**: [abenassign_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenassign_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) → 

Obsolete Object Creation

This section describes the creation of a local data object with the statement [ASSIGN LOCAL COPY](javascript:call_link\('abapassign_local_copy.htm'\)).

Continue
[ASSIGN LOCAL COPY](javascript:call_link\('abapassign_local_copy.htm'\))



**📖 Source**: [abenassign_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenassign_obsolete.htm)

### abapassign_local_copy.htm

> **📖 Official SAP Documentation**: [abapassign_local_copy.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapassign_local_copy.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Object Creation](javascript:call_link\('abenassign_obsolete.htm'\)) → 

ASSIGN LOCAL COPY

[Quick Reference](javascript:call_link\('abapassign_local_copy_shortref.htm'\))

Obsolete Syntax

ASSIGN LOCAL COPY
  OF *{* *{**\[*INITIAL*\]* mem\_area*}*
     *|* *{*INITIAL LINE OF *{*itab*|*(itab\_name)*}**}*
     *|* *{*MAIN TABLE FIELD (name)*}* *}*
  TO <fs> casting\_spec.

Extras:

[1\. ... mem\_area](#!ABAP_ADDITION_1@1@)
[2\. ... MAIN TABLE FIELD (name)](#!ABAP_ADDITION_2@2@)
[3\. ... casting\_spec](#!ABAP_ADDITION_3@3@)

Effect

Obsolete creation of a local data object. This variant of the [ASSIGN](javascript:call_link\('abapassign.htm'\)) statement can only be used in [subroutines](javascript:call_link\('abensubroutine_glosry.htm'\) "Glossary Entry") and [function modules](javascript:call_link\('abenfunction_module_glosry.htm'\) "Glossary Entry"). The [field symbol](javascript:call_link\('abenfield_symbol_glosry.htm'\) "Glossary Entry") <fs> must be declared locally in the procedure.

Like the regular statement [ASSIGN](javascript:call_link\('abapassign.htm'\)), the statement ASSIGN LOCAL COPY assigns a memory area mem\_area to the field symbol <fs>. Unlike the regular statement ASSIGN, the field symbol does not reference the memory area specified in mem\_area after the successful assignment. Instead, an [anonymous data object](javascript:call_link\('abenanonymous_data_object_glosry.htm'\) "Glossary Entry") is created in the local data area of the procedure. After the successful execution of the statement, the field symbol points to the new data object. The new data object is treated as follows:

-   The size of the memory area of the new data object conforms to either the data in mem\_area or the [line type](javascript:call_link\('abenrow_type_glosry.htm'\) "Glossary Entry")of an internal table if LINE OF is specified. The internal table can be specified directly as itab or as the content of a [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like field itab\_name.
    
-   The data type with which the new data object is to be handled conforms to the data in casting\_spec as is the case when using the regular ASSIGN.
    
-   The initial content of the new data object is copied from the memory area specified in mem\_area when specifying mem\_area without the addition INITIAL. Otherwise it is initialized according to type.
    

Limitation of the memory area [range\_spec](javascript:call_link\('abapassign_range.htm'\)), which can occur in the regular ASSIGN statement implicitly and explicitly, occurs only implicitly in accordance with the rules that also apply to the normal ASSIGN.

Note

The creation of a local data object using the statement ASSIGN LOCAL COPY is replaced by the statement CREATE DATA with subsequent dereferencing in the regular ASSIGN statement.

Addition 1

... mem\_area

Syntax of mem\_area

... *{* dobj*\[*+off*\]**\[*(len)*\]*
    *|* (name)
    *|* oref->(attr\_name)
    *|* *{*class*|*(class\_name)*}*\=>*{*attr*|*(attr\_name)*}*
    *|* dref->\* *}* ...

Effect

The specifications in mem\_area are a subset of the [specifications](javascript:call_link\('abapassign_mem_area.htm'\)) in the regular ASSIGN statement. They have the same function except for the following restrictions:

-   If the addition INITIAL is used before mem\_area, the data object name must be character-like and [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry").
    
-   If the addition INITIAL is used before mem\_area, the data object dref cannot be typed [generically](javascript:call_link\('abengeneric_data_type_glosry.htm'\) "Glossary Entry") when using the dereferencing operator \->\*.
    

Addition 2

... MAIN TABLE FIELD (name)

This addition is for internal use only.
It must not be used in application programs.

Effect

This addition is a special form of the specified memory area mem\_area that can only be used in this variant of the ASSIGN statement. It has the same function as the obsolete [TABLE FIELD (name)](javascript:call_link\('abapassign_table_field.htm'\)) in a regular ASSIGN with the exception that the search area is restricted to the current [main program group](javascript:call_link\('abenmain_program_group_glosry.htm'\) "Glossary Entry").

Addition 3

... casting\_spec

Effect

If specified, casting\_spec is the same as a regular [ASSIGN](javascript:call_link\('abapassign_casting.htm'\)) with the limitation that if the addition INITIAL is used before mem\_area and an internal tables is specified, no explicit specifications can be made. This means, the field symbol copies the data type of the data object in mem\_area or the line type of the internal table.

Example

A typical use of the statement ASSIGN LOCAL COPY was the creation of a local copy of a global data object.

DATA g\_dobj TYPE i.
...
CLEAR g\_dobj.
PERFORM subroutine1.
...
FORM subroutine1.
  FIELD-SYMBOLS <l\_dobj> TYPE ANY.
  ASSIGN LOCAL COPY OF g\_dobj TO <l\_dobj>.
  <l\_dobj> = <l\_dobj> + 1.
  cl\_demo\_output=>write\_data( <l\_dobj> ).
  cl\_demo\_output=>display\_data( g\_dobj ).
ENDFORM.

The following subroutine shows how the same functions can be universally implemented with a data reference.

DATA g\_dobj TYPE i.
...
CLEAR g\_dobj.
PERFORM subroutine2.
...
FORM subroutine2.
  DATA dref TYPE REF TO data.
  FIELD-SYMBOLS <l\_dobj> TYPE ANY.
  CREATE DATA dref LIKE g\_dobj.
  ASSIGN dref->\* TO <l\_dobj>.
  <l\_dobj> = g\_dobj.
  <l\_dobj> = <l\_dobj> + 1.
  cl\_demo\_output=>write\_data( <l\_dobj> ).
  cl\_demo\_output=>display\_data( g\_dobj ).
ENDFORM.


---


## ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Data and Communication Interfaces

**Files**: 17 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Data and Communication Interfaces

Included pages: 17



**📖 Source**: [abapassign_local_copy.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapassign_local_copy.htm)

### abenextern_obsolete.htm

> **📖 Official SAP Documentation**: [abenextern_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenextern_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) → 

Obsolete Data and Communication Interfaces

-   [Transactional RFC](javascript:call_link\('abenrfc_obsolete.htm'\))

-   [ABAP and XML](javascript:call_link\('abenabap_xml_obsolete.htm'\))

-   [CPI-C Interface](javascript:call_link\('abenabap_cpic.htm'\))

-   [ABAP and JavaScript](javascript:call_link\('abenabap_java_script.htm'\))

Continue
[Obsolete Transactional RFC](javascript:call_link\('abenrfc_obsolete.htm'\))
[Obsolete Wait](javascript:call_link\('abenwait_obsolete.htm'\))
[Obsolete XML Binding](javascript:call_link\('abenabap_xml_obsolete.htm'\))
[CPI-C Interface](javascript:call_link\('abenabap_cpic.htm'\))
[ABAP and JavaScript](javascript:call_link\('abenabap_java_script.htm'\))



**📖 Source**: [abenextern_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenextern_obsolete.htm)

### abenrfc_obsolete.htm

> **📖 Official SAP Documentation**: [abenrfc_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) → 

Obsolete Transactional RFC

-   [CALL FUNCTION - IN BACKGROUND TASK](javascript:call_link\('abapcall_function_background_task.htm'\))

Note

[Transactional remote function call (tRFC)](javascript:call_link\('abentrfc_1_glosry.htm'\) "Glossary Entry") and its enhancement, [queued remote function call (qRFC)](javascript:call_link\('abenqueued_remote_function_glosry.htm'\) "Glossary Entry"), have been replaced by [background RFC (bgRFC)](javascript:call_link\('abenbg_remote_function_glosry.htm'\) "Glossary Entry"). It is strongly recommended that bgRFC is used instead of tRFC.

Continue
[CALL FUNCTION - IN BACKGROUND TASK](javascript:call_link\('abapcall_function_background_task.htm'\))



**📖 Source**: [abenrfc_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_obsolete.htm)

### abapcall_function_background_task.htm

> **📖 Official SAP Documentation**: [abapcall_function_background_task.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcall_function_background_task.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) →  [Obsolete Transactional RFC](javascript:call_link\('abenrfc_obsolete.htm'\)) → 

CALL FUNCTION - IN BACKGROUND TASK

[Quick Reference](javascript:call_link\('abapcall_function_shortref.htm'\))

Obsolete Syntax

CALL FUNCTION func IN BACKGROUND TASK
                   *\[*AS SEPARATE UNIT*\]*
                   *\[*DESTINATION dest*\]*
                   [parameter\_list](javascript:call_link\('abapcall_function_background_para.htm'\)).

Addition:

[... AS SEPARATE UNIT](#!ABAP_ONE_ADD@1@)

Effect

Transactional call (tRFC) of a [remote-enabled function module](javascript:call_link\('abenremote_enabled_fm_glosry.htm'\) "Glossary Entry") specified in func using the [RFC interface](javascript:call_link\('abenrfc_interface_glosry.htm'\) "Glossary Entry"). Using the addition DESTINATION, a unique [destination](javascript:call_link\('abenrfc_destination.htm'\)) can be specified in dest. If the destination is not specified, the destination "NONE" is used implicitly. func and dest expect character-like data objects.

The transactional call registers the name of the called function, together with the destination and the actual parameters passed in [parameter\_list](javascript:call_link\('abapcall_function_background_para.htm'\)) for the current [SAP LUW](javascript:call_link\('abensap_luw_glosry.htm'\) "Glossary Entry") in the database tables ARFCSSTATE and ARFCSDATA of the current [AS ABAP](javascript:call_link\('abensap_nw_abap_glosry.htm'\) "Glossary Entry") under a unique transaction ID (abbreviated as TID, stored in a structure of type ARFCTID from ABAP Dictionary, viewed using transaction SM58). After registration, the calling program is continued after the statement CALL FUNCTION.

When the [COMMIT WORK](javascript:call_link\('abapcommit.htm'\)) statement is executed, the function modules registered for the current SAP LUW are started in the order in which they were registered. The statement [ROLLBACK WORK](javascript:call_link\('abaprollback.htm'\)) deletes all previous registrations for the current SAP LUW.

If the specified destination is not available when COMMIT WORK is executed, an [executable program](javascript:call_link\('abenexecutable_program_glosry.htm'\) "Glossary Entry") called RSARFCSE is started in [background processing](javascript:call_link\('abenbackround_processing_glosry.htm'\) "Glossary Entry"). By default, this tries to start the function modules registered for a SAP LUW in their destination every 15 minutes and up to 30 times. Changes can be made to these parameters using transaction SM59. If the destination does not become available within the defined time, it is recorded in the database table ARFCSDATA as the entry "CPICERR". By default, this entry in database table ARFCSSTATE is deleted after eight days.

Note

[background RFC (bgRFC)](javascript:call_link\('abenbg_remote_function_glosry.htm'\) "Glossary Entry") executed with the statement [CALL FUNCTION IN BACKGROUND UNIT](javascript:call_link\('abapcall_function_background_unit.htm'\)) is the enhanced successor technology of transactional RFC (tRFC) and makes this technology obsolete. It is strongly recommended to use bgRFC instead of tRFC.

More Information

More information about tRFC can be found in the RFC documentation on [SAP Help Portal](http://help.sap.com).

Addition

... AS SEPARATE UNIT

Effect

When using the addition AS SEPARATE UNIT, the relevant function module is executed in a separate [RFC session](javascript:call_link\('abenrfc_session_glosry.htm'\) "Glossary Entry"), in which the global data of the function group is not influenced by previous calls. Each function module that is registered with the addition AS SEPARATE UNIT is given a separate transaction ID. Without the addition AS SEPARATE UNIT, the usual [description](javascript:call_link\('abenrfc_context.htm'\)) applies to the [RFC session](javascript:call_link\('abenrfc_session_glosry.htm'\) "Glossary Entry") of the called function modules. This means that, when using the same [RFC destination](javascript:call_link\('abendestination_glosry.htm'\) "Glossary Entry") for multiple calls of function modules belonging to the same function group, the global data of this function group is accessed collectively.

Notes

-   The function module ID\_OF\_BACKGROUNDTASK can be used after a transactional RFC to determine the transactional ID (TID) of the current [SAP LUW](javascript:call_link\('abensap_luw_glosry.htm'\) "Glossary Entry").
    
-   The transactional RFC (tRFC) is suitable for realizing LUWs in distributed environments (a typical application is ALE). Note that, although the execution of the function modules within a transaction ID is specified, the order of the [LUWs](javascript:call_link\('abenluw_glosry.htm'\) "Glossary Entry") on the RFC servers is not necessarily the same as the order of the SAP LUWs on the RFC client. To ensure the same serialization is also used on RFC servers, the tRFC can be enhanced as ([queued RFC (qRFC)](javascript:call_link\('abenqrfc_glosry.htm'\) "Glossary Entry")). For this, the function module TRFC\_SET\_QUEUE\_NAME can be called before a transactional RFC. More information about qRFC can be found in the RFC documentation on [SAP Help Portal](http://help.sap.com).
    
-   If [tRFC](javascript:call_link\('abentrfc_2_glosry.htm'\) "Glossary Entry") or [qRFC](javascript:call_link\('abenqrfc_glosry.htm'\) "Glossary Entry") are registered in a [dialog module](javascript:call_link\('abendialog_module_object_glosry.htm'\) "Glossary Entry") and are not started with COMMIT WORK, they are not executed by the COMMIT WORK of the caller.
    
-   The new variant [CALL FUNCTION IN BACKGROUND UNIT](javascript:call_link\('abapcall_function_background_unit.htm'\)) ([bgRFC](javascript:call_link\('abenbgrfc_glosry.htm'\) "Glossary Entry")) includes and enhances the existing tRFC and qRFC variants. For this reason, we strongly recommend using bgRFC instead of tRFC.
    
-   The statements [COMMIT WORK](javascript:call_link\('abapcommit.htm'\)) and [ROLLBACK WORK](javascript:call_link\('abaprollback.htm'\)) must not be executed within a LUW. In addition, no implicit [database commit](javascript:call_link\('abendatabase_commit_glosry.htm'\) "Glossary Entry") can be triggered there.
    
-   When handling the registration entries in the database tables ARFCSSTATE and ARFCSDATA, note that they are subject to the regular administration rules for a [database LUW](javascript:call_link\('abendatabase_luw_glosry.htm'\) "Glossary Entry"). For example, the database LUW is ended by a [database rollback](javascript:call_link\('abendatabase_rollback_glosry.htm'\) "Glossary Entry"), all registration entries of the current database LUW are deleted.



**📖 Source**: [abapcall_function_background_task.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcall_function_background_task.htm)

### abenrfc_obsolete.htm

> **📖 Official SAP Documentation**: [abenrfc_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) → 

Obsolete Transactional RFC

-   [CALL FUNCTION - IN BACKGROUND TASK](javascript:call_link\('abapcall_function_background_task.htm'\))

Note

[Transactional remote function call (tRFC)](javascript:call_link\('abentrfc_1_glosry.htm'\) "Glossary Entry") and its enhancement, [queued remote function call (qRFC)](javascript:call_link\('abenqueued_remote_function_glosry.htm'\) "Glossary Entry"), have been replaced by [background RFC (bgRFC)](javascript:call_link\('abenbg_remote_function_glosry.htm'\) "Glossary Entry"). It is strongly recommended that bgRFC is used instead of tRFC.

Continue
[CALL FUNCTION - IN BACKGROUND TASK](javascript:call_link\('abapcall_function_background_task.htm'\))



**📖 Source**: [abenrfc_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenrfc_obsolete.htm)

### abenwait_obsolete.htm

> **📖 Official SAP Documentation**: [abenwait_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenwait_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) → 

Obsolete Wait

-   [WAIT UNTIL - Short Form](javascript:call_link\('abapwait_obsolete.htm'\))

Continue
[WAIT UNTIL - Short Form](javascript:call_link\('abapwait_obsolete.htm'\))



**📖 Source**: [abenwait_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenwait_obsolete.htm)

### abapwait_obsolete.htm

> **📖 Official SAP Documentation**: [abapwait_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapwait_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) →  [Obsolete Wait](javascript:call_link\('abenwait_obsolete.htm'\)) → 

WAIT UNTIL - Short Form

[Quick Reference](javascript:call_link\('abapwait_shortref.htm'\))

Obsolete Syntax

WAIT UNTIL [log\_exp](javascript:call_link\('abenlogexp.htm'\)) *\[*UP TO sec SECONDS*\]*.

Effect

This statement works in the same way as

[WAIT FOR ASYNCHRONOUS TASKS](javascript:call_link\('abapwait_until.htm'\)) UNTIL logexp *\[*UP TO sec SECONDS*\]*.

Note

The complete form using FOR ASYNCHRONOUS TASKS should always be used. This addition indicates that an [asynchronous RFC](javascript:call_link\('abenasynchronous_rfc_glosry.htm'\) "Glossary Entry") is expected and distinguishes the statement from [WAIT FOR MESSAGING CHANNELS](javascript:call_link\('abapwait_amc.htm'\)) or [WAIT FOR PUSH CHANNELS](javascript:call_link\('abapwait_apc.htm'\)), which are waiting for messages from [ABAP Messaging Channels](javascript:call_link\('abenabap_messaging_channels_glosry.htm'\) "Glossary Entry") or [ABAP Push Channels](javascript:call_link\('abenabap_push_channels_glosry.htm'\) "Glossary Entry").



**📖 Source**: [abapwait_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapwait_obsolete.htm)

### abenwait_obsolete.htm

> **📖 Official SAP Documentation**: [abenwait_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenwait_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) → 

Obsolete Wait

-   [WAIT UNTIL - Short Form](javascript:call_link\('abapwait_obsolete.htm'\))

Continue
[WAIT UNTIL - Short Form](javascript:call_link\('abapwait_obsolete.htm'\))



**📖 Source**: [abenwait_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenwait_obsolete.htm)

### abenabap_xml_obsolete.htm

> **📖 Official SAP Documentation**: [abenabap_xml_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_xml_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) → 

Obsolete XML Binding

-   [CALL TRANSFORMATION - OBJECTS](javascript:call_link\('abapcall_transformation_objects.htm'\))

Continue
[CALL TRANSFORMATION - OBJECTS](javascript:call_link\('abapcall_transformation_objects.htm'\))



**📖 Source**: [abenabap_xml_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_xml_obsolete.htm)

### abapcall_transformation_objects.htm

> **📖 Official SAP Documentation**: [abapcall_transformation_objects.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcall_transformation_objects.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) →  [Obsolete XML Binding](javascript:call_link\('abenabap_xml_obsolete.htm'\)) → 

CALL TRANSFORMATION - OBJECTS

[Quick Reference](javascript:call_link\('abapcall_transformation_shortref.htm'\))

Obsolete Syntax

... OBJECTS *{*o1 = e1 o2 = e2 ...*}**|*(otab) ...

Effect

This addition of the statement [CALL TRANSFORMATION](javascript:call_link\('abapcall_transformation.htm'\)) can be used to pass object references e1 e2 ... to an XSL transformation as external objects o1 o2 ... to call their methods here.

Instead of using a static parameter list, the objects can be passed dynamically as value pairs in the columns of the internal table otab with the type ABAP\_TRANS\_OBJBIND\_TAB from the [type group](javascript:call_link\('abentype_group_1_glosry.htm'\) "Glossary Entry") ABAP.

Note

The addition OBJECTS is obsolete. External objects are handled like parameters and object references must be passed accordingly with the addition [PARAMETERS](javascript:call_link\('abapcall_transformation.htm'\)).



**📖 Source**: [abapcall_transformation_objects.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcall_transformation_objects.htm)

### abenabap_xml_obsolete.htm

> **📖 Official SAP Documentation**: [abenabap_xml_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_xml_obsolete.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) → 

Obsolete XML Binding

-   [CALL TRANSFORMATION - OBJECTS](javascript:call_link\('abapcall_transformation_objects.htm'\))

Continue
[CALL TRANSFORMATION - OBJECTS](javascript:call_link\('abapcall_transformation_objects.htm'\))



**📖 Source**: [abenabap_xml_obsolete.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_xml_obsolete.htm)

### abenabap_cpic.htm

> **📖 Official SAP Documentation**: [abenabap_cpic.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_cpic.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) → 

CPI-C Interface

This section describes cross-system communications between two ABAP programs as realized using the [COMMUNICATION](javascript:call_link\('abapcommunication.htm'\)) statement.

Note

SDK for CPI-C is no longer supported. The CPI-C libraries and the documentation for programming are no longer delivered. For new programs, SDK and the libraries for [RFC](javascript:call_link\('abenrfc_glosry.htm'\) "Glossary Entry") must be used. The API for CPI-C was retained to support existing programs and for internal technical purposes.

Continue
[COMMUNICATION](javascript:call_link\('abapcommunication.htm'\))



**📖 Source**: [abenabap_cpic.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_cpic.htm)

### abapcommunication.htm

> **📖 Official SAP Documentation**: [abapcommunication.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcommunication.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) →  [CPI-C Interface](javascript:call_link\('abenabap_cpic.htm'\)) → 

COMMUNICATION

[Quick Reference](javascript:call_link\('abapcommunication_shortref.htm'\))

Obsolete Syntax

COMMUNICATION [comstep](javascript:call_link\('abapcommunication_comstep.htm'\)) ID id *\[* [cpic\_options](javascript:call_link\('abapcommunication_options.htm'\))*\]*.

Effect

This statement enables cross-system communication between two ABAP programs, or between an ABAP program and a program written in another programming language. The whole communication process takes place in individual communication steps, which involve repeated execution of the statement COMMUNICATION with the corresponding additions [comstep](javascript:call_link\('abapcommunication_comstep.htm'\)). For both partner programs, communication is based on the [CPI-C](javascript:call_link\('abencpi-c_glosry.htm'\) "Glossary Entry") interface, which has been defined as a communication standard by IBM as a part of the SAA standard. This interface provides the following functions in the form of the CPI-C starter set:

-   Creating, accepting, and closing a connection
    
-   Sending and receiving data
    

Coordination of the individual communication steps, recording any errors that occur in the database table TCPIC and, if necessary, data conversion, take place in the individual programs themselves. The parameters that determined the physical partner system for a connection are administrated in the database table TXCOM.

Once the connection is initialized, the system writes an eight-digit connection number in the data object id. This number can be used to identify individual connections. As standard, 2\*\*16 connections are possible for each calling program. id expects only [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like data types, with a minimum length of eight digits.

After initialization, the connection must be created. Then, in the first connection step, all the necessary administration data is sent to the partner system. The data sent in this connection step must have a specific structure and must be available in an [EBCDIC](javascript:call_link\('abenebcdic_glosry.htm'\) "Glossary Entry") format. The example below shows how a specifically formed structure can be converted into the EBCDIC format. The subsequent response also exists in EBCDIC format. After this initial connection has been established, data can be transferred without the need for further conversion.

In communications, the [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") in the called program must not be changed. Screen output is ignored or, in the case of list output to the SAP spool system, is diverted if the statement NEW-PAGE is entered beforehand. [Messages](javascript:call_link\('abenmessage_glosry.htm'\) "Glossary Entry") of types I, S, and W are ignored, while types A and E cause the program to terminate.

Notes

-   The statement COMMUNICATION is not supported in classes and should not appear in programs anymore, since support for the direct programming of the CPI-C interface has largely been discontinued. Instead, only the [RFC interface](javascript:call_link\('abenrfc_interface_glosry.htm'\) "Glossary Entry") is to be used for communication between programs. However, the function of the statement is maintained for supporting existing programs and for internal purposes.
    
-   The EBCDIC format is used in the first connection step because the CPI-C interface was mainly used for connections to R/2 systems.
    

Example

In the simplest case, an ABAP program calls a subroutine in an ABAP program of another [AS ABAP](javascript:call_link\('abensap_nw_abap_glosry.htm'\) "Glossary Entry"). To enable this, the calling program must register on the other system by specifying the type of CPI-C service, the logon data, the programs and subroutines, and the type of error handling. The registration is performed by sending a specific structure to the other system in EBCDIC format.

The following example shows a schematic representation of the communication between two ABAP programs P1 and P2 without querying return values. The calling program P1 first creates the connection and sends a field connect\_xstr that contains the content of the connect structure converted into EBCDIC format, with the necessary data. After the connection is confirmed by P2, P1 sends the actual, unconverted application data in the buffer b. When this data has been received, P2 sends a confirmation to P1. The connection from P1 is then closed again and the content of the buffer ("Answer") is produced as output.

PROGRAM p1.
DATA: d    TYPE c LENGTH 8,
      id   TYPE c LENGTH 8,
      b TYPE c LENGTH 10,
      len  TYPE x LENGTH 4,
      dat  TYPE xstring,
      stat TYPE xstring,
      BEGIN OF connect,
        header   TYPE c LENGTH 12 VALUE 'CONNCPIC1',
        client   TYPE c LENGTH  3 VALUE '001',
        user     TYPE c LENGTH 12 VALUE 'BONDJ',
        password TYPE c LENGTH  8 VALUE '007',
        language TYPE c LENGTH  1 VALUE 'E',
        corr     TYPE c LENGTH  1 VALUE ' ',
        program  TYPE c LENGTH  8 VALUE 'P2',
        routine  TYPE c LENGTH 30 VALUE 'CPIC\_START',
      END OF connect,
      connect\_str  TYPE c LENGTH 75,
      connect\_xstr TYPE x LENGTH 75,
      connect\_ret  TYPE x LENGTH 75,
      converter TYPE REF TO cl\_abap\_conv\_out\_ce.
connect\_str = connect.
converter = cl\_abap\_conv\_out\_ce=>create( encoding = '0101' ).
converter->write( data = connect\_str ).
connect\_xstr = converter->get\_buffer( ).
d = ...
COMMUNICATION INIT
  DESTINATION d
  ID id.
COMMUNICATION ALLOCATE
  ID id.
COMMUNICATION SEND
  BUFFER connect\_xstr
  ID id.
                        PROGRAM p2.
                        DATA:
                          id   TYPE c LENGTH 8,
                          b TYPE c LENGTH 10,
                          len  TYPE x LENGTH 4,
                          dat  TYPE xstring,
                          stat TYPE xstring.
                        FORM cpic\_start.
                          COMMUNICATION ACCEPT
                            ID id.
COMMUNICATION RECEIVE
  BUFFER     connect\_ret
  DATAINFO   dat
  STATUSINFO stat
  RECEIVED   len
  ID id.
b = 'Request'.
COMMUNICATION SEND
  BUFFER b
  ID id.
                          COMMUNICATION RECEIVE
                            BUFFER     b
                            RECEIVED   len
                            DATAINFO   dat
                            STATUSINFO stat
                            ID         id.
                          IF b = 'Request'.
                            b = 'Answer'.
                          ENDIF.
                          COMMUNICATION SEND
                            BUFFER     b
                            ID         id.
                        ENDFORM.
CLEAR b.
COMMUNICATION RECEIVE
  BUFFER     b
  DATAINFO   dat
  STATUSINFO stat
  RECEIVED   len
  ID         id.
WRITE / b.
COMMUNICATION DEALLOCATE ID id.

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Non-Handleable Exceptions

-   Cause: No authorization to accept a CPIC connection.
    Runtime error: COMMUNICATION\_ACCEPT\_NO\_AUTH
    
-   Cause: No authorization to open a CPIC connection.
    Runtime error: COMMUNICATION\_INIT\_NO\_AUTH
    

Continue
[COMMUNICATION - comstep](javascript:call_link\('abapcommunication_comstep.htm'\))
[COMMUNICATION - cpic\_options](javascript:call_link\('abapcommunication_options.htm'\))



**📖 Source**: [abapcommunication.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcommunication.htm)

### abapcommunication_comstep.htm

> **📖 Official SAP Documentation**: [abapcommunication_comstep.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcommunication_comstep.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) →  [CPI-C Interface](javascript:call_link\('abenabap_cpic.htm'\)) →  [COMMUNICATION](javascript:call_link\('abapcommunication.htm'\)) → 

COMMUNICATION - comstep

[Quick Reference](javascript:call_link\('abapcommunication_shortref.htm'\))

Obsolete Syntax

... *{*INIT DESTINATION dest*}*
  *|* ALLOCATE
  *|* ACCEPT
  *|* *{*SEND BUFFER buf*}*
  *|* *{*RECEIVE BUFFER buf DATAINFO dat STATUSINFO stat*}*
  *|* DEALLOCATE ...

Alternatives:

[1\. ... INIT DESTINATION dest](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... ALLOCATE](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... ACCEPT](#!ABAP_ALTERNATIVE_3@3@)
[4\. ... SEND BUFFER buf](#!ABAP_ALTERNATIVE_4@4@)
[5\. ... RECEIVE BUFFER buf DATAINFO dat STATUSINFO stat](#!ABAP_ALTERNATIVE_5@5@)
[6\. ... DEALLOCATE](#!ABAP_ALTERNATIVE_6@6@)

Effect

There are different alternatives for specifying comstep, each of which is responsible for a connection step.

Alternative 1

... INIT DESTINATION  dest

Effect

The connection between the programs initialized by specifying dest. dest expects a [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like data object of the length 8 and, when executing the statement, the data object contains a value from the column SDEST of the database table TXCOM.

On initialization, the system automatically executes an authorization check on the [authorization object](javascript:call_link\('abenauthorization_object_glosry.htm'\) "Glossary Entry") S\_CPIC. The authorization can be checked before the connection is established using the function module AUTHORITY\_CHECK\_CPIC.

Alternative 2

... ALLOCATE

Effect

Establishes a connection to the partner identified in the previous addition DESTINATION. At the same time, a start request is passed to the partner, if it is a program.

Alternative 3

... ACCEPT

Effect

This addition can be used to accept the established connection in a called partner program. After authentication, the called program is in receive status.

Alternative 4

... SEND BUFFER buf

Effect

Sends data to the partner program. A data object can be specified for buf, for which all [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") elementary types are permitted and the memory requirement of 32000 bytes cannot be exceeded. If the statement COMMUNICATION is executed, the content of buf is passed to the partner program.

Notes

-   A connection step opened with SEND must be followed by a connection step opened with RECEIVE.
    
-   Information loss, for example as a result of different number formats between the communication partners, is avoided if only character-like types are used for transferring the data. Furthermore, the data is only transferred completely if the sending and receiving buffers have the same structure and length.
    

Alternative 5

... RECEIVE BUFFER buf DATAINFO dat STATUSINFO stat

Effect

Receives data from the partner program. A data object can be specified for buf, for which all flat elementary types are permitted and the memory requirement of 32000 bytes cannot be exceeded. On execution of the statement COMMUNICATION, the content of buf is received by the partner program.

After the execution of the statement, the data object dat contains information about whether the data is sent completely and the content of the data object stat indicates whether the current program is in send or receive mode. Only byte-like data objects are allowed for dat and stat, the length should not be less than 4 bytes. The encoding for the values in dat and stat can be extracted from the [include program](javascript:call_link\('abeninclude_program_glosry.htm'\) "Glossary Entry") RSCPICDF. Here, data objects with a descriptive name and [start values](javascript:call_link\('abenstart_value_glosry.htm'\) "Glossary Entry") are declared which can be compared with dat and stat.

Note

A connection step opened with RECEIVE must be followed by a connection step opened with SEND.

Alternative 6

... DEALLOCATE

Effect

The connection is terminated and all memory areas are released.



**📖 Source**: [abapcommunication_comstep.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcommunication_comstep.htm)

### abapcommunication_options.htm

> **📖 Official SAP Documentation**: [abapcommunication_options.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcommunication_options.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) →  [CPI-C Interface](javascript:call_link\('abenabap_cpic.htm'\)) →  [COMMUNICATION](javascript:call_link\('abapcommunication.htm'\)) → 

COMMUNICATION - cpic\_options

[Quick Reference](javascript:call_link\('abapcommunication_shortref.htm'\))

Obsolete Syntax

... *\[*RETURNCODE rc*\]*
    *\[*LENGTH leng*\]*
    *\[*RECEIVED rec*\]*
    *\[*HOLD*\]*.

Extras:

[1\. ... RETURNCODE  rc](#!ABAP_ADDITION_1@1@)
[2\. ... LENGTH leng](#!ABAP_ADDITION_2@2@)
[3\. ... RECEIVED rec](#!ABAP_ADDITION_3@3@)
[4\. ... HOLD](#!ABAP_ADDITION_4@4@)

Effect

Additional additions for the statement COMMUNICATION.

Addition 1

... RETURNCODE  rc

Effect

This addition can be specified for any communication steps and receives the return code in rc. rc expects the data type i. The meaning of the return codes is encoded in the [include program](javascript:call_link\('abeninclude_program_glosry.htm'\) "Glossary Entry") RSCPICDF. Here, data objects with descriptive names and [start values](javascript:call_link\('abenstart_value_glosry.htm'\) "Glossary Entry") are declared and can be compared with rc. The following table contains a list of possible return codes.

rc

Data Object from RSCPICDF

0

CM\_OK

1

CM\_ALLOCATE\_FAILURE\_NO\_RETRY

2

CM\_ALLOCATE\_FAILURE\_RETRY

3

CM\_CONVERSATION\_TYPE\_MISMATCH

6

CM\_SECURITY\_NOT\_VALID

8

CM\_SYNC\_LVL\_NOT\_SUPPORTED\_PGM

9

CM\_TPN\_NOT\_RECOGNIZED

10

CM\_TP\_NOT\_AVAILABLE\_NO\_RETRY

11

CM\_TP\_NOT\_AVAILABLE\_RETRY

12

CM\_DEALLOCATED\_ABEND

13

CM\_DEALLOCATED\_NORMAL

14

CM\_PARAMETER\_ERROR

15

CM\_PRODUCT\_SPECIFIC\_ERROR

16

CM\_PROGRAM\_ERROR\_NO\_TRUNC

18

CM\_PROGRAM\_ERROR\_NO\_TRUNC

19

CM\_PROGRAM\_ERROR\_TRUNC

26

CM\_RESOURCE\_FAILURE\_NO\_RETRY

27

CM\_RESOURCE\_FAILURE\_RETRY

28

CM\_UNSUCCESSFUL

The same return codes are also written to the system field sy-subrc.

Addition 2

... LENGTH leng

Effect

This addition can only be specified in the communication steps SEND and RECEIVE. As a result, the data buffer buffer is only sent or received in the length leng. The length leng expects a data object of the data type i.

Addition 3

... RECEIVED rec

Effect

This addition can only be specified for the communication step RECEIVE. The data object rec contains the number of bytes received by the partner program. Only byte-like data objects of length 4 are allowed for rec.

Addition 4

... HOLD

Effect

This addition can only be specified for the communication step RECEIVE. It prevents the [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") being changed when receiving data to avoid the possible loss of the [database cursor](javascript:call_link\('abendatabase_cursor_glosry.htm'\) "Glossary Entry"). In this case, the current work process waits until all data has been received.



**📖 Source**: [abapcommunication_options.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcommunication_options.htm)

### abapcommunication.htm

> **📖 Official SAP Documentation**: [abapcommunication.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcommunication.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) →  [CPI-C Interface](javascript:call_link\('abenabap_cpic.htm'\)) → 

COMMUNICATION

[Quick Reference](javascript:call_link\('abapcommunication_shortref.htm'\))

Obsolete Syntax

COMMUNICATION [comstep](javascript:call_link\('abapcommunication_comstep.htm'\)) ID id *\[* [cpic\_options](javascript:call_link\('abapcommunication_options.htm'\))*\]*.

Effect

This statement enables cross-system communication between two ABAP programs, or between an ABAP program and a program written in another programming language. The whole communication process takes place in individual communication steps, which involve repeated execution of the statement COMMUNICATION with the corresponding additions [comstep](javascript:call_link\('abapcommunication_comstep.htm'\)). For both partner programs, communication is based on the [CPI-C](javascript:call_link\('abencpi-c_glosry.htm'\) "Glossary Entry") interface, which has been defined as a communication standard by IBM as a part of the SAA standard. This interface provides the following functions in the form of the CPI-C starter set:

-   Creating, accepting, and closing a connection
    
-   Sending and receiving data
    

Coordination of the individual communication steps, recording any errors that occur in the database table TCPIC and, if necessary, data conversion, take place in the individual programs themselves. The parameters that determined the physical partner system for a connection are administrated in the database table TXCOM.

Once the connection is initialized, the system writes an eight-digit connection number in the data object id. This number can be used to identify individual connections. As standard, 2\*\*16 connections are possible for each calling program. id expects only [flat](javascript:call_link\('abenflat_glosry.htm'\) "Glossary Entry") character-like data types, with a minimum length of eight digits.

After initialization, the connection must be created. Then, in the first connection step, all the necessary administration data is sent to the partner system. The data sent in this connection step must have a specific structure and must be available in an [EBCDIC](javascript:call_link\('abenebcdic_glosry.htm'\) "Glossary Entry") format. The example below shows how a specifically formed structure can be converted into the EBCDIC format. The subsequent response also exists in EBCDIC format. After this initial connection has been established, data can be transferred without the need for further conversion.

In communications, the [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") in the called program must not be changed. Screen output is ignored or, in the case of list output to the SAP spool system, is diverted if the statement NEW-PAGE is entered beforehand. [Messages](javascript:call_link\('abenmessage_glosry.htm'\) "Glossary Entry") of types I, S, and W are ignored, while types A and E cause the program to terminate.

Notes

-   The statement COMMUNICATION is not supported in classes and should not appear in programs anymore, since support for the direct programming of the CPI-C interface has largely been discontinued. Instead, only the [RFC interface](javascript:call_link\('abenrfc_interface_glosry.htm'\) "Glossary Entry") is to be used for communication between programs. However, the function of the statement is maintained for supporting existing programs and for internal purposes.
    
-   The EBCDIC format is used in the first connection step because the CPI-C interface was mainly used for connections to R/2 systems.
    

Example

In the simplest case, an ABAP program calls a subroutine in an ABAP program of another [AS ABAP](javascript:call_link\('abensap_nw_abap_glosry.htm'\) "Glossary Entry"). To enable this, the calling program must register on the other system by specifying the type of CPI-C service, the logon data, the programs and subroutines, and the type of error handling. The registration is performed by sending a specific structure to the other system in EBCDIC format.

The following example shows a schematic representation of the communication between two ABAP programs P1 and P2 without querying return values. The calling program P1 first creates the connection and sends a field connect\_xstr that contains the content of the connect structure converted into EBCDIC format, with the necessary data. After the connection is confirmed by P2, P1 sends the actual, unconverted application data in the buffer b. When this data has been received, P2 sends a confirmation to P1. The connection from P1 is then closed again and the content of the buffer ("Answer") is produced as output.

PROGRAM p1.
DATA: d    TYPE c LENGTH 8,
      id   TYPE c LENGTH 8,
      b TYPE c LENGTH 10,
      len  TYPE x LENGTH 4,
      dat  TYPE xstring,
      stat TYPE xstring,
      BEGIN OF connect,
        header   TYPE c LENGTH 12 VALUE 'CONNCPIC1',
        client   TYPE c LENGTH  3 VALUE '001',
        user     TYPE c LENGTH 12 VALUE 'BONDJ',
        password TYPE c LENGTH  8 VALUE '007',
        language TYPE c LENGTH  1 VALUE 'E',
        corr     TYPE c LENGTH  1 VALUE ' ',
        program  TYPE c LENGTH  8 VALUE 'P2',
        routine  TYPE c LENGTH 30 VALUE 'CPIC\_START',
      END OF connect,
      connect\_str  TYPE c LENGTH 75,
      connect\_xstr TYPE x LENGTH 75,
      connect\_ret  TYPE x LENGTH 75,
      converter TYPE REF TO cl\_abap\_conv\_out\_ce.
connect\_str = connect.
converter = cl\_abap\_conv\_out\_ce=>create( encoding = '0101' ).
converter->write( data = connect\_str ).
connect\_xstr = converter->get\_buffer( ).
d = ...
COMMUNICATION INIT
  DESTINATION d
  ID id.
COMMUNICATION ALLOCATE
  ID id.
COMMUNICATION SEND
  BUFFER connect\_xstr
  ID id.
                        PROGRAM p2.
                        DATA:
                          id   TYPE c LENGTH 8,
                          b TYPE c LENGTH 10,
                          len  TYPE x LENGTH 4,
                          dat  TYPE xstring,
                          stat TYPE xstring.
                        FORM cpic\_start.
                          COMMUNICATION ACCEPT
                            ID id.
COMMUNICATION RECEIVE
  BUFFER     connect\_ret
  DATAINFO   dat
  STATUSINFO stat
  RECEIVED   len
  ID id.
b = 'Request'.
COMMUNICATION SEND
  BUFFER b
  ID id.
                          COMMUNICATION RECEIVE
                            BUFFER     b
                            RECEIVED   len
                            DATAINFO   dat
                            STATUSINFO stat
                            ID         id.
                          IF b = 'Request'.
                            b = 'Answer'.
                          ENDIF.
                          COMMUNICATION SEND
                            BUFFER     b
                            ID         id.
                        ENDFORM.
CLEAR b.
COMMUNICATION RECEIVE
  BUFFER     b
  DATAINFO   dat
  STATUSINFO stat
  RECEIVED   len
  ID         id.
WRITE / b.
COMMUNICATION DEALLOCATE ID id.

[Exceptions](javascript:call_link\('abenabap_language_exceptions.htm'\))

Non-Handleable Exceptions

-   Cause: No authorization to accept a CPIC connection.
    Runtime error: COMMUNICATION\_ACCEPT\_NO\_AUTH
    
-   Cause: No authorization to open a CPIC connection.
    Runtime error: COMMUNICATION\_INIT\_NO\_AUTH
    

Continue
[COMMUNICATION - comstep](javascript:call_link\('abapcommunication_comstep.htm'\))
[COMMUNICATION - cpic\_options](javascript:call_link\('abapcommunication_options.htm'\))



**📖 Source**: [abapcommunication.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abapcommunication.htm)

### abenabap_cpic.htm

> **📖 Official SAP Documentation**: [abenabap_cpic.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_cpic.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) → 

CPI-C Interface

This section describes cross-system communications between two ABAP programs as realized using the [COMMUNICATION](javascript:call_link\('abapcommunication.htm'\)) statement.

Note

SDK for CPI-C is no longer supported. The CPI-C libraries and the documentation for programming are no longer delivered. For new programs, SDK and the libraries for [RFC](javascript:call_link\('abenrfc_glosry.htm'\) "Glossary Entry") must be used. The API for CPI-C was retained to support existing programs and for internal technical purposes.

Continue
[COMMUNICATION](javascript:call_link\('abapcommunication.htm'\))



**📖 Source**: [abenabap_cpic.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_cpic.htm)

### abenabap_java_script.htm

> **📖 Official SAP Documentation**: [abenabap_java_script.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_java_script.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP − Reference](javascript:call_link\('abenabap_reference.htm'\)) →  [Obsolete Language Elements](javascript:call_link\('abenabap_obsolete.htm'\)) →  [Obsolete Data and Communication Interfaces](javascript:call_link\('abenextern_obsolete.htm'\)) → 

ABAP and JavaScript

In the kernel of an AS ABAP, a JavaScript (JS) Engine is integrated, in which execute JavaScript programs can be executed either in normal or in debugging mode (server-side scripting). The JavaScript (JS) Engine used supports JavaScript Version 1.5. Proxies can be used to bind script variables to data objects in ABAP programs.

The class CL\_JAVA\_SCRIPT realizes an API, which can be used in ABAP programs, for the JavaScript (JS) Engine implemented in the kernel. This class encapsulates the JavaScript C Engine API and makes methods and attributes available to the ABAP programmer to perform JavaScript programs.

Note

Support for the binding of JavaScript to ABAP is scheduled to be stopped. This means that the class CL\_JAVA\_SCRIPT can no longer be used.

Example

The program DEMO\_JAVA\_SCRIPT\_MINI\_EDITOR is an example of a minimal JavaScript editor in which JavaScript programs can be edited, executed, and tested. This program was created using ABAP methods only and uses the class CL\_JAVA\_SCRIPT.


---


## ABAP Keyword Documentation / ABAP Programming Guidelines / Architecture / Object-Oriented Programming

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP Programming Guidelines / Architecture / Object-Oriented Programming

Included pages: 8



**📖 Source**: [abenabap_java_script.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenabap_java_script.htm)

### abenobj_oriented_guidl.htm

> **📖 Official SAP Documentation**: [abenobj_oriented_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenobj_oriented_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) → 

Object-Oriented Programming

Achieving an optimal object-oriented design is not an easy task and this is not the subject of these programming guidelines. It is definitely worth consulting the relevant literature for this topic. The rules below are limited to basic recommendations (for making source codes easier to understand and maintain) and ABAP specifics on working with global and local classes.

Developers who have experience with object-oriented development in other programming languages should be aware of the differences between ABAP Objects and Java:

-   In Java, all superior data objects (especially container variables such as strings) are modeled using classes. By contrast, ABAP provides very powerful, built-in types. Besides the built-in ABAP strings, internal tables are also provided that are used for structured data storage. These tables represent the most powerful ABAP type. Therefore, it is generally not beneficial to implement own container types using ABAP classes.

-   Java reaches a high processing speed for methods, by using optimizations and JIT compilation. In ABAP, however, the high processing speed is primarily attained using very powerful and complex individual statements. This is another reason why implementing own container classes is usually not beneficial. Direct access to a suitable internal table, for example, is always faster than handwritten access logic in ABAP.

Of course, you can transfer algorithms and a general class structure to ABAP, from an application written in another object-oriented programming language. However, the greater the depth, the greater the differences. Therefore, you need to make appropriate modifications to map a detailed design in a different language to ABAP Objects.

-   [Encapsulation](javascript:call_link\('abenencapsulation_guidl.htm'\) "Guideline")

-   [Modularization](javascript:call_link\('abenmodularization_guidl.htm'\) "Guideline")

-   [Static Classes and Singletons](javascript:call_link\('abenstatic_class_singleton_guidl.htm'\) "Guideline")

-   [Inheritance](javascript:call_link\('abeninheritance_guidl.htm'\) "Guideline")

-   [Class References and Interface References](javascript:call_link\('abenclass_ref_interf_ref_guidl.htm'\) "Guideline")

-   [Local Types for Global Classes](javascript:call_link\('abenlocal_type_glob_class_guidl.htm'\) "Guideline")

-   [Instance Constructor](javascript:call_link\('abeninstance_constructor_guidl.htm'\) "Guideline")

Continue
[Encapsulation](javascript:call_link\('abenencapsulation_guidl.htm'\))
[Modularization](javascript:call_link\('abenmodularization_guidl.htm'\))
[Static Classes and Singletons](javascript:call_link\('abenstatic_class_singleton_guidl.htm'\))
[Inheritance](javascript:call_link\('abeninheritance_guidl.htm'\))
[Class References and Interface References](javascript:call_link\('abenclass_ref_interf_ref_guidl.htm'\))
[Local Types for Global Classes](javascript:call_link\('abenlocal_type_glob_class_guidl.htm'\))
[Instance Constructor](javascript:call_link\('abeninstance_constructor_guidl.htm'\))



**📖 Source**: [abenobj_oriented_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenobj_oriented_guidl.htm)

### abenencapsulation_guidl.htm

> **📖 Official SAP Documentation**: [abenencapsulation_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenencapsulation_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) →  [Object-Oriented Programming](javascript:call_link\('abenobj_oriented_guidl.htm'\)) → 

Encapsulation

Background

A program that is created based on the procedural programming model and that includes many procedures and global variables is usually difficult to understand because the numerous possible interdependencies of these publicly accessible variables and procedures are difficult to comprehend . The object-oriented approach solves this particular problem by providing visibility sections that are not public. This enables readers who want to get an overview of how the software functions to restrict the overview to the public interfaces of the classes involved. The non-public visibility sections only contain details of the implementation that are not important for a view from the outside.

Of course, this clear overview benefit is only realized in places where the developer makes use of the non-public visibility sections. The same applies to non-public object creation and final classes, where it is becomes immediately clear whether objects can also be generated outside of the class or whether derived classes can exist.

For the development or the design of an application, it is useful to encapsulate as restrictively as possible initially, and to undo the encapsulation only where required.

Rule

Exploit the benefits of encapsulation

Utilize the encapsulation options provided in the form of non-public visibility sections, non-public object creation, and final classes as much as possible. The use of units that are encapsulated in such a way should preferably be free of side effects.

Details

This simple rule provides practical access to object-oriented programming that produces programs that are more robust and more easily maintainable than if you use procedural ABAP, and without a prolonged object-oriented design phase. To use encapsulation appropriately, do the following:

-   Keep the number of public components of a class as small as possible (components that may be private or protected should therefore be created in the corresponding visibility section as well).

-   Declare public attributes only as READ-ONLY.

-   Consider the private instantiation of classes.

-   Mark classes that are not intended as superclasses as [FINAL](javascript:call_link\('abeninheritance_guidl.htm'\) "Guideline").

Conversely, within an encapsulated unit, that is, within a class, you should avoid accessing more global data directly. Within methods, you should generally modify attributes of the class only. Performing writes to global data outside the class is not recommended. Accessing data in this way should only be done using specially marked methods, if at all. The use of methods of a class should not evoke any side effects outside the class itself.



**📖 Source**: [abenencapsulation_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenencapsulation_guidl.htm)

### abenmodularization_guidl.htm

> **📖 Official SAP Documentation**: [abenmodularization_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmodularization_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) →  [Object-Oriented Programming](javascript:call_link\('abenobj_oriented_guidl.htm'\)) → 

Modularization

Background

The main programming model that was propagated before the implementation of ABAP Objects was structured programming:

-   In this model, the programs are split into procedures as appropriate.

-   Sequences, branches, and loops are the only control structures permitted.

The implementation of object-oriented programming languages such as ABAP Objects does not make structured programming obsolete. Object-oriented programming is based on the structured programming and enhances and supplements it.

With regard to ABAP, you must note that ABAP is still a programming language of the fourth generation (4GL) that has been developed especially for application programming in the SAP environment, that is, for mass data processing in business applications. Therefore, ABAP includes significantly more language elements than an elementary programming language in which the more complex functions are usually stored in libraries. This ranges from simple statements for string processing, which are provided as methods of string classes in other object-oriented languages such as Java, to the processing of complex mass data objects, such as internal tables, to very complex statements for operating interfaces such as ABAP SQL or for calling data transformations (XML), for which other languages have entire class hierarchies.

As already [mentioned](javascript:call_link\('abenobj_oriented_guidl.htm'\) "Guideline"), the performance of the ABAP language is therefore optimized mainly for the execution of its complex statements for mass data processing and less for the individual method call.

Rule

Modularize rather than atomize

Modularize your program in classes, but not to the extent that there is an individual method for every trivial function. Methods that consist of only one or just a few statements should be an exception in ABAP and not the rule.

Details

You should only use [methods of ABAP Objects](javascript:call_link\('abenabap_obj_progr_model_guidl.htm'\) "Guideline") for the implementation of functions; there are very good reasons for this. But ABAP remains ABAP, and the good reasons for using a well-structured program are not invalidated by the implementation of ABAP Objects. Indeed, the ABAP language elements proven and tested in so many application cases are still valid today, are undergoing continuously development, and should be used in their present form in ABAP Objects as well.

A well-structured classic ABAP program, for instance a function group that fulfills a specific task and is modularized using subroutines, should therefore be transferable to a class without any major changes to the implementation, while being provided with all the additional benefits of ABAP Objects.

However, the modularization at the level of a few single statements is and will remain untypical for ABAP. On the one hand this is because of performance reasons, because the costs for the method call must remain low in comparison to the costs for executing the implementation. For example, instead of providing the get\_attribute methods typical for other object-oriented languages that only set their return value to the value of an attribute attribute, you should use public READ-ONLY attributes in ABAP. (If reads on an attribute are associated with further actions, for example, authorization checks, get\_attribute methods are appropriate of course.) On the other hand, virtually all non-fundamental statements of ABAP (all language elements that do not have any equivalent in an elementary language like Java) already play the same role that the methods of system classes assume in other programming languages. The use of a statement like this corresponds to a method call, and another encapsulation is usually not necessary.

Also, for legibility and maintainability reasons, a method with a [reasonable size](javascript:call_link\('abenproc_volume_guidl.htm'\) "Guideline") is preferable to splitting into atomic units, that is, into methods with only one or two statements.

Exception

Procedures that encapsulate nothing but the call of another procedure are an exception. A single procedure call represents the implementation of an entire procedure. This applies in particular to function modules and subroutines, which can only be created in [exceptional cases](javascript:call_link\('abenabap_obj_progr_model_guidl.htm'\) "Guideline") anyway. They should include exactly one [method call](javascript:call_link\('abenfunct_module_subroutine_guidl.htm'\) "Guideline"), which delegates the implementation to ABAP Objects. In this case, the improved security through the stricter checks in ABAP Objects outweighs the disadvantages of very short procedures.

Bad Example

The following source code shows the rudimentary implementation of a string class in ABAP Objects. The methods of this class each contain only a single statement. A consumer must create objects of the class and call the methods to handle the strings.

CLASS cl\_string DEFINITION PUBLIC.
   PUBLIC SECTION.
     METHODS:
       constructor IMPORTING value        TYPE string OPTIONAL,
       set\_string  IMPORTING value        TYPE string,
       get\_string  RETURNING VALUE(value) TYPE string,
       shift\_left  IMPORTING places       TYPE i,
       shift\_right IMPORTING places       TYPE i,
       ...
    PRIVATE SECTION.
      DATA string TYPE string.
ENDCLASS.

CLASS cl\_string IMPLEMENTATION.
   METHOD constructor.
     string = value.
   ENDMETHOD.
   METHOD set\_string.
     string = value.
   ENDMETHOD.
   METHOD get\_string.
     value = string.
   ENDMETHOD.
   METHOD shift\_left.
     SHIFT string LEFT BY places PLACES.
   ENDMETHOD.
   METHOD shift\_right.
     SHIFT string RIGHT BY places PLACES.
   ENDMETHOD.
   ...
ENDCLASS.
...

CLASS application IMPLEMENTATION.
  ...
   METHOD do\_something.
     DATA string TYPE REF TO cl\_string.
     CREATE OBJECT string EXPORTING value = 'abcde'.
     ...
     string->shift\_left( ... ).
     ...
    ENDMETHOD.
  ...
ENDCLASS.

Good Example

The following source code shows the handling of strings typical to ABAP. A method directly declares a data object of type string and directly uses the corresponding ABAP statements for processing.

CLASS application IMPLEMENTATION.
  ...
   METHOD do\_something.
     DATA string TYPE string.
     ...
     SHIFT string LEFT BY ... PLACES.
     ...
   ENDMETHOD.
  ...
ENDCLASS.

There is a corresponding built-in function for almost every string processing statement. They can also be used in operand positions, negating another reason for the encapsulation of statements in methods. The statement SHIFT LEFT in this example can be replaced as follows, whereas shift\_left is a built-in function:

string = shift\_left( val = string places = ... ).



**📖 Source**: [abenmodularization_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenmodularization_guidl.htm)

### abenstatic_class_singleton_guidl.htm

> **📖 Official SAP Documentation**: [abenstatic_class_singleton_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenstatic_class_singleton_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) →  [Object-Oriented Programming](javascript:call_link\('abenobj_oriented_guidl.htm'\)) → 

Static Classes and Singletons

Background

The classes of ABAP Objects support two types of components:

-   Instance components (instance attributes, instance events and instance methods). You can only address the instance components of a class using instances of the class (objects).

-   Static components (static attributes, static events and static methods). The static components of a class can be addressed using an object and also using the name of the class. This means they can be used independently of a class instance.

A class that only contains static components and no instance components is referred to as a static class. A global static class is loaded once with its class pool into the current [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry"). Like every ABAP program, it cannot be explicitly deleted from the session. The static methods (declared using CLASS-METHODS) of a class cannot be redefined in subclasses.

A singleton is a design pattern where the class has the task of creating objects. The class ensures that only one object exists for every internal session that is made available to consumers.

Rule

Do not use static classes

Use objects instead of static classes. If you do not want multiple instantiation, you can use singletons.

Details

If no real object-oriented design exists that would use the multiple instantiation of classes, for example, this often produces classes that only contain static methods (declared using CLASS-METHODS), when [ABAP Objects](javascript:call_link\('abenabap_obj_progr_model_guidl.htm'\) "Guideline") are used. These methods are then used as simple procedures. However, even if multiple instantiation is not explicitly required, object creation is preferable to the use of static classes, for the reasons listed below. You can use the singleton design pattern to prevent multiple instantiation:

-   Explicit object creation is essential for object-oriented programming. Static classes, however, are implicitly loaded the first time they are used, and the corresponding static constructor — if available — is executed. They are persisted in the memory for as long as the current internal session exists. Therefore, if you use static classes, you cannot actually control the time of initialization. You have no way of releasing the memory occupied by the attributes, as soon as the class function is no longer required.

-   Another important argument against the use of static classes are the limited functions of the static constructor, in comparison to an instance constructor. A static constructor has no parameter interface and cannot propagate any [exceptions](javascript:call_link\('abenerror_handling_guidl.htm'\) "Guideline"). This is why you cannot always respond appropriately to an error situation in the static constructor, which can cause a runtime error in extreme cases. However, the exceptions of an instance constructor can be handled.

-   By using static classes, you restrict your polymorphism options, which are actually provided by object-oriented programming. On the one hand, you cannot redefine static methods. On the other hand, access is not possible using reference variables (the other “pillar” of polymorphism). However, it is worth keeping the option of polymorphism open:

-   Even if you initially do not plan to overwrite the behavior of a method later on using inheritance or redefinition, this is a request that frequently arises in the course of the further development.

-   When implementing unit tests with ABAP Unit, redefining the behavior of certain methods, to resolve problematic dependencies, is often unavoidable.

To keep the option of redefinition open, you should always use instance methods instead of static methods.

You can express the retrieval of a singleton object and the subsequent call of an instance method, by using the very compact form of a chained method call:

cl\_singleton=>get\_instance( )->do\_something( ).

Since an additional object reference variable and an additional factory call are omitted, there are no aesthetic disadvantages related to the use of a singleton design pattern.

Exception

Classes that only cover trivial functions can still be implemented as static classes. Here you must accurately assess whether one of the previously mentioned aspects has any effect. The need for a class constructor can be an indicator here. Once a static class requires a nontrivial class constructor to provide the required functions, you should use objects instead.

Bad Example

The following source code shows a static class with purely static methods and how one of these methods is used. In general, it is not immediately obvious from the source code whether the method call also calls the static constructor or whether this has already happened earlier (following a simple attribute access, for example).

CLASS static\_class DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: class\_constructor,
                   meth1,
                   meth2,
                   ...
ENDCLASS.
...
static\_class=>meth1( ).
...

Good Example

The following source code shows an implementation of the singleton design pattern. A static method allows access to the only object of the class.

CLASS singleton\_class DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    CLASS-METHODS get\_instance
    RETURNING VALUE(r\_instance) TYPE REF TO singleton\_class
    RAISING cx\_some\_failure.
  METHODS constructor
    RAISING cx\_some\_failure.
  METHODS: meth1,
           meth2.
           ...
  PRIVATE SECTION.
    CLASS-DATA instance TYPE REF TO singleton\_class.
ENDCLASS.

CLASS singleton\_class IMPLEMENTATION.
  METHOD get\_instance.
    IF instance IS NOT BOUND.
      CREATE OBJECT instance.
    ENDIF.
    r\_instance = instance.
  ENDMETHOD.
  ...
ENDCLASS.

...
  TRY.
     singleton\_class=>get\_instance( )->meth1( ).
   CATCH cx\_some\_failure.
     ...
  ENDTRY.

In the above example, the get\_instance method is used to return the object reference to the object created with the first call. Therefore, this example would appear to violate the rule [modularize rather than atomize](javascript:call_link\('abenmodularization_guidl.htm'\) "Guideline"). This rule states that no method should be created in ABAP that only returns the value of an attribute. However, this objection is not justified here, because the main task of the get\_instance method is to enable the object consumer to control the time of object creation. This is necessary to enable the consumer to respond (in the usual way) to any exceptional situation during the object creation process.

In special cases, where object creation is performed without parameters and is always successful, you can omit the get\_instance method and publish the object reference using a READ-ONLY attribute. In this case, the object is created within the static constructor. Therefore, this approach is still afflicted with some of the problems of static classes described in other sections.



**📖 Source**: [abenstatic_class_singleton_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenstatic_class_singleton_guidl.htm)

### abeninheritance_guidl.htm

> **📖 Official SAP Documentation**: [abeninheritance_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninheritance_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) →  [Object-Oriented Programming](javascript:call_link\('abenobj_oriented_guidl.htm'\)) → 

Inheritance

Background

Inheritance is the method by which subclasses are derived from a superclass while inheriting the components of the superclass. A subclass can be made more specific by declaring new components and redefining instance methods. ABAP Objects supports simple inheritance, in which a class can have multiple subclasses but only one direct superclass. (Despite this, the interface concept does enable something like multiple inheritance to take place, at least with respect to attributes and method declarations. Method implementations, on the other hand, are not inherited when an interface is included.) This creates an inheritance hierarchy in an inheritance tree, with a unique path running from each subclass to a root class. In ABAP Objects, all classes are subclasses of the predefined abstract root class object. Final classes (classes defined using the addition FINAL) close the bottom of a path in the inheritance tree.

Rule

Avoid using deep inheritance hierarchies

Avoid using deep inheritance hierarchies, since they are often difficult to maintain.

Details

Deep inheritance hierarchies are examples of successful reuse, but are also the source of maintenance problems, due to the complexity inherent in the large number of classes involved.

-   The behavior of classes deep down in the inheritance hierarchy is difficult to predict, since they potentially inherit from a large number of methods.

-   Classes with a lot of subclasses exert great influence on the system as a whole, making the consequences of modifications to a superclass hard to predict.

-   A large number of subclasses may also indicate an unsuitable level of abstraction.

To prevent unintended reuse of your classes by inheritance, we recommend that you use final classes to close the paths of inheritance trees.

Note

If your main aim is to exploit the possibilities of polymorphism, interfaces are often a preferable solution to inheritance. If all you want to do is use interfaces, method interfaces should be used instead of abstract classes. These can be used to create composite interfaces. In ABAP, on the other hand, a composite interface is impossible due to the nature of simple inheritance using classes.



**📖 Source**: [abeninheritance_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninheritance_guidl.htm)

### abenclass_ref_interf_ref_guidl.htm

> **📖 Official SAP Documentation**: [abenclass_ref_interf_ref_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenclass_ref_interf_ref_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) →  [Object-Oriented Programming](javascript:call_link\('abenobj_oriented_guidl.htm'\)) → 

Class References and Interface References

Background

Interface components in objects can be addressed using a class reference variable or an interface reference variable. If you use a class reference variable, the interface component is addressed using the name of the interface and the interface component selector (~). If you use a suitable interface reference variable, the component is addressed directly using its name.

Rule

Address interface components using interface reference variables

From outside a class, only access its interface components using a relevant interface reference variable; do not use the interface component selector (~).

Details

Accessing interface components externally using an interface reference variable makes code easier to understand because it is clear that the user of the class is interested in exactly the aspect provided by the interface. Accessing interface components using a class reference variable, on the other hand, suggests that components are used that are not provided by an interface. As a rule, only use the interface component selector within classes and interfaces, to address the interfaces included there. If you want to provide an interface component of an included interface as a separate component, you can declare an alias name by using ALIASES.

Bad Example

The following source code shows an interface method call using a class reference variable and the interface component selector (~); this is not recommended, as mentioned in the rule above.

CLASS cl\_class DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if\_intf.
  ...
ENDCLASS.
...
    DATA cref TYPE REF TO cl\_class.
    ...
    cref->if\_intf~meth( ).
    ...

Good Example

The following source code shows the method call from the above example, but using an interface reference variable. Instead of cref->if\_intf~meth, iref->meth is used to express that components of a class are accessed that are on the same hierarchy level as all public components, but in another part of the public interface.

CLASS cl\_class DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if\_intf.
     ...
ENDCLASS.
...
     DATA iref TYPE REF TO if\_intf.
     ...
     iref->meth( ).
     ...



**📖 Source**: [abenclass_ref_interf_ref_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenclass_ref_interf_ref_guidl.htm)

### abenlocal_type_glob_class_guidl.htm

> **📖 Official SAP Documentation**: [abenlocal_type_glob_class_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlocal_type_glob_class_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) →  [Object-Oriented Programming](javascript:call_link\('abenobj_oriented_guidl.htm'\)) → 

Local Types for Global Classes

Background

Within class pools, as in virtually any other ABAP program, data types, local interfaces, and local classes can be defined to ensure a better structure of the implementation of the global class. From a technical point of view, these optional declaration parts, together with the declaration part of the global class, form the global declaration part of the [class pool](javascript:call_link\('abenglobal_declar_guidl.htm'\) "Guideline").

These local declarations in a class pool are invisible outside the class pool, which means they can only be used as followed:

-   In the private visibility section (PRIVATE SECTION) of the declarations in the global class

-   Within the method implementations in the global class

These two usage types have different technical visibility requirements because friends of a global class have access to its private visibility section. Local type declarations that are used in the PRIVATE SECTION must therefore be accessible for any possible friends of the class, whereas those type declarations that are only used within the method implementations are completely meaningless for other classes.

In general, local classes consist of the declaration part and the associated method implementations. These are invisible to the friends of the global class and have thus technically the same visibility requirements as local type declarations that are only used within the implementation.

Local data types, interfaces, and classes within a class pool are saved in dedicated include programs. The following two areas are distinguished:

-   Class-relevant local definitions

-   Local definitions/implementations

These areas match the different technical visibility requirements. The internal names of the include programs end with CCDEF or CCIMP, which is why they are also known as CCDEF or CCIMP includes.

Rule

Position local declarations appropriately

Position the local declarations of a class pool at appropriate positions depending on the requirements. Types that are only used within the implementation of the global class need to be in a different position than types that are also addressed in the PRIVATE SECTION of the global class.

Details

From the perspective of a class pool, all local type definitions and the associated implementations of local classes can be saved in the Class-Relevant Local Definitions area. However, such an approach is disadvantageous from the dependency management perspective. Dependent classes (subclasses and friends of the global class) only have to be invalidated for changes to the local type declarations of a class pool that are used in the PRIVATE SECTION of the global class. But technically speaking, this invalidation occurs for all changes in the Class-Relevant Local Definitions area (the CCDEF include). For this reason, the additional area Local Definitions/Implementations (the CCIMP include) exists, which is intended for local type declarations that are only used within the class implementation of the global class, and for the implementation part of local classes. If this area is changed, dependent classes are not invalidated.

To prevent unnecessary new generations of other classes that are based on unwanted technical dependencies, the class-local types must be defined in the class pool at the appropriate positions after changes have been made to the global class:

-   All types used only within the method implementations of the global class should be declared under Local Definitions/Implementations (CCIMP include). The local classes should be implemented here as well.

-   Only those types that can also be referenced in the PRIVATE SECTION should be defined under Class-Relevant Local Definitions (CCDEF include).

Declarations and implementations of a local class are only supposed to be distributed across the areas Local Definitions/Implementations and Class-Relevant Local Definitions if they are to be referenced in the PRIVATE SECTION. However, if the local class is only used within the implementation of the global class, both the declaration and the implementation are to be carried out in the Local Definitions/Implementations.

Note

The rule specified here specializes the general rule [implement global declarations centrally](javascript:call_link\('abenglobal_declar_guidl.htm'\) "Guideline") with respect to class pools. They are especially oriented toward the external call of methods of their respective global class and are therefore particularly integrated within a dependency network. For this reason, the rule just mentioned cannot apply to its full extent.

Note

[Test classes](javascript:call_link\('abentest_class_glosry.htm'\) "Glossary Entry") should only be created in [test includes](javascript:call_link\('abentest_include_glosry.htm'\) "Glossary Entry").



**📖 Source**: [abenlocal_type_glob_class_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlocal_type_glob_class_guidl.htm)

### abeninstance_constructor_guidl.htm

> **📖 Official SAP Documentation**: [abeninstance_constructor_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninstance_constructor_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) →  [Object-Oriented Programming](javascript:call_link\('abenobj_oriented_guidl.htm'\)) → 

Instance Constructor

Background

When you define an ABAP class, you specify who creates an instance of this class or who may access the instance constructor of the class. To do this, you use the addition CREATE of the statement CLASS ... DEFINITION. The addition CREATE PUBLIC is the default setting and allows for the instancing by any user of the class. By specifying CREATE PROTECTED, you can restrict the object creation to the class itself and its subclasses. Using the addition CREATE PRIVATE addition, objects can only be created by the class itself. The restriction of the object creation to the class itself is useful in connection with the [singleton design pattern](javascript:call_link\('abenstatic_class_singleton_guidl.htm'\) "Guideline"), for example, where the class itself performs the object creation.

From a technical point of view, the instance constructor can be declared in all visibility sections that are more general or equal to the instantiation specified in the addition CREATE of the statement CLASS ... DEFINITION, using the statement METHODS constructor. However, the actual visibility is controlled by the addition CREATE.

Rule

Declare the instance constructor in the public visibility section.

Always declare the instance constructor of a global class in its public visibility section and independently of the instantiation specified by the addition CREATE in the class definition.

Details

The components of global classes are stored internally, separated according to the visibility section they belong to. Depending on the usage type of the class, only parts of the class are respected by ABAP Compiler in compilations. This procedure requires that the constructor of a global class is always declared in the public visibility section of the class. For these technical reasons, the instance constructor of a global class is always supposed to be declared in the public visibility section (PUBLIC SECTION). If it is declared in another visibility section, this may produce unjustified syntax errors in individual cases when global classes are used.

Exception

The technical restrictions mentioned only apply to the processing of global classes. Within local classes, the instance constructor can also be defined in other visibility sections. However, this positioning should correspond with the visibility section specified using the addition CREATE. A strategy like this enables you to use types for the interface of the instance constructor of a local class that are only accessible in a restricted visibility section.


---


## ABAP Keyword Documentation / ABAP Programming Guidelines / Architecture / User Interfaces

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP Programming Guidelines / Architecture / User Interfaces

Included pages: 5



**📖 Source**: [abeninstance_constructor_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninstance_constructor_guidl.htm)

### abenuser_interfaces_guidl.htm

> **📖 Official SAP Documentation**: [abenuser_interfaces_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenuser_interfaces_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) → 

User Interfaces

The user interface is the interface between a (human) user and a machine, in this case between the user and the ABAP program that is running. In the ABAP environment, graphical user interfaces (GUIs) are used which can be operated using a keyboard, mouse, or other input devices. They are based on assorted interface technologies and use either SAP's own SAP GUI or are Web-based technologies that create HTML pages displayed using Web browsers.

-   [Selecting the User Interface Technology](javascript:call_link\('abeninterface_tech_guidl.htm'\) "Guideline")

-   [Encapsulating Classic User Interfaces](javascript:call_link\('abenencap_class_interf_guidl.htm'\) "Guideline")

-   [Lists](javascript:call_link\('abenlist_guidl.htm'\) "Guideline")

-   [Accessibility](javascript:call_link\('abenaccessibility_guidl.htm'\) "Guideline")

Continue
[Selecting the User Interface Technology](javascript:call_link\('abeninterface_tech_guidl.htm'\))
[Encapsulating Classic User Interfaces](javascript:call_link\('abenencap_class_interf_guidl.htm'\))
[Lists](javascript:call_link\('abenlist_guidl.htm'\))
[Accessibility](javascript:call_link\('abenaccessibility_guidl.htm'\))



**📖 Source**: [abenuser_interfaces_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenuser_interfaces_guidl.htm)

### abeninterface_tech_guidl.htm

> **📖 Official SAP Documentation**: [abeninterface_tech_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterface_tech_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) →  [User Interfaces](javascript:call_link\('abenuser_interfaces_guidl.htm'\)) → 

Selecting the User Interface Technology

Background

Various UI technologies can be used in the ABAP environment. We distinguish between classic technologies, which are based on the SAP GUI and are almost completely integrated into the ABAP language, and new Web-based technologies, which display the UI in a Web browser and are accessed through object-oriented interfaces in ABAP.

The classic SAP GUI technologies are:

-   Classic dynpros
    A classic dynpro is a component of an ABAP program. It is created using Screen Painter in ABAP Workbench and called using either a transaction code or the CALL SCREEN statement. Every time a dynpro is called, a dynpro sequence is started.

-   Selection screens
    A selection screen is a specific classic dynpro that is not created manually in Screen Painter. Instead, it is defined using the ABAP statements PARAMETERS, SELECT-OPTIONS, and SELECTION-SCREEN. A selection screen is called either implicitly when executable programs are started or explicitly using the CALL SELECTION-SCREEN statement.

-   Classic lists
    Classic lists are used to output data in a structured and formatted manner. The formatted data is stored in a list buffer using specific ABAP statements (such as WRITE, FORMAT) and displayed on a special system dynpro. Classic lists are called either automatically (when an executable program is run) or with the LEAVE TO LIST-PROCESSING statement.

The new Web-based technologies are:

-   Business Server Pages
    Business Server Pages (BSP) are the counterpart to JavaServer Pages (JSP). BSPs are HTML pages with content that is partly dynamic. The dynamic content is created by server-side scripts that are written in ABAP. In AS ABAP, this type of script occurs as a generated ABAP Objects class. You create Business Server Pages using Web Application Builder in ABAP Workbench.

-   Web Dynpro ABAP
    Web Dynpro ABAP is a technology for creating platform-independent, Web-based interfaces. The architecture of Web Dynpro is based on the Model View Controller approach (MVC) for [SoC](javascript:call_link\('abenseperation_concerns_guidl.htm'\) "Guideline"). The three components of the model view controller are the data model, which describes the application, the presentation view, and the program controller for responding to user actions. Web Dynpro applications are created using Web Dynpro Explorer in ABAP Workbench and appear in AS ABAP using generated ABAP Objects classes.

-   SAPUI5
    SAPUI5 is a tool set for developing user interfaces for Web applications in HTML5. SAPUI5 supports the Model View Controller (MVC) approach and based on the user interface elements delivered in JavaScript and CSS libraries. The data connection to the application server is established using the data formats [XML](javascript:call_link\('abenxml_glosry.htm'\) "Glossary Entry"), [JSON](javascript:call_link\('abenjson_glosry.htm'\) "Glossary Entry") or OData. User interfaces developed with SAPUI5 can be connected to SAP and non-SAP platforms. In particular, SAPUI5 user interfaces can be developed for ABAP applications of [AS ABAP](javascript:call_link\('abensap_nw_abap_glosry.htm'\) "Glossary Entry"). The connection is established using [ICF](javascript:call_link\('abenicf_glosry.htm'\) "Glossary Entry") and [APC](javascript:call_link\('abenapc_glosry.htm'\) "Glossary Entry").

Rule

Use Web Dynpro ABAP or SAPUI5

Use Web Dynpro ABAP or SAPUI5 whenever possible to create the UIs of new application programs.

Details

Web Dynpro ABAP and SAPUI5 are SAP's standard UI technologies for developing modern Web applications in the ABAP environment. The MVC approach automatically ensures a separation of presentation logic and application logic, based on the [SoC principle](javascript:call_link\('abenseperation_concerns_guidl.htm'\) "Guideline").

Compared to Web Dynpro, the BSP technology is much more fundamental. An MVC approach for the SoC is supported, but developers are still responsible for the implementation. BSPs can be regarded as the predecessor technology of Web Dynpro ABAP. The use of BSPs is now restricted to cases where a Web application is based on a single HTML page, for which scripting is required and the function cannot be implemented with Web Dynpro ABAP.

The classic SAP UI technology (classic dynpros based on the SAP GUI, including selection screens and lists) is no longer sufficient for modern and flexible business applications where the user interface must be accessible in a portal, for example. The MVC approach is not supported by frameworks or by any relevant tools.

Exception

The various UI technologies are not interoperable. In other words, it is usually not possible to switch parts of an application based on classical dynpros (including selection screens and classic lists) to Web Dynpro ABAP or SAPUI5. In addition, the commonly implemented dynpro programming model was previously not very oriented toward SoC. This makes it difficult or even impossible to implement a changeover for the purpose of further development. Consequently, in exceptional cases, classic dynpros and/or selection screens might be required if a new development needs to be included in an existing framework. For these exceptional cases, the following rules have been devised to ensure that these obsolete UI technologies are handled using a more modern approach.

Notes

-   In general, the UI technology of an application that is strictly modeled on the [separation of concerns](javascript:call_link\('abenseperation_concerns_guidl.htm'\) "Guideline") can be replaced without any problems (see example below).

-   Web Dynpro ABAP and SAPUI5 are not part of the ABAP language. Specific guidelines regarding their use are not in the scope of these programming guidelines, which focus mainly on using the ABAP language to implement services.

Example

The transaction DEMO\_CR\_CAR\_RENTAL is called. Now two user interfaces can be selected for a car rental example:

-   A UI based on classic dynpros and selection screens. However, according to the above rule, using this UI technology in application programs is no longer recommended.

-   A modern UI based on Web Dynpro ABAP

Since the example application strictly separates all concerns, you can use it with different UIs without having to make adjustments to the application and persistence logic. The SoC is therefore a critical prerequisite for potential changeovers from classic dynpros to Web Dynpro ABAP.



**📖 Source**: [abeninterface_tech_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abeninterface_tech_guidl.htm)

### abenencap_class_interf_guidl.htm

> **📖 Official SAP Documentation**: [abenencap_class_interf_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenencap_class_interf_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) →  [User Interfaces](javascript:call_link\('abenuser_interfaces_guidl.htm'\)) → 

Encapsulating Classic User Interfaces

Background

The [separation of concerns](javascript:call_link\('abenseperation_concerns_guidl.htm'\) "Guideline") is one of the basic rules of these ABAP programming guidelines. This separation, which refers to a strict division of ABAP code into parts for presentation services, application services, and persistence services, is also technically possible for classic dynpro-based UI technologies. The MVC approach is not directly supported, but SoC can also be achieved through the consistent use of the available encapsulation technologies.

However, SoC was rarely implemented in classic dialog programming. Here, presentation logic, application logic, and persistence logic were often combined in a monolithic module pool.

Rule

Encapsulate classic dynpros and selection screens

Only create classic dynpros and selection screens in programs in a logical layer specifically provided for this purpose. You can use function groups as the program type.

Details

When using classic UI technologies, you need to separate the display logic from the application logic for the following reasons:

-   Reuse individual components

-   Automated program logic tests, irrespective of the UI

-   Change the UI technology

In addition, the communication between classic dynpros/selection screens and ABAP programs is implemented using global variables. This poses conceptual problems and cannot be combined with a modern, object-oriented approach for application programs.

Since class pools do not support classic dynpros and selection screens, you can only use function groups for encapsulation. In this role, a function group must be considered a global class. Here, the data of the global declaration part assumes the role of the private attributes, and the function modules assume the role of the public methods. The relevant procedure is demonstrated in DEMO\_CR\_CAR\_RENTAL\_SCREENS of package SABAP\_DEMOS\_CAR\_RENTAL\_DYNPRO. It applies to selection screens.

Besides UI elements, these function groups can only contain display logic in the form of local classes. The application logic communicates with the display logic using the function modules of this function group. You can still call the first dynpro of a dynpro sequence using a transaction code. This method is used in cases where the user starts the application.

The guidelines described in this book are also valid in function groups. It is especially important that the [dialog modules](javascript:call_link\('abendial_mod_event_block_guidl.htm'\) "Guideline") (PBO and PAI), which are called by the dynpro, or the [event blocks](javascript:call_link\('abendial_mod_event_block_guidl.htm'\) "Guideline") for selection screen processing do not contain any program logic. Instead they should directly delegate the processing to the relevant methods of the local classes. The same applies to the [function modules](javascript:call_link\('abenfunct_module_subroutine_guidl.htm'\) "Guideline") that act as the external interface. In addition, you must [restrict](javascript:call_link\('abenselect_table_type_guidl.htm'\) "Guideline") the scope of the function group global data to the minimum scope required for communicating with dynpros.

Exception

Following the above rule means you cannot use standard selection screens. Therefore, it is necessary to make an exception to this rule for executable programs that are executed during background processing. This is because the required parameter interface must be a standard selection screen defined directly in the program. An encapsulation in a function group is not possible here. However, in this case, the events of selection screen processing should only call one appropriate method of a local class within the executable program.

Bad Example

A classic dialog program - usually a single module pool - processes all the facets of an application.

Good Example

The following source code shows a part of a function group DEMO\_CR\_CAR\_RENTAL\_SCREENS with expanded include programs. This function group encapsulates the dynpro and selection screen for transaction DEMO\_CR\_CAR\_RENTAL, following the above rule. The connection to the application layer is established exclusively using the if\_demo\_cr\_car\_rentl\_service interface, which is also used in the Web Dynpro application of this transaction.

FUNCTION-POOL demo\_cr\_car\_rental\_screens.

\* Top Include

SELECTION-SCREEN BEGIN OF SCREEN 200 TITLE text-ccr.
PARAMETERS g\_name TYPE demo\_cr\_customer\_name.
SELECTION-SCREEN END OF SCREEN 200.

TABLES demo\_cr\_scustomer\_cntrl.

CONTROLS: customers TYPE TABLEVIEW USING SCREEN 0100,
          reservations TYPE TABLEVIEW USING SCREEN 0100.

DATA g\_ok\_code TYPE sy-ucomm.

DATA: g\_customers TYPE TABLE OF demo\_cr\_scustomer\_cntrl,
      g\_customer LIKE LINE OF g\_customers.

DATA: g\_reservations TYPE TABLE OF demo\_cr\_sreservation\_cntrl,
      g\_reservation LIKE LINE OF g\_reservations.

\* Local Class Declarations

CLASS screen\_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA car\_rental\_service
       TYPE REF TO if\_demo\_cr\_car\_rentl\_service.
    CLASS-METHODS: class\_constructor,
                   status\_0100,
                   user\_command\_0100,
                   cancel.
  PRIVATE SECTION.
    CLASS-METHODS: customer\_search\_by\_id,
                   ...
ENDCLASS.

CLASS customer\_table DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: change\_tc\_attr,
                   mark.
ENDCLASS.
...
\* Function Module

FUNCTION demo\_cr\_call\_car\_rental\_screen.
  CALL SCREEN 100.
ENDFUNCTION.
\* PBO Modules

MODULE status\_0100 OUTPUT.
  screen\_handler=>status\_0100( ).
ENDMODULE.

MODULE customers\_change\_tc\_attr OUTPUT.
  customer\_table=>change\_tc\_attr( ).
ENDMODULE.
...
\* PAI Modules

MODULE cancel INPUT.
  screen\_handler=>cancel( ).
ENDMODULE.

MODULE user\_command\_0100 INPUT.
  screen\_handler=>user\_command\_0100( ).
ENDMODULE.

MODULE customers\_mark INPUT.
  customer\_table=>mark( ).
ENDMODULE.
...
\* Local Class Implementations
...

Dynpro 100 is called in a function module but can also be linked to a transaction code. In the classic PBO and PAI modules, methods of local classes are called. However the implementation of these methods is not shown here. There is a class for general screen handling and a class for each table control. The application layer is accessed using the specified interface for implementations of the class.



**📖 Source**: [abenencap_class_interf_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenencap_class_interf_guidl.htm)

### abenlist_guidl.htm

> **📖 Official SAP Documentation**: [abenlist_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) →  [User Interfaces](javascript:call_link\('abenuser_interfaces_guidl.htm'\)) → 

Lists

Background

A list is a medium used for the structured and formatted output of data. The following lists are available in ABAP:

-   Classic lists, which are written to a list buffer using ABAP statements and displayed on a special list dynpro.

-   Output of the SAP List Viewer (ALV), which is displayed in [GUI controls](javascript:call_link\('abengui_control_glosry.htm'\) "Glossary Entry") during the processing of classic dynpros. ALV lists are accessed using classes, such as CL\_SALV\_TABLE (non-hierarchically tabular lists), CL\_SALV\_HIERSEQ\_TABLE (hierarchically sequential lists), or CL\_SALV\_TREE (hierarchically tabular lists).

Classic lists are the only option to send ABAP data from ABAP programs directly to the SAP spool system as print lists. If SAP List Viewer is used, the lists that are displayed in the viewer are automatically converted to classic print lists during printing.

Rule

Use SAP List Viewer

Do not use classic lists. If dynpro-based, classic UI technologies are still used, SAP List Viewer (ALV) or other GUI control-based technologies should be used instead of classic lists in production programs.

Details

Using classic lists is no longer recommended for the following reasons:

-   The processing of lists is based on global data and events of the ABAP runtime environment.

-   The list buffer that is used for classic lists is bound to an executable program or a dynpro sequence and not to classes and objects.

-   It is almost impossible to separate presentation logic and application logic when writing to lists.

-   The UI of a classic list is not standardized and thus usually not accessible.

The concept of classic lists is therefore mostly incompatible with the ABAP Objects concept, and classic lists cannot be encapsulated in function groups as easily as classic dynpros and selection screens.

While the application developer must ensure [accessibility](javascript:call_link\('abenaccessibility_guidl.htm'\) "Guideline") in classic lists with a great deal of effort, the ALV lists automatically comply with the accessibility requirements because the ALV already provides the required services, such as user-specific settings.

Exception

Small helper programs that are not intended for live use in application systems can continue to use classic lists for system-related console output. The WRITE list statement here assumes the same role as System.out.println(...) in Java or printf in C.

In cases in which an ALV output seems to be overdimensioned, other methods are possible, such as Textedit Control or Browser Control (or its wrapping in dynamic documents) for the formatted output of non-tabular content. As before, accessibility must be guaranteed here.

Note

For simple console output, XML-based output streams can be used. An example of this is shown by the class CL\_DEMO\_OUTPUT\_STREAM. The class CL\_DEMO\_OUTPUT demonstrates possible applications of this class. It is used in programs in the [ABA Example Library](javascript:call_link\('abenabap_examples.htm'\)).

Bad Example

Executing the program DEMO\_CLASSICAL\_REPORTING produces a classic list output. However, according to the above rule, using classic lists in application programs is no longer recommended.

Good Example

Executing the program DEMO\_ALV\_REPORTING produces ALV lists with the same content and the same functions as the classic lists in the previous example. ALV lists replace classic lists in those cases in which classic dynpros are still used.



**📖 Source**: [abenlist_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenlist_guidl.htm)

### abenaccessibility_guidl.htm

> **📖 Official SAP Documentation**: [abenaccessibility_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenaccessibility_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Architecture](javascript:call_link\('abenarchitecture_guidl.htm'\)) →  [User Interfaces](javascript:call_link\('abenuser_interfaces_guidl.htm'\)) → 

Accessibility

Background

Accessibility is a [product standard](javascript:call_link\('abencorrectness_quality_guidl.htm'\) "Guideline") that ensures that information technology products can also be used by people with impairments. For user interfaces, for instance, this means meeting the needs of visually impaired or blind users in particular. These users usually need a screen reader program, which reads the content of the screen aloud.

Rule

Ensuring Accessibility

Make sure that your user interfaces are accessible, no matter what interface technology is used, so that they can be used by users with impairments.

Details

Primarily, user interfaces must be designed so that they can be processed by technologies such as screen readers or magnifiers. This means meeting the following requirements:

-   All input and output fields must have meaningful labels.

-   All table columns must have a header.

-   All icons must have a tooltip.

-   Information must not be expressed by color alone.

-   Input and output fields on the screen should be grouped as appropriate in frames, each with a meaningful title.

This is another reason to use the most up-to-date interface technologies, such as SAPUI5, Web Dynpro ABAP or ALV. These automatically only allow accessible interfaces, whereas application developers using older technologies such as classic screens or classic lists are themselves responsible for ensuring that the accessibility requirements are met. There are some checks in the [check tools](javascript:call_link\('abencheck_correctness_guidl.htm'\) "Guideline") for classic dynpros and selection screens that report violations of these rules (if they can be identified statically). However, for classic lists such checks are not possible until display.

Note

As regards using the browser control in classic dynpros, we refer here to the class CL\_HTMLTIDY. This class enables HTML files to be checked for formal correctness and accessibility. It is best to only display HTML files in a browser control if they have been checked by CL\_HTMLTIDY. The class CL\_ABAP\_BROWSER, which wraps the browser control for simple displays of HTML files, performs a check with CL\_HTMLTIDY by default.


---


## ABAP Keyword Documentation / ABAP Programming Guidelines / Robust ABAP / Data Types and Data Objects

**Files**: 13 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP Programming Guidelines / Robust ABAP / Data Types and Data Objects

Included pages: 13



**📖 Source**: [abenaccessibility_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenaccessibility_guidl.htm)

### abendata_type_obj_guidl.htm

> **📖 Official SAP Documentation**: [abendata_type_obj_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendata_type_obj_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) → 

Data Types and Data Objects

Together with classes and objects, data types and data objects are the essentials of ABAP programming.

-   Data type

A data type describes a data object, just as a class describes an object. In this sense, a data type is comparable with a class without methods. ABAP interprets the content of a data object in accordance with its data type. Data types exist either as attributes bound to data objects or as standalone data objects. Standalone data types can be defined either in ABAP Dictionary or using the statement TYPES in an ABAP program.

-   Data object

A data object is an instance of a data type, just as an object is an instance of a class. It exists in the [internal session](javascript:call_link\('abeninternal_session_glosry.htm'\) "Glossary Entry") of an ABAP program or as a shared object in the shared memory and occupies memory there for the contained data. A data object is created either implicitly when a program or procedure is loaded (named data object), or by using the statement CREATE DATA (anonymous data object). Named data objects are either variables (statements DATA, CLASS-DATA, and so on) or constants (statement CONSTANTS).

A data type describes the technical attributes of a data object (for example, the elementary types it is comprised of, its length) and semantic attributes (what type of entity is represented by the data object). Types that are defined in ABAP dictionary have additional attributes, for example for input/output on a classic dynpro or in Web Dynpro.

As far as the ABAP runtime environment is concerned, only the technical attributes of a data object are of interest for program execution. However, the semantic information, which is linked to the appropriate use of types, is essential for the legibility of the source code. For this reason, some of the rules covered in this section could also fall under the heading [Structure and Style](javascript:call_link\('abenstructure_style_guidl.htm'\) "Guideline"), since this covers not only robustness, but also good style, which, although it does not affect program execution, is nevertheless significant for readability and maintainability.

-   [Bound and Standalone Data Types](javascript:call_link\('abenbound_independent_dtype_guidl.htm'\) "Guideline")

-   [Declaration of Data Types and Constants](javascript:call_link\('abendeclaration_dtypes_const_guidl.htm'\) "Guideline")

-   [Declaration of Variables](javascript:call_link\('abendeclaration_variables_guidl.htm'\) "Guideline")

-   [Inline Declarations](javascript:call_link\('abendeclaration_inline_guidl.htm'\) "Guideline")

-   [Including Structures](javascript:call_link\('abenincluding_structures_guidl.htm'\) "Guideline")

-   [Using Types](javascript:call_link\('abenusing_types_guidl.htm'\) "Guideline")

-   [Reference to Data Types or Data Objects](javascript:call_link\('abenref_types_objects_guidl.htm'\) "Guideline")

-   [Table Work Areas](javascript:call_link\('abentable_work_area_guidl.htm'\) "Guideline")

-   [Literals](javascript:call_link\('abenliterals_guidl.htm'\) "Guideline")

-   [Strings](javascript:call_link\('abenstrings_guidl.htm'\) "Guideline")

-   [Start Values](javascript:call_link\('abenstart_values_guidl.htm'\) "Guideline")

-   [Data Objects for Truth Values](javascript:call_link\('abendataobjects_true_value_guidl.htm'\) "Guideline")

Continue
[Bound and Standalone Data Types](javascript:call_link\('abenbound_independent_dtype_guidl.htm'\))
[Declaration of Data Types and Constants](javascript:call_link\('abendeclaration_dtypes_const_guidl.htm'\))
[Declaration of Variables](javascript:call_link\('abendeclaration_variables_guidl.htm'\))
[Inline Declarations](javascript:call_link\('abendeclaration_inline_guidl.htm'\))
[Including Structures](javascript:call_link\('abenincluding_structures_guidl.htm'\))
[Using Types](javascript:call_link\('abenusing_types_guidl.htm'\))
[Reference to Data Types or Data Objects](javascript:call_link\('abenref_types_objects_guidl.htm'\))
[Table Work Areas](javascript:call_link\('abentable_work_area_guidl.htm'\))
[Literals](javascript:call_link\('abenliterals_guidl.htm'\))
[Strings](javascript:call_link\('abenstrings_guidl.htm'\))
[Start Values](javascript:call_link\('abenstart_values_guidl.htm'\))
[Data Objects for Truth Values](javascript:call_link\('abendataobjects_true_value_guidl.htm'\))



**📖 Source**: [abendata_type_obj_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendata_type_obj_guidl.htm)

### abenbound_independent_dtype_guidl.htm

> **📖 Official SAP Documentation**: [abenbound_independent_dtype_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenbound_independent_dtype_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Bound and Standalone Data Types

Background

A bound data type only exists as an attribute of a data object. It is created when a data object is not declared using a reference to a standalone data type that defines all technical attributes, but when technical attributes are defined in the statement DATA instead. Here DATA is used as a synonym for all statements that declare data objects. The resulting type is an attribute of the declared variable and it is bound to this variable. If this type is needed in several different places, it has to be defined separately for each place where it is used.

A standalone data type is declared in the ABAP Dictionary or using the statement TYPES and defines all technical attributes of a data object with one exception: When table types are defined, they can be generic with respect to the keys specified. A standalone generic type can only be used for typing but not for data declarations. However, there is one exception: In a DATA statement, the standard key is added to the generic standard table type.

Rule

Use standalone data types

Use standalone data types instead of constructing bound data types when declaring data objects.

Details

Here is a list of reasons that support the declaration of standalone types:

-   The declaration of a standalone data type allows multiple data objects (or interface parameters or field symbols) to use a type without the need to always redefine this type.

-   Even if only one data object of this type is required initially, it is very likely that further data objects will be added during the course of the development. If the type needs to be adapted later on, you can do this centrally.

-   Declaring a standalone type and using it to declare a data object is nothing more than following the rule for the [SoC principle](javascript:call_link\('abenseperation_concerns_guidl.htm'\) "Guideline").

The data type should always have a specific meaning and a meaningful [name](javascript:call_link\('abennaming_guidl.htm'\) "Guideline"). This gives data types a clear semantic meaning and makes the program easier to read and understand. Therefore, you should declare different data types for technically identical but semantically different data objects. This also increases the probability that a type can be adapted later on without making major program changes.

Therefore you should avoid declaring purely technical data types that cannot be associated with specific semantics, because this does not make it easier to read or enhance the program.

Note

A separate [rule](javascript:call_link\('abendeclaration_dtypes_const_guidl.htm'\) "Guideline") specifies where the standalone data types should be declared.

Bad Example

The following source code shows the declaration of two data objects that are supposed to have the same data type. However, the technical attributes, length, and number of decimal places are defined as standalone, bound data types in the DATA statements in question.

...
DATA number\_1 TYPE p LENGTH 6 DECIMALS 2.
DATA number\_2 TYPE p LENGTH 6 DECIMALS 2.
...

Good Example

The following source code moves the definition of the technical attributes of the data objects in the above example to a separate TYPES statement. The standalone data type is only declared once and can then be used multiple times.

TYPES number\_type TYPE p LENGTH 6 DECIMALS 2.
...
DATA: number\_1 TYPE number\_type,
      number\_2 TYPE number\_type.
...



**📖 Source**: [abenbound_independent_dtype_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenbound_independent_dtype_guidl.htm)

### abendeclaration_dtypes_const_guidl.htm

> **📖 Official SAP Documentation**: [abendeclaration_dtypes_const_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclaration_dtypes_const_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Declaration of Data Types and Constants

Background

Data types and constants can be declared in the following contexts:

-   Cross-program

-   in the ABAP Dictionary

-   in global classes and interfaces

-   in type groups

-   Local program

-   in the global declaration part of a program

-   in global classes and interfaces

-   in procedures ([Methods](javascript:call_link\('abenfunct_module_subroutine_guidl.htm'\) "Guideline"))

Technically speaking, type groups, global classes and interfaces are also ABAP programs, in which data types and constants are created using the TYPES and CONSTANTS statements. In contrast to other ABAP programs, the declarations can also be statically visible in other programs, depending on the visibility section. Absolute type names enable you to dynamically access the types of all programs.

Rule

Declare data types and constants in the appropriate context

Declare data types and constants in the context that guarantees the best possible encapsulation.

Details

Data types and constants should be declared in the context in which they are [visible](javascript:call_link\('abenencapsulation_guidl.htm'\) "Guideline") for all potential consumers but not anywhere else:

-   Local program data types and constants

-   Data types that are only required by local data objects (usually helper variables) or constants that are only required in a procedure ([method](javascript:call_link\('abenfunct_module_subroutine_guidl.htm'\) "Guideline")) should be declared as local data types or constants.

-   Data types and constants that are only required within local classes should be declared in the corresponding visibility section of the classes or integrated using an interface.

-   If data types are required in multiple local classes and interfaces of a program, they should be created in the appropriate visibility section of a local class or an interface. Local classes or interfaces can be used that contain nothing else apart from these types or constants. In the global declaration part of programs, declarations of data types or constants are not required for semantic reasons.

-   Cross-program data types and constants

-   Data types and constants that a consumer requires to use a class/interface should be declared in the public (or package-public) visibility section of the global class/interface. Examples include data types used to type interface parameters of methods, and constants expected as actual parameters by methods, such as IDs of [exception texts](javascript:call_link\('abenexception_texts_guidl.htm'\) "Guideline") in exception classes.

-   Data types required by different programs, classes, or interfaces are declared as real types of the ABAP Dictionary (not in type groups). These are usually semantically independent types, for which the ABAP Dictionary provides additional services, such as descriptive texts and documentation options. In this context, you must consider the [separation of concerns](javascript:call_link\('abenseperation_concerns_guidl.htm'\) "Guideline").
    For example, a structure of the ABAP Dictionary should never be used to type (Web) Dynpro fields and to simultaneously define a database table. Ideally, data types should be declared in encapsulated packages, which manage the cross-package use of their repository objects and which only expose types actually required outside the package in their package interfaces.
    You should generally avoid declaring or even exposing purely technical types without semantic meaning, in application development packages of the ABAP Dictionary. The declaration of these types (such as INT2 or CHAR10) should be restricted to fundamental basis packages.

-   You should not create any new type groups. Data types should be declared in global classes or interfaces, or as real types of the ABAP Dictionary. You should only create constants in global classes or interfaces. However, the use of existing type groups is still [allowed](javascript:call_link\('abendataobjects_true_value_guidl.htm'\) "Guideline"). It is no longer necessary to load type groups explicitly using the TYPE-POOLS statement. However, you only need to declare new types or constants in a context, if no [semantically appropriate](javascript:call_link\('abenusing_types_guidl.htm'\) "Guideline") types or constants exist that are more global. For example, if an appropriate ABAP Dictionary data type exists, it is not necessary to create a local data type in the class, to type an interface parameter of a global class method. In this case, the data type in the ABAP Dictionary might have to be published in the same package interface as the class. This would also be the case, however, if an interface parameter is typed with a data type of the class that refers to an ABAP Dictionary data type.

Note

The misuse of include programs for the declaration of data types and data objects that can be reused across various programs is [not allowed](javascript:call_link\('abenmultiple_use_include_guidl.htm'\) "Guideline").

Bad Example

The following source code shows the declaration of constants in a type group that are required across different programs. The name of the type group must precede the names of the constants as a prefix. You should not create any new [type groups](javascript:call_link\('abenprogram_type_guidl.htm'\) "Guideline"). For constants that are required in various different programs, the above rule recommends a declaration in global classes or interfaces.

TYPE-POOL zicon.
  TYPES zicon\_icon TYPE ...
  CONSTANTS:
    zicon\_cancel      TYPE zicon\_icon VALUE icon\_cancel,
    zicon\_check       TYPE zicon\_icon VALUE icon\_check,
    zicon\_check\_words TYPE zicon\_icon VALUE icon\_intensify,
    zicon\_document    TYPE zicon\_icon VALUE icon\_hlp,
    zicon\_download    TYPE zicon\_icon VALUE icon\_export,
    ...

Good Example

The following source code illustrates the declaration of the constants in the above example in a global class. The visibility of the constants is restricted to the current package. In other programs, the constants are addressed using cl\_...\_icons=>.

CLASS cl\_...\_icons DEFINITION PUBLIC FINAL.
  PUBLIC SECTION.
    TYPES  icon TYPE ...
    CONSTANTS cancel      TYPE icon VALUE icon\_cancel.
    CONSTANTS check       TYPE icon VALUE icon\_check.
    CONSTANTS check\_words TYPE icon VALUE icon\_intensify.
    CONSTANTS document    TYPE icon VALUE icon\_hlp.
    CONSTANTS download    TYPE icon VALUE icon\_export.
    ...
ENDCLASS.



**📖 Source**: [abendeclaration_dtypes_const_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclaration_dtypes_const_guidl.htm)

### abendeclaration_variables_guidl.htm

> **📖 Official SAP Documentation**: [abendeclaration_variables_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclaration_variables_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Declaration of Variables

Background

Variables can be declared in the following contexts:

-   As attributes of global classes and interfaces across programs

-   Locally in the program

-   in the global declaration part of a program

-   as attributes of local classes and interfaces

-   in procedures ([Methods](javascript:call_link\('abenfunct_module_subroutine_guidl.htm'\) "Guideline"))

Variables that are declared within most of the event blocks or dialog modules as well as between completed processing blocks also belong to the global declaration part of a program, but violate the rule [implement global declarations centrally](javascript:call_link\('abenglobal_declar_guidl.htm'\) "Guideline").

Program-local variables that are declared in the global declaration part of a program are generally referred to as global variables.

Rule

Do not declare global variables

Do not declare variables in the global declaration part of a program. Variables may only be declared as attributes of classes and interfaces or locally in methods.

Details

This rule is directly derived from the basic rule [use ABAP objects](javascript:call_link\('abenabap_obj_progr_model_guidl.htm'\) "Guideline"). If you disregard helper variables in procedures ([methods](javascript:call_link\('abenfunct_module_subroutine_guidl.htm'\) "Guideline")), the content of the variable of a program indicates the state of the program and consequently the state of an application. In object-oriented programming, the class replaces the program, and the state of an application is no longer the state of the programs but the state of the classes or objects.

Furthermore, the rule [exploit the benefits of encapsulation](javascript:call_link\('abenencapsulation_guidl.htm'\) "Guideline") also assumes a critical role. The data of an application is sufficiently protected from misuse only in the visibility sections of classes.

Except for the following exception, you should not declare any global variables in a new ABAP program. They indicate a poor programming style that disregards proven concepts such as task sharing and encapsulation. If you need to access the same data of a program from multiple local classes and interfaces, you must create them in an appropriate visibility section of a local class or an interface. These can also be local classes or interfaces that contain nothing but such attributes.

Note

The above rule also applies to the declaration of [field symbols](javascript:call_link\('abendyn_access_data_obj_guidl.htm'\) "Guideline") with the FIELD-SYMBOLS statement.

Exception

If classic dynpros and selections screens are still used instead of [SAPUI5](javascript:call_link\('abeninterface_tech_guidl.htm'\) "Guideline") or [Web Dynpro ABAP](javascript:call_link\('abeninterface_tech_guidl.htm'\) "Guideline"), global variables are required as interfaces for the communication between ABAP and classic dynpros. Global variables can be declared using the following statements for this purpose alone:

-   DATA, [TABLES](javascript:call_link\('abentable_work_area_guidl.htm'\) "Guideline") and CONTROLS for general dynpros

-   PARAMETERS and SELECT-OPTIONS for selection screens

In these cases, you have to ensure the maximum possible [encapsulation](javascript:call_link\('abenencap_class_interf_guidl.htm'\) "Guideline") of those global variables.

Bad Example

The following source code shows the top include of a function group for document display. In addition to the required interface work area, which is declared with TABLES, further global variables exist that indicate the state of the display. However, according to the above rule, you are not allowed to use global variables for purposes other than communication with a classic dynpro.

FUNCTION-POOL show\_documents.
TABLES document\_structure.
DATA: g\_language TYPE sy-langu,
      g\_display\_mode TYPE ...
      ...
CLASS screen\_handler DEFINITION.
  PUBLIC SECTION.
    ...

Good Example

The following source code shows an improved example. The previously global variables are encapsulated in a class that is specifically provided for the state of the display, and can be addressed using display\_status=> in the other classes of the program.

FUNCTION-POOL show\_documents.
TABLES document\_structure.
CLASS display\_status DEFINITION.
  PUBLIC SECTION.
      CLASS-DATA: language TYPE sy-langu,
                  display\_mode TYPE ...
                  ...
ENDCLASS.
CLASS screen\_handler DEFINITION.
  PUBLIC SECTION.
  ...



**📖 Source**: [abendeclaration_variables_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclaration_variables_guidl.htm)

### abendeclaration_inline_guidl.htm

> **📖 Official SAP Documentation**: [abendeclaration_inline_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclaration_inline_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Inline Declarations

Background

The declaration operators

-   [DATA(var)](javascript:call_link\('abendata_inline.htm'\))

-   [FIELD-SYMBOLS <fs>.](javascript:call_link\('abenfield-symbol_inline.htm'\))

can be used to make inline declarations in [writing positions](javascript:call_link\('abenwriting_position_glosry.htm'\) "Glossary Entry"). In this way, declarations are made in operational statements rather than in [declaration statements](javascript:call_link\('abendeclaration_statement_glosry.htm'\) "Glossary Entry"). The declaration is made when the program is compiled, regardless of whether the statement is actually executed.

Rule

Only use inline declarations locally

Only make inline declarations in processing blocks that support [local data](javascript:call_link\('abenlocal_data_glosry.htm'\) "Glossary Entry"). Use them as if they were local declarations in the current statement block.

Details

If used correctly, inline declarations are an excellent way of making programs leaner and easier to understand. An inline declaration in a statement works like a short form of a declaration statement directly in front of the statement, which is why the guidelines for declaration statements must be followed:

-   The rule dictating that [no global program variables and field symbols](javascript:call_link\('abendeclaration_variables_guidl.htm'\) "Guideline") are to be declared also applies to inline declarations, without restrictions. For this reason, statements with inline declarations should only be specified in processing blocks with local data, namely procedures and preferably methods. If not, the variables and field symbols declared inline would be global in the program, with all the drawbacks listed in the description of the rule.

-   Inline declarations are an exception to the rule that [local declarations](javascript:call_link\('abenlocal_declar_guidl.htm'\) "Guideline") should only be made at the start of a procedure. They are specified in operational statements, which means that, unlike declaration statements, they cannot be specified at the start of the procedure. Despite this, the restrictions stated in the rule for local declarations are still valid for inline declarations. In particular, the validity of inline declarations is not limited to their current statement block. Inline declarations should, therefore, only be specified in less complex procedures, so making them easier to understand. The variables and field symbols declared inline should only be used in the direct vicinity of their declaration. Under no circumstances should a variable declared inline be accessed dynamically before the declaration. When an inline declaration is specified in a (conditional) control structure, it should usually only be accessed within this statement block.

Bad Example

Inline declaration of a field symbol <pattern> and two variables moff and mlen in a LOOP and their later reuse in a different loop. At first glance, it appears that the declarations are only valid in the first loop and only conditionally, but they are valid for the whole method and unconditionally.

METHOD demo\_method.
  "IMPORTING i\_tab1 TYPE TANDARD TABLE OF string
  "IMPORTING i\_tab2 TYPE TANDARD TABLE OF string
  "IMPORTING i\_text TYPE string
  IF i\_tab1 IS NOT INITIAL.
    LOOP AT i\_tab1 ASSIGNING FIELD-SYMBOL(<pattern>).
      FIND <pattern> IN i\_text MATCH OFFSET DATA(moff)
                               MATCH LENGTH DATA(mlen).
      ...
    ENDLOOP.
  ENDIF.
  IF i\_tab2 IS NOT INITIAL.
    LOOP AT i\_tab2 ASSIGNING <pattern>.
      FIND <pattern> IN i\_text MATCH OFFSET moff
                               MATCH LENGTH mlen.
      ...
    ENDLOOP.
  ENDIF.
ENDMETHOD.

Good Example

The field symbols and variables declared inline are only used locally in the their respective loops. The fact that they are valid in the whole method is ignored, for the sake of simplicity. If the field symbol and the variables are only to be declared once for both loops, they should be declared at the start of the method using declaration statements.

METHOD demo\_method.
  "IMPORTING i\_tab1 TYPE TANDARD TABLE OF string
  "IMPORTING i\_tab2 TYPE TANDARD TABLE OF string
  "IMPORTING i\_text TYPE string
  IF i\_tab1 IS NOT INITIAL.
    LOOP AT i\_tab1 ASSIGNING FIELD-SYMBOL(<pattern1>).
      FIND <pattern1> IN i\_text MATCH OFFSET DATA(moff1)
                                MATCH LENGTH DATA(mlen1).
      ...
    ENDLOOP.
  ENDIF.
  IF i\_tab2 IS NOT INITIAL.
    LOOP AT i\_tab2 ASSIGNING FIELD-SYMBOL(<pattern2>.
      FIND <pattern2> IN i\_text MATCH OFFSET DATA(moff2)
                                MATCH LENGTH DATA(mlen2).
      ...
    ENDLOOP.
  ENDIF.
ENDMETHOD.



**📖 Source**: [abendeclaration_inline_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendeclaration_inline_guidl.htm)

### abenincluding_structures_guidl.htm

> **📖 Official SAP Documentation**: [abenincluding_structures_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenincluding_structures_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Including Structures

Background

In the program-internal design of structures with the BEGIN OF and END OF additions of the TYPES and DATA statements, you can use the INCLUDE TYPE or INCLUDE STRUCTURE statements to integrate all components of another structure with the current structure at this place without creating a specific substructure. You can specify a name for shared addressing and a suffix to avoid naming conflicts. ABAP Dictionary provides the same functions.

Substructures, in contrast, are formed if the components of a structure themselves are structured. A structure with substructures is known as a nested structure.

Rule

Do not include components from structures

Do not integrate the components of other structures by using INCLUDE when declaring a structure. If required, you can include the components in a real substructure.

Details

The reasons for this rule are the following:

-   The integration of components can lead to naming conflicts. This is particularly problematic if structures of other contexts are integrated and changed retroactively.

-   Although it is possible to assign a name, the integrated structures cannot be addressed as such without restrictions. The necessary internal type information is individually stored for each integrated component. For the components of a substructure, however, this information is stored only once for the substructure

-   In contrast to real substructures, structures integrated using INCLUDE cannot be declared as boxed components. A boxed component is a structured component, which is managed through an internal reference and thus supports initial value sharing. This can considerably reduce the memory requirements for rarely filled components.

-   The statement cancels a [chained statement](javascript:call_link\('abenchained_statements_guidl.htm'\) "Guideline") that has been created with BEGIN OF and END OF.

If no real substructures can be formed, you must avoid naming conflicts as far as possible by using suffixes (RENAMING WITH SUFFIX addition). This recommendation also applies to the integration of structures in ABAP Dictionary, where you cannot always create real substructures (for example, for database tables).

Bad Example

The following source code shows the integration of the components of a structure into another structure, which is not recommended according to the above rule.

TYPES:
  BEGIN OF structure\_1,
  ...
  END OF structure\_1.
TYPES:
  BEGIN OF structure\_2,
  ...
  INCLUDE TYPE structure\_1 AS sub\_structure.
TYPES:
    ...
  END OF structure\_2.

Good Example

The following source code shows the declaration of a component of a structure as a substructure as recommended in the above rule.

TYPES:
  BEGIN OF structure\_1,
   ...
  END OF structure\_1.
TYPES:
  BEGIN OF structure\_2,
    ...
    sub\_structure TYPE structure\_1.
    ...
END OF structure\_2.



**📖 Source**: [abenincluding_structures_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenincluding_structures_guidl.htm)

### abenusing_types_guidl.htm

> **📖 Official SAP Documentation**: [abenusing_types_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenusing_types_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Using Types

Background

You can use the data types declared according to the rules on [Bound and Standalone Data Types](javascript:call_link\('abenbound_independent_dtype_guidl.htm'\) "Guideline") and [Declaration of Data Types and Constants](javascript:call_link\('abendeclaration_dtypes_const_guidl.htm'\) "Guideline") for declaring and creating data objects, as well as for typing field symbols or interface parameters. You specify them after the TYPE addition of the corresponding statement.

Rule

Use semantically appropriate data types only

Use existing types only if they match the semantics of the typed object. You must not select an existing type based only on the technical attributes.

Details

As long as it extends beyond an elemental ABAP type, the type of a data object or an interface parameter provides the source code reader with information about the semantics of these variables. This makes it easier to recognize the meaning of individual variables.

For this reason, you must use only data types whose semantics match the usage. The technical attributes of a type alone do not justify its use in a specific context, as this impedes the readability of the program.

In particular, this applies to the reuse or multiple use of existing types. If you require a data type with specific technical attributes for an application, you should not simply use any type with these attributes from ABAP Dictionary. In the past, this has frequently been the chosen procedure. Consequently applying package encapsulation may help prevent the unwanted use of own data types.

Note

This rule applies especially for the use of structures from ABAP Dictionary. For example, you should never use a structure defining a database table as a template for input or output fields of classic dynpros or in Web Dynpro. This would violate the [SoC principle](javascript:call_link\('abenseperation_concerns_guidl.htm'\) "Guideline").

Bad Example

In the following source code a variable is declared, whose name and use clearly indicate that it is used for a truth value. The variable is declared with a technically correct, but semantically incorrect, data type. syst-batch, after all, is the data type for the [system field](javascript:call_link\('abensystem_fields_guidl.htm'\) "Guideline") sy-batch, which indicates whether a program is executed in the background.

DATA is\_empty TYPE syst-batch.
...
IF is\_empty IS INITIAL.
  ...
ENDIF.

Good Example

The following source code shows an improved example compared to the source code above. In this case, the abap\_bool type of type group abap, which is intended for [truth values](javascript:call_link\('abendataobjects_true_value_guidl.htm'\) "Guideline"), is used. In addition, the request of the truth value is performed using a specifically designated constant from the same type group.

DATA is\_empty TYPE abap\_bool.
...
IF is\_empty EQ abap\_false.
  ...
ENDIF.



**📖 Source**: [abenusing_types_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenusing_types_guidl.htm)

### abenref_types_objects_guidl.htm

> **📖 Official SAP Documentation**: [abenref_types_objects_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenref_types_objects_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Reference to Data Types or Data Objects

Background

As well as [using data types](javascript:call_link\('abenusing_types_guidl.htm'\) "Guideline") for declarations and typings with the addition TYPE, the alternative addition LIKE of the corresponding statements can be used to reference the data type of one of the data objects visible at this position directly. This includes references to data objects of the same program, interface parameters of the current procedure, attributes of global classes and interfaces, and constants in type groups.

Rule

Declare dependent data objects with reference to other data objects

If a data object directly depends on another data object, refer to it directly using LIKE for the declaration. In all other cases, use TYPE to refer to a standalone data type.

Details

For example, if a helper variable of the type of an input parameter is required within a procedure ([method](javascript:call_link\('abenfunct_module_subroutine_guidl.htm'\) "Guideline")), it should not be declared with reference to the type of the parameter using TYPE but with reference to the parameter itself using LIKE. It is also possible to declare work areas using LIKE LINE OF if the parameter is an internal table. In the case of typing with LIKE, the type of the parameter can be changed retroactively without always having to adapt the procedure implementation.

However, if no close reference to another data object exists, it is usually more useful to declare data objects with reference to a [standalone data type](javascript:call_link\('abenbound_independent_dtype_guidl.htm'\) "Guideline") by using TYPE.

Note

Obsolete references to flat structures or database tables or views of the ABAP Dictionary using LIKE should never be implemented.

Bad Example

The following source code shows the declaration of a helper variable in a method that is supposed to be of the same data type as an interface parameter. The TYPE reference to the data type requires a manual implementation of any type changes.

CLASS some\_class DEFINITION ...
   PUBLIC SECTION.
     METHODS some\_method
       CHANGING some\_parameter TYPE some\_type.
     ...
ENDCLASS.
CLASS some\_class IMPLEMENTATION.
   METHOD some\_method.
     DATA save\_parameter TYPE some\_type.
     save\_parameter = some\_parameter.
     ...
   ENDMETHOD.
   ...
ENDCLASS.

Good Example

The following source code shows the improved declaration of the helper variable that now directly refers to the interface parameter with LIKE, so that possible type changes are automatically accepted.

   ...
    METHOD some\_method.
      DATA save\_parameter LIKE some\_parameter.
      save\_parameter = some\_parameter.
      ...
    ENDMETHOD.
...



**📖 Source**: [abenref_types_objects_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenref_types_objects_guidl.htm)

### abentable_work_area_guidl.htm

> **📖 Official SAP Documentation**: [abentable_work_area_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentable_work_area_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Table Work Areas

Background

Table work areas are structured data objects of a flat structure type, a database table type, or a view type from ABAP Dictionary declared using the statements TABLES or NODES. If declared using NODES, other ABAP Dictionary types are also possible.

From the perspective of the data type, the statements

[TABLES table\_wa](javascript:call_link\('abaptables.htm'\)).

[NODES table\_wa](javascript:call_link\('abapnodes.htm'\)).

are the same as

DATA table\_wa TYPE table\_wa.

This means that data objects with the same name and type as the corresponding data types from ABAP Dictionary are declared. This is supplemented by further meanings of TABLES and NODES. For the full range of meanings, refer to their documentation. The essential properties are as follows:

-   TABLES and NODES declare [interface work areas](javascript:call_link\('abenintern_extern_proc_call_guidl.htm'\) "Guideline"), which are shared by multiple programs of a program group.

-   TABLES declares interfaces to classic dynpros and selection screens.

-   NODES declares an interface to logical databases.

In addition, it is also possible to use table work areas declared using TABLES as implicit work areas in obsolete abbreviated forms of ABAP SQL, or even older statements for database accesses.

Rule

No table work areas except for classic dynpros

Only use the statement TABLES in the global declaration part of function groups to communicate with classic dynpros. Apart from in wrappers of logical databases, the statement NODES is no longer required.

Details

The statement TABLES is not allowed within classes anyway and, in the syntax, the statement NODES can only be created in the global declaration part of an executable program associated with a logical database. The latter option is [no longer allowed](javascript:call_link\('abenprogram_attribute_guidl.htm'\) "Guideline").

Since obsolete database accesses requiring the statement TABLES and shared data areas between programs are not allowed, there is no need to use the statement TABLES, except for declaring interfaces to classic dynpros (see the following exception).

Exception

If dynpro fields in [classic dynpros](javascript:call_link\('abenuser_interfaces_guidl.htm'\) "Guideline") are defined with reference to flat structures in ABAP Dictionary, the identically named global data objects of the ABAP program must be declared with the statement TABLES. Otherwise, the data objects of the ABAP program are not linked to the dynpro fields, and their content cannot be accessed. In addition, TABLES is also required for declaring specific work areas when handling function codes of selection screens.

Note

The restriction on the statement TABLES to this last remaining technical requirement, that is, the communication with classic dynpros and selection screens, can also be derived from other rules of these guidelines. However, since the use of the statement TABLES instead of the statement DATA is still very popular among experienced ABAP developers, the rule above explicitly stresses that it is not allowed.



**📖 Source**: [abentable_work_area_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abentable_work_area_guidl.htm)

### abenliterals_guidl.htm

> **📖 Official SAP Documentation**: [abenliterals_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenliterals_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Literals

Background

A literal is a data object defined in the source code of a program by specifying a character-like value. Possible literals are:

-   Numeric literals
    String of digits with an optional sign. The data type is either i or p.

-   Character literals

-   Text field literals enclosed in single quotation marks ('). The data type is c.

-   String literals, which are enclosed in backquotes (\`). The data type is string.

In numeric literals, neither decimal separators nor scientific notation with mantissa and exponent are possible. Character literals with [correct content](javascript:call_link\('abennumbers_guidl.htm'\) "Guideline") must be used to represent thesetypes of numeric values.

Rule

Avoid using literals in operand positions

Avoid using literals to specify values directly in the source code. Instead constants should be declared with these values. This applies to numeric values in particular.

Details

Certain values are required in more than one place in the source code. It is therefore not helpful to specify these values directly in the source code, since multiple statements would need to be modified each time the value is changed. An appropriate constant can be used instead to enable the value to modified at a central position in the source code. Literals are, of course, allowed when specifying values in the declaration of the constants. This can make the program significantly easier to maintain and enhance at a later date.

It can also be a good idea to create an appropriate constant for values used in only one place. The name of the constant gives the values semantics that make the source code easier to understand.

Number literals that appear in source code seemingly without any semantic meaning are often known as "magic numbers". Avoid using these in ABAP programs. When using character literals, [translatability](javascript:call_link\('abensystem_text_guidl.htm'\) "Guideline") is also important.

Exception

In certain situations, however, using constants can affect the readability of a program. It is better to specify a literal in these cases, as in the following examples:

-   CALL FUNCTION 'MY\_FUNC'.

-   IF sy-subrc = 0.

-   READ TABLE itab INDEX 1 or itab\[ 1 \]

-   ADD 1 TO counter.

These examples make the semantic meaning of the literals clear and translatability is not an issue.

Another area where character literals are vital is dynamic programming. Here, parts of statements or entire programs are generated, which is virtually impossible without using character literals. In addition, string templates offer various enhanced options for using literal texts.

Bad Example

The following source code uses the same literal multiple times to specify pi (π) in operand positions. This multiple use makes the program unclear and error-prone.

DATA: radius TYPE decfloat34,
      circumference TYPE decfloat34,
      area TYPE decfloat34.
...

circumference =
  2\* '3.141592653589793238462643383279503' \* radius.
area =
  '3.141592653589793238462643383279503' \* radius \*\* 2.

Good Example

The following source code declares a constant that requires the literal with the value pi (π) only once, and uses it in the appropriate operand positions.

CONSTANTS pi TYPE decfloat34
             VALUE '3.141592653589793238462643383279503'.

DATA: radius        TYPE decfloat34,
      circumference TYPE decfloat34,
      area          TYPE decfloat34.
...
circumference = 2 \* pi \* radius.
area          = pi \* radius \*\* 2.



**📖 Source**: [abenliterals_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenliterals_guidl.htm)

### abenstrings_guidl.htm

> **📖 Official SAP Documentation**: [abenstrings_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenstrings_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Strings

Background

Strings are [dynamic data objects](javascript:call_link\('abenuse_dyn_data_object_guidl.htm'\) "Guideline") of variable length. There are text strings of the string data type and byte strings of the xstring data type, in which character strings or byte strings can be saved.

In contrast to text and byte fields of a fixed length (c, x data types), the length of strings automatically adapts to the content. Other data types, such as n, d, and t, are also handled as text fields in many operand positions. Strings are deep data objects that are internally managed by references. For this, the following additional memory is required:

-   Strings whose length is less than approximately 30 characters or 60 bytes require between approximately 10 and 40 bytes of additional memory, depending on the string length.

-   For longer strings, the additional memory requirement is approximately 50 bytes, irrespective of the string length.

In the case of assignments between strings, sharing takes effect. This means that only the internal reference is copied first. Sharing is canceled if the source or target object is accessed for modification.

Rule

Use strings in character string and byte string processing

Use strings rather than fixed length fields for the internal saving and processing of character strings and byte strings.

Details

Strings are more flexible than fields of a fixed length and usually help to save memory space, because no unnecessary space is occupied by blanks or zeroes, and because sharing is implemented for assignments. Furthermore, trailing blanks are always significant in text strings. Text fields simply ignore trailing blanks in many operand positions (but not in all), which may be quite confusing at times.

Exception

In the following cases, fields of a fixed length should be used instead of strings:

-   The length of the field is critical, for example, for templates or for interfaces to screen fields.

-   Despite [sharing](javascript:call_link\('abenadmin_costs_dyn_mem_obj_guidl.htm'\) "Guideline"), the additional administration work outweighs the benefits which can often be the case for very short strings. If it is obvious that a certain length is never exceeded, short fields of a fixed length can also be used.

-   Structures that only contain character-like components should be handled like a single text field. This is not possible for structures that contain text strings.

Bad Example

The following source code shows an internal table for saving an HTML page whose row type is a text field with a fixed length of 255. Most of the memory space of the internal table, however, is probably wasted on blanks.

TYPES html\_line TYPE c LENGTH 255.
DATA html\_table TYPE TABLE OF html\_line.
APPEND '<HTML>' TO html\_table.
...
APPEND '<BODY>' TO html\_table.
...
APPEND '</BODY>' TO html\_table.
APPEND '</HTML>' TO html\_table.

Good Example

The following source code shows the above example but uses text strings. The memory space gained should outweigh the additional administration effort considerably. As an alternative to using an internal table, the HTML page can also be concatenated in a single text string; however, this makes it more difficult to read, for example, in the ABAP Debugger.

DATA html\_table TYPE TABLE OF string.
APPEND \`<HTML>\` TO html\_table.
...
APPEND \`<BODY>\` TO html\_table.
...
APPEND \`</BODY>\` TO html\_table.
APPEND \`</HTML>\` TO html\_table.



**📖 Source**: [abenstrings_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenstrings_guidl.htm)

### abenstart_values_guidl.htm

> **📖 Official SAP Documentation**: [abenstart_values_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenstart_values_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Start Values

Background

If you declare a data object with the statement DATA, you can use the addition [VALUE](javascript:call_link\('abapdata_options.htm'\)) to set a value, with which the data object is filled when it is created. If the addition VALUE is not used, the system uses the type-dependent initial value. If the statement CONSTANTS is used, the addition VALUE must always be specified. If the type-dependent initial value is required here, this can be achieved using the addition VALUE IS INITIAL. The addition [DEFAULT](javascript:call_link\('abapmethods_parameters.htm'\)) for input parameters of methods is a further option for start values.

If the specified start value does match the type and length of the data object, the value is converted when the program is generated.

Rule

Start values must match the data type of the data object

Only use the addition VALUE to enter start values that exactly match the data type of the declared data object in terms of type, content, and length.

Details

The start value cannot always be specified in a type-friendly way, since ABAP does not support type-friendly [literals](javascript:call_link\('abenliterals_guidl.htm'\) "Guideline") for all possible data types. In all cases where a conversion cannot be avoided, choose the content of literals specified as start values so that the actual value meets the requirements when the source code is read.

Note

If a start value cannot be converted to the data type of the data object, no syntax error occurs and program generation is canceled at activation time instead. Non-convertible start values for input parameters of methods, in fact, are not detected until the method is called. This can only occur, however, when literals are specified.

Bad Example

The average reader may well expect the constant high\_noon in the following source code to contain the value 120000. However, the constant actually contains the value 092000, because the value of the numeric literal refers to the number of seconds. This means 12,000 seconds is actually the time 09:20 on the following day.

CONSTANTS high\_noon TYPE t VALUE 120000.

Good Example

The following source code corrects the above example by replacing the numeric literal with a text field literal. Now the constant high\_noon contains the expected value 120000.

CONSTANTS high\_noon TYPE t VALUE '120000'.



**📖 Source**: [abenstart_values_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenstart_values_guidl.htm)

### abendataobjects_true_value_guidl.htm

> **📖 Official SAP Documentation**: [abendataobjects_true_value_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendataobjects_true_value_guidl.htm)
> **🔍 Direct Link**: This section contains the complete content from the official SAP ABAP documentation page.


**📖 Source**: [abendataobjects_true_value_guidl.htm](https://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abendataobjects_true_value_guidl.htm)


  

* * *

AS ABAP Release 753, ©Copyright 2019 SAP AG. All rights reserved.

[ABAP Keyword Documentation](javascript:call_link\('abenabap.htm'\)) →  [ABAP Programming Guidelines](javascript:call_link\('abenabap_pgl.htm'\)) →  [Robust ABAP](javascript:call_link\('abenrobust_abap_guidl.htm'\)) →  [Data Types and Data Objects](javascript:call_link\('abendata_type_obj_guidl.htm'\)) → 

Data Objects for Truth Values

Background

Truth values are results of logical expressions. A truth value is either true or false. ABAP does not yet support Boolean data types and thus does not support data objects for truth values. Therefore, the result of a logical expression cannot be assigned directly to a data object.

It has become common practice to express the truth value "true" as value "X" and the truth value "false" as a blank (" "). There are also Boolean functions that have a logical expression as an argument and are returned as the value "X" or a blank, depending on the result.

To make it easier to handle truth values expressed in this way, the type group abap contains a data type abap\_bool of elementary type c with length 1, and the constants abap\_true of value "X" and abap\_false of value " " as substitutes for a real Boolean data type. There is also a constant abap\_undefined of value "-".

Rule

Use the data type abap\_bool for truth values

When working explicitly with truth values, use the type abap\_bool as a substitute for a real Boolean data type. A data object declared in this way should have no values other than the relevant constants abap\_true and abap\_false (also abap\_undefined).

Details

Using the type abap\_bool and the constants abap\_true and abap\_false makes it clear that truth values are being used here.

In accordance with the rule for [avoiding](javascript:call_link\('abenliterals_guidl.htm'\) "Guideline") literals in operand positions, not only the literals 'X' and ' ' should be used. State queries about the [predicate operators](javascript:call_link\('abenpredicate_operator_glosry.htm'\) "Glossary Entry") IS INITIAL and IS NOT INITIAL or the use of the constant space are also not advisable, because they require knowledge of the technical values of abap\_true and abap\_false, which are not significant in the sense of real Boolean data objects.

The type group abap contains a third constant for the type abap\_bool, namely abap\_undefined. However, implementing a three-value logic is only useful and recommended in exceptional cases. In this case, note that abap\_undefined does not contain the initial value for a variable of type abap\_bool. The initial value is always the value of abap\_false. However, the value of abap\_undefined can, if required, be specified using the addition VALUE when declaring a truth value as the start value.

Bad Example

The following source code shows an unsuitable emulation of the Boolean data objects not present in ABAP.

DATA is\_found TYPE c LENGTH 1.
...
is\_found = 'X'.
...
IF is\_found IS NOT INITIAL.
   ...
ENDIF.

Good Example

The following source code shows the recommended emulation of the Boolean data objects not present in ABAP.

DATA is\_found TYPE abap\_bool.
...
is\_found = abap\_true.
...
IF is\_found = abap\_true.
   ...
ENDIF.


---
