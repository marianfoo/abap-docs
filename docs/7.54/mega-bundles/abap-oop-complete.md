# ABAP OOP - Complete Reference (7.54)

**Generated**: 2025-09-01T19:37:38.070Z
**Bundles Combined**: 139
**Category**: oop

---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Data Elements

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Data Elements

Included pages: 7


### abenddic_data_elements.htm

---
title: "Data Elements"
description: |
  A data element in ABAP Dictionary defines an elementary data type(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenelementary_data_type_glosry.htm 'Glossary Entry') or a reference type(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreference_type_glosry.htm 'Glossar
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm"
abapFile: "abenddic_data_elements.htm"
keywords: ["do", "try", "class", "data", "types", "abenddic", "elements"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) → 

Data Elements

A data element in ABAP Dictionary defines an [elementary data type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenelementary_data_type_glosry.htm "Glossary Entry") or a [reference type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreference_type_glosry.htm "Glossary Entry") and describes, alongside the technical type attributes, the semantic meaning of an object defined with reference to the data element. Data elements are the elementary parts of complex types such as [structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm), [table types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types.htm), or [database tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables.htm). An internal program object declared with reference to a data element always has one of the elementary built-in ABAP types. The type in question is defined by the mapping of the [built-in types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) in ABAP Dictionary to ABAP types.

-   [Technical attributes of data elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements_tech.htm)

-   [Semantic attributes of data elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements_sema.htm)

Notes

-   The technical attributes of a data element can be defined either directly or by using a reusable [domain](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm). This is why the concept is known as a two-level domain concept.

-   Data elements can be edited in form-based editors both in the ABAP Dictionary [tool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_tools.htm) and in the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry").

Continue
[Technical Attributes of Data Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements_tech.htm)
[Semantic Attributes of Data Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements_sema.htm)
[Domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm)


### abenddic_data_elements_tech.htm

---
title: "Technical Attributes of Data Elements"
description: |
  A data element describes an elementary data type(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenelementary_data_type_glosry.htm 'Glossary Entry') or a reference type(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreference_type_glosry.htm 'Glossary Entry') with th
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements_tech.htm"
abapFile: "abenddic_data_elements_tech.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddic", "elements", "tech"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Data Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) → 

Technical Attributes of Data Elements

A data element describes an [elementary data type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenelementary_data_type_glosry.htm "Glossary Entry") or a [reference type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreference_type_glosry.htm "Glossary Entry") with the following technical attributes:

-   Elementary type

A data element that describes an elementary type has a [built-in data type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) from ABAP Dictionary, a length, and an (optional) number of fractional digits as its technical attributes. These technical attributes are defined either directly in the data element or are applied from a [domain](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm).

-   Reference type

A data element that describes a reference type is either a type for a [data reference variable](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_reference_variable_glosry.htm "Glossary Entry") or for an [object reference variable](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobject_refer_variable_glosry.htm "Glossary Entry").

-   The [static type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_type_glosry.htm "Glossary Entry") for a data reference variable is either the generic type DATA, any data type from ABAP Dictionary (including [database tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables.htm) or [views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_views.htm)), or a directly specified [built-in data type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm).

-   The [static type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_type_glosry.htm "Glossary Entry") for an object reference variable is either the generic type OBJECT or a global class or global interface from the [class library](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_library_glosry.htm "Glossary Entry").

Notes

-   When existing data elements are modified, all consumers of the data element are also affected. In particular, [foreign keys](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_forkey.htm) can become inconsistent when used for fields of database tables, which makes [conversions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_conv.htm) necessary.

-   Global reference types in ABAP Dictionary can be used to specify types in ABAP programs. They cannot, however, be used for fields of database tables or in CDS views.

Example

The data element S\_CONN\_ID takes its technical attributes (data type NUMC, length 4) from the domain S\_CONN\_ID. The data element S\_CONN\_ID has documentation and further texts that describe its semantics. It is used as a data type of many table fields that match these semantic attributes, such as the column CONNID of the database tables SPFLI, SBOOK, and SFLIGHT.


### abenddic_data_elements_sema.htm

---
title: "Semantic Attributes of Data Elements"
description: |
  The semantic attributes of data elements are mainly significant when they are used as types of fields on user interfaces such as dynpro(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_glosry.htm 'Glossary Entry') (or Web Dynpro(https://help.sap.com/doc/abapdocu_754_index_ht
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements_sema.htm"
abapFile: "abenddic_data_elements_sema.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddic", "elements", "sema"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Data Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) → 

Semantic Attributes of Data Elements

The semantic attributes of data elements are mainly significant when they are used as types of fields on user interfaces such as [dynpro](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_glosry.htm "Glossary Entry") (or [Web Dynpro](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenweb_dynpro_glosry.htm "Glossary Entry")) fields . The only exceptions to this are the default component name and the flag for the change document. ABAP data objects declared with reference to a data element ignore the semantic attributes of the element.

-   Short text

Short text of the data element. The short text assigned to a data element appears as a header in a [field help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfield_help_glosry.htm "Glossary Entry") of all dynpro fields or Web Dynpro fields defined with a direct or indirect reference to the data element.

-   Field label

The short, medium, and long field labels assigned to a data element, plus a header, can be created where appropriate as descriptions or column headers of lists for fields on screens of dynpros or Web Dynpros with direct or indirect reference to the data element. A freely definable maximum length with varying upper limits for the different field labels is applied to all languages and must be set accordingly.

-   Documentation

Documentation of the data element. The documentation created for a data element appears by default as [field help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfield_help_glosry.htm "Glossary Entry") for all dynpro fields or Web Dynpro fields defined with a direct or indirect reference to the data element. If no documentation was created, only the short text appears.

-   Supplement documentation

Additional supplement documentation objects can be created for a data element, with each documentation object identified by a four-digit number. This supplement documentation can be used for program-specific and dynpro-specific [field helps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynp_field_help.htm). The assignment of supplement documentation to a dynpro field is saved in the database table THLPF.

-   Documentation status

The status of the documentation for a data element can be noted as follows for any check tools:

-   Object is documented
    The default setting, indicating that the data element requires documentation.

-   Object not used on a screen
    The data element is not implemented for screen fields of dynpro fields or Web Dynpro fields and no further documentation is required.

-   Object is documented by its short text.
    The short text provides enough documentation.

-   Documentation is currently on hold
    The data element requires documentation but it does not yet exist.

-   Search help

A data element with an elementary data type can be assigned a [search help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_help_glosry.htm "Glossary Entry") and a parameter can be passed to this search help.
This search help is used for the [input help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninput_help_glosry.htm "Glossary Entry") of all dynpro fields or Web Dynpro fields defined with direct or indirect reference to the data element, unless the dynpro field is itself associated with a search help. Search helps cannot be assigned to a data element with a reference type.

-   SPA/GPA parameter

A data element with an elementary data type can be associated with an [SPA/GPA parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmemory.htm).
Dynpro fields defined with direct or indirect reference to the data element are filled with the content of the parameter, unless the dynpro field is itself associated with an SPA/GPA parameter. A data element with a reference type cannot be associated with an SPA/GPA parameter.

-   Flag for input history

The flag for the input history defines whether the input history in SAP GUI is active for dynpro fields defined with direct or indirect reference to the data element. This makes it possible to switch the input history off for sensitive fields.

-   Flag for bidirectional fonts

This flag defines the behavior of dynpro fields or Web Dynpro fields defined with direct or indirect reference to the data element when handling bidirectional fonts (such as Hebrew or Arabic).

-   Writing direction
    This flag can specify the writing direction of a dynpro field as "From left to right", which overwrites the direction "From right to left" specified by logons in a bidirectional font. This flag can be useful for fields with numeric texts.

-   BIDI filter
    This flag can be used to prevent the Unicode formatting characters that specify the writing direction of bidirectional fonts in data transports between GUI and AS ABAP from being filtered out, regardless of the global system settings. The global system setting is made in the program I18N\_SET\_DATAELEMENT\_FLAGS.

-   Default component name

The default component name of a data element is a naming suggestion for structure components or table fields defined with reference to this data element. Structures used in APIs in particular should use this proposal.

-   Flag for change document

The flag for change documents specifies whether changes to fields in database tables defined with reference to this data element are logged when change document objects are involved. A change document object groups multiple tables and is used to generate function modules that can be integrated into ABAP programs and that log changes. This flag cannot be set for data elements with a reference type.

-   Further semantic attributes can be defined in the [domain](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm) referenced by a data element.

The texts in the semantic attributes (the short text, field labels, and documentation) are, like all AS ABAP texts, passed to the translation tools.

Note

It is highly significant that many semantic attributes of a data element define the behavior of dynpro fields or Web Dynpro fields. For example, a data element whose documentation describes the internal attributes of a technical type is not usually suitable for use in UI fields. One example are the data elements SYST\_... that define the components of the system structure SYST. The documentation of these data elements describes the corresponding system fields and must not appear on a UI. Ideally, separate data elements are created with their own semantic attributes for UIs and database tables. Any data elements not used for UI fields do not usually need semantic attributes (except for the short text and possibly documentation). Conversely, attributes such as the flag for change documents are not relevant for data elements for UIs.


### abenddic_domains.htm

---
title: "Domains"
description: |
  A domain is a standalone dictionary object that defines technical and semantic attributes of elementary data types. Data elements(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) can be defined with reference to a domain and inherit its attributes. Domains can
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm"
abapFile: "abenddic_domains.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddic", "domains"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Data Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) → 

Domains

A domain is a standalone dictionary object that defines technical and semantic attributes of elementary data types. [Data elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) can be defined with reference to a domain and inherit its attributes. Domains can only be used in data elements. A domain can be used by any number of data elements.

-   [Technical attributes of domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains_tech.htm)

-   [Semantic attributes of domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains_sema.htm)

Notes

-   Domains are located in a different namespace from data types. A domain can have the exact same name as a data type and, more particularly, a data element.

-   Redundant domains within an application component or a package should be avoided. Domains that only have technical attributes must be created as reusable domains in central basis packages. One example is the domain CHAR255.

-   The [fixed values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfixed_value_glosry.htm "Glossary Entry") of a domain can be used as special literals in [CDS views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry") as well as the full domain being used in data elements.

-   A domain describes the attributes of an elementary data type but is not a data type itself. More specifically, a domain cannot be specified after a TYPE addition in ABAP.

-   Domains can be edited in form-based editors both in the ABAP Dictionary [tool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_tools.htm) and in the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry").

Continue
[Technical Attributes of Domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains_tech.htm)
[Semantic Attributes of Domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains_sema.htm)


### abenddic_domains_tech.htm

---
title: "Technical Attributes of Domains"
description: |
  The only technical attribute of a domain is the description of an elementary data type whose following technical attributes are defined directly in the domain: -   Built-in data type(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) in ABAP Dictionary -   Lengt
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains_tech.htm"
abapFile: "abenddic_domains_tech.htm"
keywords: ["do", "if", "class", "data", "types", "abenddic", "domains", "tech"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Data Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) →  [Domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm) → 

Technical Attributes of Domains

The only technical attribute of a domain is the description of an elementary data type whose following technical attributes are defined directly in the domain:

-   [Built-in data type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) in ABAP Dictionary

-   Length

-   A number of decimal places (optional)

Note

When existing domains are modified, all consumers of the domain are also affected. In particular, [foreign keys](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_forkey.htm) can become inconsistent when used for the fields of database tables, which makes [conversions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_conv.htm) necessary.


### abenddic_domains_sema.htm

---
title: "Semantic Attributes of Domains"
description: |
  Domains can be given the following semantic attributes: -   Short text Each domain has a short description specified when it is created. -   Documentation A domain can be given (optional) documentation. -   Output attributes The output attributes determine how fields defined with reference to a data
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains_sema.htm"
abapFile: "abenddic_domains_sema.htm"
keywords: ["do", "if", "case", "try", "class", "data", "types", "abenddic", "domains", "sema"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Data Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) →  [Domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm) → 

Semantic Attributes of Domains

Domains can be given the following semantic attributes:

-   Short text

Each domain has a short description specified when it is created.

-   Documentation

A domain can be given (optional) documentation.

-   Output attributes

The output attributes determine how fields defined with reference to a data element (that itself references the domain) are displayed on [dynpros or Web Dynpros](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_glosry.htm "Glossary Entry") or when formatted with the statements [WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite-.htm) or [WRITE TO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_to.htm). .

-   Output length
    The (optional) output length overrides the [implicit output length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwrite_output_length.htm) as assigned to the built-in elementary data types. The potential output length is determined by the data type and is checked by ABAP Dictionary [tools](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_tools.htm). If a format is assigned to the built-in data type in question, the output length should be long enough for all formatting characters.

-   Output style
    A domain with the type of a decimal floating point number must be assigned an [output style](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_decimal_floating_point.htm).

-   Conversion routine
    If a domain is assigned to a [conversion routine](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_routine_glosry.htm "Glossary Entry"), the associated function module ...\_INPUT (for each input in a [dynpro field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_field_glosry.htm "Glossary Entry") defined with reference to a data element that itself references the domain) is called. Similarly, the associated function module ...\_OUTPUT (for each output using a dynpro field defined with reference to a data element that itself references the domain) is also called. The function module ...\_OUTPUT is executed in the same way when a data object is formatted using [WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite-.htm) or [WRITE TO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_to.htm) when the data object is declared with reference to a data element of this type.
    

-   Sign
    If a data type of a [dynpro field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_field_glosry.htm "Glossary Entry") defined in ABAP Dictionary is numeric, the "Sign" attribute must be set so that negative numbers can be displayed on the screen. This attribute can only be specified using a domain.

-   Lowercase letters
    If a data type of a [dynpro field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_field_glosry.htm "Glossary Entry") defined in ABAP Dictionary is character-like, the "Lowercase Letters" attribute can be set so that these letters are not transformed to uppercase. This attribute can only be specified using a domain.

-   Time format
    For the data type [TIMS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm), a 24-hour or 12-hour format can be set for displaying dynpro fields in accordance with the ABAP [time formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_formats.htm).

-   Value range

Value ranges for fields on user interfaces can be defined for domains of the [built-in types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) CHAR, NUMC, DEC, INT1, INT2, INT4, and INT8. For domains of the types CHAR and NUMC, this range specifies the valid input values in dynpro fields defined with reference to a data element of the domain in question. The value range is evaluated for all types for the [input help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninput_help_glosry.htm "Glossary Entry") of [dynpro fields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_field_glosry.htm "Glossary Entry") if no input help with a higher priority exists. The value range is ignored for the content of data objects in ABAP programs or of database table fields that reference a data element with a domain of this type. A value range can be defined using the following:

-   Fixed values

-   Intervals

Fixed values and intervals can be combined here as required. The following can be specified as fixed values and interval boundaries:

-   Alphanumeric characters including blanks and special characters for the type CHAR. The length is restricted to 10.

-   Positive integers (including 0) for the types NUMC, INT1, INT2, INT4, INT8, and DEC within the [value range](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) defined by the technical attributes.

A short text can be specified for each fixed value or interval, which is then displayed when used in an input help. The fixed values of a domain can be specified as special [literals](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_f1_literal.htm) in a [CDS view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry"). The fixed values provided by SAP can be enhanced by customers or partners using [fixed value appends](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_fixed_value_appends.htm).

-   Value table

A value table can be a database table that is used as a default for the [check table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_checktab.htm) in cases where a table field of a database table that references a data element with this domain is included in a [foreign key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_forkey.htm). Just specifying a value table does not trigger a check.

Example

The domain S\_CLASS with the type CHAR describes the possible classes in a flight booking. The value range of the domain is defined by the fixed values "C" (Business Class), "F“ (First Class), and "Y“ (Economy Class). This means that only the values "C", "F", and "Y" can be entered for all dynpro fields that point to this domain.


### abenddic_domains.htm

---
title: "Domains"
description: |
  A domain is a standalone dictionary object that defines technical and semantic attributes of elementary data types. Data elements(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) can be defined with reference to a domain and inherit its attributes. Domains can
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm"
abapFile: "abenddic_domains.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddic", "domains"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Data Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) → 

Domains

A domain is a standalone dictionary object that defines technical and semantic attributes of elementary data types. [Data elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) can be defined with reference to a domain and inherit its attributes. Domains can only be used in data elements. A domain can be used by any number of data elements.

-   [Technical attributes of domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains_tech.htm)

-   [Semantic attributes of domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains_sema.htm)

Notes

-   Domains are located in a different namespace from data types. A domain can have the exact same name as a data type and, more particularly, a data element.

-   Redundant domains within an application component or a package should be avoided. Domains that only have technical attributes must be created as reusable domains in central basis packages. One example is the domain CHAR255.

-   The [fixed values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfixed_value_glosry.htm "Glossary Entry") of a domain can be used as special literals in [CDS views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry") as well as the full domain being used in data elements.

-   A domain describes the attributes of an elementary data type but is not a data type itself. More specifically, a domain cannot be specified after a TYPE addition in ABAP.

-   Domains can be edited in form-based editors both in the ABAP Dictionary [tool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_tools.htm) and in the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry").

Continue
[Technical Attributes of Domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains_tech.htm)
[Semantic Attributes of Domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains_sema.htm)


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Structures / Technical Attributes of Structures

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Structures / Dictionary DDL for Structure Definitions

Included pages: 11


### abenddic_define_structure.htm

---
title: "Dictionary DDL for Structure Definitions"
description: |
  In the ABAP Development Tools (ADT)(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm 'Glossary Entry'), a structure can be displayed and modified using source-code-based methods in the Dictionary DDL(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendict
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm"
abapFile: "abenddic_define_structure.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "abenddic", "define", "structure"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) → 

Dictionary DDL for Structure Definitions

In the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry"), a structure can be displayed and modified using source-code-based methods in the [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry"). Here, the source code of a structure is not saved and transported. Instead, the source code of an existing structure is generated from the metadata of the associated system tables. When saved, the metadata is derived directly from the source code and saved to the system tables.

-   [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm)

Note

All properties of a structure described in the preceding sections can be defined using DEFINE STRUCTURE or in transaction SE11.

Continue
[DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm)


### abenddicddl_define_structure.htm

---
title: "DEFINE STRUCTURE"
description: |
  Syntax structure_annos(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm) DEFINE STRUCTURE struct  ... component;(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) ... include;(https://help.sap.com/doc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm"
abapFile: "abenddicddl_define_structure.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "abenddicddl", "define", "structure"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) → 

DEFINE STRUCTURE

Syntax

[structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm)
DEFINE STRUCTURE struct {
  ...
  [component;](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)
  ...
  [include;](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)
  ...
}

Effect

[Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry") statement for defining an ABAP Dictionary [structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) struct in the [ABAP Development Tools](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry").

-   A structure is defined using the statement DEFINE STRUCTURE. The usual restrictions for ABAP Dictionary [data types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) apply to the name struct.

-   The mandatory structure properties must be specified as annotations [structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm) in front of the statement DEFINE STRUCTURE.

-   The structure components are defined in a semicolon-separated list in curly brackets { } by one of the following methods:

-   Defining individual components [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)

-   Including include structures [include](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)

Notes

-   As in the [CDS syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_general_syntax_rules.htm), an ABAP Dictionary structure definition can contain comments after // and between /\* ... \*/.

-   A more detailed description of the syntax is available in the ADT documentation Syntax of ABAP Dictionary Objects.

Example

Defines the structure DEMOFLI in the ADT.

@EndUserText.label : 'Structure for ALV Demo'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demofli {
  fldate   : s\_date;
  seatsmax : s\_seatsmax;
  seatsocc : s\_seatsocc; }

Continue
[DEFINE STRUCTURE - structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm)
[DEFINE STRUCTURE - component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)
[DEFINE STRUCTURE - include](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)


### abenddicddl_define_struct_props.htm

---
title: "Syntax"
description: |
  @EndUserText.label : '...' @AbapCatalog.enhancementCategory : enh_cat Effect Mandatory annotations for specifying structure properties in the definition of a structure using the statement DEFINE STRUCTURE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm"
abapFile: "abenddicddl_define_struct_props.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddicddl", "define", "struct", "props"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) → 

DEFINE STRUCTURE - structure\_annos

Syntax

@EndUserText.label : '...'
@AbapCatalog.enhancementCategory : enh\_cat

Effect

Mandatory annotations for specifying structure properties in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   In quotation marks, @EndUserText.label defines the [short text of the structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) in its original language.

-   @AbapCatalog.enhancementCategory defines the [enhancement category of the structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm). The following can be specified for enh\_cat:

-   #NOT\_CLASSIFIED - [Not classified](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm)

-   #NOT\_EXTENSIBLE - [Cannot be enhanced (extended)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm)

-   #EXTENSIBLE\_CHARACTER - [Can be enhanced (extended) and is character-like](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm)

-   #EXTENSIBLE\_CHARACTER\_NUMERIC - [Can be enhanced (extended) and is character-like or numeric](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm)

-   #EXTENSIBLE\_ANY - [Can be enhanced (extended) in any way](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm)

Notes

-   If specified, #NOT\_CLASSIFIED is used only to display existing structures with this property. Any new or modified structures should always have an enhancement category.

-   The same annotations must also be specified in the definition of a database table using [DEFINE TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table.htm) and an append structure using [EXTEND TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_extend_type.htm).

-   The syntax used to specify the properties is based on [CDS annotations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_annotation_glosry.htm "Glossary Entry"). There are, however, no visible associated [annotation definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_anno_definition_glosry.htm "Glossary Entry").


### abenddicddl_define_struct_comps.htm

---
title: "DEFINE STRUCTURE - component"
description: |
  Syntax component_annos foreign_key_annos(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) KEY comp :  data_element  value_help(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm"
abapFile: "abenddicddl_define_struct_comps.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddicddl", "define", "struct", "comps"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) → 

DEFINE STRUCTURE - component

Syntax

*\[*component\_annos*\]*
*\[*[foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm)*\]*
*\[*KEY*\]* comp : *{* *{*data\_element *\[* [value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm)*\]*
                             *\[*[foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm)*\]**}*
               *|*abap. [type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm)*\[*(n)*|*(n,m)*\]* *}*
           *|* *{* REFERENCE TO any\_type *}*
           *|* *{* struct *\[*BOXED*\]* *}*
           *|* *{* table\_type *}*
           *\[*NOT NULL*\]*;

Effect

Defines a single [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_tech.htm) in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   Optional component properties can be specified using annotations [component\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_cmpprps.htm) before the component itself is specified.

-   [foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) can be used to specify the properties of a foreign key dependency defined with [foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm).

-   comp indicates the name of the component.

-   data\_element or abap.type is used to define an elementary component or a component with a reference type:

-   data\_element can be used to specify an existing [data element](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_element_glosry.htm "Glossary Entry"). If the data element has an elementary data type, an elementary component is defined. If the data element has a reference type, the component is defined with this reference type.

-   abap.type*\[*(n)*|*(n,m)*\]* can be used to specify a built-in data type from ABAP Dictionary and an elementary component of this type is defined. When specified after the mandatory prefix abap, [type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) indicates the type. n and m must be used to specify the length and number of decimal places, as specified by the type.

-   REFERENCE TO any\_type is used to define a reference type. For any\_type, the syntax abap.type*\[*(n)*|*(n,m)*\]* can be used to specify any existing data types from ABAP Dictionary, classes or interfaces from the class library, the generic types DATA or OBJECT, or built-in types.

-   struct *\[*BOXED*\]* is used to define a substructure. Structures, database tables, or views from ABAP Dictionary can all be specified for struct. BOXED can be used to define the substructure as a [static box](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_box_glosry.htm "Glossary Entry").

-   table\_type is used to define a tabular component. [Table types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_type_glosry.htm "Glossary Entry") from ABAP Dictionary can be specified for table\_type.

-   The additions KEY and NOT NULL can be used to define the component as a [key field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) and to set a [flag for initial values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm). Both these additions are only applicable to structures that are included in database tables.

-   The addition [value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm) can be used to assign a search help to a structure component whose data type is defined using a data element with elementary data type.

-   The addition [foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm) can be used to define a [foreign key dependency](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenforeign_key_dependency_glosry.htm "Glossary Entry") for a structure component whose data type is defined using a data element with elementary data type. This addition is only applicable to structures that are included in database tables.

Note

The [activation type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_tech.htm) (relevant only for database tables) cannot be modified using DEFINE STRUCTURE.

Example

Defines elementary components of the structure DEMO\_DAY with reference to built-in dictionary types. In the example for [include structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm), the structure is included more than once in another structure.

@EndUserText.label : 'Demo for include structure'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demo\_day {
  work : abap.char(8);
  free : abap.char(16); }

Continue
[DEFINE STRUCTURE - component\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_cmpprps.htm)
[DEFINE STRUCTURE - value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm)


### abenddicddl_define_struct_cmpprps.htm

---
title: "Syntax"
description: |
  @EndUserText.label : '...' @Semantics.amount.currencyCode : 'struct.comp' @Semantics.quantity.unitOfMeasure : 'struct.comp' Effect Applies annotations to specify optional properties of a component(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_cmpprps.htm"
abapFile: "abenddicddl_define_struct_cmpprps.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddicddl", "define", "struct", "cmpprps"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) →  [DEFINE STRUCTURE - component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) → 

DEFINE STRUCTURE - component\_annos

Syntax

*\[*@EndUserText.label : '...'*\]*
*\[*@Semantics.amount.currencyCode : 'struct.comp'*\]*
*\[*@Semantics.quantity.unitOfMeasure : 'struct.comp'*\]*

Effect

Applies annotations to specify optional properties of a [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   In quotation marks, @EndUserText.label defines the [short text of the component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) in the original language of the structure.

-   @Semantics.amount.currencyCode - Definition of a [reference field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) for a [currency field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_currency_field.htm). A component comp with the built-in dictionary type CUKY from the same or from a different structure struc must be specified in quotation marks.

-   @Semantics.quantity.unitOfMeasure - Definition of a [reference field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) for a [quantity field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_quantity_field.htm). A component comp with the built-in dictionary type UNIT from the same or from a different structure struc must be specified in quotation marks.

Note

The syntax used to specify the properties is based on [CDS annotations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_annotation_glosry.htm "Glossary Entry"). There are, however, no visible associated [annotation definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_anno_definition_glosry.htm "Glossary Entry").

Example

Defines the component weight\_unit as a reference field for the quantity field weight in the same structure.

...
define structure struct {
  ...
  @Semantics.quantity.unitOfMeasure : 'struct.weight\_unit'
  weight :      abap.quan(2);
  weight\_unit : abap.unit(2);
  ...
  }


### abenddicddl_define_struct_valuhelp.htm

---
title: "Syntax"
description: |
  ...  WITH VALUE HELP value_help WHERE parameter1 = structure.component1 AND parameter2 = structure.component2 ... ... Effect Assigns a search help(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_help_glosry.htm 'Glossary Entry') to a structure component(https://hel
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm"
abapFile: "abenddicddl_define_struct_valuhelp.htm"
keywords: ["do", "try", "class", "data", "types", "abenddicddl", "define", "struct", "valuhelp"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) →  [DEFINE STRUCTURE - component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) → 

DEFINE STRUCTURE - value\_help

Syntax

...  WITH VALUE HELP value\_help
       WHERE parameter1 = structure.component1
         *\[*AND parameter2 = structure.component2 ...*\]* ...

Effect

Assigns a [search help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_help_glosry.htm "Glossary Entry") to a [structure component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) whose data type is defined by a data element with an elementary data type in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry"). Here, value\_help is an existing search help in ABAP Dictionary. All parameters of the search help must be associated with structure components after WHERE.

Note

The addition WITH VALUE HELP can be used, with the same meaning, in the definition of a database using [DEFINE TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table.htm).

Example

Defines elementary components with reference to data elements and binds a search help to the second component.

...
define structure struct {
  comp1 : s\_carr\_id;
  comp2 : s\_conn\_id
    with value help demo\_f4\_field
      where carrid = struct.comp1
        and connid = struct.comp2;
  ...
  }


### abenddicddl_define_struct_comps.htm

---
title: "DEFINE STRUCTURE - component"
description: |
  Syntax component_annos foreign_key_annos(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) KEY comp :  data_element  value_help(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm"
abapFile: "abenddicddl_define_struct_comps.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddicddl", "define", "struct", "comps"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) → 

DEFINE STRUCTURE - component

Syntax

*\[*component\_annos*\]*
*\[*[foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm)*\]*
*\[*KEY*\]* comp : *{* *{*data\_element *\[* [value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm)*\]*
                             *\[*[foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm)*\]**}*
               *|*abap. [type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm)*\[*(n)*|*(n,m)*\]* *}*
           *|* *{* REFERENCE TO any\_type *}*
           *|* *{* struct *\[*BOXED*\]* *}*
           *|* *{* table\_type *}*
           *\[*NOT NULL*\]*;

Effect

Defines a single [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_tech.htm) in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   Optional component properties can be specified using annotations [component\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_cmpprps.htm) before the component itself is specified.

-   [foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) can be used to specify the properties of a foreign key dependency defined with [foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm).

-   comp indicates the name of the component.

-   data\_element or abap.type is used to define an elementary component or a component with a reference type:

-   data\_element can be used to specify an existing [data element](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_element_glosry.htm "Glossary Entry"). If the data element has an elementary data type, an elementary component is defined. If the data element has a reference type, the component is defined with this reference type.

-   abap.type*\[*(n)*|*(n,m)*\]* can be used to specify a built-in data type from ABAP Dictionary and an elementary component of this type is defined. When specified after the mandatory prefix abap, [type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) indicates the type. n and m must be used to specify the length and number of decimal places, as specified by the type.

-   REFERENCE TO any\_type is used to define a reference type. For any\_type, the syntax abap.type*\[*(n)*|*(n,m)*\]* can be used to specify any existing data types from ABAP Dictionary, classes or interfaces from the class library, the generic types DATA or OBJECT, or built-in types.

-   struct *\[*BOXED*\]* is used to define a substructure. Structures, database tables, or views from ABAP Dictionary can all be specified for struct. BOXED can be used to define the substructure as a [static box](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_box_glosry.htm "Glossary Entry").

-   table\_type is used to define a tabular component. [Table types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_type_glosry.htm "Glossary Entry") from ABAP Dictionary can be specified for table\_type.

-   The additions KEY and NOT NULL can be used to define the component as a [key field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) and to set a [flag for initial values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm). Both these additions are only applicable to structures that are included in database tables.

-   The addition [value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm) can be used to assign a search help to a structure component whose data type is defined using a data element with elementary data type.

-   The addition [foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm) can be used to define a [foreign key dependency](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenforeign_key_dependency_glosry.htm "Glossary Entry") for a structure component whose data type is defined using a data element with elementary data type. This addition is only applicable to structures that are included in database tables.

Note

The [activation type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_tech.htm) (relevant only for database tables) cannot be modified using DEFINE STRUCTURE.

Example

Defines elementary components of the structure DEMO\_DAY with reference to built-in dictionary types. In the example for [include structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm), the structure is included more than once in another structure.

@EndUserText.label : 'Demo for include structure'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demo\_day {
  work : abap.char(8);
  free : abap.char(16); }

Continue
[DEFINE STRUCTURE - component\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_cmpprps.htm)
[DEFINE STRUCTURE - value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm)


### abenddicddl_define_struct_incl.htm

---
title: "DEFINE STRUCTURE - include"
description: |
  Syntax group : INCLUDE struct WITH SUFFIX suffix ... extend(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm) ...; Effect Includes an include structure(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_inc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm"
abapFile: "abenddicddl_define_struct_incl.htm"
keywords: ["do", "if", "case", "try", "class", "data", "types", "abenddicddl", "define", "struct", "incl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) → 

DEFINE STRUCTURE - include

Syntax

*\[*group :*\]* INCLUDE struct *\[*WITH SUFFIX suffix*\]*
                  *\[*...
                   [extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm)
                   ...*\]*;

Effect

Includes an [include structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm) in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   Any existing structure from ABAP Dictionary, including database tables or views, can be specified as struct.

-   group can be used to specify an optional name of a [group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm).

-   suffix can be used to specify an optional three-character [suffix](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm).

-   A blank-separated list of additions, [extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm), can be used to overwrite the assignment to a search help and the definition of a foreign key dependency for each included component.

Note

The addition INCLUDE can be used with the same semantics in the statement [DEFINE TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table.htm) in cases where the include structure is suitable for database tables.

Example

Syntax for defining the structure DEMO\_WEEK in the ADT.

...
define structure demo\_week {
  monday    : include demo\_day with suffix \_mo;
  tuesday   : include demo\_day with suffix \_tu;
  wednesday : include demo\_day with suffix \_we;
  thursday  : include demo\_day with suffix \_th;
  friday    : include demo\_day with suffix \_fr;
}

Continue
[DEFINE STRUCTURE - extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm)


### abenddicddl_define_struct_comp_ext.htm

---
title: "DEFINE STRUCTURE - extend"
description: |
  Syntax ... foreign_key_annos(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) EXTEND component : value_help(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm) foreign_key ..
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm"
abapFile: "abenddicddl_define_struct_comp_ext.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddicddl", "define", "struct", "comp", "ext"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) →  [DEFINE STRUCTURE - include](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm) → 

DEFINE STRUCTURE - extend

Syntax

... *\[*[foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm)*\]*
    EXTEND component : *\[*[value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm)*\]* *\[*foreign\_key*\]* ...

Effect

Defines component properties when [including](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm) include structures using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry"). The addition EXTEND can be specified for the every component component in the included [include structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm) and defines the following properties for this structure. If any of the properties of the included component already exist, they are overwritten.

-   [foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) - Properties of a foreign key relationship

-   [value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm) - Assignment to a search help.

-   foreign\_key - Definition of a foreign key dependency.

At least one of the additions value\_help and foreign\_key must be specified.

Note

The addition EXTEND can be used for individual components and with the same meaning in the definition of a database table with [DEFINE TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table.htm) or an append structure with [EXTEND TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_extend_type.htm).

Example

Includes a structure include\_struct in a structure struct, where EXTEND is used to assign a search help to the components comp1 and comp2.

...
define structure struct {
  ...
  include include\_struct
    extend comp1 :
      with value help demo\_f4\_field
        where carrid = struct.comp1
          and connid = struct.comp2
    extend comp2 :
      with value help demo\_f4\_field
        where carrid = struct.comp1
          and connid = struct.comp2;
  ...
  }


### abenddicddl_define_struct_incl.htm

---
title: "DEFINE STRUCTURE - include"
description: |
  Syntax group : INCLUDE struct WITH SUFFIX suffix ... extend(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm) ...; Effect Includes an include structure(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_inc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm"
abapFile: "abenddicddl_define_struct_incl.htm"
keywords: ["do", "if", "case", "try", "class", "data", "types", "abenddicddl", "define", "struct", "incl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) → 

DEFINE STRUCTURE - include

Syntax

*\[*group :*\]* INCLUDE struct *\[*WITH SUFFIX suffix*\]*
                  *\[*...
                   [extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm)
                   ...*\]*;

Effect

Includes an [include structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm) in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   Any existing structure from ABAP Dictionary, including database tables or views, can be specified as struct.

-   group can be used to specify an optional name of a [group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm).

-   suffix can be used to specify an optional three-character [suffix](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm).

-   A blank-separated list of additions, [extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm), can be used to overwrite the assignment to a search help and the definition of a foreign key dependency for each included component.

Note

The addition INCLUDE can be used with the same semantics in the statement [DEFINE TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table.htm) in cases where the include structure is suitable for database tables.

Example

Syntax for defining the structure DEMO\_WEEK in the ADT.

...
define structure demo\_week {
  monday    : include demo\_day with suffix \_mo;
  tuesday   : include demo\_day with suffix \_tu;
  wednesday : include demo\_day with suffix \_we;
  thursday  : include demo\_day with suffix \_th;
  friday    : include demo\_day with suffix \_fr;
}

Continue
[DEFINE STRUCTURE - extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm)


### abenddicddl_define_structure.htm

---
title: "DEFINE STRUCTURE"
description: |
  Syntax structure_annos(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm) DEFINE STRUCTURE struct  ... component;(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) ... include;(https://help.sap.com/doc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm"
abapFile: "abenddicddl_define_structure.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "abenddicddl", "define", "structure"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) → 

DEFINE STRUCTURE

Syntax

[structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm)
DEFINE STRUCTURE struct {
  ...
  [component;](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)
  ...
  [include;](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)
  ...
}

Effect

[Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry") statement for defining an ABAP Dictionary [structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) struct in the [ABAP Development Tools](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry").

-   A structure is defined using the statement DEFINE STRUCTURE. The usual restrictions for ABAP Dictionary [data types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) apply to the name struct.

-   The mandatory structure properties must be specified as annotations [structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm) in front of the statement DEFINE STRUCTURE.

-   The structure components are defined in a semicolon-separated list in curly brackets { } by one of the following methods:

-   Defining individual components [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)

-   Including include structures [include](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)

Notes

-   As in the [CDS syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_general_syntax_rules.htm), an ABAP Dictionary structure definition can contain comments after // and between /\* ... \*/.

-   A more detailed description of the syntax is available in the ADT documentation Syntax of ABAP Dictionary Objects.

Example

Defines the structure DEMOFLI in the ADT.

@EndUserText.label : 'Structure for ALV Demo'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demofli {
  fldate   : s\_date;
  seatsmax : s\_seatsmax;
  seatsocc : s\_seatsocc; }

Continue
[DEFINE STRUCTURE - structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm)
[DEFINE STRUCTURE - component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)
[DEFINE STRUCTURE - include](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Structures / Dictionary DDL for Structure Definitions

**Files**: 11 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Structures / Dictionary DDL for Structure Definitions

Included pages: 11


### abenddic_define_structure.htm

---
title: "Dictionary DDL for Structure Definitions"
description: |
  In the ABAP Development Tools (ADT)(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm 'Glossary Entry'), a structure can be displayed and modified using source-code-based methods in the Dictionary DDL(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendict
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm"
abapFile: "abenddic_define_structure.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "abenddic", "define", "structure"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) → 

Dictionary DDL for Structure Definitions

In the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry"), a structure can be displayed and modified using source-code-based methods in the [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry"). Here, the source code of a structure is not saved and transported. Instead, the source code of an existing structure is generated from the metadata of the associated system tables. When saved, the metadata is derived directly from the source code and saved to the system tables.

-   [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm)

Note

All properties of a structure described in the preceding sections can be defined using DEFINE STRUCTURE or in transaction SE11.

Continue
[DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm)


### abenddicddl_define_structure.htm

---
title: "DEFINE STRUCTURE"
description: |
  Syntax structure_annos(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm) DEFINE STRUCTURE struct  ... component;(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) ... include;(https://help.sap.com/doc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm"
abapFile: "abenddicddl_define_structure.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "abenddicddl", "define", "structure"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) → 

DEFINE STRUCTURE

Syntax

[structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm)
DEFINE STRUCTURE struct {
  ...
  [component;](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)
  ...
  [include;](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)
  ...
}

Effect

[Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry") statement for defining an ABAP Dictionary [structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) struct in the [ABAP Development Tools](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry").

-   A structure is defined using the statement DEFINE STRUCTURE. The usual restrictions for ABAP Dictionary [data types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) apply to the name struct.

-   The mandatory structure properties must be specified as annotations [structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm) in front of the statement DEFINE STRUCTURE.

-   The structure components are defined in a semicolon-separated list in curly brackets { } by one of the following methods:

-   Defining individual components [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)

-   Including include structures [include](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)

Notes

-   As in the [CDS syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_general_syntax_rules.htm), an ABAP Dictionary structure definition can contain comments after // and between /\* ... \*/.

-   A more detailed description of the syntax is available in the ADT documentation Syntax of ABAP Dictionary Objects.

Example

Defines the structure DEMOFLI in the ADT.

@EndUserText.label : 'Structure for ALV Demo'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demofli {
  fldate   : s\_date;
  seatsmax : s\_seatsmax;
  seatsocc : s\_seatsocc; }

Continue
[DEFINE STRUCTURE - structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm)
[DEFINE STRUCTURE - component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)
[DEFINE STRUCTURE - include](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)


### abenddicddl_define_struct_props.htm

---
title: "Syntax"
description: |
  @EndUserText.label : '...' @AbapCatalog.enhancementCategory : enh_cat Effect Mandatory annotations for specifying structure properties in the definition of a structure using the statement DEFINE STRUCTURE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm"
abapFile: "abenddicddl_define_struct_props.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddicddl", "define", "struct", "props"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) → 

DEFINE STRUCTURE - structure\_annos

Syntax

@EndUserText.label : '...'
@AbapCatalog.enhancementCategory : enh\_cat

Effect

Mandatory annotations for specifying structure properties in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   In quotation marks, @EndUserText.label defines the [short text of the structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) in its original language.

-   @AbapCatalog.enhancementCategory defines the [enhancement category of the structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm). The following can be specified for enh\_cat:

-   #NOT\_CLASSIFIED - [Not classified](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm)

-   #NOT\_EXTENSIBLE - [Cannot be enhanced (extended)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm)

-   #EXTENSIBLE\_CHARACTER - [Can be enhanced (extended) and is character-like](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm)

-   #EXTENSIBLE\_CHARACTER\_NUMERIC - [Can be enhanced (extended) and is character-like or numeric](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm)

-   #EXTENSIBLE\_ANY - [Can be enhanced (extended) in any way](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm)

Notes

-   If specified, #NOT\_CLASSIFIED is used only to display existing structures with this property. Any new or modified structures should always have an enhancement category.

-   The same annotations must also be specified in the definition of a database table using [DEFINE TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table.htm) and an append structure using [EXTEND TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_extend_type.htm).

-   The syntax used to specify the properties is based on [CDS annotations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_annotation_glosry.htm "Glossary Entry"). There are, however, no visible associated [annotation definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_anno_definition_glosry.htm "Glossary Entry").


### abenddicddl_define_struct_comps.htm

---
title: "DEFINE STRUCTURE - component"
description: |
  Syntax component_annos foreign_key_annos(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) KEY comp :  data_element  value_help(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm"
abapFile: "abenddicddl_define_struct_comps.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddicddl", "define", "struct", "comps"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) → 

DEFINE STRUCTURE - component

Syntax

*\[*component\_annos*\]*
*\[*[foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm)*\]*
*\[*KEY*\]* comp : *{* *{*data\_element *\[* [value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm)*\]*
                             *\[*[foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm)*\]**}*
               *|*abap. [type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm)*\[*(n)*|*(n,m)*\]* *}*
           *|* *{* REFERENCE TO any\_type *}*
           *|* *{* struct *\[*BOXED*\]* *}*
           *|* *{* table\_type *}*
           *\[*NOT NULL*\]*;

Effect

Defines a single [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_tech.htm) in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   Optional component properties can be specified using annotations [component\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_cmpprps.htm) before the component itself is specified.

-   [foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) can be used to specify the properties of a foreign key dependency defined with [foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm).

-   comp indicates the name of the component.

-   data\_element or abap.type is used to define an elementary component or a component with a reference type:

-   data\_element can be used to specify an existing [data element](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_element_glosry.htm "Glossary Entry"). If the data element has an elementary data type, an elementary component is defined. If the data element has a reference type, the component is defined with this reference type.

-   abap.type*\[*(n)*|*(n,m)*\]* can be used to specify a built-in data type from ABAP Dictionary and an elementary component of this type is defined. When specified after the mandatory prefix abap, [type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) indicates the type. n and m must be used to specify the length and number of decimal places, as specified by the type.

-   REFERENCE TO any\_type is used to define a reference type. For any\_type, the syntax abap.type*\[*(n)*|*(n,m)*\]* can be used to specify any existing data types from ABAP Dictionary, classes or interfaces from the class library, the generic types DATA or OBJECT, or built-in types.

-   struct *\[*BOXED*\]* is used to define a substructure. Structures, database tables, or views from ABAP Dictionary can all be specified for struct. BOXED can be used to define the substructure as a [static box](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_box_glosry.htm "Glossary Entry").

-   table\_type is used to define a tabular component. [Table types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_type_glosry.htm "Glossary Entry") from ABAP Dictionary can be specified for table\_type.

-   The additions KEY and NOT NULL can be used to define the component as a [key field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) and to set a [flag for initial values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm). Both these additions are only applicable to structures that are included in database tables.

-   The addition [value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm) can be used to assign a search help to a structure component whose data type is defined using a data element with elementary data type.

-   The addition [foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm) can be used to define a [foreign key dependency](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenforeign_key_dependency_glosry.htm "Glossary Entry") for a structure component whose data type is defined using a data element with elementary data type. This addition is only applicable to structures that are included in database tables.

Note

The [activation type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_tech.htm) (relevant only for database tables) cannot be modified using DEFINE STRUCTURE.

Example

Defines elementary components of the structure DEMO\_DAY with reference to built-in dictionary types. In the example for [include structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm), the structure is included more than once in another structure.

@EndUserText.label : 'Demo for include structure'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demo\_day {
  work : abap.char(8);
  free : abap.char(16); }

Continue
[DEFINE STRUCTURE - component\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_cmpprps.htm)
[DEFINE STRUCTURE - value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm)


### abenddicddl_define_struct_cmpprps.htm

---
title: "Syntax"
description: |
  @EndUserText.label : '...' @Semantics.amount.currencyCode : 'struct.comp' @Semantics.quantity.unitOfMeasure : 'struct.comp' Effect Applies annotations to specify optional properties of a component(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_cmpprps.htm"
abapFile: "abenddicddl_define_struct_cmpprps.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddicddl", "define", "struct", "cmpprps"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) →  [DEFINE STRUCTURE - component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) → 

DEFINE STRUCTURE - component\_annos

Syntax

*\[*@EndUserText.label : '...'*\]*
*\[*@Semantics.amount.currencyCode : 'struct.comp'*\]*
*\[*@Semantics.quantity.unitOfMeasure : 'struct.comp'*\]*

Effect

Applies annotations to specify optional properties of a [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   In quotation marks, @EndUserText.label defines the [short text of the component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) in the original language of the structure.

-   @Semantics.amount.currencyCode - Definition of a [reference field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) for a [currency field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_currency_field.htm). A component comp with the built-in dictionary type CUKY from the same or from a different structure struc must be specified in quotation marks.

-   @Semantics.quantity.unitOfMeasure - Definition of a [reference field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) for a [quantity field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_quantity_field.htm). A component comp with the built-in dictionary type UNIT from the same or from a different structure struc must be specified in quotation marks.

Note

The syntax used to specify the properties is based on [CDS annotations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_annotation_glosry.htm "Glossary Entry"). There are, however, no visible associated [annotation definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_anno_definition_glosry.htm "Glossary Entry").

Example

Defines the component weight\_unit as a reference field for the quantity field weight in the same structure.

...
define structure struct {
  ...
  @Semantics.quantity.unitOfMeasure : 'struct.weight\_unit'
  weight :      abap.quan(2);
  weight\_unit : abap.unit(2);
  ...
  }


### abenddicddl_define_struct_valuhelp.htm

---
title: "Syntax"
description: |
  ...  WITH VALUE HELP value_help WHERE parameter1 = structure.component1 AND parameter2 = structure.component2 ... ... Effect Assigns a search help(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_help_glosry.htm 'Glossary Entry') to a structure component(https://hel
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm"
abapFile: "abenddicddl_define_struct_valuhelp.htm"
keywords: ["do", "try", "class", "data", "types", "abenddicddl", "define", "struct", "valuhelp"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) →  [DEFINE STRUCTURE - component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) → 

DEFINE STRUCTURE - value\_help

Syntax

...  WITH VALUE HELP value\_help
       WHERE parameter1 = structure.component1
         *\[*AND parameter2 = structure.component2 ...*\]* ...

Effect

Assigns a [search help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_help_glosry.htm "Glossary Entry") to a [structure component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) whose data type is defined by a data element with an elementary data type in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry"). Here, value\_help is an existing search help in ABAP Dictionary. All parameters of the search help must be associated with structure components after WHERE.

Note

The addition WITH VALUE HELP can be used, with the same meaning, in the definition of a database using [DEFINE TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table.htm).

Example

Defines elementary components with reference to data elements and binds a search help to the second component.

...
define structure struct {
  comp1 : s\_carr\_id;
  comp2 : s\_conn\_id
    with value help demo\_f4\_field
      where carrid = struct.comp1
        and connid = struct.comp2;
  ...
  }


### abenddicddl_define_struct_comps.htm

---
title: "DEFINE STRUCTURE - component"
description: |
  Syntax component_annos foreign_key_annos(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) KEY comp :  data_element  value_help(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm"
abapFile: "abenddicddl_define_struct_comps.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddicddl", "define", "struct", "comps"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) → 

DEFINE STRUCTURE - component

Syntax

*\[*component\_annos*\]*
*\[*[foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm)*\]*
*\[*KEY*\]* comp : *{* *{*data\_element *\[* [value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm)*\]*
                             *\[*[foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm)*\]**}*
               *|*abap. [type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm)*\[*(n)*|*(n,m)*\]* *}*
           *|* *{* REFERENCE TO any\_type *}*
           *|* *{* struct *\[*BOXED*\]* *}*
           *|* *{* table\_type *}*
           *\[*NOT NULL*\]*;

Effect

Defines a single [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_tech.htm) in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   Optional component properties can be specified using annotations [component\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_cmpprps.htm) before the component itself is specified.

-   [foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) can be used to specify the properties of a foreign key dependency defined with [foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm).

-   comp indicates the name of the component.

-   data\_element or abap.type is used to define an elementary component or a component with a reference type:

-   data\_element can be used to specify an existing [data element](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_element_glosry.htm "Glossary Entry"). If the data element has an elementary data type, an elementary component is defined. If the data element has a reference type, the component is defined with this reference type.

-   abap.type*\[*(n)*|*(n,m)*\]* can be used to specify a built-in data type from ABAP Dictionary and an elementary component of this type is defined. When specified after the mandatory prefix abap, [type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) indicates the type. n and m must be used to specify the length and number of decimal places, as specified by the type.

-   REFERENCE TO any\_type is used to define a reference type. For any\_type, the syntax abap.type*\[*(n)*|*(n,m)*\]* can be used to specify any existing data types from ABAP Dictionary, classes or interfaces from the class library, the generic types DATA or OBJECT, or built-in types.

-   struct *\[*BOXED*\]* is used to define a substructure. Structures, database tables, or views from ABAP Dictionary can all be specified for struct. BOXED can be used to define the substructure as a [static box](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_box_glosry.htm "Glossary Entry").

-   table\_type is used to define a tabular component. [Table types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_type_glosry.htm "Glossary Entry") from ABAP Dictionary can be specified for table\_type.

-   The additions KEY and NOT NULL can be used to define the component as a [key field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm) and to set a [flag for initial values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_sema.htm). Both these additions are only applicable to structures that are included in database tables.

-   The addition [value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm) can be used to assign a search help to a structure component whose data type is defined using a data element with elementary data type.

-   The addition [foreign\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_forkey.htm) can be used to define a [foreign key dependency](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenforeign_key_dependency_glosry.htm "Glossary Entry") for a structure component whose data type is defined using a data element with elementary data type. This addition is only applicable to structures that are included in database tables.

Note

The [activation type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_tech.htm) (relevant only for database tables) cannot be modified using DEFINE STRUCTURE.

Example

Defines elementary components of the structure DEMO\_DAY with reference to built-in dictionary types. In the example for [include structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm), the structure is included more than once in another structure.

@EndUserText.label : 'Demo for include structure'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demo\_day {
  work : abap.char(8);
  free : abap.char(16); }

Continue
[DEFINE STRUCTURE - component\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_cmpprps.htm)
[DEFINE STRUCTURE - value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm)


### abenddicddl_define_struct_incl.htm

---
title: "DEFINE STRUCTURE - include"
description: |
  Syntax group : INCLUDE struct WITH SUFFIX suffix ... extend(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm) ...; Effect Includes an include structure(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_inc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm"
abapFile: "abenddicddl_define_struct_incl.htm"
keywords: ["do", "if", "case", "try", "class", "data", "types", "abenddicddl", "define", "struct", "incl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) → 

DEFINE STRUCTURE - include

Syntax

*\[*group :*\]* INCLUDE struct *\[*WITH SUFFIX suffix*\]*
                  *\[*...
                   [extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm)
                   ...*\]*;

Effect

Includes an [include structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm) in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   Any existing structure from ABAP Dictionary, including database tables or views, can be specified as struct.

-   group can be used to specify an optional name of a [group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm).

-   suffix can be used to specify an optional three-character [suffix](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm).

-   A blank-separated list of additions, [extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm), can be used to overwrite the assignment to a search help and the definition of a foreign key dependency for each included component.

Note

The addition INCLUDE can be used with the same semantics in the statement [DEFINE TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table.htm) in cases where the include structure is suitable for database tables.

Example

Syntax for defining the structure DEMO\_WEEK in the ADT.

...
define structure demo\_week {
  monday    : include demo\_day with suffix \_mo;
  tuesday   : include demo\_day with suffix \_tu;
  wednesday : include demo\_day with suffix \_we;
  thursday  : include demo\_day with suffix \_th;
  friday    : include demo\_day with suffix \_fr;
}

Continue
[DEFINE STRUCTURE - extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm)


### abenddicddl_define_struct_comp_ext.htm

---
title: "DEFINE STRUCTURE - extend"
description: |
  Syntax ... foreign_key_annos(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) EXTEND component : value_help(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm) foreign_key ..
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm"
abapFile: "abenddicddl_define_struct_comp_ext.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenddicddl", "define", "struct", "comp", "ext"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) →  [DEFINE STRUCTURE - include](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm) → 

DEFINE STRUCTURE - extend

Syntax

... *\[*[foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm)*\]*
    EXTEND component : *\[*[value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm)*\]* *\[*foreign\_key*\]* ...

Effect

Defines component properties when [including](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm) include structures using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry"). The addition EXTEND can be specified for the every component component in the included [include structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm) and defines the following properties for this structure. If any of the properties of the included component already exist, they are overwritten.

-   [foreign\_key\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table_fkprps.htm) - Properties of a foreign key relationship

-   [value\_help](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_valuhelp.htm) - Assignment to a search help.

-   foreign\_key - Definition of a foreign key dependency.

At least one of the additions value\_help and foreign\_key must be specified.

Note

The addition EXTEND can be used for individual components and with the same meaning in the definition of a database table with [DEFINE TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table.htm) or an append structure with [EXTEND TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_extend_type.htm).

Example

Includes a structure include\_struct in a structure struct, where EXTEND is used to assign a search help to the components comp1 and comp2.

...
define structure struct {
  ...
  include include\_struct
    extend comp1 :
      with value help demo\_f4\_field
        where carrid = struct.comp1
          and connid = struct.comp2
    extend comp2 :
      with value help demo\_f4\_field
        where carrid = struct.comp1
          and connid = struct.comp2;
  ...
  }


### abenddicddl_define_struct_incl.htm

---
title: "DEFINE STRUCTURE - include"
description: |
  Syntax group : INCLUDE struct WITH SUFFIX suffix ... extend(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm) ...; Effect Includes an include structure(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_inc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm"
abapFile: "abenddicddl_define_struct_incl.htm"
keywords: ["do", "if", "case", "try", "class", "data", "types", "abenddicddl", "define", "struct", "incl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) →  [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) → 

DEFINE STRUCTURE - include

Syntax

*\[*group :*\]* INCLUDE struct *\[*WITH SUFFIX suffix*\]*
                  *\[*...
                   [extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm)
                   ...*\]*;

Effect

Includes an [include structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm) in the definition of a structure using the statement [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm) in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry").

-   Any existing structure from ABAP Dictionary, including database tables or views, can be specified as struct.

-   group can be used to specify an optional name of a [group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm).

-   suffix can be used to specify an optional three-character [suffix](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_include_structure.htm).

-   A blank-separated list of additions, [extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm), can be used to overwrite the assignment to a search help and the definition of a foreign key dependency for each included component.

Note

The addition INCLUDE can be used with the same semantics in the statement [DEFINE TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_table.htm) in cases where the include structure is suitable for database tables.

Example

Syntax for defining the structure DEMO\_WEEK in the ADT.

...
define structure demo\_week {
  monday    : include demo\_day with suffix \_mo;
  tuesday   : include demo\_day with suffix \_tu;
  wednesday : include demo\_day with suffix \_we;
  thursday  : include demo\_day with suffix \_th;
  friday    : include demo\_day with suffix \_fr;
}

Continue
[DEFINE STRUCTURE - extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm)


### abenddicddl_define_structure.htm

---
title: "DEFINE STRUCTURE"
description: |
  Syntax structure_annos(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm) DEFINE STRUCTURE struct  ... component;(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) ... include;(https://help.sap.com/doc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm"
abapFile: "abenddicddl_define_structure.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "abenddicddl", "define", "structure"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) →  [Dictionary DDL for Structure Definitions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_define_structure.htm) → 

DEFINE STRUCTURE

Syntax

[structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm)
DEFINE STRUCTURE struct {
  ...
  [component;](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)
  ...
  [include;](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)
  ...
}

Effect

[Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry") statement for defining an ABAP Dictionary [structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) struct in the [ABAP Development Tools](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry").

-   A structure is defined using the statement DEFINE STRUCTURE. The usual restrictions for ABAP Dictionary [data types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) apply to the name struct.

-   The mandatory structure properties must be specified as annotations [structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm) in front of the statement DEFINE STRUCTURE.

-   The structure components are defined in a semicolon-separated list in curly brackets { } by one of the following methods:

-   Defining individual components [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)

-   Including include structures [include](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)

Notes

-   As in the [CDS syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_general_syntax_rules.htm), an ABAP Dictionary structure definition can contain comments after // and between /\* ... \*/.

-   A more detailed description of the syntax is available in the ADT documentation Syntax of ABAP Dictionary Objects.

Example

Defines the structure DEMOFLI in the ADT.

@EndUserText.label : 'Structure for ALV Demo'
@AbapCatalog.enhancementCategory : #NOT\_EXTENSIBLE
define structure demofli {
  fldate   : s\_date;
  seatsmax : s\_seatsmax;
  seatsocc : s\_seatsocc; }

Continue
[DEFINE STRUCTURE - structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm)
[DEFINE STRUCTURE - component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)
[DEFINE STRUCTURE - include](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Table Types

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Data Types / Table Types

Included pages: 4


### abenddic_table_types.htm

---
title: "Table Types"
description: |
  A table type in ABAP Dictionary defines the data type of an internal table(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_table_glosry.htm 'Glossary Entry') in ABAP. The table type defines the following in an internal table: -   Row type(https://help.sap.com/doc/abapdocu
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types.htm"
abapFile: "abenddic_table_types.htm"
keywords: ["do", "if", "try", "class", "data", "types", "internal-table", "abenddic", "table"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) → 

Table Types

A table type in ABAP Dictionary defines the data type of an [internal table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_table_glosry.htm "Glossary Entry") in ABAP. The table type defines the following in an internal table:

-   [Row type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrow_type_glosry.htm "Glossary Entry")

-   The [table category](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_category_glosry.htm "Glossary Entry")

-   The [table key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_key_glosry.htm "Glossary Entry")

An internal program object declared with reference to a table type is an internal table of this type.

-   [Technical attributes of table types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types_tech.htm)

-   [Semantic attributes of table types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types_sema.htm)

Note

Unlike in [data elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) and [structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm), the table types in ABAP Dictionary exist only to create globally visible definitions of internal tables. Table types replace the definition of internal tables in [type groups](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") and can themselves be replaced using the declaration of internal table types in global classes and interfaces (if the context where the type is required is suitable). The attributes of an internal table that can be defined in ABAP Dictionary match in full those that can be specified using the statement [TYPES ... TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm) in ABAP programs. More information can be found in the in-depth documentation about internal tables in [ABAP - Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenitab.htm).

Example

The table type SPFLI\_KEY\_TAB describes a hashed table with the structured row type SPFLI with a unique primary key and two non-unique secondary table keys.

Continue
[Technical Attributes of Table Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types_tech.htm)
[Semantic Attributes of Table Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types_sema.htm)
[Ranges Table Type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types_ranges.htm)


### abenddic_table_types_tech.htm

---
title: "Technical Attributes of Table Types"
description: |
  A table type describes an internal table(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_table_glosry.htm 'Glossary Entry') with the following technical attributes: -   Row type The row type can be defined as follows: -   Any row type can be defined by referencing any data
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types_tech.htm"
abapFile: "abenddic_table_types_tech.htm"
keywords: ["loop", "do", "if", "case", "try", "method", "class", "data", "types", "internal-table", "field-symbol", "abenddic", "table", "tech"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Table Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types.htm) → 

Technical Attributes of Table Types

A table type describes an [internal table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_table_glosry.htm "Glossary Entry") with the following technical attributes:

-   Row type

The row type can be defined as follows:

-   Any row type can be defined by referencing any [data type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm), including [database tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables.htm) and [classic views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_views.htm) in ABAP Dictionary.

-   Elementary or reference-like row types can also be specified by using their technical attributes directly. This is done in the same way as with [data elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) or [structure components](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_tech.htm).

-   Table category

The table category can be specified as follows:

-   [Standard table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_table_glosry.htm "Glossary Entry")

-   [Sorted table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensorted_table_glosry.htm "Glossary Entry")

-   [Hashed table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhashed_table_glosry.htm "Glossary Entry")

-   [Index table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenindex_table_glosry.htm "Glossary Entry") as a generic table category for standard tables and sorted tables

-   Any table as a generic table category for all table categories

These methods are the same as defining the table category using the statement [TYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_tabkind.htm).

-   Table key

The following can be defined as table keys:

-   A primary key as a [primary table key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprimary_table_key_glosry.htm "Glossary Entry"). The primary key is either the [standard key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_key_glosry.htm "Glossary Entry"), the entire table row (if this is not a table type or does not contain a table type as component), or is defined using individual components of a structured row type in the relevant order. A primary key of sorted tables and hashed tables can be given a unique [alias name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenalias_glosry.htm "Glossary Entry") from the namespace of the secondary keys. It is not currently possible to specify an [empty primary table key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenitab_empty_key.htm) explicitly in ABAP Dictionary. Depending on the table category, the primary key is either unique or non-unique (and cannot be specified at all in the case of generic table categories). If no primary key is specified or its uniqueness is not defined, the table type is generic with respect to this attribute.

-   Up to 15 secondary keys as [secondary table keys](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensecondary_table_key_glosry.htm "Glossary Entry"). Each secondary key has a unique name, which cannot be PRIMARY\_KEY or LOOP\_KEY, and is either a sorted key or a hash key. Sorted keys can be either unique or non-unique and a hash key is always unique. A secondary key is defined either by the entire table row (if this is not a table type or does not contain a table type as component), or is defined using individual components of a structured row type in the relevant order. Using the additions [WITH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_keydef.htm) or [WITHOUT FURTHER SECONDARY KEYS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_keydef.htm) of the statement TYPES, it is possible to define explicitly whether the table type is generic with respect to the secondary keys.

-   Initial row count

This is information for internal memory management of internal tables and corresponds to the addition [INITIAL SIZE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm) in the declaration of an internal table in an ABAP program.

Notes

-   Generic table types (namely table types for which one or more attributes are generic) can only be used in ABAP for [generic typings](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneric_typing_glosry.htm "Glossary Entry") of formal parameters or field symbols.

-   A row type cannot be defined using a reference to a [CDS entity](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_entity_glosry.htm "Glossary Entry"), but it can be defined using a reference to a [CDS database view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_database_view_glosry.htm "Glossary Entry") of a [CDS view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_entity_glosry.htm "Glossary Entry").


### abenddic_table_types_sema.htm

---
title: "Semantic Attributes of Table Types"
description: |
  Table types in ABAP Dictionary can be given the following semantic attributes: -   Short text of the table type Each table type has a short description specified when it is created. -   Documentation A table type can be given (optional) documentation. -   Short description of a secondary key Each se
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types_sema.htm"
abapFile: "abenddic_table_types_sema.htm"
keywords: ["do", "if", "class", "data", "types", "abenddic", "table", "sema"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Table Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types.htm) → 

Semantic Attributes of Table Types

Table types in ABAP Dictionary can be given the following semantic attributes:

-   Short text of the table type

Each table type has a short description specified when it is created.

-   Documentation

A table type can be given (optional) documentation.

-   Short description of a secondary key

Each secondary key has a short description specified when it is created.


### abenddic_table_types_ranges.htm

---
title: "Ranges Table Type"
description: |
  A ranges table type is a table type for a ranges table(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenranges_table_glosry.htm 'Glossary Entry'). A ranges table is a standard table with a standard key and a specially structured row type and can be used in general logical expressions
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types_ranges.htm"
abapFile: "abenddic_table_types_ranges.htm"
keywords: ["select", "do", "if", "try", "class", "data", "types", "abenddic", "table", "ranges"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) →  [Table Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_table_types.htm) → 

Ranges Table Type

A ranges table type is a table type for a [ranges table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenranges_table_glosry.htm "Glossary Entry"). A ranges table is a standard table with a standard key and a specially structured row type and can be used in general logical expressions with the relational expression [IN range tab](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogexp_select_option.htm) or used after WHERE in ABAP SQL with the relational expression [IN range tab](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwhere_logexp_seltab.htm). In ABAP Dictionary, ranges table types are created in the same way as with the statement [TYPES ... RANGE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_ranges.htm).

The data types of the components SIGN and OPTION are the data elements DDSIGN and DDOPTION. The data type for the components LOW and HIGH must be elementary and can be specified directly as a [built-in data type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) or using a [data element](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm).

The structure of the ranges table must be a standalone structure in ABAP Dictionary. When a ranges table type is defined, it can be created from the types specified for the components LOW and HIGH.

Notes

-   In ABAP programs, ranges tables can also be defined with reference to data types other than elementary data types.

-   In ABAP programs, the structure of a ranges table does not need to be a standalone structure.


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Views

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Views

Included pages: 8


### abenddic_views.htm

---
title: "Views"
description: |
  A view in ABAP Dictionary is a grouping of columns in one or more database tables in accordance with an application-specific view. In AS ABAP, views are defined in ABAP Dictionary and can be referenced as data types (like flat structures). Views can be used like database tables in ABAP SQL read stat
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_views.htm"
abapFile: "abenddic_views.htm"
keywords: ["select", "do", "if", "try", "class", "data", "types", "abenddic", "views"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) → 

Views

A view in ABAP Dictionary is a grouping of columns in one or more database tables in accordance with an application-specific view. In AS ABAP, views are defined in ABAP Dictionary and can be referenced as data types (like flat structures). Views can be used like database tables in ABAP SQL read statements (and sometimes in write statements). For this reason, the ABAP Dictionary views are in the same namespace as all types and database tables in ABAP Dictionary and the global [object types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobject_type_glosry.htm "Glossary Entry") in the [class library](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_library_glosry.htm "Glossary Entry").

The name of a view can have a maximum of 16 characters, can consist of letters, numbers, and underscores, must start with a letter, and can be prefixed by a [namespace prefix](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenname_space_prefix_glosry.htm "Glossary Entry") (/.../) of a [prefix namespace](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprefix_name_space_glosry.htm "Glossary Entry"). The name is in the namespace of the [data types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_types.htm) in ABAP Dictionary.

The data in a view is read from the database tables involved by the database and is not saved physically.

-   Views for a database table can be used to restrict database access to specific fields (known as projection) or to specific rows (known as selection).

-   Views for multiple database tables use joins or subqueries to join these tables and to read the required fields and rows.

The views in ABAP Dictionary are usually platform-independent. With some special exceptions, the views in ABAP Dictionary are, when activated, transformed into platform-specific [SQL views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensql_view_glosry.htm "Glossary Entry") in the current [standard AS ABAP database](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_db_glosry.htm "Glossary Entry") in the [ABAP database schema](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_db_schema_glosry.htm "Glossary Entry"). This is done using the [DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddl_glosry.htm "Glossary Entry") statement CREATE VIEW with the addition AS SELECT, which formulates the corresponding SELECT statement. The definition of a view in the database can be displayed in ABAP Dictionary by choosing Utilities → Database Object.

ABAP Dictionary manages the following categories of views:

-   [Classic views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_views.htm)

In classic views (or views for short), the platform-dependent DDL statement is created from the definition of the view in the form-based ABAP Dictionary [tool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_tools.htm).

-   [External views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_external_views.htm)

An external view externalizes an [SAP HANA view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhana_view_glosry.htm "Glossary Entry") in ABAP programs and makes it usable like a regular view in ABAP Dictionary.

When a view is accessed using the ABAP SQL statement [SELECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect.htm), the SELECT statement defined in the DDL statement is executed and the results set is returned as if a SELECT were executed on a database table whose structure matches the structure defined by the view.

Notes

-   Views are usually defined in the implementation of data models in ABAP Dictionary and this is not usually the job of a regular ABAP application programmer. Once created, views are used in ABAP programs using ABAP SQL statements and must be stable enough to allow this.

-   When making selections using views, it is also important that suitable [indexes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_index.htm) are created for the basis tables in the view.

-   The [CDS views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_cds_views.htm) in the [ABAP Core Data Services (CDS)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds.htm) are added to the views specified. A CDS view is defined in a (mostly) platform-independent [CDS DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_ddl_glosry.htm "Glossary Entry") in [DDL source code](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddl_source_code_glosry.htm "Glossary Entry"). CDS views expand on the functions provided by the classic views.

Continue
[Classic Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_views.htm)
[External Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_external_views.htm)


### abenddic_classical_views.htm

---
title: "Classic Views"
description: |
  A classic view (or view for short) is a repository object in ABAP Dictionary defined for existing database tables and their fields in the form-based ABAP Dictionary tool(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_tools.htm) in ABAP Workbench(https://help.sap.com/doc/abap
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_views.htm"
abapFile: "abenddic_classical_views.htm"
keywords: ["select", "insert", "update", "do", "while", "if", "case", "try", "class", "data", "types", "abenddic", "classical", "views"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_views.htm) → 

Classic Views

A classic view (or view for short) is a repository object in ABAP Dictionary defined for existing database tables and their fields in the form-based ABAP Dictionary [tool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_tools.htm) in [ABAP Workbench](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_workbench_glosry.htm "Glossary Entry"). As well as the classic views, the ABAP Dictionary also manages the [CDS views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry") of the [ABAP Core Data Services](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds.htm), which are defined by the [CDS DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_ddl_glosry.htm "Glossary Entry") in [DDL source code](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddl_source_code_glosry.htm "Glossary Entry").

The definition of a classic view consists of the following:

-   Basis tables

A list of database tables accessed by the view. Multiple tables are joined using joins.

-   View fields

A list of table fields of the basis tables that defines the structure of the view. Except in the case of projection views, a different [data element](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) can be assigned to a view field that that used for the corresponding table field of the basis table. This can only happen if the type of the table field is defined using a data element with a [domain](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm) and if the new data element references the same domain. This makes it possible to adjust the semantic attributes of the view field to the view.

-   Key

A key of the view that consists of key fields. The tool derives the key of a view from the key fields of the basis tables and the join conditions. All the key fields must be located contiguously at the start of the view. Fields that do not belong to the key, but are located between the key fields, are thus marked as key fields. All rows determined by the view must be unique with respect to the key. If no key with this property can be identified, all fields of the view are key fields, which can be bad for performance. In the case of ABAP SQL accesses to the view, its key behaves like the key of a database table.

-   Join conditions

Conditions for joining multiple basis tables using inner joins or outer joins. A join condition compares two fields from basis tables of a view for equality. If no join conditions are specified for a pair of basis tables, the view is used to select the cross product of the basis tables. Each row in a table is combined with each row of the other table. Each join condition then selects the matching rows from the cross product.

-   Selection conditions

Used to restrict the read rows to specific values of view fields or other fields.

-   The possible relational operators are \=, <>, \>=, \>, <=, <, LIKE, and NOT LIKE.

-   Depending on the data type of the view field, constant texts and numbers are allowed as comparison values. [System fields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_field_glosry.htm "Glossary Entry") can be specified for maintenance views and help views using SYST-... or SY-....

-   Multiple comparisons can be joined using AND and multiple comparisons for the same field can be joined using OR. Here, OR is stronger than AND.

The following types of classic views exist, of which only the database views are defined as SQL views on the database:

-   [Database views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_views.htm)

-   [Projection views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_projection_views.htm)

-   [Maintenance views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_maintenance_views.htm)

-   [Help views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_help_views.htm)

Like database tables, views have a short text description and (optional) documentation. A status known as a maintenance status determines whether a view is read-only or whether data can be inserted or modified in the view.

Notes

-   Projections can be implemented using both database views and with special projection views.

-   Only database tables can be specified as the basis tables of classic views, and no other views.

-   In [ABAP SQL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenopen_sql_glosry.htm "Glossary Entry"), only views whose key fields are located together at the beginning of the view can be accessed.

-   Views whose fields are all key fields should not be written to using [UPDATE FROM](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapupdate.htm) or [MODIFY FROM](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmodify_dbtab.htm). For database views, this produces a syntax check warning and for projection views a syntax error or runtime error.

-   As in database tables, the [client dependency](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclient_dependence_glosry.htm "Glossary Entry") of a classic view that can be accessed using ABAP SQL (a database view or projection view) is determined by a first column with the built-in dictionary type CLNT. The client dependency of the basis tables is ignored here.

-   [CDS views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_cds_views.htm) defined using the [CDS DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_ddl_glosry.htm "Glossary Entry") of the ABAP Core Data Services in [DDL source code](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddl_source_code_glosry.htm "Glossary Entry") offer all the functions of classic views and more. CDS views are, however, read-only, while some classic views can be modified.

Continue
[Database Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_views.htm)
[Projection Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_projection_views.htm)
[Maintenance Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_maintenance_views.htm)
[Help Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_help_views.htm)


### abenddic_database_views.htm

---
title: "Database Views"
description: |
  A database view is a general view for one or more basis tables. If there are multiple basis tables, they are joined using an inner join. A matching SQL view(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensql_view_glosry.htm 'Glossary Entry') is created as a database object(https:
version: "7.54"
category: "database"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_views.htm"
abapFile: "abenddic_database_views.htm"
keywords: ["select", "insert", "delete", "do", "if", "case", "try", "method", "class", "data", "types", "abenddic", "database", "views"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_views.htm) →  [Classic Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_views.htm) → 

Database Views

A database view is a general view for one or more basis tables. If there are multiple basis tables, they are joined using an inner join. A matching [SQL view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensql_view_glosry.htm "Glossary Entry") is created as a [database object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendb_object_glosry.htm "Glossary Entry") on the database when the view is activated. The structure type defined using the view fields of the database view can be referenced in ABAP programs using TYPE. A database view can be accessed using ABAP SQL, Native SQL, or AMDP in CDS views, and also from outside AS ABAP using the programming interface of the database. The latter method is, however, [not recommended](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendatabase_access_recomm.htm).

-   [Basis Tables](#abenddic-database-views-1--------view-fields---@ITOC@@ABENDDIC_DATABASE_VIEWS_2)

-   [Join Conditions](#abenddic-database-views-3--------maintenance-status---@ITOC@@ABENDDIC_DATABASE_VIEWS_4)

-   [Table Buffering](#abenddic-database-views-5---notes------a-database-view-can-be-activated-in-abap-dictionary-without-its-basis-tables-being-defined-on-the-database--the-view-is-also-not-created-on-the-database-in-this-case-------as-in-a--database-table--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-database-tables-client-htm---the-client-dependency-of-a-database-view-is-determined-by-an-initial-column-with-the-built-in-dictionary-type-clnt--------append-views--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-append-views-htm--are-available-for-enhancing-the-database-views-in-abap-dictionary-delivered-by-sap-without-making-any-modifications-------suitable--cds-views--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abencds-view-glosry-htm--glossary-entry---can-be-defined-as--replacement-objects--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-replacement-objects-htm--for-database-views--in-this-case--reads-in--abap-sql--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenopen-sql-glosry-htm--glossary-entry---access-the-replacement-objects-rather-than-the-database-views-------database-views-managed-by-abap-dictionary-should-not-be-accessed-directly-in-the-database--see--access-to-abap-managed-database-objects--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abendatabase-access-recomm-htm-----basis-tables--the-basis-tables-of-database-views-can-be--transparent-tables--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abentransparent-table-glosry-htm--glossary-entry---and--global-temporary-tables--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenglobal-temporary-table-glosry-htm--glossary-entry-----note--the-basis-tables-of--cds-database-views--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abencds-database-view-glosry-htm--glossary-entry---that-are-generated-for--cds-views--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abencds-view-glosry-htm--glossary-entry---can-also-be-other-database-views---view-fields--an-include-mechanism-can-be-used-to-add-individual-fields-or-all-fields-from-the-basis-tables-as-view-fields-of-a-database-view--when-individual-fields-are-used--a-name-other-than-the-name-in-the-basis-tables-can-be-defined-for-a-view-field--this-name-can-have-a-maximum-of-30-characters--must-meet-the-naming-conventions-for-component-names-of--structures--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-structures-htm---and-cannot-be-a-reserved-name--the-reserved-names-that-cannot-be-used-are-specified-in-the-database-table-trese--fields-with-the-type-char-can-have-a-maximum-of-1333-characters--fields-with-the-type-lraw-or-lchr-must-be-at-the-end-of-the-view--only-one-such-field-is-allowed-per-view--furthermore--a-field-with-the-type-int2-or-int4--for-the-maximum-length-of-the-field--must-be-located-directly-in-front-of-this-field---to-use-all-fields--the----character-is-used-instead-of-the-field-name--if-the----character-is-used-for-individual-fields-of-a-basis-table-included-using-----all-fields-up-to-the-fields-specified-with----become-view-fields--if-the-structure-of-a-database-table-whose-fields-were-added-in-this-way-is-modified--the-structure-of-the-view-is-also-modified---notes------if-a--foreign-key-field--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenforeign-key-field-glosry-htm--glossary-entry---is-added-as-a-view-field--it-keeps-this-attribute-and-all-associated-foreign-key-fields-become-the-foreign-key-of-the-view-------for--cds-database-views--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abencds-database-view-glosry-htm--glossary-entry----the-view-fields-displayed-as-key-fields-are-in-no-way-related-to-the-key-fields-defined-using--define-view--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abencds-f1-define-view-htm--for-the--cds-entity--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abencds-entity-glosry-htm--glossary-entry---------a-database-view-in-the-software-component-sap--basis-can-contain-a-maximum-of-749-view-fields-and-the-total-of-the-field-lengths--the-number-of-bytes-in-non-character-like-fields-plus-the-number-of-characters-in-flat-character-like-fields--must-not-exceed-4096--a-database-view-in-any-other-software-component-can-contain-a-maximum-of-1500-view-fields-and-the-total-of-the-field-lengths-is-not-checked-in-abap-dictionary---join-conditions--the-join-conditions-for-the-inner-join-can-be-formulated-using-equality-relationships-between-any-two-table-fields-in-the-basis-tables--the-inner-join-joins-the-rows-of-the-basis-tables-in-question-as-a-results-set-containing-all-combinations-of-rows-whose-columns-together-meet-the-join-conditions--if-there-are-no-rows-that-meet-the-join-conditions-in-the-basis-tables-in-question--no-row-is-created-in-the-results-set--if-there-is-a-suitable--foreign-key-dependency--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-database-tables-forkeyrel-htm---including-generic-and-constant-foreign-keys--between-two-basis-tables--this-dependency-can-be-used-as-a-default-for-defining-join-conditions-in-abap-dictionary---maintenance-status--the-access-setting-in-the-maintenance-status-of-a-database-view-can-have-the-following-values-------read-only--the-database-view-can-only-be-used-to-read-data-with-abap-sql-------read--change--delete--and-insert--if-the-database-view-contains-only-a-single-basis-table--data-can-be--changed--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenopen-sql-writing-htm--using-abap-sql---a-database-view-with-multiple-basis-tables-can-only-be-read-with-abap-sql--if-a-database-view-contains-only-a-single-table--data-can-be-inserted-in-this-table-using-the-view-with-the-abap-sql-statements--insert--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abapinsert-dbtab-htm--or--modify--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abapinsert-dbtab-htm---the-following-options-are-available-for-the-content-of-the-table-fields-not-in-the-view-------if-the-table-field-is-defined-with--not-null--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-database-tables-init-htm--on-the-database--the-field-is-filled-with-the-corresponding-initial-value-------if-the-table-field-is-defined-with--not-null--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-database-tables-init-htm--on-the-database--and-there-is-no-initial-value--nothing-can-be-inserted-and-a-database-error-occurs-with-a-corresponding-exception-------if-the-table-field-is-not-defined-with--not-null--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-database-tables-init-htm--on-the-database--the-field-is-filled-with-the--null-value--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abennull-value-glosry-htm--glossary-entry-----notes------a-database-view-should-only-be-used-to-insert-data-in-the-table-if-the-flag-for-initial-values-is-set-for-all-table-fields-that-are-not-in-the-view-------it-is-not-usually-a-problem-to-modify-existing-data-records-using-a-database-view-in-cases-where-the-database-view-contains-all-key-fields-of-the-table-------like-a-database-table--the-maintenance-status-of-a-database-view-has-a--display-and-maintain--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-database-tables-maint-htm--setting-alongside-the-access-setting--the-setting-must-match-the-access-setting--in-database-views-containing-multiple-basis-tables--only-the-setting-display-maintenance-not-allowed-is-possible---table-buffering--just-like-in-database-tables--it-is-possible-to-define-for-a-database-view-whether-the-data-in-the--table-buffer--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abentable-buffer-glosry-htm--glossary-entry---is-buffered--the-same--buffering-types--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-database-tables-buffer-htm--can-be-defined-and--table-buffering-in-abap-sql--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abensap-puffering-htm--is-handled-in-the-same-way-for-views-and-for-database-tables-with-the-only-difference-being-that--when-data-is-modified-in-one-of-the-basis-tables--the-entire-buffer-is-invalidated-when-the--buffers-are-synchronized--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenbuffer-synchro-htm---regardless-of-the-buffering-type-in-client-specific-views--however--this-only-affects-the-content-of-the-current-client---the-following-prerequisites-must-be-met-before-a-database-view-can-be-buffered-------a-basis-table-can-occur-in-no-more-than-nine-buffered-database-views-------if-all-fields-of-the-database-view-are-key-fields--these-fields-must-also-be-key-fields-of-the-basis-tables-------a-view-whose-data-is-written-to-using-abap-sql-cannot-have-a--replacement-object--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-replacement-objects-htm----note--no--replacement-objects--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenddic-replacement-objects-htm--can-be-created-for-an-existing-buffered-view-whose-data-can-be-written-to-using-abap-sql---example--the-database-view-demo--scarr--spfli-contains-fields-of-the-tables-scarr-and-spfli--other-names-are-assigned-to-these-fields-in-the-view---the-associated-database-object-could-be-as-follows---create-view-demo--scarr--spfli-----client-----id-----carrier-----flight-----departure-----destination---as-select----t1--mandt------t2--carrid------t1--carrname------t2--connid------t2--cityfrom------t2--cityto--from------scarr--t1-------spfli--t2-where-----t1--mandt-----t2--mandt--and-----t1--carrid----t2--carrid---the-view-can-be-accessed-as-follows-using-abap-sql---select-----------from-demo--scarr--spfli--------order-by-id--carrier--flight--------into-table-DATA(result).
cl\_demo\_output=>display( result ).


### abenddic_projection_views.htm

---
title: "Projection Views"
description: |
  A projection view is a special view for hiding fields from a single basis table. An SQL view is not created on the database. No selection conditions can be specified for a projection view. The structure type defined using the view fields of the projection view can be referenced in ABAP programs usin
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_projection_views.htm"
abapFile: "abenddic_projection_views.htm"
keywords: ["select", "insert", "delete", "do", "if", "try", "class", "data", "abenddic", "projection", "views"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_views.htm) →  [Classic Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_views.htm) → 

Projection Views

A projection view is a special view for hiding fields from a single basis table. An SQL view is not created on the database. No selection conditions can be specified for a projection view.

The structure type defined using the view fields of the projection view can be referenced in ABAP programs using TYPE. A projection view can be accessed using ABAP SQL but not using CDS views, Native SQL, or AMDP. The database interface transforms an ABAP SQL statement that accesses a projection view to a platform-specific SQL statement that provides the correct result.

The Access setting in the maintenance status of a projection view can have the following values:

-   Read only

The projection view can only be used to read data with ABAP SQL.

-   Read, change, delete, and insert

The projection view can only be used to [change](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenopen_sql_writing.htm) data with ABAP SQL.

When rows are inserted using projection views, all table fields not in the view are given the type-specific initial values of the field. This is done regardless of whether the field is defined as [NOT NULL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_init.htm) on the database.

Notes

-   As in a [database table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_client.htm), the client dependency of a projection view is determined by an initial column with the built-in dictionary type CLNT.

-   Like a database table, the maintenance status of a projection view has a [Display and Maintain](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_maint.htm) setting alongside the Access setting. The setting must match the Access setting.

-   The basis table of a projection view can be a [transparent table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentransparent_table_glosry.htm "Glossary Entry") and a [global temporary table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_temporary_table_glosry.htm "Glossary Entry").

Example

The projection view DEMO\_SPFLI contains fields of the tables SPFLI. The view can be accessed as follows using ABAP SQL:

SELECT \*
       FROM demo\_spfli
       ORDER BY carrid, connid
       INTO TABLE @DATA(result).
cl\_demo\_output=>display( result ).


### abenddic_maintenance_views.htm

---
title: "Maintenance Views"
description: |
  A maintenance view is a special view for performing writes on multiple tables using extended table maintenance. A single maintenance view can be used to modify the content of multiple related database tables consistently. A maintenance view is not defined on the database. The structure type defined
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_maintenance_views.htm"
abapFile: "abenddic_maintenance_views.htm"
keywords: ["select", "insert", "delete", "do", "if", "case", "try", "class", "data", "abenddic", "maintenance", "views"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_views.htm) →  [Classic Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_views.htm) → 

Maintenance Views

A maintenance view is a special view for performing writes on multiple tables using extended table maintenance. A single maintenance view can be used to modify the content of multiple related database tables consistently.

A maintenance view is not defined on the database. The structure type defined using a maintenance view can be referenced in ABAP programs using TYPE. A maintenance view cannot, however, be accessed using ABAP SQL. Instead, the transaction SE54 can be used to create dialogs called maintenance dialogs for maintenance views, which can themselves be used to edit the tables of the maintenance views jointly in extended table maintenance (transactions SM30 and SM31).

When data records are inserted using maintenance views, all tables fields not in the view are given the type-specific initial values of the field. This is done regardless of whether the field is defined as [NOT NULL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_init.htm) on the database.

Primary Table and Secondary Tables

All database tables grouped in a maintenance view must be joined using [foreign key dependencies](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_forkeyrel.htm), which means that the join conditions are always derived from a foreign key in the case of maintenance views. The first table included in the maintenance view is known as the primary table of the maintenance view. The tables added to this primary table using foreign keys are known as secondary tables. The following restrictions apply when selecting the secondary tables of a maintenance view:

-   The secondary tables must have an N:1 dependency on the primary table or on the transitively preceding secondary table. This makes sure that no more than one dependent data record exists in each of the secondary tables for a specific data record in the primary table. An N:1 dependency exists if the secondary table is the [check table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencheck_table_glosry.htm "Glossary Entry") in the [foreign key in question](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenforeign_key_glosry.htm "Glossary Entry").

-   If the secondary table is the [foreign key table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenforeign_key_table_glosry.htm "Glossary Entry"), the foreign key fields must be key fields of a table or the foreign key must have the cardinality N:1 or N:C.

A maintenance view implements an inner join. All key fields in the primary table must be included in its maintenance view. All key fields of secondary tables that are not part of the foreign key (that is, they are not joined with a key field already in the view using a join condition) must also be included in the view. This makes sure that the records inserted using a maintenance view can be written correctly to the tables in the view.

Note

If a database table is joined with its [text table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_table_glosry.htm "Glossary Entry") in a maintenance view, the logon language is selected automatically for this table.

Time-Dependent Key

In maintenance views, the key can be divided into a non-time-dependent area and a time-dependent area. The time-dependent area can, for example, contain date fields and time fields. This means that the rows of these views have chronological importance.

Note

The ability to change time-dependent views makes it possible to restrict the new entries inserted to those that are only missing time information.

Maintenance Status

The Access setting in the maintenance status of a maintenance view can have the following values:

-   Read only

The maintenance view can only be used to read data.

-   Read, change, delete, and insert

The maintenance view can be used to change, delete, and insert data.

-   Read and change

The maintenance view can be used to change data, but not delete or insert it.

-   Read and change (time-dependent views)

The maintenance view can be used to insert only entries whose non-time-dependent part of the key does not differ from existing entries.

Note

Like a database table, the maintenance status of a maintenance view has a [Display and Maintain](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_maint.htm) setting alongside the Access setting. The setting must match the Access setting. The setting Display/maintenance not allowed is not possible here.

Maintenance Characteristics of View Fields

Alongside the maintenance status of the view, characteristics called maintenance characteristics can be defined for each view field:

-   Standard

There are no restrictions on the view field.

-   Read-only

The maintenance view cannot be used to perform writes on the view field.

-   Subset

A field of this type is used to construct subsets when data is edited in extended table maintenance. Only a subset of the data is displayed. This subset is defined by entering an appropriate value in this field.

-   Hidden

A field of this type is not displayed in extended table maintenance and cannot be edited there. The content is initialized implicitly.

Delivery Class

A maintenance view also has a [delivery class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_delivery.htm). The delivery class of a maintenance view is analyzed in the extended table maintenance.

-   If the view is assigned one of the delivery classes G or E, the customer namespace for the entries of the view must be defined in the database table TRESC.

-   The transport interface of extended table maintenance must match the delivery class.

Regardless of this, the transport of the basis tables involved in upgrades and in transports between customer systems is determined solely by their [delivery class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_delivery.htm).


### abenddic_help_views.htm

---
title: "Help Views"
description: |
  A help view is a special view for use in search helps(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_help_glosry.htm 'Glossary Entry'). The selection methods of a search help can be database tables, database views, and the special help views. Database tables restrict the sea
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_help_views.htm"
abapFile: "abenddic_help_views.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abenddic", "help", "views"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_views.htm) →  [Classic Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_views.htm) → 

Help Views

A help view is a special view for use in [search helps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_help_glosry.htm "Glossary Entry"). The selection methods of a search help can be database tables, database views, and the special help views. Database tables restrict the search help to one table and database views restrict it to inner joins, whereas help views also make outer joins possible. A help view is not defined on the database. The structure type defined using a help view can be referenced in ABAP programs using TYPE. A help view cannot, however, be accessed using ABAP SQL.

The join conditions of a help view must be applied from existing foreign keys. Tables can be grouped in help views only if they are joined using [foreign keys](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenforeign_key_glosry.htm "Glossary Entry"). The first table included in the help view is known as the primary table of the help view. The tables added to this primary table using foreign keys are known as secondary tables. The same restrictions apply when selecting secondary tables of a help view as to [maintenance views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_maintenance_views.htm).

A help view implements an outer join, which means that the full content of the primary table of the help view is always displayed. If records in a secondary table cannot be read due to a selection condition, the content of the corresponding fields of the secondary table are displayed with initial values.

Notes

-   Like other views, help views can be used in elementary search helps if the selection is too complex to be defined using a single database table.

-   Unlike database views, help views implement an outer join, which is why this type is particularly well suited for including supplementary information such as explanatory texts from secondary tables. If the supplementary information were missing in an inner join, no part of the dataset would be selected.

-   If the selection is only made using a table and its text table, it is enough to specify the table directly as a selection method of the search help, since the fields of the text table can also be used as parameters in the search help in this case.

-   Help views should not be used if the selection is often restricted using fields of the secondary tables. In this case, a database view should be created instead. It might also be necessary to create additional suitable indexes for the basis tables.

-   Selections using help views can only be made quicker by making restrictions on the primary table. When accessing help views from the ABAP runtime environment, special selection routines are generated. These routines always make the selection using the primary table first and then use the records found as a key for selecting the supplementary information.


### abenddic_classical_views.htm

---
title: "Classic Views"
description: |
  A classic view (or view for short) is a repository object in ABAP Dictionary defined for existing database tables and their fields in the form-based ABAP Dictionary tool(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_tools.htm) in ABAP Workbench(https://help.sap.com/doc/abap
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_views.htm"
abapFile: "abenddic_classical_views.htm"
keywords: ["select", "insert", "update", "do", "while", "if", "case", "try", "class", "data", "types", "abenddic", "classical", "views"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_views.htm) → 

Classic Views

A classic view (or view for short) is a repository object in ABAP Dictionary defined for existing database tables and their fields in the form-based ABAP Dictionary [tool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_tools.htm) in [ABAP Workbench](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_workbench_glosry.htm "Glossary Entry"). As well as the classic views, the ABAP Dictionary also manages the [CDS views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry") of the [ABAP Core Data Services](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds.htm), which are defined by the [CDS DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_ddl_glosry.htm "Glossary Entry") in [DDL source code](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddl_source_code_glosry.htm "Glossary Entry").

The definition of a classic view consists of the following:

-   Basis tables

A list of database tables accessed by the view. Multiple tables are joined using joins.

-   View fields

A list of table fields of the basis tables that defines the structure of the view. Except in the case of projection views, a different [data element](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_data_elements.htm) can be assigned to a view field that that used for the corresponding table field of the basis table. This can only happen if the type of the table field is defined using a data element with a [domain](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm) and if the new data element references the same domain. This makes it possible to adjust the semantic attributes of the view field to the view.

-   Key

A key of the view that consists of key fields. The tool derives the key of a view from the key fields of the basis tables and the join conditions. All the key fields must be located contiguously at the start of the view. Fields that do not belong to the key, but are located between the key fields, are thus marked as key fields. All rows determined by the view must be unique with respect to the key. If no key with this property can be identified, all fields of the view are key fields, which can be bad for performance. In the case of ABAP SQL accesses to the view, its key behaves like the key of a database table.

-   Join conditions

Conditions for joining multiple basis tables using inner joins or outer joins. A join condition compares two fields from basis tables of a view for equality. If no join conditions are specified for a pair of basis tables, the view is used to select the cross product of the basis tables. Each row in a table is combined with each row of the other table. Each join condition then selects the matching rows from the cross product.

-   Selection conditions

Used to restrict the read rows to specific values of view fields or other fields.

-   The possible relational operators are \=, <>, \>=, \>, <=, <, LIKE, and NOT LIKE.

-   Depending on the data type of the view field, constant texts and numbers are allowed as comparison values. [System fields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_field_glosry.htm "Glossary Entry") can be specified for maintenance views and help views using SYST-... or SY-....

-   Multiple comparisons can be joined using AND and multiple comparisons for the same field can be joined using OR. Here, OR is stronger than AND.

The following types of classic views exist, of which only the database views are defined as SQL views on the database:

-   [Database views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_views.htm)

-   [Projection views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_projection_views.htm)

-   [Maintenance views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_maintenance_views.htm)

-   [Help views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_help_views.htm)

Like database tables, views have a short text description and (optional) documentation. A status known as a maintenance status determines whether a view is read-only or whether data can be inserted or modified in the view.

Notes

-   Projections can be implemented using both database views and with special projection views.

-   Only database tables can be specified as the basis tables of classic views, and no other views.

-   In [ABAP SQL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenopen_sql_glosry.htm "Glossary Entry"), only views whose key fields are located together at the beginning of the view can be accessed.

-   Views whose fields are all key fields should not be written to using [UPDATE FROM](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapupdate.htm) or [MODIFY FROM](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmodify_dbtab.htm). For database views, this produces a syntax check warning and for projection views a syntax error or runtime error.

-   As in database tables, the [client dependency](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclient_dependence_glosry.htm "Glossary Entry") of a classic view that can be accessed using ABAP SQL (a database view or projection view) is determined by a first column with the built-in dictionary type CLNT. The client dependency of the basis tables is ignored here.

-   [CDS views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_cds_views.htm) defined using the [CDS DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_ddl_glosry.htm "Glossary Entry") of the ABAP Core Data Services in [DDL source code](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddl_source_code_glosry.htm "Glossary Entry") offer all the functions of classic views and more. CDS views are, however, read-only, while some classic views can be modified.

Continue
[Database Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_views.htm)
[Projection Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_projection_views.htm)
[Maintenance Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_maintenance_views.htm)
[Help Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_help_views.htm)


### abenddic_external_views.htm

---
title: "External Views"
description: |
  An external view is a special view in ABAP Dictionary that defines(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexternal_views.htm) an SAP HANA View(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhana_view_glosry.htm 'Glossary Entry') in SAP HANA XSC(https://h
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_external_views.htm"
abapFile: "abenddic_external_views.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "types", "abenddic", "external", "views"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_views.htm) → 

External Views

An external view is a special view in ABAP Dictionary that [defines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexternal_views.htm) an [SAP HANA View](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhana_view_glosry.htm "Glossary Entry") in [SAP HANA XSC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenxsc_glosry.htm "Glossary Entry") in ABAP programs. The structure type defined using the view fields of an external view can be referenced in ABAP programs using TYPE. An external view can be specified as a source in [ABAP SQL read](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenopen_sql_reading.htm) statements

External views can only be created using the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry") and only if the current database is an [SAP HANA database](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhana_database_glosry.htm "Glossary Entry"). The SAP HANA view must exist in the [SAP HANA Repository](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_hana_repository_glosry.htm "Glossary Entry").

When an external view is activated, an alias with the name of the view is created on the SAP HANA database that points to the SAP HANA view. The names of the view fields of the external view can be defined differently from the names of the view fields of the SAP HANA view. The [runtime object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenruntime_object_glosry.htm "Glossary Entry") of the external view accesses the alias on the SAP HANA database. This performs a mapping of HANA-specific data types to the [built-in types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) in ABAP Dictionary. The following table lists the currently supported HANA-specific data types and indicates which ABAP Dictionary types they are mapped to by default.

HANA Type

Meaning

Type in ABAP Dictionary

SMALLINT

2-byte integer

INT2

INTEGER

4-byte integer

INT4

BIGINT

8-byte integer

INT8

DECIMAL

Packed number

DEC

SMALLDECIMAL

Packed number

DEC

FLOAT

Binary floating point number

FLTP

NVARCHAR

Unicode character string

CHAR

VARBINARY

Byte string

RAW

BLOB

Byte string

RAWSTRING

NCLOB

Unicode character string

STRING

External views can be displayed in the ABAP Dictionary [tool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_tools.htm) in the SAP GUI-based ABAP Workbench, but not edited.

An external view can only be read using ABAP SQL if an SAP HANA database is being accessed in which the associated SAP HANA view exists. If not, the non-handleable exception DBSQL\_TABLE\_UNKNOWN is raised. External views can exist actively and be used as data types in a system whose standard database is not an SAP HANA database. Views of this type cannot, however, be accessed through the [standard connection](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_db_connection_glosry.htm "Glossary Entry") using ABAP SQL, only through a [secondary connection](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensecondary_db_connection_glosry.htm "Glossary Entry") to an SAP HANA database. Conversely, when an SAP HANA view in an SAP HANA database is accessed through a secondary connection in the current system, only an identically named database table or a structure suitable for any view in ABAP Dictionary can exist actively in ABAP Dictionary.

Notes

-   The following restrictions currently apply to the use of external views in ABAP programs:

-   The structure of analytic views do not allow them to be read using [SELECT \*](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect_list.htm). The same basic rules apply to the statement SELECT in ABAP SQL as when using the HAND SQL statement SELECT, with individual columns and the addition GROUP BY needing to be specified. If SELECT \* is used, a runtime error occurs.

-   Calculation views with parameters can be access only if a default value is defined for each parameter. If not, reads are canceled and produce a runtime error.

-   External views should only be used in those cases that are not covered by [ABAP CDS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_cds_glosry.htm "Glossary Entry") or [AMDP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamdp_glosry.htm "Glossary Entry").

-   Access to SAP HANA views in [SAP HANA XS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenxs_glosry.htm "Glossary Entry"):

-   SAP HANA views in [SAP HANA XSC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenxsc_glosry.htm "Glossary Entry") are stored in the SAP HANA Repository and external views can be used for access to these views from ABAP.

-   SAP HANA views in [SAP HANA XSA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenxsa_glosry.htm "Glossary Entry"), the successor to [SAP HANA XSC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenxsc_glosry.htm "Glossary Entry"), are usually [HDI objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhdi_object_glosry.htm "Glossary Entry") for which no external views can be created. For access from ABAP, other methods must be used such as [AMDP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamdp_glosry.htm "Glossary Entry") or [ADBC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadbc_glosry.htm "Glossary Entry").


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Enhancements

**Files**: 9 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Enhancements

Included pages: 9


### abenddic_enhancements.htm

---
title: "Enhancements"
description: |
  A structure(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm), database table(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables.htm), database view(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_v
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_enhancements.htm"
abapFile: "abenddic_enhancements.htm"
keywords: ["do", "if", "try", "class", "data", "abenddic", "enhancements"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) → 

Enhancements

A [structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm), [database table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables.htm), [database view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_views.htm), or [domain](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm) in ABAP Dictionary created in a system can be enhanced in a different system using customizing includes, append structures, or append views without making any modifications. Customizing includes indicate points already marked by SAP for enhancements, whereas append structures can be appended anywhere.

-   [Customizing includes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_customizing_includes.htm)

-   [Append structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_append_structures.htm)

-   [Append views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_append_views.htm)

-   [Fixed value appends](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_fixed_value_appends.htm)

[Search helps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_help_glosry.htm "Glossary Entry") can be expanded using [append search helps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenappend_search_help_glosry.htm "Glossary Entry").

Extensions are connection to [Switch Framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenswitch_framework_glosry.htm "Glossary Entry") whenever they are defined in a [package](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpackage_glosry.htm "Glossary Entry") that is assigned a [switchSchalter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenswitch_german_glosry.htm "Glossary Entry").

Note

For [CDS views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry"), [CDS view enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_extend_glosry.htm "Glossary Entry") are an option for enhancements that is based on the CDS DDL in ABAP CDS.

Continue
[Customizing Includes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_customizing_includes.htm)
[Append Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_append_structures.htm)
[Append Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_append_views.htm)
[Fixed Value Appends](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_fixed_value_appends.htm)


### abenddic_customizing_includes.htm

---
title: "Customizing Includes"
description: |
  A customizing include is a structure in ABAP Dictionary whose name has the prefix CI_ for customers and SI_ for partners and is in the customer namespace. Customizing includes can be included in structures(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) and d
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_customizing_includes.htm"
abapFile: "abenddic_customizing_includes.htm"
keywords: ["insert", "do", "if", "class", "data", "abenddic", "customizing", "includes"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_enhancements.htm) → 

Customizing Includes

A customizing include is a structure in ABAP Dictionary whose name has the prefix CI\_ for customers and SI\_ for partners and is in the customer namespace. Customizing includes can be included in [structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) and [database tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables.htm) delivered by SAP. The customizing includes in structures and database tables delivered by SAP are usually empty. They are not associated with existing structures and reserve only the names of the structures. In customer or partner systems, these includes can be enhanced as part of an [enhancement category](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm) in customizing by creating the included customizing includes and using customizing transactions to give them components. Any existing transparent database tables are not transformed, which can put the fields in different orders in the dictionary and on the database.

A customizing include can be included in multiple database tables or structures. Its enhancement is then applied to all database tables or structures in which it is included. An empty customizing include of a database table or structure does not need to be enhanced.

Enhancements of a delivered structure or database table using a customizing include are not modifications. If a customizing include is used to add fields to a database table or structure in the standard system, these fields are inserted automatically in the new structure or database table delivered by SAP in an upgrade.


### abenddic_append_structures.htm

---
title: "Append Structures"
description: |
  An append structure is a structure in ABAP Dictionary appended to another structure(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) or database table(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables.htm) and which adds its co
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_append_structures.htm"
abapFile: "abenddic_append_structures.htm"
keywords: ["insert", "do", "if", "try", "class", "data", "abenddic", "append", "structures"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_enhancements.htm) → 

Append Structures

An append structure is a structure in ABAP Dictionary appended to another [structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) or [database table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables.htm) and which adds its components to this structure or table. In customer systems, append structures can be added to structures and database tables delivered by SAP. An append structure is assigned to exactly one table or structure. There can, however, be more than one append structure for a table or structure. The components of append structures must meet the [prerequisites](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_techstruc.htm) for table fields.

The following enhancements can be made to a database table or structure using an append structure:

-   New components inserted (if permitted by the [enhancement category](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm))

-   [Foreign keys](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenforeign_key_glosry.htm "Glossary Entry") defined for existing fields of a database table

-   [Search helps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_help_glosry.htm "Glossary Entry") bound to existing components

All enhancements are part of the append structure, which means that any changes made to these enhancements are made only using the append structure. The same applies to transports. When a database table or structure is activated, all associated append structures are found and their components are appended to the database table or structure. Any foreign keys or search help bindings added using the append structure are also appended. When an append structure is activated, the assigned database table or structure is adapted to the changes made. Any existing tables are not [converted](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_conv.htm), which can put the fields in the dictionary in a different order from the order on the database. When a structure or database table with an append structure is copied, the appended fields, foreign keys, and search helps become real elements of the target of the copy.

The following must be noted when using append structures to enhance database tables:

-   Append structures can only be appended to [transparent tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentransparent_table_glosry.htm "Glossary Entry").

-   No append structures can be appended to database tables with fields of the type LCHR or LRAW, since these fields must always be the last field of the table.

-   Any fields appended to a database table using an append structure can be added to its [secondary indexes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_index.htm). No secondary index can be defined for the append structure itself.

-   A binding of a check table or search help that already exists for a field of the database table cannot be modified using the append structure.

Enhancements of SAP structures or SAP tables using append structures in customer systems do not constitute modifications. Append structures created for SAP objects in customer systems are in the customer namespace (or in the namespace of a partner of a special development project) and hence are protected from being overwritten by upgrades. It is advisable to also create the components of append structures of this type with names from the customer namespace to avoid naming conflicts. After an upgrade, the associated append structures are again appended to tables modified by SAP.

Append structures can be defined as form-based structures in transaction SE11 or as source-code-based structures using [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry") in the [ABAP Development Tools](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry"). The following section is a summary of the syntax of the source code-based definition:

-   [Dictionary DDL for Structure Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_extend_type.htm)

Note

The same structure can be appended to multiple database tables or structures by including it in the individual append structures as an include structure.

Example

The append structure DEMO\_APPEND\_STRUCTURE enhances the structure DEMO\_STRUCTURE.

Continue
[Dictionary DDL for Structure Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_extend_type.htm)


### abenddic_extend_type.htm

---
title: "Dictionary DDL for Structure Enhancements"
description: |
  In the ABAP Development Tools (ADT)(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm 'Glossary Entry'), a structure or database table can be given a source-code-based enhancement known as an append structure in Dictionary DDL(https://help.sap.com/doc/abapdocu_754_ind
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_extend_type.htm"
abapFile: "abenddic_extend_type.htm"
keywords: ["do", "try", "class", "data", "abenddic", "extend", "type"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_enhancements.htm) →  [Append Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_append_structures.htm) → 

Dictionary DDL for Structure Enhancements

In the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry"), a structure or database table can be given a source-code-based enhancement known as an append structure in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry"). Here, however, the source code of an append structure is not saved and transported. Instead, the source code of an existing append structure is generated from the metadata of the associated system tables. When saved, the metadata is derived directly from the append structure and saved to the system tables.

-   [EXTEND TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_extend_type.htm)

Note

Each property of an append structure can be defined using either EXTEND TYPE or in the transaction SE11.

Continue
[EXTEND TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_extend_type.htm)


### abenddicddl_extend_type.htm

---
title: "EXTEND TYPE"
description: |
  Syntax structure_annos(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm) EXTEND TYPE structdbtab WITH append_struct  ... component(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) ... extend(
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_extend_type.htm"
abapFile: "abenddicddl_extend_type.htm"
keywords: ["do", "if", "try", "class", "data", "abenddicddl", "extend", "type"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_enhancements.htm) →  [Append Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_append_structures.htm) →  [Dictionary DDL for Structure Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_extend_type.htm) → 

EXTEND TYPE

Syntax

[structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm)
EXTEND TYPE struct*|*dbtab WITH append\_struct {
  ...
  [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm)
  *\[*...
  [extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm)
  ...*\]*;
  ...
  [include;](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm)
  ...
}

Effect

[Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry") statement for defining an ABAP Dictionary [append structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_append_structures.htm) append\_struct in the [ABAP Development Tools](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry").

-   The statement EXTEND TYPE adds the append structure append\_struct defined here either to an existing structure struct or to a database table dbtab.

-   The mandatory properties of the append structure must be specified in front of the statement EXTEND TYPE using the same annotations [structure\_annos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_props.htm) as in the definition of a structure.

-   As in the definition of a structure using [DEFINE STRUCTURE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_structure.htm), the components of the append structure are defined in a semicolon-separated list in curly brackets { }, either as individual components [component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comps.htm) or by including include structures [include](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_incl.htm).

-   As when including structures, an assignment to a search help and a definition of a foreign key dependency can be overwritten using additions [extend](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_define_struct_comp_ext.htm) in a blank-separated list.

Notes

-   As in the [CDS syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_general_syntax_rules.htm), the definition of an ABAP Dictionary append structure can contain comments after // and between /\* ... \*/.

-   A more detailed description of the syntax is available in the ADT documentation Syntax of ABAP Dictionary Objects.

Example

Adds the append structure DEMO\_APPEND\_STRUCTURE to the structure DEMO\_STRUCTURE in the ADT.

@EndUserText.label : 'Demo append structure'
@AbapCatalog.enhancementCategory : #EXTENSIBLE\_CHARACTER\_NUMERIC
extend type demo\_structure with demo\_append\_structure {
  comp3 : dats;
  comp4 : tims; }

The source code used to define the structure DEMO\_STRUCTURE is not modified by this enhancement. In the ADT, however, an icon indicates that the structure is enhanced using DEMO\_APPEND\_STRUCTURE.


### abenddic_extend_type.htm

---
title: "Dictionary DDL for Structure Enhancements"
description: |
  In the ABAP Development Tools (ADT)(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm 'Glossary Entry'), a structure or database table can be given a source-code-based enhancement known as an append structure in Dictionary DDL(https://help.sap.com/doc/abapdocu_754_ind
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_extend_type.htm"
abapFile: "abenddic_extend_type.htm"
keywords: ["do", "try", "class", "data", "abenddic", "extend", "type"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_enhancements.htm) →  [Append Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_append_structures.htm) → 

Dictionary DDL for Structure Enhancements

In the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry"), a structure or database table can be given a source-code-based enhancement known as an append structure in [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry"). Here, however, the source code of an append structure is not saved and transported. Instead, the source code of an existing append structure is generated from the metadata of the associated system tables. When saved, the metadata is derived directly from the append structure and saved to the system tables.

-   [EXTEND TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_extend_type.htm)

Note

Each property of an append structure can be defined using either EXTEND TYPE or in the transaction SE11.

Continue
[EXTEND TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddicddl_extend_type.htm)


### abenddic_append_structures.htm

---
title: "Append Structures"
description: |
  An append structure is a structure in ABAP Dictionary appended to another structure(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) or database table(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables.htm) and which adds its co
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_append_structures.htm"
abapFile: "abenddic_append_structures.htm"
keywords: ["insert", "do", "if", "try", "class", "data", "abenddic", "append", "structures"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_enhancements.htm) → 

Append Structures

An append structure is a structure in ABAP Dictionary appended to another [structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures.htm) or [database table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables.htm) and which adds its components to this structure or table. In customer systems, append structures can be added to structures and database tables delivered by SAP. An append structure is assigned to exactly one table or structure. There can, however, be more than one append structure for a table or structure. The components of append structures must meet the [prerequisites](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_techstruc.htm) for table fields.

The following enhancements can be made to a database table or structure using an append structure:

-   New components inserted (if permitted by the [enhancement category](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_structures_enh_cat.htm))

-   [Foreign keys](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenforeign_key_glosry.htm "Glossary Entry") defined for existing fields of a database table

-   [Search helps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_help_glosry.htm "Glossary Entry") bound to existing components

All enhancements are part of the append structure, which means that any changes made to these enhancements are made only using the append structure. The same applies to transports. When a database table or structure is activated, all associated append structures are found and their components are appended to the database table or structure. Any foreign keys or search help bindings added using the append structure are also appended. When an append structure is activated, the assigned database table or structure is adapted to the changes made. Any existing tables are not [converted](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_conv.htm), which can put the fields in the dictionary in a different order from the order on the database. When a structure or database table with an append structure is copied, the appended fields, foreign keys, and search helps become real elements of the target of the copy.

The following must be noted when using append structures to enhance database tables:

-   Append structures can only be appended to [transparent tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentransparent_table_glosry.htm "Glossary Entry").

-   No append structures can be appended to database tables with fields of the type LCHR or LRAW, since these fields must always be the last field of the table.

-   Any fields appended to a database table using an append structure can be added to its [secondary indexes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables_index.htm). No secondary index can be defined for the append structure itself.

-   A binding of a check table or search help that already exists for a field of the database table cannot be modified using the append structure.

Enhancements of SAP structures or SAP tables using append structures in customer systems do not constitute modifications. Append structures created for SAP objects in customer systems are in the customer namespace (or in the namespace of a partner of a special development project) and hence are protected from being overwritten by upgrades. It is advisable to also create the components of append structures of this type with names from the customer namespace to avoid naming conflicts. After an upgrade, the associated append structures are again appended to tables modified by SAP.

Append structures can be defined as form-based structures in transaction SE11 or as source-code-based structures using [Dictionary DDL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendictionary_ddl_glosry.htm "Glossary Entry") in the [ABAP Development Tools](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadt_glosry.htm "Glossary Entry"). The following section is a summary of the syntax of the source code-based definition:

-   [Dictionary DDL for Structure Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_extend_type.htm)

Note

The same structure can be appended to multiple database tables or structures by including it in the individual append structures as an include structure.

Example

The append structure DEMO\_APPEND\_STRUCTURE enhances the structure DEMO\_STRUCTURE.

Continue
[Dictionary DDL for Structure Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_extend_type.htm)


### abenddic_append_views.htm

---
title: "Append Views"
description: |
  Database views(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_views.htm) delivered by SAP can be enhanced by partners and customers using views known as append views, without making any modifications. The name of an append view is subject to the same rules as the name
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_append_views.htm"
abapFile: "abenddic_append_views.htm"
keywords: ["select", "do", "if", "case", "try", "class", "data", "abenddic", "append", "views"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_enhancements.htm) → 

Append Views

[Database views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_views.htm) delivered by SAP can be enhanced by partners and customers using views known as append views, without making any modifications. The name of an append view is subject to the same rules as the name of a classic [view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_views.htm) and should be located in the customer namespace (or in the namespace of a partner or special development) to protect it against being overwritten by upgrades or new releases.

Further fields from basis tables in the database view can be added to append views as view fields. Append views cannot be used to add further basis tables to the view or to modify the join conditions or selection conditions of a database view. An append view is assigned to exactly one database view. More than one append view can be created for a database view.

When an append view is activated, an [append structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenappend_structure_glosry.htm "Glossary Entry") with this name is created in ABAP Dictionary and its components become the additional view fields of the append view.

If a database view is activated, all append views for this view are found and their fields are appended to the database view. The append structure of the append view is added to the structure of the database view. If an append view is created or modified, the associated database view is adjusted to this change automatically when the append view is activated.

Notes

-   Append views are possible only for database views and not for other [views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_views.htm).

-   In the case of [CDS views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry"), [CDS view enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_extend_glosry.htm "Glossary Entry") are a separate option for enhancements and work in the similar way to append views. When a CDS view enhancement is created, an append view is created that enhances the [CDS database view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_database_view_glosry.htm "Glossary Entry").

Example

The database view DEMO\_ORIGINAL is enhanced using the append view DEMO\_APPEND\_VIEW. The program DEMO\_APPEND\_VIEW uses [SELECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect.htm) to access the enhanced view and also displays the components of the structures in question.


### abenddic_fixed_value_appends.htm

---
title: "Fixed Value Appends"
description: |
  Domains(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm) delivered by SAP can be enhanced by partners and customers using appends known as fixed value appends, without making any modifications. The name of a fixed value append is subject to the same rules as the nam
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_fixed_value_appends.htm"
abapFile: "abenddic_fixed_value_appends.htm"
keywords: ["do", "if", "try", "class", "abenddic", "fixed", "value", "appends"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Enhancements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_enhancements.htm) → 

Fixed Value Appends

[Domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_domains.htm) delivered by SAP can be enhanced by partners and customers using appends known as fixed value appends, without making any modifications. The name of a fixed value append is subject to the same rules as the name of a domain and should be located in the customer namespace (or in the namespace of a partner or special development) to protect it against being overwritten by upgrades or new releases.

A fixed value append adds further [fixed values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfixed_value_glosry.htm "Glossary Entry") or intervals to the value range of a domain. A domain can have more than one fixed value append.

When a domain is activated, all fixed value appends for this domain are found and their fixed values and intervals added to the domain. When a fixed value append is created or modified, the associated domain is adjusted to this change automatically when the fixed value append is activated.

Example

The fixed value append DEMO\_FIXED\_VALUE\_APPEND is added to the domain DEMO\_ORIGINAL. The program DEMO\_FIXED\_VALUE\_APPEND reads the fixed values and intervals of the extended domain and displays them. In the table, the column APPVAL indicates which fixed values and intervals come from the fixed value append.


---


## ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Replacement Objects

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP - Dictionary / Classic Objects in ABAP Dictionary / Replacement Objects

Included pages: 2


### abenddic_replacement_objects.htm

---
title: "Replacement Objects"
description: |
  A CDS view(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm 'Glossary Entry') can be assigned to a transparent(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentransparent_table_glosry.htm 'Glossary Entry') database table(https://help.sap.com/doc
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_replacement_objects.htm"
abapFile: "abenddic_replacement_objects.htm"
keywords: ["select", "update", "do", "if", "case", "try", "class", "data", "types", "abenddic", "replacement", "objects"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) → 

Replacement Objects

A [CDS view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry") can be assigned to a [transparent](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentransparent_table_glosry.htm "Glossary Entry") [database table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_tables.htm) and classic [database view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_database_views.htm) in ABAP Dictionary as a replacement object using the name of its [CDS entity](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_entity_glosry.htm "Glossary Entry"). A prerequisite is that the structure type defined by the CDS view matches the structure of the database table or classic view as follows:

-   The number of components must match.

-   It must be possible to assign a component of the CDS view to each component of the database table or classic view:

-   A [client column](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclient_column_glosry.htm "Glossary Entry") is assigned regardless of its name.

-   For all other components of the database table, an identically named element of the CDS view must exist.

The order of the components in the database table and the CDS view does not need to match.

-   The technical type properties [built-in data type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm), length, and number of decimal places must match for all assigned components.

-   The CDS view cannot have any input parameters.

-   It is not possible to have both a replacement object defined and table buffering switched on for a database view whose maintenance status is modifiable.

If a database table or a classic view is accessed and a replacement object is assigned to the table or view in the following cases, the replacement object is evaluated instead of the database table or classic view:

-   When used as a [data source](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect_data_source.htm) of a [SELECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect.htm) statement in [ABAP SQL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenopen_sql_glosry.htm "Glossary Entry"). This also applies to [subqueries](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubquery_glosry.htm "Glossary Entry") in any ABAP SQL statement and to the statements [OPEN CURSOR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_cursor.htm) and [FETCH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapfetch.htm). This bypasses any [table buffering](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_puffering.htm) defined for the database table or the classic view.

-   When a [foreign key relationship](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenforeign_key_dependency_glosry.htm "Glossary Entry") is checked for Web Dynpros or dynpros.

All other access types are still performed on the database table or classic view, such as:

-   Writes in ABAP SQL

-   [Writes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenopen_sql_writing.htm) in ABAP SQL

-   Use of the addition [SINGLE FOR UPDATE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect_single.htm) in the statement [SELECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect.htm)

Writes of this type produce a syntax check warning.

-   Use in other database objects, such as:

-   Use as a data source of a view defined on the database

-   Access from database procedures or database functions

Here it is not important how the database object was created, which means that, in addition to native views, the views defined for [classic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclassical_view_glosry.htm "Glossary Entry") [database views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendatabase_view_glosry.htm "Glossary Entry") in ABAP Dictionary or for [CDS views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry") on the database also do not access the replacement object. A similar principle applies to [AMDP procedures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamdp_procedure_glosry.htm "Glossary Entry") and [AMDP functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamdp_function_glosry.htm "Glossary Entry"). Even if ABAP SQL is used to access a classic database view in ABAP Dictionary, a CDS view, or a [CDS table function](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_table_function_glosry.htm "Glossary Entry") comprising database tables with replacement objects, no redirection is performed. In these cases, the replacement object must be accessed directly. For classic database views, a replacement object can be created that performs this task without the need to modify the programs.

-   Access types other than with ABAP SQL, for example:

-   Access with [IMPORT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapimport_data_cluster.htm) FROM [DATABASE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapimport_medium.htm) or [EXPORT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapexport_data_cluster.htm) TO [DATABASE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapexport_data_cluster_medium.htm).

-   Access using [Native SQL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennative_sql.htm) ([ADBC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadbc_glosry.htm "Glossary Entry"), [EXEC SQL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapexec.htm)), and [AMDP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamdp_glosry.htm "Glossary Entry").

When a replacement object is defined for a database table for a classic database view, the system checks whether the specified CDS view meets the prerequisites. If a CDS view used as a replacement object is changed later and the prerequisites are no longer met, a runtime error DBSQL\_REDIRECT\_INCONSISTENCY occurs when an ABAP SQL read is performed on the database table or on the database view.

No replacement objects can be defined for [global temporary tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_temporary_table_glosry.htm "Glossary Entry"). In customer systems, replacement objects can only be defined for self-defined database views and not for database tables.

If there is a diversion to a CDS view for which one or more [CDS roles](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_role_glosry.htm "Glossary Entry") are defined as part of the [CDS access control,](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_access_control_glosry.htm "Glossary Entry") the associated access conditions are not evaluated when the replacement object is accessed.

Notes

-   Extreme care should be taken when specifying a replacement object for a database table or a database view. Incorrect usage can cause inconsistencies.

-   Replacement objects are mainly intended for existing aggregate tables. These are database tables, which contain aggregated data from other tables. Instead of aggregating data in an ABAP program and writing data to an aggregate table, which can be exclusively accessed by reads in programs, the aggregation can be performed for every read using the CDS view. This prevents redundant data from being stored. In addition, aggregation on the database can improve performance if it is necessary to read large volumes of data for aggregation in ABAP. Replacement objects can make this possible without invalidating the programs.

-   A prerequisite for assigning a replacement object to an existing database table or database view is that the CDS view returns the expected data and that, apart from aggregation, only ABAP SQL reads are performed on the aggregate table.

-   Once a replacement object is defined, no further writes should be performed on an aggregate table. These writes produce a syntax check warning and are scheduled to be disallowed in an upcoming release.

-   Make sure that, apart from the use of ABAP SQL, no other type of access is performed on an aggregate table with a replacement object. More specifically, CDS views used as a replacement object are not allowed to access the replaced object, because the content is usually no longer updated.

-   It is not advisable to transport table content for which a replacement object is defined. This content is scheduled to no longer be transported in an upcoming release.

-   Table buffering should be deactivated for an aggregate table for which a replacement object is defined to prevent buffer invalidations.

-   In customer systems, it may be useful to define a replacement object for a self-defined classic database view, if a replacement object was defined for one of their basis tables at SAP. In this case, the replacement object of the view must access the replacement object of the basis table.

-   If a database table or a classical view , which a replacement object is defined for, is [extended](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_enhancements.htm) in a follow-on system, the assigned CDS view must also be extended accordingly with [EXTEND VIEW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_f1_extend_view.htm).

-   The classic [projection view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprojection_view_glosry.htm "Glossary Entry"), [maintenance views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmaintenance_view_glosry.htm "Glossary Entry"), and [help views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhelp_view_glosry.htm "Glossary Entry") are not defined on the database. Access to their basis tables is carried out on AS ABAP by using ABAP SQL. If a basis table has a replacement object, its reads are redirected as required.

-   Frameworks that use ABAP SQL, such as [Data Browser](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_browser_glosry.htm "Glossary Entry"), automatically access replacement objects if these objects are defined for a database table or a database view. Frameworks that use Native SQL or AMDP, such as [SADL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensadl_glosry.htm "Glossary Entry"), have to make sure that they access a replacement object rather than the database table or the database view.

-   Wherever possible, any programs that directly accessed aggregate tables or views with aggregate tables as basis tables should be modified so that they directly access the CDS views that are used as replacement objects. However, this cannot usually be done by simply replacing the data source in the relevant SELECT statements. This is because a [client-specific CDS view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_client_handling.htm) does not have a client column and therefore the used target objects no longer match. Furthermore, if a CDS view is accessed directly, the [CDS roles](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_role_glosry.htm "Glossary Entry") defined for it also have an effect.

-   Replacement objects cannot be defined for the following:

-   [Projection Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_projection_views.htm)

-   [Maintenance Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_maintenance_views.htm)

-   [Help Views](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_help_views.htm)

Executable Example

[Replacement Object for Database Table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_replacement_object_abexa.htm)

Continue
![Example](exa.gif "Example") [Replacement Object for Database Table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_replacement_object_abexa.htm)


### abenddic_replacement_object_abexa.htm

---
title: "Replacement Object for Database Table"
description: |
  This example demonstrates a database table with a replacement object(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreplacement_object_glosry.htm 'Glossary Entry'). Source Code REPORT demo_table_replacement_object. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS: class_con
version: "7.54"
category: "database"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_replacement_object_abexa.htm"
abapFile: "abenddic_replacement_object_abexa.htm"
keywords: ["select", "insert", "delete", "do", "if", "try", "method", "class", "data", "abenddic", "replacement", "object", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP - Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm) →  [Classic Objects in ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_classical_objects.htm) →  [Replacement Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_replacement_objects.htm) → 

Replacement Object for Database Table

This example demonstrates a database table with a [replacement object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreplacement_object_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_table\_replacement\_object.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      class\_constructor,
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    "Aggregate table (GTT)
    SELECT FROM demo\_sumdist\_agg
           FIELDS \*
           ORDER BY PRIMARY KEY
           INTO TABLE @DATA(result\_agg).
    DELETE FROM demo\_sumdist\_agg.
    "Table with replacement object
    SELECT FROM demo\_sumdist
           FIELDS \*
           ORDER BY PRIMARY KEY
           INTO TABLE @DATA(result).
    ASSERT result = result\_agg.
    "Direct access to CDS view
    SELECT FROM demo\_cds\_sumdist
           FIELDS @sy-mandt AS mandt, demo\_cds\_sumdist~\*
           ORDER BY PRIMARY KEY
           INTO TABLE @DATA(result\_cds).
    ASSERT result\_cds = result.
    out->write( result ).
    "Classic view on demo\_sumdist without replacement object
    SELECT FROM demo\_sumdist\_obs
           FIELDS \*
           ORDER BY PRIMARY KEY
           INTO TABLE @DATA(result\_view\_obs).
    IF result <> result\_view\_obs.
      out->write(
        'Classic view without replacement object differs.' ).
    ENDIF.
    "Classic view on demo\_sumdist with replacement object
    SELECT FROM demo\_sumdistview
           FIELDS \*
           ORDER BY PRIMARY KEY
           INTO TABLE @DATA(result\_view).
    IF result =  result\_view.
      out->write(
        'Classic view with replacement object is the same.' ).
    ENDIF.
    out->display( ).  ENDMETHOD.
  METHOD class\_constructor.
    DELETE FROM demo\_sumdist\_agg.
    INSERT demo\_sumdist\_agg FROM
      ( SELECT
          FROM scarr AS s
            INNER JOIN spfli AS p ON s~carrid = p~carrid
          FIELDS s~carrname,
                 p~distid,
                 SUM( p~distance ) AS sum\_distance
          GROUP BY s~mandt, s~carrname, p~distid ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This program accesses two database tables, DEMO\_SUMDIST\_AGG and DEMO\_SUMDIST. These tables are identical except for the fact that the [CDS view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry") DEMO\_CDS\_SUMDIST is defined as a [replacement object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_replacement_objects.htm) for DEMO\_SUMDIST.

The database table DEMO\_SUMDIST\_AGG is filled with aggregated data (done here in the static constructor of the class demo). When DEMO\_SUMDIST is accessed, the replacement object performs exactly the same aggregation:

@AbapCatalog.sqlViewName: 'DEMO\_CDS\_SUDI'
@AccessControl.authorizationCheck: #NOT\_REQUIRED
define view demo\_cds\_sumdist(
client,
carrname,
distid,
sum\_distance
)
as select from
scarr as s
join spfli as p on
s.carrid = p.carrid
{
key s.mandt,
key s.carrname,
key p.distid,
sum(p.distance)
}
group by
s.mandt,
s.carrname,
p.distid    

Similar access to the database tables produce similar results, which can be verified using the statement [ASSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassert.htm).

A third SELECT statement accesses the [CDS view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry") DEMO\_CDS\_SUMDIST directly. To produce the same results set for the comparison with the other results as when accessing the database tables, the [client column](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclient_column_glosry.htm "Glossary Entry") must be added, since the results set of a [client-specific CDS view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_client_handling.htm) does not contain a column of this type.

A [classic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclassical_view_glosry.htm "Glossary Entry") [database view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendatabase_view_glosry.htm "Glossary Entry") DEMO\_SUMDIST\_OBS contains the database table DEMO\_SUMDIST as a basis table. There is no redirect to the replacement object of DEMO\_SUMDIST in a SELECT. A classic database view DEMO\_SUMDISTVIEW that is otherwise similar has the following CDS view as a replacement object:

@AbapCatalog.sqlViewName: 'DEMO\_CDS\_SUDIV'
@AccessControl.authorizationCheck: #NOT\_REQUIRED
define view demo\_cds\_sumdistview
as select from
demo\_cds\_sumdist
{
key client,
key carrname,
key distid,
sum\_distance
}    

This view accesses the replacement object of the database table DEMO\_SUMDIST. When DEMO\_SUMDISTVIEW is accessed using SELECT, its replacement object is evaluated and the result again matches the preceding result.


---


## ABAP Keyword Documentation / ABAP − Reference / ABAP Syntax / ABAP Statements / Operands / Data Objects in Operand Positions

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / ABAP Syntax / ABAP Statements / Operands / Data Objects in Operand Positions

Included pages: 6


### abenoperands_data_objects.htm

---
title: "Data Objects in Operand Positions"
description: |
  For data objects in operand positions, you must distinguish between read and write positions. The data type and content of the specified data objects must also be appropriate for the operand position. -   Read positions(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_objects_us
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_data_objects.htm"
abapFile: "abenoperands_data_objects.htm"
keywords: ["do", "if", "data", "abenoperands", "objects"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP Syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_syntax.htm) →  [ABAP Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_statements.htm) →  [Operands](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands.htm) → 

Data Objects in Operand Positions

For data objects in operand positions, you must distinguish between read and write positions. The data type and content of the specified data objects must also be appropriate for the operand position.

-   [Read positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_objects_usage_reading.htm)

-   [Write positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_objects_usage_writing.htm)

-   [Subfield access](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length.htm)

Continue
[Read Positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_objects_usage_reading.htm)
[Writer Positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_objects_usage_writing.htm)
[Substring Access](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length.htm)


### abendata_objects_usage_reading.htm

---
title: "Read Positions"
description: |
  At a read position, the content of an operand is only read, and not changed, when the statement is executed. Data objects can be specified as followed at read positions: -   As a literal(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenliteral_glosry.htm 'Glossary Entry'). -   As a
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_objects_usage_reading.htm"
abapFile: "abendata_objects_usage_reading.htm"
keywords: ["do", "if", "case", "try", "data", "types", "internal-table", "field-symbol", "abendata", "objects", "usage", "reading"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP Syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_syntax.htm) →  [ABAP Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_statements.htm) →  [Operands](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands.htm) →  [Data Objects in Operand Positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_data_objects.htm) → 

Read Positions

At a read position, the content of an operand is only read, and not changed, when the statement is executed. Data objects can be specified as followed at read positions:

-   As a [literal](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenliteral_glosry.htm "Glossary Entry").
    

-   As a [data object visible](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlifetime_and_visibility.htm) in this place using a name dobj, a [field symbol](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfield_symbol_glosry.htm "Glossary Entry") <fs>, or a data reference dref->\* dereferenced using the [dereferencing operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendereferencing_operat_glosry.htm "Glossary Entry") \->\* (providing dref is specified in full).
    Here, the names of data objects also include any [text symbols](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_symbol_glosry.htm "Glossary Entry") specified using the following:
    ... text-idf ...,
    Here, idf is the three-character ID of the text symbol or chainings of reference variables. If a field symbol is used, it must be assigned to a memory area and a data reference must point to a data object. Otherwise an unhandleable exception is raised. As an alternative to specifying a text symbol using text-idf, the three-character code of a text symbol can be appended to the [text field literal](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_field_literal_glosry.htm "Glossary Entry") in parentheses:
    ... '...'(idf) ...
    If the text symbol exists in the currently loaded [text pool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_pool_glosry.htm "Glossary Entry"), the content of the text symbol is used instead of the text field literal, otherwise the literal is used.

-   If the data object is an internal table, the expressions dobj\[\], <fs>\[\], or dref->\*\[\] can also be used. An exception to this is when specifying the internal table of a [table expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_expression_glosry.htm "Glossary Entry"), where \[\] cannot be appended to the name. In the case of dobj\[\], this ensures that the [table body](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_body_glosry.htm "Glossary Entry") is addressed and no [header lines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry"). If an internal table does not have a header line, its simple name dobj (without \[\]) is interpreted as the table body in all operand positions. However, if an internal table does have a header line, its simple name dobj (without \[\]) is interpreted as the header line and not the table body in almost all operand positions. The operand positions in which the name of an internal table with a header line is interpreted as the internal table are specified under [internal tables with headers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenitab_header_line.htm).

-   As a [subarea](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length.htm) of a character-like or byte-like data object (or a character-like initial part of a structure) by specifying an [offset/length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length_specific_glosry.htm "Glossary Entry").

-   In some positions, number values must be specified directly as digits, although it is often not possible to specify a sign (which is not the case with [numeric literals](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumeric_literal_glosry.htm "Glossary Entry")). Examples are numbers specified in declarative statements for the length of elementary data objects or for the initial memory requirements of internal tables.

Notes

-   Text symbols cannot be listed at all read positions. For example, they are not permitted for specifying the target of dynamic [executions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_execution.htm).

-   A [system field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_field_glosry.htm "Glossary Entry") should only be specified as an operand in a reading position if its content is not set by the same statement, since otherwise undefined behavior may occur.

-   The predicate expressions [IS ASSIGNED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogexp_assigned.htm) and [IS BOUND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogexp_assigned.htm) can be used to check whether field symbols or data references.

-   A data reference variable with a generic static type can only be deserialized using the statement [ASSIGN dref->\* TO <fs>](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_mem_area_dynamic_dobj.htm).

-   In many reading positions, [functions or expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_expressions.htm) can be specified as well as data objects.

-   [Enumerated objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_object_glosry.htm "Glossary Entry") with an [enumerated type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry") can be used in all reading positions in which the operand type is their enumerated type or in which the operand is converted to one of the character-like types c or string.


### abendata_objects_usage_writing.htm

---
title: "Writer Positions"
description: |
  In a writer position, the content of the operand is changed when the statement is executed. Only modifiable data objects (that is, no literals, text symbols, constants, or non-modifiable formal parameters) can be specified as follows in writer positions: -   A visible data object(https://help.sap.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_objects_usage_writing.htm"
abapFile: "abendata_objects_usage_writing.htm"
keywords: ["do", "if", "try", "data", "types", "internal-table", "field-symbol", "abendata", "objects", "usage", "writing"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP Syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_syntax.htm) →  [ABAP Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_statements.htm) →  [Operands](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands.htm) →  [Data Objects in Operand Positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_data_objects.htm) → 

Writer Positions

In a writer position, the content of the operand is changed when the statement is executed. Only modifiable data objects (that is, no literals, text symbols, constants, or non-modifiable formal parameters) can be specified as follows in writer positions:

-   A [visible data object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlifetime_and_visibility.htm) specified in this place using a name dobj, a field symbol <fs>, or a dereferenced data reference dref->\* (if dref is typed in full). Like in [reading positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreading_position_glosry.htm "Glossary Entry"), \[\] can be appended in internal tables, to address the [table body](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_body_glosry.htm "Glossary Entry").

-   A [subarea](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length.htm) of a [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like or byte-like data object specified using an [offset/length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length_specific_glosry.htm "Glossary Entry"). An offset or length cannot be specified in writing positions for data objects of the [deep](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeep_glosry.htm "Glossary Entry") data types string and xstring.

-   In a [declaration position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclaration_position_glosry.htm "Glossary Entry"), an [inline declaration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninline_declaration_glosry.htm "Glossary Entry") of a data object or field symbol can be made using a [declaration expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclaration_expression_glosry.htm "Glossary Entry").

-   [Writable expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwritable_expression_glosry.htm "Glossary Entry") can be specified in a [result position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenresult_position_glosry.htm "Glossary Entry").

Writer-only positions, where an operand is overwritten without being read, and writer positions where an operand is read and written are both available.

Notes

-   In [some writing positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexpression_positions_write.htm), certain expressions can also be specified.

-   [Enumerated variables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_variable_glosry.htm "Glossary Entry") can only be used in writing positions in which the operand type is the enumerated type and only the associated [enumerated values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_value_glosry.htm "Glossary Entry") can be written.


### abenoffset_length.htm

---
title: "Substring Access"
description: |
  In operand positions, subareas of certain data objects can be accessed by specifying an offset/length: Syntax dobj+off(len) <fs>+off(len) dref->+off(len) Effect A specified offset or length is directly appended to either the dobj descriptor of the da
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length.htm"
abapFile: "abenoffset_length.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "field-symbol", "abenoffset", "length"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP Syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_syntax.htm) →  [ABAP Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_statements.htm) →  [Operands](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands.htm) →  [Data Objects in Operand Positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_data_objects.htm) → 

Substring Access

In operand positions, subareas of certain data objects can be accessed by specifying an offset/length:

Syntax

dobj*\[*+off*\]**\[*(len)*\]*

<fs>*\[*+off*\]**\[*(len)*\]*

dref->\**\[*+off*\]**\[*(len)*\]*

Effect

A specified offset or length is directly appended to either the dobj descriptor of the data object, an <fs> field symbol, or a dereferenced data reference variable dref->\*. Offsets/lengths can be specified for:

-   [Elementary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenelementary_data_object_glosry.htm "Glossary Entry") [byte-like data objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbyte_like_data_object_glosry.htm "Glossary Entry")

-   [Elementary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenelementary_data_object_glosry.htm "Glossary Entry") [character-like data objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencharlike_data_object_glosry.htm "Glossary Entry")

-   [Flat structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_structure_glosry.htm "Glossary Entry") where one of the following prerequisites must be met:

-   The structure contains flat character-like components only.

-   The first fragment of the [structure fragment view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenunicode_fragment_view_glosry.htm "Glossary Entry") is flat and character-like, and the substring addressed by specifying the offset and length is located within this fragment.

The following restrictions apply:

-   In [write positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwriting_position_glosry.htm "Glossary Entry"), only flat data objects are permitted; it is not possible to write to substrings of strings.

-   Access to substrings of strings is also not possible in the following [reading positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreading_position_glosry.htm "Glossary Entry"):

-   dobj*\[*+off*\]**\[*(len)*\]* specified as a memory area [mem\_area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_mem_area_static_dobj.htm) of the statement [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign.htm).

-   dobj*\[*+off*\]**\[*(len)*\]* specified as an argument of the statement [GET REFERENCE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_reference.htm) or the reference operator [REF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_ref.htm).

-   dobj*\[*+off*\]**\[*(len)*\]* specified as an actual parameter for input parameters in calls of [methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmethod_calls.htm), [function modules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function.htm) , and [subroutines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapperform.htm) .

-   Offsets/lengths cannot be specified for literals or text symbols.

-   A specified offset/length cannot be appended directly to a table expression [itab\[ ... \]](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_expressions.htm), but this is possible after a [chaining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_exp_chaining.htm) whose final place is a suitable structure component after a structure component selector.

-   No offset or length can be specified for an [enumerated object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_object_glosry.htm "Glossary Entry") with an [enumerated type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry"), regardless of the [base type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbase_type_glosry.htm "Glossary Entry").

-   In the case of dynamically [specified operands](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_specifying.htm) in parentheses, no lengths can be specified.

-   A dereferenced data reference variable dref->\* must be typed in full.

-   For a [writable expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwritable_expression_glosry.htm "Glossary Entry"), offsets/lengths cannot be specified as [memory areas](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_mem_area_writable_exp.htm) in the statement ASSIGN or as arguments of the reference operator [REF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_ref.htm) (table expressions only).

The segment of the data object is used that has the offset specified in off and the length (in characters or bytes) specified in len. A memory area must not be addressed outside the field boundaries, except in the case of the statement [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign.htm). In an offset specified without a length, the entire substring is addressed from off characters; for a length specified without an offset, the first len characters are addressed (different rules apply to the statement [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign.htm)).

The operands off and len expect data objects of the type i. These data objects must contain positive integers, with the following exceptions.

-   The length 0 can be specified for [strings](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_glosry.htm "Glossary Entry").

-   A negative offset (but never length 0) can be specified if an <fs> field symbol is specified in the statement [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_mem_area_static_dobj.htm) for dobj.

-   If off is less than the length of dobj, an asterisk (\*) can be specified for len. The upper limit of dobj then determines the upper limit of the memory area.

If the prerequisites are not met or if the subarea defined by off and len is not completely contained in the data object (except in the case of [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign.htm)), a syntax error occurs (if statically identifiable). Otherwise, an exception of the class CX\_SY\_RANGE\_OUT\_OF\_BOUNDS is raised. If off is specified as a numeric literal, this literal cannot be prefixed with a sign.

The offset and length specifications are counted in characters for character-like data objects and in bytes for all other data objects.

A substring specified by an offset or length specification is treated like a data object of the specified length for which the data type depends on the data type of the original data object, the field symbol, or the data reference variable, as shown below:

Original Data Type

Data Type of Substring

c

c

n

n

d

n

t

n

string

string

x

x

xstring

xstring

Structure type

c

If the length of the substring matches the length of the structure in a substring access to a structure exactly, the substring does not have data type c and is handled like the structure itself instead.

Notes

-   For reads on substrings of character-like data objects, built-in [substring functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm) that allow searches by specifying both substring and offset/lengths are available. The substring functions can also be used to edit arguments where offsets and lengths cannot be specified, such as data objects with an [enumerated type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry"). This is because an implicit conversion to string is performed here.

-   It is a good idea to specify offsets with the value 0 explicitly too (that is, dobj+0(len) instead of dobj(len)). This distinguishes a substring access in the source code clearly from other language constructs that also use parentheses, such as dynamic specifications, method calls, or inline declarations.

-   dobj+0(\*), dobj+0, or dobj(\*) are always interpreted as dobj. In this case, dobj can also be a data object where substring access according to the rules above is not possible.

-   No substring access cnt(len), sum(len) can be performed on data objects called cnt and sum unless an offset is specified explicitly. The compiler always interprets this as a [number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcnt.htm) or [sum](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapsum.htm) of a field len in the group level processing of an [extract dataset](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextract_dataset_glosry.htm "Glossary Entry").

-   [Obsolete syntax forms](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentokenization_obsolete.htm) can still occur with substring access (apart from with classes).

-   The statement [MOVE PERCENTAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmove_percentage.htm) indicates an obsolete form of substring access.

Example

The following structure has both character-like and non-character-like components:

DATA:
  BEGIN OF struc,
    a TYPE c LENGTH 3,    "Length 3 characters
    b TYPE n LENGTH 4,    "Length 4 characters
    c TYPE d,             "Length 8 characters
    d TYPE t,             "Length 6 characters
    e TYPE decfloat16,    "Length 8 bytes
    f TYPE c LENGTH 28,   "Length 28 characters
    g TYPE x LENGTH 2,    "Length 2 bytes
  END OF struc.

The [fragment view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenunicode_fragment_view_glosry.htm "Glossary Entry") splits the structure into five areas, F1 - F5.

\[ aaa | bbbb | cccccccc | ddd | AAA | eeee | fffffffffffff | gg \]
\[            F1               |  F2 |  F3  |       F4      | F5 \]

Offset/length accesses are possible on the character-like initial fragment F1 only, for example struc(21) or struc+7(14). An access such as struc+57(2), for example, is not permitted.

Executable Example

[Substrings](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_process_fields_abexa.htm)

Continue
![Example](exa.gif "Example") [Substrings](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_process_fields_abexa.htm)


### abendata_process_fields_abexa.htm

---
title: "Substrings"
description: |
  This example demonstrates how substrings can be accessed. Source Code REPORT demo_data_process_fields. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA time TYPE t VALUE '172545'. DATA: f1(8)  TYPE c VALUE 'ABCDEFGH', f2(20) TYPE c
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_process_fields_abexa.htm"
abapFile: "abendata_process_fields_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abendata", "process", "fields", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP Syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_syntax.htm) →  [ABAP Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_statements.htm) →  [Operands](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands.htm) →  [Data Objects in Operand Positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_data_objects.htm) →  [Substring Access](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length.htm) → 

Substrings

This example demonstrates how substrings can be accessed.

Source Code

REPORT demo\_data\_process\_fields.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA time TYPE t VALUE '172545'.
    DATA: f1(8)  TYPE c VALUE 'ABCDEFGH',
          f2(20) TYPE c VALUE '12345678901234567890'.
    DATA: f3(8) TYPE c VALUE 'ABCDEFGH',
          f4(8) TYPE c.
    DATA: o     TYPE i VALUE 2,
          l     TYPE i VALUE 4.
    DATA: string(20) TYPE c,
          number(8)  TYPE c VALUE '123456',
          offset     TYPE i VALUE 8,
          length     TYPE i VALUE 12.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Example 1\`
      )->write( time
      )->write( time+2(2)
      )->write( time+2(4) ).
    CLEAR time+2(4).
    out->write( time ).
    out->next\_section( \`Example 2\` ).
    f2+6(5) = f1+3(5).
    out->write( f1
      )->write( f2 ).
    out->next\_section( \`Example 3\` ).
    f4 = f3.
    out->write( f4 ).
    f4 = f3+o(l).
    out->write( f4 ).
    f4+o(l) = f3.
    out->write( f4 ).
    CLEAR f4.
    f4+o(l) = f3.
    out->write( f4 ).
    f4+o(l) = f3+o(l).
    out->write( f4 ).
    out->next\_section( \`Example 4\` ).
    WRITE number(6) TO string+offset(length) LEFT-JUSTIFIED.
    out->write( string ).
    CLEAR string.
    WRITE number(6) TO string+offset(length) CENTERED.
    out->write( string ).
    CLEAR string.
    WRITE number TO string+offset(length) RIGHT-JUSTIFIED.
    out->display( string ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In the first part, the minutes of a time field are selected by specifying an offset. Then the minutes and seconds are set to their initial values by specifying an offset in the CLEAR statement.

In the second part, the five character sequence 78901 from the field f2 is replaced with DEFGH from f1 by specifying offsets and lengths.

In the third part, assignments are used. First, the content of f1 is assigned to f2 without offsets. This is repeated with offsets and lengths for f1. The next three assignments overwrite the content of f2 with an offset of 2. Note that f2 is padded on the right with blanks, in accordance with the conversion rules for source type c.

In part four, the WRITE TO statement is used. The first six places in the field number are written to the last 12 places of the string field as left-justified, centered, and right-justified places.


### abenoffset_length.htm

---
title: "Substring Access"
description: |
  In operand positions, subareas of certain data objects can be accessed by specifying an offset/length: Syntax dobj+off(len) <fs>+off(len) dref->+off(len) Effect A specified offset or length is directly appended to either the dobj descriptor of the da
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length.htm"
abapFile: "abenoffset_length.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "field-symbol", "abenoffset", "length"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP Syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_syntax.htm) →  [ABAP Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_statements.htm) →  [Operands](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands.htm) →  [Data Objects in Operand Positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_data_objects.htm) → 

Substring Access

In operand positions, subareas of certain data objects can be accessed by specifying an offset/length:

Syntax

dobj*\[*+off*\]**\[*(len)*\]*

<fs>*\[*+off*\]**\[*(len)*\]*

dref->\**\[*+off*\]**\[*(len)*\]*

Effect

A specified offset or length is directly appended to either the dobj descriptor of the data object, an <fs> field symbol, or a dereferenced data reference variable dref->\*. Offsets/lengths can be specified for:

-   [Elementary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenelementary_data_object_glosry.htm "Glossary Entry") [byte-like data objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbyte_like_data_object_glosry.htm "Glossary Entry")

-   [Elementary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenelementary_data_object_glosry.htm "Glossary Entry") [character-like data objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencharlike_data_object_glosry.htm "Glossary Entry")

-   [Flat structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_structure_glosry.htm "Glossary Entry") where one of the following prerequisites must be met:

-   The structure contains flat character-like components only.

-   The first fragment of the [structure fragment view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenunicode_fragment_view_glosry.htm "Glossary Entry") is flat and character-like, and the substring addressed by specifying the offset and length is located within this fragment.

The following restrictions apply:

-   In [write positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwriting_position_glosry.htm "Glossary Entry"), only flat data objects are permitted; it is not possible to write to substrings of strings.

-   Access to substrings of strings is also not possible in the following [reading positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreading_position_glosry.htm "Glossary Entry"):

-   dobj*\[*+off*\]**\[*(len)*\]* specified as a memory area [mem\_area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_mem_area_static_dobj.htm) of the statement [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign.htm).

-   dobj*\[*+off*\]**\[*(len)*\]* specified as an argument of the statement [GET REFERENCE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_reference.htm) or the reference operator [REF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_ref.htm).

-   dobj*\[*+off*\]**\[*(len)*\]* specified as an actual parameter for input parameters in calls of [methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmethod_calls.htm), [function modules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function.htm) , and [subroutines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapperform.htm) .

-   Offsets/lengths cannot be specified for literals or text symbols.

-   A specified offset/length cannot be appended directly to a table expression [itab\[ ... \]](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_expressions.htm), but this is possible after a [chaining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_exp_chaining.htm) whose final place is a suitable structure component after a structure component selector.

-   No offset or length can be specified for an [enumerated object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_object_glosry.htm "Glossary Entry") with an [enumerated type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry"), regardless of the [base type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbase_type_glosry.htm "Glossary Entry").

-   In the case of dynamically [specified operands](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_specifying.htm) in parentheses, no lengths can be specified.

-   A dereferenced data reference variable dref->\* must be typed in full.

-   For a [writable expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwritable_expression_glosry.htm "Glossary Entry"), offsets/lengths cannot be specified as [memory areas](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_mem_area_writable_exp.htm) in the statement ASSIGN or as arguments of the reference operator [REF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_ref.htm) (table expressions only).

The segment of the data object is used that has the offset specified in off and the length (in characters or bytes) specified in len. A memory area must not be addressed outside the field boundaries, except in the case of the statement [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign.htm). In an offset specified without a length, the entire substring is addressed from off characters; for a length specified without an offset, the first len characters are addressed (different rules apply to the statement [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign.htm)).

The operands off and len expect data objects of the type i. These data objects must contain positive integers, with the following exceptions.

-   The length 0 can be specified for [strings](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_glosry.htm "Glossary Entry").

-   A negative offset (but never length 0) can be specified if an <fs> field symbol is specified in the statement [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_mem_area_static_dobj.htm) for dobj.

-   If off is less than the length of dobj, an asterisk (\*) can be specified for len. The upper limit of dobj then determines the upper limit of the memory area.

If the prerequisites are not met or if the subarea defined by off and len is not completely contained in the data object (except in the case of [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign.htm)), a syntax error occurs (if statically identifiable). Otherwise, an exception of the class CX\_SY\_RANGE\_OUT\_OF\_BOUNDS is raised. If off is specified as a numeric literal, this literal cannot be prefixed with a sign.

The offset and length specifications are counted in characters for character-like data objects and in bytes for all other data objects.

A substring specified by an offset or length specification is treated like a data object of the specified length for which the data type depends on the data type of the original data object, the field symbol, or the data reference variable, as shown below:

Original Data Type

Data Type of Substring

c

c

n

n

d

n

t

n

string

string

x

x

xstring

xstring

Structure type

c

If the length of the substring matches the length of the structure in a substring access to a structure exactly, the substring does not have data type c and is handled like the structure itself instead.

Notes

-   For reads on substrings of character-like data objects, built-in [substring functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm) that allow searches by specifying both substring and offset/lengths are available. The substring functions can also be used to edit arguments where offsets and lengths cannot be specified, such as data objects with an [enumerated type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry"). This is because an implicit conversion to string is performed here.

-   It is a good idea to specify offsets with the value 0 explicitly too (that is, dobj+0(len) instead of dobj(len)). This distinguishes a substring access in the source code clearly from other language constructs that also use parentheses, such as dynamic specifications, method calls, or inline declarations.

-   dobj+0(\*), dobj+0, or dobj(\*) are always interpreted as dobj. In this case, dobj can also be a data object where substring access according to the rules above is not possible.

-   No substring access cnt(len), sum(len) can be performed on data objects called cnt and sum unless an offset is specified explicitly. The compiler always interprets this as a [number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcnt.htm) or [sum](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapsum.htm) of a field len in the group level processing of an [extract dataset](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextract_dataset_glosry.htm "Glossary Entry").

-   [Obsolete syntax forms](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentokenization_obsolete.htm) can still occur with substring access (apart from with classes).

-   The statement [MOVE PERCENTAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmove_percentage.htm) indicates an obsolete form of substring access.

Example

The following structure has both character-like and non-character-like components:

DATA:
  BEGIN OF struc,
    a TYPE c LENGTH 3,    "Length 3 characters
    b TYPE n LENGTH 4,    "Length 4 characters
    c TYPE d,             "Length 8 characters
    d TYPE t,             "Length 6 characters
    e TYPE decfloat16,    "Length 8 bytes
    f TYPE c LENGTH 28,   "Length 28 characters
    g TYPE x LENGTH 2,    "Length 2 bytes
  END OF struc.

The [fragment view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenunicode_fragment_view_glosry.htm "Glossary Entry") splits the structure into five areas, F1 - F5.

\[ aaa | bbbb | cccccccc | ddd | AAA | eeee | fffffffffffff | gg \]
\[            F1               |  F2 |  F3  |       F4      | F5 \]

Offset/length accesses are possible on the character-like initial fragment F1 only, for example struc(21) or struc+7(14). An access such as struc+57(2), for example, is not permitted.

Executable Example

[Substrings](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_process_fields_abexa.htm)

Continue
![Example](exa.gif "Example") [Substrings](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_process_fields_abexa.htm)


---


## ABAP Keyword Documentation / ABAP − Reference / Program Layout / Modularization Statements / Procedures / Parameter Interface of Procedures

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Layout / Modularization Statements / Procedures / Parameter Interface of Procedures

Included pages: 2


### abenformal_parameters_oview.htm

---
title: "Parameter Interface of Procedures"
description: |
  The parameter interface of a procedure consists of formal parameters(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenformal_parameter_glosry.htm 'Glossary Entry') and specifies the exceptions(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_glosry.htm 'Glos
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenformal_parameters_oview.htm"
abapFile: "abenformal_parameters_oview.htm"
keywords: ["select", "update", "do", "while", "if", "case", "try", "catch", "method", "class", "data", "internal-table", "abenformal", "parameters", "oview"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Layout](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_program_layout.htm) →  [Modularization Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_modularization.htm) →  [Procedures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_procedures.htm) → 

Parameter Interface of Procedures

The parameter interface of a procedure consists of [formal parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenformal_parameter_glosry.htm "Glossary Entry") and specifies the [exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_glosry.htm "Glossary Entry") possible in the procedure.

Formal Parameters

Formal parameters are [input parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninput_parameter_glosry.htm "Glossary Entry"), [output parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoutput_parameter_glosry.htm "Glossary Entry"), [input/output parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninput_output_parameter_glosry.htm "Glossary Entry"), or [return values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreturn_value_glosry.htm "Glossary Entry"). Several obsolete [table parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_parameter_glosry.htm "Glossary Entry") also exist. Formal parameters are either generic or fully [typed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentyping_glosry.htm "Glossary Entry"). [Pass by reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpass_by_reference_glosry.htm "Glossary Entry") or [pass by value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpass_by_value_glosry.htm "Glossary Entry") can be specified for most formal parameters. Pass by value is mandatory for some formal parameters.

Programming Guideline

[Choose the appropriate formal parameter type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_formal_param_proc_guidl.htm "Guideline")

Exceptions

[Class-based exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_based_exception_glosry.htm "Glossary Entry") can be declared using RAISING for all procedures ( [methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmethod_glosry.htm "Glossary Entry"), [function modules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunction_module_glosry.htm "Glossary Entry") , and [subroutines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubroutine_glosry.htm "Glossary Entry") ), and can then be [propagated from the procedure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_procedures.htm). EXCEPTIONS can also be used in methods and function modules to define non-class-based exceptions, which can then be triggered in the procedure using [RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception.htm) or [MESSAGE ... RAISING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_raising.htm).

Pass by Reference or Pass by Value

Parameters can be passed to procedures either by reference or by value.

-   Pass by reference
    In the case of pass by reference, a reference to the actual parameter is passed to the procedure when it is called. The procedure then works with the actual parameter. No local data object is created for the actual parameter. Input parameters that are passed by reference cannot be changed in the procedure (with the exception of USING parameters of subroutines).

-   Pass by value
    In the case of pass by value, a type-friendly local data object is created as a copy of the actual parameter for the formal parameter. The system initializes output parameters and return values when the procedure is started. Input parameters as well as input/output parameters receive the value of the actual parameter. A changed formal parameter is only passed to the actual parameter if the procedure is completed without errors.

When deciding whether to use pass by reference or pass by value for a formal parameter, the performance and robustness of each pass-by type must be compared.

In ABAP, pass by reference always leads to better performance since no local data object has to be stored and no data transport is necessary when the procedure is called. Therefore, for performance reasons, pass by reference is usually preferable, unless explicit or implicit writes are made to an input parameter in the procedure or if it is necessary to ensure that an input/output parameter or an output parameter is returned only if the procedure ends without any errors. In such cases, pass by value is mandatory, to make sure that the assigned [actual parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenactual_parameter_glosry.htm "Glossary Entry") is not modified simultaneously in the caller when writes are made to a formal parameter. For performance reasons, only parameters of 100 bytes or less should be passed in these cases, whenever possible.

Also note the following when using pass by reference:

-   In [subroutines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubroutine_glosry.htm "Glossary Entry"), writes can be made to an input parameter defined using USING without a syntax error being produced (as is the case with input parameters of methods or function modules defined using IMPORTING).

-   An output parameter that is passed by reference acts like an input/ output parameter; in other words, if read access to an output parameter exists in the procedure before the value of that parameter is changed, this value is not initial, unlike with pass by value, but is the same as the current value of the actual parameter in the caller.

-   If a procedure is stopped because of an error (that is, if it is stopped for a reason other than reaching its last statement or RETURN, EXIT, or CHECK), all actual parameters that are passed by reference retain the value of the assigned formal parameter that the parameter had when the program was stopped. In pass by value, no values are passed to actual parameters when a procedure terminates.

Procedures and their calls have to be programmed so that these kinds of errors do not occur.

To summarize, pass by reference is always preferable when performance is an issue, while pass by value is more suitable in situations where robustness and data consistency are more important. These factors must be taken into account in each individual case when deciding which pass-by type to use with which type of parameter.

Programming Guideline

[Choose a suitable pass-by type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_transf_formal_para_guidl.htm "Guideline")

Notes

-   When strings or internal tables of the same type are passed by value, [table sharing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensharing_glosry.htm "Glossary Entry") comes into force between the data object created locally and the data object passed, as in [assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenassignment_glosry.htm "Glossary Entry"). However, [table sharing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_sharing_glosry.htm "Glossary Entry") only happens if the row type of the internal table permits it. This means that, when passing strings and internal tables, the performance benefits of pass by reference over pass by value may be negated by sharing (in certain circumstances).

-   Only pass by reference can be specified for the obsolete [table parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_parameter_glosry.htm "Glossary Entry").

-   Pass by value is mandatory for the [return value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreturn_value_glosry.htm "Glossary Entry") of [functional methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunctional_method_glosry.htm "Glossary Entry"), the output parameters of [events](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenevent_glosry.htm "Glossary Entry") in ABAP Objects, and all formal parameters of [RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_glosry.htm "Glossary Entry")\-enabled function modules and [update function modules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenupdate_function_module_glosry.htm "Glossary Entry") (pass by value is also used implicitly with table parameters).

-   A local data object is generated for formal parameters passed by reference that are not bound to an actual parameter during the call (as for pass by value).

-   There are special rules for defining [literals](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentyping_literals.htm) and [functions and expressions as actual parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentyping_arith_expr.htm):

-   When a literal is bound, its typing is not checked as strictly.

-   When a function, a calculation expression, a constructor expression, or a table expression is bound, passing is always [pass by value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpass_by_value_glosry.htm "Glossary Entry"), even if the formal parameter is defined as [pass by reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpass_by_reference_glosry.htm "Glossary Entry").

-   The result of the [typing check](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentyping_check.htm) when passing actual parameters to formal parameters is independent of the pass type. In a [pass by value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpass_by_value_glosry.htm "Glossary Entry"), the check for [pass by reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpass_by_reference_glosry.htm "Glossary Entry") is always carried out, even though this is stricter than necessary in individual cases. For example, a special reference variable cannot be passed to a general typed CHANGING parameter, even if pass by value is defined for this parameter.

Example

For a method meth, CHANGING parameter p1 is defined for pass by reference and p2 for pass by value. The values of both parameters are modified before an exception is raised. The actual parameter a1 bound to the parameter using pass by reference contains the modified value when the exception is handled. The actual parameter a2 bound to the parameter using pass by value, on the other hand, keeps its value.

CLASS cx\_exception DEFINITION
                   INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS cls DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS meth CHANGING p1        TYPE i
                                VALUE(p2) TYPE i
                       RAISING  cx\_exception.
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD meth.
    p1 = 333.
    p2 = 444.
    RAISE EXCEPTION TYPE cx\_exception.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(a1) = 111.
  DATA(a2) = 222.
  TRY.
      cls=>meth( CHANGING p1 = a1
                          p2 = a2 ).
    CATCH cx\_exception.
      cl\_demo\_output=>display( |{ a1 }, { a2 }| ).
  ENDTRY.

Continue
![Example](exa.gif "Example") [Pass by Parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocedure_param_abexa.htm)


### abenprocedure_param_abexa.htm

---
title: "Pass by Parameter"
description: |
  This example demonstrates the difference between passing a parameter in a procedure by value or by reference. Source Code REPORT demo_procedure_param. CLASS demo_fibb DEFINITION. PUBLIC SECTION. TYPES: BEGIN OF line, x TYPE i, y TYPE i, range TYPE i, END OF line. CLASS-DATA: param TYPE STANDARD T
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocedure_param_abexa.htm"
abapFile: "abenprocedure_param_abexa.htm"
keywords: ["select", "loop", "do", "if", "method", "class", "data", "types", "internal-table", "abenprocedure", "param", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Layout](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_program_layout.htm) →  [Modularization Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_modularization.htm) →  [Procedures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_procedures.htm) →  [Parameter Interface of Procedures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenformal_parameters_oview.htm) → 

Pass by Parameter

This example demonstrates the difference between passing a parameter in a procedure by value or by reference.

Source Code

REPORT demo\_procedure\_param.
CLASS demo\_fibb DEFINITION.
  PUBLIC SECTION.
    TYPES: BEGIN OF line,
               x TYPE i,
               y TYPE i,
               range TYPE i,
           END OF line.
    CLASS-DATA: param TYPE STANDARD TABLE OF line,
                res TYPE i.
    CLASS-METHODS: main,
                   fill\_table  CHANGING  g\_param LIKE param,
                   solve\_table IMPORTING g\_param LIKE param,
                   fibb IMPORTING VALUE(l\_line) TYPE line
                        EXPORTING VALUE(r) TYPE i.
ENDCLASS.
CLASS demo\_fibb IMPLEMENTATION.
  METHOD main.
    fill\_table(  CHANGING  g\_param = param ).
    solve\_table( EXPORTING g\_param = param ).
  ENDMETHOD.
  METHOD fill\_table.
    g\_param = VALUE #( FOR j = 1 UNTIL j > 3
                       ( x = j
                         y = j \*\* 2
                         range = 12 / j ) ).
  ENDMETHOD.
  METHOD solve\_table.
    DATA l\_line LIKE LINE OF g\_param.
    LOOP AT g\_param INTO l\_line.
      fibb( EXPORTING l\_line = l\_line IMPORTING r = res ).
      cl\_demo\_output=>write(
      |Fibb( { l\_line-x }, { l\_line-y }, { l\_line-range }) = { res }| ).
    ENDLOOP.
    cl\_demo\_output=>display( ).
  ENDMETHOD.
  METHOD fibb.
    IF l\_line-range = 1.
      IF l\_line-x < l\_line-y.
        r = l\_line-x.
      ELSE.
        r = l\_line-y.
      ENDIF.
    ELSEIF l\_line-range = 2.
      IF l\_line-x < l\_line-y.
        r = l\_line-y.
      ELSE.
        r = l\_line-x.
      ENDIF.
    ELSE.
      l\_line-range -= 2.
      DO l\_line-range TIMES.
        IF l\_line-x < l\_line-y.
          l\_line-x += l\_line-y.
          r = l\_line-x.
        ELSE.
          l\_line-y += l\_line-x.
          r = l\_line-y.
        ENDIF.
      ENDDO.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_fibb=>main( ).

Description

The method fibb calculates the sequence term with the number range in a Fibonacci sequence using the start values x and y. As a rule, the next sequence term is always the sum of two previous sequence terms (which is why there are two start values). The method inherits two parameters, a structured parameter l\_line used to pass the input values, and a parameter r of type i used to provide the result. The parameter l\_line is defined as an IMPORTING parameter but still has to be changed in the method, which means that the method definition must contain the keyword VALUE before the parameter. If not, a syntax error occurs. This ensures that a local copy of the parameter is used within the method. The addition VALUE of the output parameter r assigns the result to the static class attribute res only after the method has been processed completely. Otherwise res would be changed in every single step of the algorithm.

The internal table param contains the input values for calculating three different sequence terms of the Fibonacci sequence. The method fill\_table is used to fill param with values and the method solve\_table is used to calculate and display fibb for each line of param.


---


## ABAP Keyword Documentation / ABAP − Reference / Built-In Types, Data Objects, Functions, and Constructors / Predefined Data Types / Built-In ABAP Types

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Built-In Types, Data Objects, Functions, and Constructors / Predefined Data Types / Built-In ABAP Types

Included pages: 7


### abenbuilt_in_types_complete.htm

---
title: "Built-In ABAP Types"
description: |
  The following types are predefined in every ABAP program: -   Built-in numeric types(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm) -   Built-in character-like types(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_character.
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_complete.htm"
abapFile: "abenbuilt_in_types_complete.htm"
keywords: ["do", "while", "if", "try", "data", "types", "abenbuilt", "complete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Predefined Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types.htm) → 

Built-In ABAP Types

The following types are predefined in every ABAP program:

-   [Built-in numeric types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm)

-   [Built-in character-like types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_character.htm)

-   [Built-in byte-like types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_byte.htm)

-   [Built-in date types and time types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_date_time.htm)

All built-in ABAP types from these tables are elementary and are included in the generic type [simple](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_generic.htm). Apart from the types [b](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm) and [s](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm), the built-in ABAP types can also be used to define separate [data types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_type_glosry.htm "Glossary Entry") and [data objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_object_glosry.htm "Glossary Entry") and for [typing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentyping_glosry.htm "Glossary Entry").

Besides the built-in ABAP types, there is a global predefined data type cursor, which currently has the same meaning as the built-in ABAP type [i](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm). This is required when declaring a cursor variable for [database cursor](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendatabase_cursor_glosry.htm "Glossary Entry") [handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_cursor.htm).

Notes

-   If a [start value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstart_value_glosry.htm "Glossary Entry") is not specified when creating a data object with one of the built-in ABAP types, the start value is set to the [initial value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninitial_value_glosry.htm "Glossary Entry") specified for the relevant type.

-   The built-in data types [string](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_character.htm) and [xstring](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_byte.htm) describe data objects of variable length ([dynamic data objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynamic_data_object_glosry.htm "Glossary Entry")). While the length of data objects in all other elementary data types is determined for its whole lifetime, the length of text strings and byte strings varies according to their content (the maximum size of a string is determined by the [profile parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprofile_parameter_glosry.htm "Glossary Entry") ztta/max\_memreq\_MB (see [Maximum Size of Dynamic Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmemory_consumption_2.htm))).
    

Continue
[Predefined Numeric Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm)
[Predefined Character-Like Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_character.htm)
[Predefined Byte-Like Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_byte.htm)
[Built-In Date Types, Time Types, and Time Stamp Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_date_time.htm)


### abenbuiltin_types_numeric.htm

---
title: "Predefined Numeric Types"
description: |
  The data objects of the numeric data types are used to handle number values. Properties Type Length Standard Length Name b 1 byte 1-byte integer(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninteger_glosry.htm 'Glossary Entry') (internal) s 2 byte 2-byte integer(https://help.sap
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm"
abapFile: "abenbuiltin_types_numeric.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abenbuiltin", "numeric"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Predefined Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types.htm) →  [Built-In ABAP Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_complete.htm) → 

Predefined Numeric Types

The data objects of the numeric data types are used to handle number values.

Properties

Type

Length

Standard Length

Name

b

1 byte

 

1-byte [integer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninteger_glosry.htm "Glossary Entry") (internal)

s

2 byte

 

2-byte [integer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninteger_glosry.htm "Glossary Entry") (internal)

i

4 byte

 

4-byte [integer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninteger_glosry.htm "Glossary Entry")

int8

8 byte

 

8-byte [integer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninteger_glosry.htm "Glossary Entry")

p

1 to 16 bytes

8 byte

[Packed number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpacked_number_glosry.htm "Glossary Entry")

decfloat16

8 byte

 

[Decimal floating point number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendecfloat_glosry.htm "Glossary Entry") with 16 places

decfloat34

16 byte

 

[Decimal floating point number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendecfloat_glosry.htm "Glossary Entry") with 34 places

f

8 byte

 

[Binary floating point number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbinfloat_glosry.htm "Glossary Entry") with 17 places

Value Ranges and Initial Values

Type

Value Range

Initial Value

b

0 to 255

0

s

\-32,768 to +32,767

0

i

\-2,147,483,648 to +2,147,483,647

0

int8

\-9,223,372,036,854,775,808 to +9,223,372,036,854,775,807

0

p

The valid length for packed numbers is between 1 and 16 bytes. Two places are packed into one byte, where the last byte only contains one place and the sign (the number of places or digits is calculated from 2 \* len1). After the decimal separator, up to 14 [decimal places](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfractional_portion_glosry.htm "Glossary Entry") are permitted (as long as the number of decimal places does not exceed the number of places). Depending on the field length len and the number of decimal places dec, the following applies to the value range: (-10^(2len-1) +1) / (10^(+dec)) to (+10^(2len-1) -1) /(10^(+dec)) in increments of 10^(-dec). Any intermediate values are rounded (decimal). Invalid content produces undefined behavior.

0

decfloat16

Decimal floating point numbers of this type are represented internally with 16 places in accordance with the IEEE-754-2008 standard. Valid values are numbers between 1E385(1E-16 - 1) and -1E-383 for the negative range, 0 and +1E-383 to 1E385(1 - 1E-16) for the positive range. Values lying between the ranges form the subnormal range and are rounded. Outside of the subnormal range, each 16-digit decimal number can be represented precisely with a decimal floating point number of this type

0

decfloat34

Decimal floating point numbers of this type are represented internally with 34 places in accordance with the IEEE-754-2008 standard. Valid values are numbers between 1E6145(1E-34 - 1) and -1E-6143 for the negative range, 0 and +1E-6143 and 1E6145(1 - 1E-34) for the positive range. Values lying between the ranges form the subnormal range and are rounded. Outside of the subnormal range, each 34-digit decimal number can be represented precisely using a decimal floating point number like this.

0

f

Binary floating point numbers are represented internally in accordance with the IEEE-754 standard (double precision). In ABAP, 17 places are represented (one integer digit and 16 decimal places). Valid values are numbers between -1.7976931348623157E+308 and -2.2250738585072014E-308 for the negative range and between +2.2250738585072014E-308 and +1.7976931348623157E+308 for the positive range, plus 0. Both validity intervals are extended in the direction of zero using subnormal numbers in accordance with the IEEE-754 standard.

0

Programming Guideline

[Select the numeric type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselect_numeric_type_guidl.htm "Guideline")

Notes

-   The numeric data objects are used to handle numeric values and [numeric calculations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencompute_expressions.htm). Here, the data type f for binary floating point numbers is replaced largely by the types decfloat16 and decfloat34 for decimal floating point numbers.

-   The types b and s are internal types and cannot be specified either statically or dynamically in ABAP statements. Self-defined data types and data objects in ABAP programs have the data types b or s if they were defined with reference to data elements in ABAP Dictionary that have the [external data types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexternal_data_type_glosry.htm "Glossary Entry") [INT1](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) or [INT2](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm).

-   The system class [CL\_ABAP\_MATH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_class.htm) contains constants for the minimum and maximum values of most numeric types. The methods GET\_MIN\_VALUE and GET\_MAX\_VALUE in the class CL\_ABAP\_EXCEPTIONAL\_VALUES can also be used.

-   The system class CL\_ABAP\_ELEMDESCR in [RTTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrtti.htm) contains constants TYPE\_P\_MAX\_LENGTH and TYPE\_P\_MAX\_DECIMALS for the maximum length and the maximum number of decimal places p.

-   Since the decimal places in a floating point number of type f are represented internally as dual fractions, there is not an exact equivalent for every number that can be represented in the decimal system. This can produce rounding errors in conversions and intermediate results of calculations. These errors can be avoided by using a two-step rounding procedure (see [Example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_class.htm)).

-   The type p, for which a length interval is specified in the second column in the first table, is [generic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_generic.htm), which means that the length is not part of the type description. Also, both the [decimal places](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfractional_portion_glosry.htm "Glossary Entry") and the length are undefined. The entry in the Standard Length column specifies the length used in declarations of data objects when using types with generic lengths, if no explicit length is specified in the relevant statement.

-   The data type p is used to implement [fixed point numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfixed_point_number_glosry.htm "Glossary Entry"). The number of decimal places in a packed number with the type p is a type attribute defined using the addition [DECIMALS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_simple.htm) and is not saved together with the number. Technically, the number value is determined by dividing the saved sequence of digits in the packed number by 10 to the power of the number of decimal places (10^(+dec)). In the definition of a packed number, the number of decimal places cannot be greater than the number of places calculated from 2 \*  len - 1. Otherwise, the decimal separator is outside the sequence of digits and not all decimal places can be given values. For example, if a packed number with length 1 and two decimal places has a value range of \-0.09 to +0.09 in increments of 0.01, there is no possible value for which the first decimal place is filled, for example 0.14.

-   A number with the data type p that has more decimal places than places can raise exceptions when converted to external formats such as data types of the database in [ABAP SQL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenopen_sql_glosry.htm "Glossary Entry") or in serializations to [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry").

-   The [built-in types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) in ABAP Dictionary mapped to the data type p cannot have more decimal places than places. In ABAP, declarations like this that are known statically produce a syntax check warning.

-   For data objects of data type p, the [program attribute](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprogram_attribute_glosry.htm "Glossary Entry") Fixed Point Arithmetic must be set so that the decimal separator is respected. Otherwise, in all operations, the content is handled as if there is no decimal separator. The sequence of digits in the variables of type p is interpreted as an integer value. Exceptions are:

-   Representation on screens

-   Formatting with [WRITE *\[*TO*\]*](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_to.htm)

-   [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_type_p.htm) to character-like objects with the types c and string

-   See also [Numeric Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumber_types.htm).

Example

Declares variables with built-in numeric ABAP types for a numeric calculation.

DATA: num1   TYPE i,
      num2   TYPE i,
      result TYPE decfloat34.
...
result = num1 / num2.

Executable Example

[Value Ranges of Packed Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_p_value_range_abexa.htm)

Continue
![Example](exa.gif "Example") [Value Ranges of Packed Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_p_value_range_abexa.htm)


### abentype_p_value_range_abexa.htm

---
title: "Value Ranges of Packed Numbers"
description: |
  This example demonstrates the value ranges of packed numbers with different lengths and decimal places. Source Code REPORT demo_type_p_value_range. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA:length   TYPE i VALUE 2, decimals
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_p_value_range_abexa.htm"
abapFile: "abentype_p_value_range_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "types", "abentype", "value", "range", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Predefined Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types.htm) →  [Built-In ABAP Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_complete.htm) →  [Predefined Numeric Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm) → 

Value Ranges of Packed Numbers

This example demonstrates the value ranges of packed numbers with different lengths and decimal places.

Source Code

REPORT demo\_type\_p\_value\_range.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:length   TYPE i VALUE 2,
         decimals TYPE i VALUE 2.
    cl\_demo\_input=>add\_field( EXPORTING text  = \`Length\`
                              CHANGING  field = length ).
    cl\_demo\_input=>request(   EXPORTING text  = \`Decimals\`
                              CHANGING  field = decimals ).
    DATA dref TYPE REF TO data.
    FIELD-SYMBOLS <pack> TYPE p.
    TRY.
        IF decimals > 2 \* length - 1.
          RAISE EXCEPTION TYPE cx\_sy\_create\_data\_error.
        ENDIF.
        CREATE DATA dref TYPE p LENGTH length DECIMALS decimals.
        ASSIGN dref->\* TO <pack>.
      CATCH cx\_sy\_create\_data\_error.
        cl\_demo\_output=>display( 'Wrong input values ...' ).
        LEAVE PROGRAM.
    ENDTRY.
    DATA(lower)
      = cl\_abap\_exceptional\_values=>get\_min\_value( <pack> ).
    IF lower IS NOT INITIAL.
      ASSIGN lower->\* TO FIELD-SYMBOL(<lower>).
      cl\_demo\_output=>write\_data( <lower> ).
    ENDIF.
    ASSERT <lower> =  CONV decfloat34(
     ( ipow( base = -10 exp = 2 \* length - 1 ) + 1 ) /
       ipow( base  = 10 exp = decimals ) ).
    DATA(upper)
       = cl\_abap\_exceptional\_values=>get\_max\_value( <pack> ).
    IF upper IS NOT INITIAL.
      ASSIGN upper->\* TO FIELD-SYMBOL(<upper>).
      cl\_demo\_output=>write\_data( <upper> ).
    ENDIF.
    ASSERT <upper> = CONV decfloat34(
     ( ipow( base = +10 exp = 2 \* length - 1 ) - 1 ) /
       ipow( base  = 10 exp = decimals ) ).
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The value range of a packed number with the length length and decimals decimal places is one of the following (in accordance with the formula in this [table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm)):

( -10^(2xlength-1) +1 ) / ( 10^decimals )

to

( +10^(2xlength-1) -1 ) / ( 10^decimals )

The program creates a packed number with a length and decimal places that can be entered from outside. The minimum and maximum values of the number are determined using methods from the system class CL\_ABAP\_EXCEPTIONAL\_VALUES and compared with self-calculated values.


### abenbuiltin_types_numeric.htm

---
title: "Predefined Numeric Types"
description: |
  The data objects of the numeric data types are used to handle number values. Properties Type Length Standard Length Name b 1 byte 1-byte integer(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninteger_glosry.htm 'Glossary Entry') (internal) s 2 byte 2-byte integer(https://help.sap
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm"
abapFile: "abenbuiltin_types_numeric.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abenbuiltin", "numeric"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Predefined Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types.htm) →  [Built-In ABAP Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_complete.htm) → 

Predefined Numeric Types

The data objects of the numeric data types are used to handle number values.

Properties

Type

Length

Standard Length

Name

b

1 byte

 

1-byte [integer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninteger_glosry.htm "Glossary Entry") (internal)

s

2 byte

 

2-byte [integer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninteger_glosry.htm "Glossary Entry") (internal)

i

4 byte

 

4-byte [integer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninteger_glosry.htm "Glossary Entry")

int8

8 byte

 

8-byte [integer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninteger_glosry.htm "Glossary Entry")

p

1 to 16 bytes

8 byte

[Packed number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpacked_number_glosry.htm "Glossary Entry")

decfloat16

8 byte

 

[Decimal floating point number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendecfloat_glosry.htm "Glossary Entry") with 16 places

decfloat34

16 byte

 

[Decimal floating point number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendecfloat_glosry.htm "Glossary Entry") with 34 places

f

8 byte

 

[Binary floating point number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbinfloat_glosry.htm "Glossary Entry") with 17 places

Value Ranges and Initial Values

Type

Value Range

Initial Value

b

0 to 255

0

s

\-32,768 to +32,767

0

i

\-2,147,483,648 to +2,147,483,647

0

int8

\-9,223,372,036,854,775,808 to +9,223,372,036,854,775,807

0

p

The valid length for packed numbers is between 1 and 16 bytes. Two places are packed into one byte, where the last byte only contains one place and the sign (the number of places or digits is calculated from 2 \* len1). After the decimal separator, up to 14 [decimal places](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfractional_portion_glosry.htm "Glossary Entry") are permitted (as long as the number of decimal places does not exceed the number of places). Depending on the field length len and the number of decimal places dec, the following applies to the value range: (-10^(2len-1) +1) / (10^(+dec)) to (+10^(2len-1) -1) /(10^(+dec)) in increments of 10^(-dec). Any intermediate values are rounded (decimal). Invalid content produces undefined behavior.

0

decfloat16

Decimal floating point numbers of this type are represented internally with 16 places in accordance with the IEEE-754-2008 standard. Valid values are numbers between 1E385(1E-16 - 1) and -1E-383 for the negative range, 0 and +1E-383 to 1E385(1 - 1E-16) for the positive range. Values lying between the ranges form the subnormal range and are rounded. Outside of the subnormal range, each 16-digit decimal number can be represented precisely with a decimal floating point number of this type

0

decfloat34

Decimal floating point numbers of this type are represented internally with 34 places in accordance with the IEEE-754-2008 standard. Valid values are numbers between 1E6145(1E-34 - 1) and -1E-6143 for the negative range, 0 and +1E-6143 and 1E6145(1 - 1E-34) for the positive range. Values lying between the ranges form the subnormal range and are rounded. Outside of the subnormal range, each 34-digit decimal number can be represented precisely using a decimal floating point number like this.

0

f

Binary floating point numbers are represented internally in accordance with the IEEE-754 standard (double precision). In ABAP, 17 places are represented (one integer digit and 16 decimal places). Valid values are numbers between -1.7976931348623157E+308 and -2.2250738585072014E-308 for the negative range and between +2.2250738585072014E-308 and +1.7976931348623157E+308 for the positive range, plus 0. Both validity intervals are extended in the direction of zero using subnormal numbers in accordance with the IEEE-754 standard.

0

Programming Guideline

[Select the numeric type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselect_numeric_type_guidl.htm "Guideline")

Notes

-   The numeric data objects are used to handle numeric values and [numeric calculations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencompute_expressions.htm). Here, the data type f for binary floating point numbers is replaced largely by the types decfloat16 and decfloat34 for decimal floating point numbers.

-   The types b and s are internal types and cannot be specified either statically or dynamically in ABAP statements. Self-defined data types and data objects in ABAP programs have the data types b or s if they were defined with reference to data elements in ABAP Dictionary that have the [external data types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexternal_data_type_glosry.htm "Glossary Entry") [INT1](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) or [INT2](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm).

-   The system class [CL\_ABAP\_MATH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_class.htm) contains constants for the minimum and maximum values of most numeric types. The methods GET\_MIN\_VALUE and GET\_MAX\_VALUE in the class CL\_ABAP\_EXCEPTIONAL\_VALUES can also be used.

-   The system class CL\_ABAP\_ELEMDESCR in [RTTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrtti.htm) contains constants TYPE\_P\_MAX\_LENGTH and TYPE\_P\_MAX\_DECIMALS for the maximum length and the maximum number of decimal places p.

-   Since the decimal places in a floating point number of type f are represented internally as dual fractions, there is not an exact equivalent for every number that can be represented in the decimal system. This can produce rounding errors in conversions and intermediate results of calculations. These errors can be avoided by using a two-step rounding procedure (see [Example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_class.htm)).

-   The type p, for which a length interval is specified in the second column in the first table, is [generic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_generic.htm), which means that the length is not part of the type description. Also, both the [decimal places](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfractional_portion_glosry.htm "Glossary Entry") and the length are undefined. The entry in the Standard Length column specifies the length used in declarations of data objects when using types with generic lengths, if no explicit length is specified in the relevant statement.

-   The data type p is used to implement [fixed point numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfixed_point_number_glosry.htm "Glossary Entry"). The number of decimal places in a packed number with the type p is a type attribute defined using the addition [DECIMALS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_simple.htm) and is not saved together with the number. Technically, the number value is determined by dividing the saved sequence of digits in the packed number by 10 to the power of the number of decimal places (10^(+dec)). In the definition of a packed number, the number of decimal places cannot be greater than the number of places calculated from 2 \*  len - 1. Otherwise, the decimal separator is outside the sequence of digits and not all decimal places can be given values. For example, if a packed number with length 1 and two decimal places has a value range of \-0.09 to +0.09 in increments of 0.01, there is no possible value for which the first decimal place is filled, for example 0.14.

-   A number with the data type p that has more decimal places than places can raise exceptions when converted to external formats such as data types of the database in [ABAP SQL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenopen_sql_glosry.htm "Glossary Entry") or in serializations to [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry").

-   The [built-in types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_builtin_types.htm) in ABAP Dictionary mapped to the data type p cannot have more decimal places than places. In ABAP, declarations like this that are known statically produce a syntax check warning.

-   For data objects of data type p, the [program attribute](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprogram_attribute_glosry.htm "Glossary Entry") Fixed Point Arithmetic must be set so that the decimal separator is respected. Otherwise, in all operations, the content is handled as if there is no decimal separator. The sequence of digits in the variables of type p is interpreted as an integer value. Exceptions are:

-   Representation on screens

-   Formatting with [WRITE *\[*TO*\]*](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_to.htm)

-   [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_type_p.htm) to character-like objects with the types c and string

-   See also [Numeric Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumber_types.htm).

Example

Declares variables with built-in numeric ABAP types for a numeric calculation.

DATA: num1   TYPE i,
      num2   TYPE i,
      result TYPE decfloat34.
...
result = num1 / num2.

Executable Example

[Value Ranges of Packed Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_p_value_range_abexa.htm)

Continue
![Example](exa.gif "Example") [Value Ranges of Packed Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_p_value_range_abexa.htm)


### abenbuiltin_types_character.htm

---
title: "Predefined Character-Like Types"
description: |
  The data objects of the character-like data types are used to handle character strings. Properties Type Length Standard Length Name c 1 to 262,143 characters 1 character Text Field(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_field_glosry.htm 'Glossary Entry') n 1 to 262,143
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_character.htm"
abapFile: "abenbuiltin_types_character.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenbuiltin", "character"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Predefined Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types.htm) →  [Built-In ABAP Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_complete.htm) → 

Predefined Character-Like Types

The data objects of the character-like data types are used to handle character strings.

Properties

Type

Length

Standard Length

Name

c

1 to 262,143 characters

1 character

[Text Field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_field_glosry.htm "Glossary Entry")

n

1 to 262,143 characters

1 character

[Numeric text field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumeric_text_field_glosry.htm "Glossary Entry")

string

Variable

 

[Text string](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_string_glosry.htm "Glossary Entry")

Value Ranges and Initial Values

Type

Value Range

Initial Value

c

Any alphanumeric characters

" " for every position

n

Any alphanumeric characters; only valid values are the digits 0 to 9, however

"0" for every position

string

As for type c

Empty string with length 0

Notes

-   The character-like data types are mainly used for [string processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_string.htm).

-   The data types c and string are general character-like data types, but n, on the other hand, has special properties. The data type n corresponds to the special type [NUMC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_special_character_types.htm) in ABAP Dictionary.

-   Further character-like data types with special properties are the built-in [date types and time types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_date_time.htm) that match the corresponding types [DATS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_date_time_types.htm) and [TIMS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_date_time_types.htm) in ABAP Dictionary. All other special character-like data types in ABAP Dictionary are assigned to the general ABAP types listed here.

-   The content of the data objects of character-like data types is saved in the memory in accordance with the current [system code page](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_codepage_glosry.htm "Glossary Entry")

-   When specifying lengths for character-like types, note that the length of a character in bytes depends on the character representation used. The length of a character is two bytes for the character representation [UCS-2](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenucs2_glosry.htm "Glossary Entry") used by the ABAP programming language.

-   The types c and n, for which a length interval is specified in the second column in the first table, are [generic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_generic.htm), which means that the length is not part of the type description. The entries in the Standard Length column specify the length used in declarations of data objects when using types with generic lengths, if no explicit length is specified in the relevant statement.

-   The system class CL\_ABAP\_ELEMDESCR contains constants TYPE\_C\_MAX\_LENGTH and TYPE\_N\_MAX\_LENGTH for the maximum length of the types c and n.

-   The valid values of the data type n are a subset of its value range. ABAP statements that work with data objects of this type are only guaranteed to function correctly for operands with valid values.

-   The [maximum size](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmemory_consumption_2.htm) of strings must be respected.

Example

Declares character-like data objects with built-in character-like data types. The flag flag is limited to one character and the set of characters in the string html is variable.

DATA: flag TYPE c LENGTH 1,
      html TYPE string.


### abenbuiltin_types_byte.htm

---
title: "Predefined Byte-Like Types"
description: |
  The data objects of the byte-like data types are used to include byte strings. Properties Type Length Standard Length Name x 1 to 524,287 bytes 1 byte Byte field(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbyte_field_glosry.htm 'Glossary Entry') xstring Variable Byte string(ht
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_byte.htm"
abapFile: "abenbuiltin_types_byte.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "abenbuiltin", "byte"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Predefined Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types.htm) →  [Built-In ABAP Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_complete.htm) → 

Predefined Byte-Like Types

The data objects of the byte-like data types are used to include byte strings.

Properties

Type

Length

Standard Length

Name

x

1 to 524,287 bytes

1 byte

[Byte field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbyte_field_glosry.htm "Glossary Entry")

xstring

Variable

 

[Byte string](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbyte_string_glosry.htm "Glossary Entry")

Value Ranges and Initial Values

Type

Value Range

Initial Value

x

Any byte values, hexadecimal 00 to FF

Hexadecimal 00

xstring

As for type x

Empty string with length 0

Notes

-   The byte-like data types are used for [byte string processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_string.htm).

-   The type x, for which a length interval is specified in the second column in the first table, is [generic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_generic.htm), which means that the length is not part of the type description. The entry in the Standard Length column specifies the length used in declarations of data objects when using types with generic lengths, if no explicit length is specified in the relevant statement.

-   The system class CL\_ABAP\_ELEMDESCR contains a constant TYPE\_X\_MAX\_LENGTH for the maximum length of the type x.

-   The [maximum size](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmemory_consumption_2.htm) of strings must be respected.

Example

Declares a byte string of the built-in ABAP type xstring for the result of a functional method. This declaration could also be made [inline](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_inline.htm) on the left side of the assignment.

DATA hex TYPE xstring.
hex =  cl\_abap\_conv\_codepage=>create\_out(  )->convert( \`...\` ).


### abenbuiltin_types_date_time.htm

---
title: "Built-In Date Types, Time Types, and Time Stamp Types"
description: |
  The data objects of the date types, time types, and time stamp types are used to handle calendar dates, times, and time stamps. Attributes Type Length Default Length Name d 8 characters Date field(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendate_field_glosry.htm 'Glossary Entry'
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_date_time.htm"
abapFile: "abenbuiltin_types_date_time.htm"
keywords: ["do", "try", "class", "data", "types", "abenbuiltin", "date", "time"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Predefined Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types.htm) →  [Built-In ABAP Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_complete.htm) → 

Built-In Date Types, Time Types, and Time Stamp Types

The data objects of the date types, time types, and time stamp types are used to handle calendar dates, times, and time stamps.

Attributes

Type

Length

Default Length

Name

d

8 characters

 

[Date field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendate_field_glosry.htm "Glossary Entry")

t

6 characters

 

[Time field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_field_glosry.htm "Glossary Entry")

utclong

8 byte

 

[Time stamp field](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentimestamp_field_glosry.htm "Glossary Entry")

Value Ranges and Initial Values

Type

Value Range

Initial Value

d

Any eight alphanumeric characters, but only those digits are valid that are valid as dates in accordance with the calendar rules in the format "yyyymmdd": "yyyy" (year): 0001 to 9999, "mm" (month): 01 to 12, "dd" (day): 01 to 31

"00000000"

t

Any six alphanumeric characters, but only those digits are valid that are valid as times in accordance in the format 24-hour clock format "hhmmss". "hh" (hours): 00 to 23, "mm" (minutes): 00 to 59, "ss" (seconds): 00 to 59.

"000000"

utclong

Internal 8-byte integer representation of a UTC time stamp exact to 100 nanoseconds, in ISO-8601 notation between "0001-01-01T00:00:00.0000000" and "9999-12-31T23:59:59.9999999". There are 3,155,380,704,000,000,000 real values and one special [initial value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutclong.htm).

[0](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutclong.htm)

Notes

-   Date types and time types d and t

-   The date types and time types are used to handle values for calendar dates and times. Information about how they are used and their special handling can be found under [Date Fields and Time Fields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencharacter_date_time.htm).

-   From a technical perspective, the data types d and t are flat character-like types. The content of their data objects is saved in accordance with the current [system code page](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_codepage_glosry.htm "Glossary Entry").

-   As character-like data types, data objects of the data types d and t can be used like text fields of the type c. This applies in particular also to structures with components of the types d and t.

-   The generic type [clike](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_generic.htm) also covers the types d and t.

-   Data objects of the types d and t display character-like behavior in character-like operand positions and numeric behavior in numeric operand positions.

-   The data types d and t are the built-in ABAP types that correspond to the special types [DATS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_date_time_types.htm), [DATN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_date_time_types.htm), and [TIMS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_date_time_types.htm), [TIMN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_date_time_types.htm) in ABAP Dictionary.

-   The valid values of the data types d and t are a subset of their value range. ABAP statements that work with data objects of these types are only guaranteed to function correctly for operands with valid values.

-   Time stamp type utclong

-   The time stamp type utclong represented internally by integer numbers is a type for real [time stamp fields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutclong.htm) and replaces the [time stamps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm) represented by packed numbers.

-   The data type utclong is the built-in ABAP type that corresponds to the special type [UTCLONG](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenddic_date_time_types.htm) in ABAP Dictionary.

-   The system class [CL\_ABAP\_UTCLONG](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentimestamp_system_class.htm) for time stamps in time stamp fields contains the minimum and maximum values of the type utclong as attributes.

-   Invalid values in time stamps (meaning integers outside of the string of valid values) can be produced by [casting](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencast_casting_glosry.htm "Glossary Entry").

-   There is not a time stamp for the missing days due to the switch from the Julian to the Gregorian calendar. The time stamp "1582-10-04T23:59:59.9999999" is followed by the time stamp "1582-10-15T00:00:00.0000000".

Example

Declares date fields and time fields of the built-in ABAP types d and t and examples for how to use them. These declarations are made both using the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) and using the declaration operator [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_inline.htm).

DATA: tomorrow  TYPE d,
      next\_hour TYPE t.
DATA(today) = sy-datlo.
DATA(now)   = sy-timlo.
tomorrow  = today + 1.
next\_hour = ( now + 3600 ) / 3600 \* 3600.

Example

Creates a time stamp of the type utclong using the built-in function [utclong\_current](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutclong_current.htm) and converts it into date fields and time fields.

DATA(ts) = utclong\_current( ).
CONVERT UTCLONG ts
        INTO DATE DATA(dat) TIME DATA(tim)
        TIME ZONE sy-zonlo.
cl\_demo\_output=>display(
  |{ ts }\\n| &&
  |{ dat }\\n| &&
  |{ tim }|  ).


---


## ABAP Keyword Documentation / ABAP − Reference / Built-In Types, Data Objects, Functions, and Constructors / Built-In Data Objects / ABAP System Fields

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Built-In Types, Data Objects, Functions, and Constructors / Built-In Functions

Included pages: 4


### abenbuilt_in_functions.htm

---
title: "Built-In Functions"
description: |
  ABAP provides a set of built-in functions. A built-in function returns a return value for one or more arguments. Built-in functions can be called by functions in certain operand positions. Built-in functions can be called functionally in certain operand positions(https://help.sap.com/doc/abapdocu_
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions.htm"
abapFile: "abenbuilt_in_functions.htm"
keywords: ["do", "method", "data", "types", "abenbuilt", "functions"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) → 

Built-In Functions

ABAP provides a set of built-in functions. A built-in function returns a return value for one or more arguments. Built-in functions can be called by functions in certain operand positions.

Built-in functions can be called functionally in [certain operand positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_expressions.htm). When a built-in function is called in an [operand position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexpression_positions.htm), the function is executed before the operand is used and the return value of the built-in function is used as the operand, in accordance with its data type.

-   [Syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_syntax.htm)

-   [Overview](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_overview.htm)

-   [Obscuring with Methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_hiding.htm)

Continue
[Built-In Functions - Syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_syntax.htm)
[Built-In Functions - Overview](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_overview.htm)
[Built-In Functions - Obscured by Methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_hiding.htm)


### abenbuilt_in_functions_syntax.htm

---
title: "Built-In Functions - Syntax"
description: |
  -   Functions with an Unnamed Argument(#abenbuilt-in-functions-syntax-1--------functions-with-named-arguments---@ITOC@@ABENBUILT_IN_FUNCTIONS_SYNTAX_2) In functions with named arguments, there is usually a main argument val and additional, possibly also optional, arguments. The following sections
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_syntax.htm"
abapFile: "abenbuilt_in_functions_syntax.htm"
keywords: ["do", "if", "method", "data", "types", "abenbuilt", "functions", "syntax"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Built-In Functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions.htm) → 

Built-In Functions - Syntax

-   [Functions with an Unnamed Argument](#abenbuilt-in-functions-syntax-1--------functions-with-named-arguments---@ITOC@@ABENBUILT_IN_FUNCTIONS_SYNTAX_2)

In functions with named arguments, there is usually a main argument val and additional, possibly also optional, arguments. The following sections show the general syntax for calling built-in functions.

Functions with an Unnamed Argument

Syntax

... func( arg ) ...

The syntax for functions with an unnamed argument is the same as the syntax for calling functional methods with an input parameter. func is the built-in function and the argument arg is an operand whose data type matches the function. The blanks after the opening parentheses and before the closing parentheses are relevant.

Example

The built-on function [line\_exists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_exists_function.htm) has an unnamed argument that expects a table expression.

DATA itab TYPE TABLE OF i WITH EMPTY KEY.
...
IF line\_exists( itab\[ 1 \] ).
  ...
ENDIF.

Functions with Named Arguments

Syntax

... func( val = arg p1 = arg1 p2 = arg2 ... ) ...

Functions with one or more named arguments are bound to keyword parameters in the same way as when functional methods are called with multiple input parameters. Operands can be specified for the arguments whose data type matches the corresponding parameter. The blanks after the opening parentheses and before the closing parentheses are relevant. If one of these functions only has one argument or only the main argument is to be populated, the syntax can be simplified as follows:

... func( arg ) ...

Example

The built-in function [condense](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencondense_functions.htm) has named arguments and can, for example, be called as follows.

DATA(str1) = condense( \`...\` ).
DATA(str2) = condense( val = \`...\` ).
DATA(str3) = condense( val = \`...\`  del = \` \` ).


### abenbuilt_in_functions_overview.htm

---
title: "Built-In Functions - Overview"
description: |
  The following tables show the built-in functions by purpose. Built-in functions are generally processing functions(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocess_function_glosry.htm 'Glossary Entry') or description functions(https://help.sap.com/doc/abapdocu_754_index_htm
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_overview.htm"
abapFile: "abenbuilt_in_functions_overview.htm"
keywords: ["insert", "do", "if", "case", "try", "data", "types", "internal-table", "abenbuilt", "functions", "overview"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Built-In Functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions.htm) → 

Built-In Functions - Overview

The following tables show the built-in functions by purpose. Built-in functions are generally [processing functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocess_function_glosry.htm "Glossary Entry") or [description functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescription_function_glosry.htm "Glossary Entry").

-   A processing function performs general processing and returns a return code according to its purpose.

-   A description function determines a property of an argument and usually returns this property as a numerical value.

Other functions are known as logical functions, which either evaluate a logical expression (Boolean functions) or return a truth value (predicate functions).

Logical Functions

Function

Meaning

[boolc](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboole_functions.htm), [boolx](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboole_functions.htm), [xsdbool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboole_functions.htm)

Boolean functions

[contains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencontains_functions.htm), [contains\_any\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencontains_functions.htm), [contains\_any\_not\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencontains_functions.htm)

Predicate functions for strings

[matches](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmatches_functions.htm)

Predicate function for strings

[line\_exists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_exists_function.htm)

Predicate function for internal tables

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogic_functions.htm)

Numerical Functions

Function

Meaning

[abs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm), [ceil](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm), [floor](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm), [frac](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm), [sign](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm), [trunc](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm)

General numerical functions

[ipow](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpower_function.htm)

Integer power function

[nmax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennmax_nmin_functions.htm), [nmin](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennmax_nmin_functions.htm)

Numerical extremum functions

[acos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [asin](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [atan](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [cos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [sin](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [tan](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [cosh](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [sinh](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [tanh](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [log](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [log10](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [sqrt](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm)

Floating point functions

[round](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendec_floating_point_functions.htm), [rescale](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendec_floating_point_functions.htm)

Rounding functions

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmathematical_functions.htm)

String Functions

Function

Meaning

[charlen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlength_functions.htm), [dbmaxlen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlength_functions.htm), [numofchar](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlength_functions.htm), [strlen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlength_functions.htm)

Length functions

[char\_off](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlength_functions_args.htm)

Length function

[cmax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencmax_cmin_functions.htm), [cmin](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencmax_cmin_functions.htm)

Character-like extremum value functions

[count](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencount_functions.htm), [count\_any\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencount_functions.htm), [count\_any\_not\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencount_functions.htm)

Search functions

[distance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendistance_functions.htm)

Similarity function

[condense](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencondense_functions.htm)

Condense function

[concat\_lines\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconcatenation_functions.htm)

Concatenation function

[escape](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenescape_functions.htm)

Escape symbol function

[find](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_functions.htm), [find\_end](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_functions.htm), [find\_any\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_functions.htm), [find\_any\_not\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_functions.htm)

Search functions

[insert](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninsert_functions.htm)

Insert function

[match](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmatch_functions.htm)

Substring function

[repeat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrepeat_functions.htm)

Repeat function

[replace](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreplace_functions.htm)

Replace function

[reverse](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreverse_functions.htm)

Reverse function

[Segment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensegment_functions.htm)

Segment function

[shift\_left](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshift_functions.htm), [shift\_right](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshift_functions.htm)

Shift functions

[substring](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm), [substring\_after](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm), [substring\_from](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm), [substring\_before](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm), [substring\_to](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm)

Substring functions

[to\_upper](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm), [to\_lower](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm), [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm), [from\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm)

Case functions

[translate](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentranslate_functions.htm)

Translation function

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_functions.htm)

Byte String Functions

Function

Meaning

[xstrlen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescriptive_functions_binary.htm)

Length function

[bit-set](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbit_functions.htm)

Bit function

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbinary_functions.htm)

Time Stamp Functions

Function

Meaning

[utclong\_current](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutclong_current.htm)

Current time stamp

[utclong\_add](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutclong_add.htm)

Addition function for time stamps

[utclong\_diffs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutclong_diff.htm)

Difference function for time stamps

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentimestamp_functions.htm)

Table Functions

Function

Meaning

[lines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescriptive_functions_table.htm)

Row function

[line\_index](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_index_function.htm)

Index function

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_functions.htm)


### abenbuilt_in_functions_hiding.htm

---
title: "Built-In Functions - Obscured by Methods"
description: |
  Within a class, a built-in function is always obscured by methods(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmethod_glosry.htm 'Glossary Entry') of the class if they have the same name, regardless of the number and type of arguments in the function. The function is also obscure
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_hiding.htm"
abapFile: "abenbuilt_in_functions_hiding.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abenbuilt", "functions", "hiding"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Built-In Functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions.htm) → 

Built-In Functions - Obscured by Methods

Within a class, a built-in function is always obscured by [methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmethod_glosry.htm "Glossary Entry") of the class if they have the same name, regardless of the number and type of arguments in the function. The function is also obscured regardless of the number and type of method parameters. This also takes place in method calls for which no selector \=> or \-> is specified in front of the method name:

-   A [static method](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_method_glosry.htm "Glossary Entry") obscures a built-in function with the same name in all methods of the associated class.

-   An [instance method](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_method_glosry.htm "Glossary Entry") obscures a built-in function with the same name in the instance methods of the associated class.

The function is obscured regardless of the operand position. More specifically, any built-in functions called as arguments of other functions are also obscured.

Note

Methods should never be given the same name as a built-in function.

Example

The following class returns a syntax error. The strlen specified on the right side of the assignment indicates the method of the class and not the built-in function. It cannot be specified in this operand position since it is not a functional method with return code.

CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS strlen IMPORTING text TYPE string
                         EXPORTING len  TYPE i.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(len) = strlen( \`xxx\` ).
  ENDMETHOD.
  METHOD strlen.
    ...
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Built-In Types, Data Objects, Functions, and Constructors / Built-In Functions

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Built-In Types, Data Objects, Functions, and Constructors / Built-In Functions

Included pages: 4


### abenbuilt_in_functions.htm

---
title: "Built-In Functions"
description: |
  ABAP provides a set of built-in functions. A built-in function returns a return value for one or more arguments. Built-in functions can be called by functions in certain operand positions. Built-in functions can be called functionally in certain operand positions(https://help.sap.com/doc/abapdocu_
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions.htm"
abapFile: "abenbuilt_in_functions.htm"
keywords: ["do", "method", "data", "types", "abenbuilt", "functions"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) → 

Built-In Functions

ABAP provides a set of built-in functions. A built-in function returns a return value for one or more arguments. Built-in functions can be called by functions in certain operand positions.

Built-in functions can be called functionally in [certain operand positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_expressions.htm). When a built-in function is called in an [operand position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexpression_positions.htm), the function is executed before the operand is used and the return value of the built-in function is used as the operand, in accordance with its data type.

-   [Syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_syntax.htm)

-   [Overview](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_overview.htm)

-   [Obscuring with Methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_hiding.htm)

Continue
[Built-In Functions - Syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_syntax.htm)
[Built-In Functions - Overview](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_overview.htm)
[Built-In Functions - Obscured by Methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_hiding.htm)


### abenbuilt_in_functions_syntax.htm

---
title: "Built-In Functions - Syntax"
description: |
  -   Functions with an Unnamed Argument(#abenbuilt-in-functions-syntax-1--------functions-with-named-arguments---@ITOC@@ABENBUILT_IN_FUNCTIONS_SYNTAX_2) In functions with named arguments, there is usually a main argument val and additional, possibly also optional, arguments. The following sections
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_syntax.htm"
abapFile: "abenbuilt_in_functions_syntax.htm"
keywords: ["do", "if", "method", "data", "types", "abenbuilt", "functions", "syntax"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Built-In Functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions.htm) → 

Built-In Functions - Syntax

-   [Functions with an Unnamed Argument](#abenbuilt-in-functions-syntax-1--------functions-with-named-arguments---@ITOC@@ABENBUILT_IN_FUNCTIONS_SYNTAX_2)

In functions with named arguments, there is usually a main argument val and additional, possibly also optional, arguments. The following sections show the general syntax for calling built-in functions.

Functions with an Unnamed Argument

Syntax

... func( arg ) ...

The syntax for functions with an unnamed argument is the same as the syntax for calling functional methods with an input parameter. func is the built-in function and the argument arg is an operand whose data type matches the function. The blanks after the opening parentheses and before the closing parentheses are relevant.

Example

The built-on function [line\_exists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_exists_function.htm) has an unnamed argument that expects a table expression.

DATA itab TYPE TABLE OF i WITH EMPTY KEY.
...
IF line\_exists( itab\[ 1 \] ).
  ...
ENDIF.

Functions with Named Arguments

Syntax

... func( val = arg p1 = arg1 p2 = arg2 ... ) ...

Functions with one or more named arguments are bound to keyword parameters in the same way as when functional methods are called with multiple input parameters. Operands can be specified for the arguments whose data type matches the corresponding parameter. The blanks after the opening parentheses and before the closing parentheses are relevant. If one of these functions only has one argument or only the main argument is to be populated, the syntax can be simplified as follows:

... func( arg ) ...

Example

The built-in function [condense](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencondense_functions.htm) has named arguments and can, for example, be called as follows.

DATA(str1) = condense( \`...\` ).
DATA(str2) = condense( val = \`...\` ).
DATA(str3) = condense( val = \`...\`  del = \` \` ).


### abenbuilt_in_functions_overview.htm

---
title: "Built-In Functions - Overview"
description: |
  The following tables show the built-in functions by purpose. Built-in functions are generally processing functions(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocess_function_glosry.htm 'Glossary Entry') or description functions(https://help.sap.com/doc/abapdocu_754_index_htm
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_overview.htm"
abapFile: "abenbuilt_in_functions_overview.htm"
keywords: ["insert", "do", "if", "case", "try", "data", "types", "internal-table", "abenbuilt", "functions", "overview"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Built-In Functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions.htm) → 

Built-In Functions - Overview

The following tables show the built-in functions by purpose. Built-in functions are generally [processing functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocess_function_glosry.htm "Glossary Entry") or [description functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescription_function_glosry.htm "Glossary Entry").

-   A processing function performs general processing and returns a return code according to its purpose.

-   A description function determines a property of an argument and usually returns this property as a numerical value.

Other functions are known as logical functions, which either evaluate a logical expression (Boolean functions) or return a truth value (predicate functions).

Logical Functions

Function

Meaning

[boolc](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboole_functions.htm), [boolx](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboole_functions.htm), [xsdbool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboole_functions.htm)

Boolean functions

[contains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencontains_functions.htm), [contains\_any\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencontains_functions.htm), [contains\_any\_not\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencontains_functions.htm)

Predicate functions for strings

[matches](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmatches_functions.htm)

Predicate function for strings

[line\_exists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_exists_function.htm)

Predicate function for internal tables

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogic_functions.htm)

Numerical Functions

Function

Meaning

[abs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm), [ceil](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm), [floor](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm), [frac](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm), [sign](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm), [trunc](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennumerical_functions.htm)

General numerical functions

[ipow](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpower_function.htm)

Integer power function

[nmax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennmax_nmin_functions.htm), [nmin](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennmax_nmin_functions.htm)

Numerical extremum functions

[acos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [asin](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [atan](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [cos](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [sin](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [tan](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [cosh](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [sinh](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [tanh](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [log](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [log10](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm), [sqrt](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_functions.htm)

Floating point functions

[round](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendec_floating_point_functions.htm), [rescale](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendec_floating_point_functions.htm)

Rounding functions

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmathematical_functions.htm)

String Functions

Function

Meaning

[charlen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlength_functions.htm), [dbmaxlen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlength_functions.htm), [numofchar](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlength_functions.htm), [strlen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlength_functions.htm)

Length functions

[char\_off](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlength_functions_args.htm)

Length function

[cmax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencmax_cmin_functions.htm), [cmin](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencmax_cmin_functions.htm)

Character-like extremum value functions

[count](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencount_functions.htm), [count\_any\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencount_functions.htm), [count\_any\_not\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencount_functions.htm)

Search functions

[distance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendistance_functions.htm)

Similarity function

[condense](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencondense_functions.htm)

Condense function

[concat\_lines\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconcatenation_functions.htm)

Concatenation function

[escape](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenescape_functions.htm)

Escape symbol function

[find](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_functions.htm), [find\_end](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_functions.htm), [find\_any\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_functions.htm), [find\_any\_not\_of](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensearch_functions.htm)

Search functions

[insert](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninsert_functions.htm)

Insert function

[match](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmatch_functions.htm)

Substring function

[repeat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrepeat_functions.htm)

Repeat function

[replace](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreplace_functions.htm)

Replace function

[reverse](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreverse_functions.htm)

Reverse function

[Segment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensegment_functions.htm)

Segment function

[shift\_left](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshift_functions.htm), [shift\_right](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshift_functions.htm)

Shift functions

[substring](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm), [substring\_after](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm), [substring\_from](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm), [substring\_before](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm), [substring\_to](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubstring_functions.htm)

Substring functions

[to\_upper](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm), [to\_lower](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm), [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm), [from\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm)

Case functions

[translate](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentranslate_functions.htm)

Translation function

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_functions.htm)

Byte String Functions

Function

Meaning

[xstrlen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescriptive_functions_binary.htm)

Length function

[bit-set](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbit_functions.htm)

Bit function

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbinary_functions.htm)

Time Stamp Functions

Function

Meaning

[utclong\_current](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutclong_current.htm)

Current time stamp

[utclong\_add](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutclong_add.htm)

Addition function for time stamps

[utclong\_diffs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutclong_diff.htm)

Difference function for time stamps

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentimestamp_functions.htm)

Table Functions

Function

Meaning

[lines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescriptive_functions_table.htm)

Row function

[line\_index](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_index_function.htm)

Index function

[→ More](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_functions.htm)


### abenbuilt_in_functions_hiding.htm

---
title: "Built-In Functions - Obscured by Methods"
description: |
  Within a class, a built-in function is always obscured by methods(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmethod_glosry.htm 'Glossary Entry') of the class if they have the same name, regardless of the number and type of arguments in the function. The function is also obscure
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions_hiding.htm"
abapFile: "abenbuilt_in_functions_hiding.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abenbuilt", "functions", "hiding"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Built-In Types, Data Objects, Functions, and Constructors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in.htm) →  [Built-In Functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions.htm) → 

Built-In Functions - Obscured by Methods

Within a class, a built-in function is always obscured by [methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmethod_glosry.htm "Glossary Entry") of the class if they have the same name, regardless of the number and type of arguments in the function. The function is also obscured regardless of the number and type of method parameters. This also takes place in method calls for which no selector \=> or \-> is specified in front of the method name:

-   A [static method](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_method_glosry.htm "Glossary Entry") obscures a built-in function with the same name in all methods of the associated class.

-   An [instance method](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_method_glosry.htm "Glossary Entry") obscures a built-in function with the same name in the instance methods of the associated class.

The function is obscured regardless of the operand position. More specifically, any built-in functions called as arguments of other functions are also obscured.

Note

Methods should never be given the same name as a built-in function.

Example

The following class returns a syntax error. The strlen specified on the right side of the assignment indicates the method of the class and not the built-in function. It cannot be specified in this operand position since it is not a functional method with return code.

CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS strlen IMPORTING text TYPE string
                         EXPORTING len  TYPE i.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(len) = strlen( \`xxx\` ).
  ENDMETHOD.
  METHOD strlen.
    ...
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Types and Objects - Overview / Data Objects / References

**Files**: 5 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2


### abendeclarations_spcl.htm

---
title: "Special Declarations"
description: |
  These language elements should be used only by specialists with in-depth knowledge of the corresponding environment. -   INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm) INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm"
abapFile: "abendeclarations_spcl.htm"
keywords: ["do", "data", "types", "abendeclarations", "spcl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)

Continue
[INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)


### abapinfotypes.htm

---
title: "INFOTYPES"
description: |
  This statement should be used by specialists only. In-depth knowledge of the corresponding environment is essential. This environment is not part of ABAP and is not documented here. Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm) Syntax INFOTY
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm"
abapFile: "abapinfotypes.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "types", "internal-table", "abapinfotypes"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) →  [Special Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm)

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninfo_type_glosry.htm "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{* 10 *|* n *}*.
  [INCLUDE TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinclude_type.htm) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declaration_sect_glosry.htm "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm)). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexecutable_program_glosry.htm "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) object.
    
-   The logical database PNP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide_obsolete.htm) of the statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm). If the addition VALID FROM is specified, other [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Types and Objects - Overview / Data Objects / Memory Management of Deep Objects

**Files**: 6 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2


### abendeclarations_spcl.htm

---
title: "Special Declarations"
description: |
  These language elements should be used only by specialists with in-depth knowledge of the corresponding environment. -   INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm) INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm"
abapFile: "abendeclarations_spcl.htm"
keywords: ["do", "data", "types", "abendeclarations", "spcl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)

Continue
[INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)


### abapinfotypes.htm

---
title: "INFOTYPES"
description: |
  This statement should be used by specialists only. In-depth knowledge of the corresponding environment is essential. This environment is not part of ABAP and is not documented here. Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm) Syntax INFOTY
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm"
abapFile: "abapinfotypes.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "types", "internal-table", "abapinfotypes"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) →  [Special Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm)

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninfo_type_glosry.htm "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{* 10 *|* n *}*.
  [INCLUDE TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinclude_type.htm) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declaration_sect_glosry.htm "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm)). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexecutable_program_glosry.htm "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) object.
    
-   The logical database PNP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide_obsolete.htm) of the statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm). If the addition VALID FROM is specified, other [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Types / TYPES / TYPES - BEGIN OF struct_type

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2


### abendeclarations_spcl.htm

---
title: "Special Declarations"
description: |
  These language elements should be used only by specialists with in-depth knowledge of the corresponding environment. -   INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm) INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm"
abapFile: "abendeclarations_spcl.htm"
keywords: ["do", "data", "types", "abendeclarations", "spcl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)

Continue
[INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)


### abapinfotypes.htm

---
title: "INFOTYPES"
description: |
  This statement should be used by specialists only. In-depth knowledge of the corresponding environment is essential. This environment is not part of ABAP and is not documented here. Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm) Syntax INFOTY
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm"
abapFile: "abapinfotypes.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "types", "internal-table", "abapinfotypes"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) →  [Special Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm)

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninfo_type_glosry.htm "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{* 10 *|* n *}*.
  [INCLUDE TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinclude_type.htm) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declaration_sect_glosry.htm "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm)). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexecutable_program_glosry.htm "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) object.
    
-   The logical database PNP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide_obsolete.htm) of the statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm). If the addition VALID FROM is specified, other [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Types / TYPES / TYPES - BEGIN OF MESH mesh_type

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2


### abendeclarations_spcl.htm

---
title: "Special Declarations"
description: |
  These language elements should be used only by specialists with in-depth knowledge of the corresponding environment. -   INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm) INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm"
abapFile: "abendeclarations_spcl.htm"
keywords: ["do", "data", "types", "abendeclarations", "spcl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)

Continue
[INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)


### abapinfotypes.htm

---
title: "INFOTYPES"
description: |
  This statement should be used by specialists only. In-depth knowledge of the corresponding environment is essential. This environment is not part of ABAP and is not documented here. Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm) Syntax INFOTY
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm"
abapFile: "abapinfotypes.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "types", "internal-table", "abapinfotypes"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) →  [Special Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm)

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninfo_type_glosry.htm "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{* 10 *|* n *}*.
  [INCLUDE TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinclude_type.htm) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declaration_sect_glosry.htm "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm)). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexecutable_program_glosry.htm "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) object.
    
-   The logical database PNP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide_obsolete.htm) of the statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm). If the addition VALID FROM is specified, other [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Types / TYPES / TYPES - TABLE OF / TYPES - tabkeys

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2


### abendeclarations_spcl.htm

---
title: "Special Declarations"
description: |
  These language elements should be used only by specialists with in-depth knowledge of the corresponding environment. -   INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm) INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm"
abapFile: "abendeclarations_spcl.htm"
keywords: ["do", "data", "types", "abendeclarations", "spcl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)

Continue
[INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)


### abapinfotypes.htm

---
title: "INFOTYPES"
description: |
  This statement should be used by specialists only. In-depth knowledge of the corresponding environment is essential. This environment is not part of ABAP and is not documented here. Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm) Syntax INFOTY
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm"
abapFile: "abapinfotypes.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "types", "internal-table", "abapinfotypes"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) →  [Special Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm)

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninfo_type_glosry.htm "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{* 10 *|* n *}*.
  [INCLUDE TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinclude_type.htm) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declaration_sect_glosry.htm "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm)). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexecutable_program_glosry.htm "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) object.
    
-   The logical database PNP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide_obsolete.htm) of the statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm). If the addition VALID FROM is specified, other [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Types / TYPES / TYPES - LOB HANDLE

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2


### abendeclarations_spcl.htm

---
title: "Special Declarations"
description: |
  These language elements should be used only by specialists with in-depth knowledge of the corresponding environment. -   INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm) INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm"
abapFile: "abendeclarations_spcl.htm"
keywords: ["do", "data", "types", "abendeclarations", "spcl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)

Continue
[INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)


### abapinfotypes.htm

---
title: "INFOTYPES"
description: |
  This statement should be used by specialists only. In-depth knowledge of the corresponding environment is essential. This environment is not part of ABAP and is not documented here. Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm) Syntax INFOTY
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm"
abapFile: "abapinfotypes.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "types", "internal-table", "abapinfotypes"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) →  [Special Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm)

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninfo_type_glosry.htm "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{* 10 *|* n *}*.
  [INCLUDE TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinclude_type.htm) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declaration_sect_glosry.htm "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm)). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexecutable_program_glosry.htm "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) object.
    
-   The logical database PNP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide_obsolete.htm) of the statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm). If the addition VALID FROM is specified, other [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Objects / Literals

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2


### abendeclarations_spcl.htm

---
title: "Special Declarations"
description: |
  These language elements should be used only by specialists with in-depth knowledge of the corresponding environment. -   INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm) INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm"
abapFile: "abendeclarations_spcl.htm"
keywords: ["do", "data", "types", "abendeclarations", "spcl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)

Continue
[INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)


### abapinfotypes.htm

---
title: "INFOTYPES"
description: |
  This statement should be used by specialists only. In-depth knowledge of the corresponding environment is essential. This environment is not part of ABAP and is not documented here. Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm) Syntax INFOTY
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm"
abapFile: "abapinfotypes.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "types", "internal-table", "abapinfotypes"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) →  [Special Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm)

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninfo_type_glosry.htm "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{* 10 *|* n *}*.
  [INCLUDE TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinclude_type.htm) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declaration_sect_glosry.htm "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm)). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexecutable_program_glosry.htm "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) object.
    
-   The logical database PNP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide_obsolete.htm) of the statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm). If the addition VALID FROM is specified, other [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Objects / DATA / DATA - BEGIN OF struc

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2


### abendeclarations_spcl.htm

---
title: "Special Declarations"
description: |
  These language elements should be used only by specialists with in-depth knowledge of the corresponding environment. -   INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm) INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm"
abapFile: "abendeclarations_spcl.htm"
keywords: ["do", "data", "types", "abendeclarations", "spcl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)

Continue
[INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)


### abapinfotypes.htm

---
title: "INFOTYPES"
description: |
  This statement should be used by specialists only. In-depth knowledge of the corresponding environment is essential. This environment is not part of ABAP and is not documented here. Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm) Syntax INFOTY
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm"
abapFile: "abapinfotypes.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "types", "internal-table", "abapinfotypes"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) →  [Special Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm)

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninfo_type_glosry.htm "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{* 10 *|* n *}*.
  [INCLUDE TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinclude_type.htm) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declaration_sect_glosry.htm "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm)). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexecutable_program_glosry.htm "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) object.
    
-   The logical database PNP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide_obsolete.htm) of the statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm). If the addition VALID FROM is specified, other [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Declaring Data Objects / DATA / DATA - TABLE OF

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2


### abendeclarations_spcl.htm

---
title: "Special Declarations"
description: |
  These language elements should be used only by specialists with in-depth knowledge of the corresponding environment. -   INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm) INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm"
abapFile: "abendeclarations_spcl.htm"
keywords: ["do", "data", "types", "abendeclarations", "spcl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)

Continue
[INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)


### abapinfotypes.htm

---
title: "INFOTYPES"
description: |
  This statement should be used by specialists only. In-depth knowledge of the corresponding environment is essential. This environment is not part of ABAP and is not documented here. Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm) Syntax INFOTY
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm"
abapFile: "abapinfotypes.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "types", "internal-table", "abapinfotypes"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) →  [Special Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm)

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninfo_type_glosry.htm "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{* 10 *|* n *}*.
  [INCLUDE TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinclude_type.htm) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declaration_sect_glosry.htm "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm)). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexecutable_program_glosry.htm "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) object.
    
-   The logical database PNP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide_obsolete.htm) of the statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm). If the addition VALID FROM is specified, other [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Data Types and Data Objects / Special Declarations

Included pages: 2


### abendeclarations_spcl.htm

---
title: "Special Declarations"
description: |
  These language elements should be used only by specialists with in-depth knowledge of the corresponding environment. -   INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm) INFOTYPES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm"
abapFile: "abendeclarations_spcl.htm"
keywords: ["do", "data", "types", "abendeclarations", "spcl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) → 

Special Declarations

These language elements should be used only by specialists with in-depth knowledge of the corresponding environment.

-   [INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)

Continue
[INFOTYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm)


### abapinfotypes.htm

---
title: "INFOTYPES"
description: |
  This statement should be used by specialists only. In-depth knowledge of the corresponding environment is essential. This environment is not part of ABAP and is not documented here. Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm) Syntax INFOTY
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes.htm"
abapFile: "abapinfotypes.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "types", "internal-table", "abapinfotypes"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_and_objects.htm) →  [Special Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations_spcl.htm) → 

INFOTYPES

This statement should be used by specialists only.
In-depth knowledge of the corresponding environment is essential.
This environment is not part of ABAP and is not documented here.

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinfotypes_shortref.htm)

Syntax

INFOTYPES nnnn *\[*NAME name*\]*
               *\[*OCCURS n*\]*
               *\[*MODE N*|*P*\]*
               *\[*AS PERSON TABLE*\]*
               *\[*VALID FROM intlim1 TO intlim2*\]*.

Extras:

[1\. ... NAME name](#!ABAP_ADDITION_1@1@)
[2\. ... OCCURS n](#!ABAP_ADDITION_2@2@)
[3\. ... MODE N*|*P](#!ABAP_ADDITION_3@3@)
[4\. ... AS PERSON TABLE](#!ABAP_ADDITION_4@4@)
[5\. ... VALID FROM intlim1 TO intlim2](#!ABAP_ADDITION_5@5@)

Effect

Declares an internal table for HR [info types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninfo_type_glosry.htm "Glossary Entry"), forbidden in classes. If the addition NAME is not specified, an internal table pnnnn or ppnnnn is created with the structure of the info type Pnnnn and a [header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry"). The name ppnnnn is used when the addition AS PERSON TABLE is specified, otherwise it is pnnnn.

If the addition MODE N is not specified, the statement INFOTYPES modifies the behavior of the special [logical databases](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") PAP, PCH, PNP, and PNPCE of the human resources component HR by default and is the prerequisite for it working correctly.

A four-digit numeric key of an info type of SAP ERP component human resources (HR) must be specified for nnnn . Each info type is represented in the HR component by a special structure called Pnnnn in ABAP Dictionary. Each info type contains the character-like components BEGDA and ENDDA.

Notes

-   The internal table created by the statement INFOTYPES can also be declared using the following (obsolete) statement sequence but is then ignored by the special logical databases.
    

[DATA BEGIN OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*pnnnn*|*ppnnnn*|*name*}* [OCCURS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{* 10 *|* n *}*.
  [INCLUDE TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinclude_type.htm) pnnnn.
DATA END OF *{*pnnnn*|*ppnnnn*|*name*}*
     [VALID BETWEEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_begin_of_occurs.htm) *{*begda*|*intlim1*}* AND *{*endda*|*intlim2*}*.

-   No internal tables with header lines can be declared in classes. For this reason, the statement INFOTYPES is forbidden here.
    
-   In executable programs that are associated with the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component, the statement INFOTYPES is still required and should only be used here.
    
-   PNPCE is by far the most important of the logical databases PAP, PCH, PNP, and PNPCE. The logical data type PAP is hardly used anymore.
    
-   Info types make it possible for an HR application to handle employee-related data effectively. The special statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm) is used for this.
    
-   To ensure that the statement works with the logical databases correctly, it must be executed in the [global declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declaration_sect_glosry.htm "Glossary Entry") and before the first operational statements of an executable program.
    
-   The properties of the special logical databases determined by the statement INFOTYPES allow themselves to be changed using defined macros while the program is executed. For the logical database PNPCE, these are the macros PNP\_SET\_INFTY\_MODE\_BY\_NAME and PNP\_SET\_INFTY\_MODE\_BY\_NUMBER for changing the mode and RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL for setting the validity period.
    

Addition 1

... NAME name

Effect

Using the addition NAME, a name of up to 20 characters can be specified that is then used for the table instead of pnnnn or ppnnnn.

Addition 2

... OCCURS n

Effect

If the addition OCCURS is not specified, the default memory requirements of the internal table are set to ten rows (see the addition INITIAL SIZE of the statement [TYPES - TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_itab.htm)). The addition OCCURS can be used to specify a numeric literal or a numeric constant n to determine a different initial memory requirement.

Addition 3

... MODE N*|*P

Addition 4

... AS PERSON TABLE

Effect

These additions modify the behavior of the special logical databases PAP, PCH, PNP, and PNPCE of the human resources component. AS PERSON TABLE and MODE P, on the other hand, only modify the logical database PNPCE.

If the addition MODE N is not specified, the properties of the internal table are stored in an internal system table accessed in this logical database. If the statement INFOTYPES is executed without the addition MODE N in an [executable program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexecutable_program_glosry.htm "Glossary Entry") that is associated with one of these logical databases, the behavior is as follows:

-   The logical database PAP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) applicant.
    
-   The logical database PCH fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) object.
    
-   The logical database PNP fills the internal table for the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr.
    
-   The behavior of the logical database PNPCE can also be controlled using the additions AS PERSON TABLE and MODE P:
    

-   If one of these additions is not specified, the table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) pernr. Only those data records are provided that fall in the specified evaluation period on the selection screen (this is a difference to the logical database PNP, which provides all data records by default). Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE is specified, the internal table is filled with the event [GET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm) group. All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure group and for which there is authorization. Only those data records are provided which fall in the evaluation time period on the selection screen. Alternatively, the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL defined in the logical database can be used to specify the data records that are to be provided.

-   If only the addition AS PERSON TABLE together with MODE P is specified, the internal table is filled with the event [GET person](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget-.htm). All data records of all personnel numbers are provided that are in the included structure ALL\_PERNRS of the structure person. No authorization check is executed and all existing data records are displayed in every case irrespective of how the evaluation period was set on the selection screen. Using the macros RP\_SET\_DATA\_INTERVAL, RP\_SET\_DATA\_INTERVAL\_INFTY, and RP\_SET\_DATA\_INTERVAL\_ALL does not have any influence.

If the addition MODE N is specified, the table is not associated with the logical databases and is not filled with the GET events.

Note

For more information, see the documentation about the logical databases and particularly the PNPCE documentation.

Addition 5

... VALID FROM intlim1 TO intlim2

Effect

If the addition VALID FROM is not specified, the components BEGDA and ENDDA of the info type Pnnnn are set implicitly as the interval boundaries for the [obsolete form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide_obsolete.htm) of the statement [PROVIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprovide.htm). If the addition VALID FROM is specified, other [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like components intlim1 and intlim2 of the info type can be set as implicit interval boundaries.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Classes / Components of Classes / Methods of Classes

**Files**: 4 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Classes / Components of Classes / Constructors of Classes

**Files**: 2 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Inheritance

**Files**: 11 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Interfaces

**Files**: 2 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Objects

**Files**: 4 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Statements in ABAP Objects

**Files**: 6 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / ABAP Objects - Overview / Examples for ABAP Objects

**Files**: 8 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / CLASS / CLASS - DEFINITION

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / INTERFACE

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Data Types and Attributes

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Methods / CLASS-METHODS

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Events

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Declarations / Declaration Statements / Classes and Interfaces / Components in Classes and Interfaces / Implementing and including interfaces

Included pages: 6


### abeninterfaces.htm

---
title: "Implementing and including interfaces"
description: |
  Interfaces can be implemented by classes using the statement -   INTERFACES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) or can be included by other interfaces. Alias names can be defined for interface components using the statement -   ALIASES(https://help.sap.
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm"
abapFile: "abeninterfaces.htm"
keywords: ["do", "if", "class", "abeninterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) → 

Implementing and including interfaces

Interfaces can be implemented by classes using the statement

-   [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)

or can be included by other interfaces.

Alias names can be defined for interface components using the statement

-   [ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)

.

Continue
[INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm)
[ALIASES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm)


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapinterfaces_class.htm

---
title: "INTERFACES - implementation"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf PARTIALLY IMPLEMENTED(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)  ABSTRACT METHODS meth1 meth2 ...
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm"
abapFile: "abapinterfaces_class.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - implementation

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf
  *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
  *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
     *\[*FINAL METHODS meth1 meth2 ... *\]**}*
  *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
  *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.

Extras:

[1\. ... ABSTRACT METHODS meth1 meth2 ...](#!ABAP_ADDITION_1@1@)
[2\. ... FINAL METHODS meth1 meth2 ...](#!ABAP_ADDITION_2@2@)
[3\. ... ALL METHODS *{*ABSTRACT*|*FINAL*}*](#!ABAP_ADDITION_3@3@)
[4\. ... DATA VALUES attr1 = val1 attr2 = val2 ...](#!ABAP_ADDITION_4@4@)

Effect

In the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry"), the statement INTERFACES implements the interface intf in the class. Additions can also be defined to determine the properties of interface components in the class.

Any local or global interfaces can be specified for intf here that are not already bound in a superclass of the current class. The components of the interfaces become public components of the class after the implementation. An interface component called comp has the name intf~comp in the class, where intf is the name of the interface and the character ~ is the interface component selector. A class must implement all methods of the interface in its implementation part, with the following exceptions:

-   Interface methods declared as optional using the addition [DEFAULT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_default.htm).
    
-   Interface methods specified in the class after the addition ABSTRACT METHODS (making them abstract).
    
-   Partial implementations are permitted in test classes using the addition [PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm).
    

Notes

-   A class can implement any number of different interfaces. All of the interfaces implemented by a class are of equal status. If one of the interfaces intf implemented in a class is a composite (meaning it contains component interfaces), these are implemented in the class like individual interfaces, regardless of their nesting hierarchy, and their components are called using the name of their component interface instead of using the name intf. Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported.
    
-   Each interface appears only once in a class and every interface component comp is always clearly accessible using the intf~comp. When the components of an interface, if they are components of more than one interface, appear to be used more than once in a class, even they appear only once.
    
-   If the implementation of a non-optional method of a global interface implemented using INTERFACES is missing in a class, a syntax warning occurs instead of a syntax error. This prevents classes from becoming unusable when later enhancements are made to global interfaces. Calls of a missing implementation, however, always raise an exception of the class CX\_SY\_DYN\_CALL\_ILLEGAL\_METHOD and produce the runtime error CALL\_METHOD\_NOT\_IMPLEMENTED if the exception is not handled. A real syntax error is produced when local interfaces are used and the implementation is missing.
    
-   If a class implements a method intf~... of a global interface intf implemented using INTERFACES in its implementation part and the method is not declared in the interface, a warning is displayed in the syntax check. This type of method implementation is dead coding that cannot be executed and is to be removed. Classes become unusable with a syntax error if methods were later deleted from an implemented global interface, and which were implemented without class and had no values. An actual syntax error results when local interfaces are used.
    

Example

Implementation of an interface intf in a class cls.

INTERFACE intf.
  CLASS-DATA selfref TYPE REF TO intf.
  CLASS-METHODS factory RETURNING VALUE(ref) TYPE REF TO intf.
  ...
ENDINTERFACE.
CLASS cls DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES intf.
    ALIASES:
      selfref FOR intf~selfref,
      factory FOR intf~factory.
    ...
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD factory.
    IF selfref IS INITIAL.
      selfref = NEW cls( ).
      ref = selfref.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  DATA(iref) = cls=>factory( ).

Addition 1

... ABSTRACT METHODS meth1 meth2 ...

Addition 2

... FINAL METHODS meth1 meth2 ...

Effect

Using the additions ABSTRACT METHODS and FINAL METHODS, the individual instance methods meth of the interface are made either abstract or final in the class to be implemented. The same rules apply as to the additions [ABSTRACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) and [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) of the statement [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm). In particular, the whole class must be abstract if an interface method is made abstract and no interface methods can be executed at the same time after ABSTRACT METHODS and FINAL METHODS.

The following can be specified as methods meth1, meth2, ...

-   Instance methods that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for instance methods declared in interfaces that are bound in intf.
    
-   Instance methods that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

If an interface is bound using multiple INTERFACES statements, the information in the additions FINAL and ABSTRACT must not produce contradictory definitions for the same method.

Example

Definition of abstract methods when binding two interfaces intf1 and intf2 in an abstract class cls.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf1 ABSTRACT METHODS meth1.
    INTERFACES intf2 ABSTRACT METHODS meth2.
ENDCLASS.

Example

Short form of the preceding example. Since intf2 binds the interface intf1, its methods can be specified as intf1~meth1. This means that a separate statement INTERFACES intf1 is no longer possible in this class.

INTERFACE intf1.
  METHODS meth1.
ENDINTERFACE.
INTERFACE intf2.
  INTERFACES intf1.
  METHODS meth2.
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf2 ABSTRACT METHODS intf1~meth1 meth2.
ENDCLASS.

Addition 3

... ALL METHODS *{*ABSTRACT*|*FINAL*}*

Effect

Instead of making individual interface methods in the class abstract or final it is possible, using the addition ALL METHODS *{*ABSTRACT*|*FINAL*}*, to make all interface methods either [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm) or [final](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_abstract_final.htm).

Example

Integration of an interface intf in an abstract class cls1, in which all methods are made abstract and must be implemented in a subclass cls2.

INTERFACE intf.
  METHODS:
    meth1,
    meth2.
  ...
ENDINTERFACE.
CLASS cls1 DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf ALL METHODS ABSTRACT.
    ALIASES:
      meth1 FOR intf~meth1,
      meth2 FOR intf~meth2.
ENDCLASS.
CLASS cls2 DEFINITION INHERITING FROM cls1.
  PUBLIC SECTION.
    METHODS:
      meth1 REDEFINITION,
      meth2 REDEFINITION.
ENDCLASS.
CLASS cls2 IMPLEMENTATION.
  METHOD meth1.
    ...
  ENDMETHOD.
  METHOD meth2.
    ...
  ENDMETHOD.
ENDCLASS.

Addition 4

... DATA VALUES attr1 = val1 attr2 = val2 ...

Effect

Using the addition DATA VALUES, initial values can be assigned to individual attributes attr. For attributes, this addition functions in the same way as the addition VALUE of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) for attributes in its own class.

The following can be specified as attributes attr1, attr2, ...

-   Attributes that are declared in the interface intf itself.
    
-   Alias names declared in the interface intf for attributes declared in interfaces that are bound in intf.
    
-   Attributes that are declared in interfaces bound in intf using the name of its own interface and the interface component selector (~). In this case the component interface cannot itself be bound with the statement INTERFACES.
    

Constants declared in the interface or in a component interface with the statement [CONSTANTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconstants.htm) cannot be specified after the addition DATA VALUES.

Example

Integration of an interface intf in a class cls, where the interface attributes are provided with start values.

INTERFACE intf.
  CLASS-DATA:
    attr1 TYPE string,
    attr2 TYPE string.
  ...
ENDINTERFACE.
CLASS cls DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES intf
      DATA VALUES attr1 = 'Hello'
                  attr2 = 'World'.
    ALIASES:
      attr1 FOR intf~attr1,
      attr2 FOR intf~attr2.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display( |{ cls=>attr1 } { cls=>attr2 }| ).


### abapinterfaces_ifac.htm

---
title: "INTERFACES - integration"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax INTERFACES intf. Effect In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm"
abapFile: "abapinterfaces_ifac.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abapinterfaces", "ifac"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) →  [INTERFACES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm) → 

INTERFACES - integration

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax

INTERFACES intf.

Effect

In the declaration of an interface, the statement INTERFACES binds the interface intf in the declared interface. You cannot specify an additions. As a result, the interface intf becomes a component interface of a composite interface.

An interface can be composed of any number of different component interfaces. All these interfaces are equally valid on one level. If a component interface itself is a composite (that is, it contains its own component interfaces) the nesting hierarchy is irrelevant for the composition of the interface. It is relevant, however, for accessing the interface components.

To access the component comp of a component interface intf within a composite interface, the expression intf~comp can be used with the interface component selector (~). Multiple use of the interface component selection in a name (such as intf1~intf2~comp) is generally not supported. In a composite interface, it is possible to use the interface component selector to access only interface components of the component interface that are bound in this interface using the statement INTERFACES. Since all nested interfaces are at the same level, however, all that is needed to access the interface components of all component interfaces is the name of their interface.

Notes

-   Each interface and its components appear only once in a composite interface. Even an interface that is seemingly implemented more than once in an interface, because it is an interface component of one or more other interfaces, really exists only once.
    
-   Since there are no separate namespaces for global and local interfaces, you have to make sure that compositions of local interfaces do not result in combinations of global and local interfaces with identical names, because they cannot be equally valid on the same level in their implementation.
    

Example

The following example demonstrates how the statement INTERFACES can be used to compose and implement interfaces. Class c1 implements the composite interfaces i2 and i3. Although i1 is a component interface of i2 and i3, it exists only once in class c1. A reference variables iref1 of the static type i1 is used to generate an object class c1 and call method i1~m1, which is implemented there.

INTERFACE i1.
  METHODS m1.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  METHODS m2.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i1.
  METHODS m3.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES: i2, i3.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~m1.
    ...
  ENDMETHOD.
  METHOD i2~m2.
    ...
  ENDMETHOD.
  METHOD i3~m3.
    ...
  ENDMETHOD.
ENDCLASS.
DATA iref1 TYPE REF TO i1.
START-OF-SELECTION.
  CREATE OBJECT iref1 TYPE c1.
  iref1->m1( ).


### abapinterfaces.htm

---
title: "INTERFACES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm) Syntax Forms Implementing Interfaces in Classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm) 1. INTERFACES intf PARTIALLY IMPLEMENTED(https://hel
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces.htm"
abapFile: "abapinterfaces.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapinterfaces"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

INTERFACES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_shortref.htm)

Syntax Forms

[Implementing Interfaces in Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
1\. INTERFACES intf
    *\[*[PARTIALLY IMPLEMENTED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_partially.htm)*\]*
    *{* *{**\[*ABSTRACT METHODS meth1 meth2 ... *\]*
       *\[*FINAL METHODS meth1 meth2 ... *\]**}*
    *|* *\[*ALL METHODS *{*ABSTRACT*|*FINAL*}**\]* *}*
    *\[*DATA VALUES attr1 = val1 attr2 = val2 ...*\]*.
[Integrating Interfaces into Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)
2\. INTERFACES intf.

Effect

This statement implements interfaces in classes or integrates interfaces into other interfaces. It can be used in the [public](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpublic_glosry.htm "Glossary Entry") [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry") of the [declaration part](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm) of classes and in [interface declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterface_definition.htm).

Continue
[INTERFACES - implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_class.htm)
[INTERFACES - integration](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinterfaces_ifac.htm)


### abapaliases.htm

---
title: "ALIASES"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm) Syntax ALIASES alias FOR intf~comp. Effect In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The naming conve
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases.htm"
abapFile: "abapaliases.htm"
keywords: ["select", "do", "if", "try", "method", "class", "abapaliases"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclarations.htm) →  [Declaration Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) →  [Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclasses_and_interfaces.htm) →  [Components in Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ifac_components.htm) →  [Implementing and including interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterfaces.htm) → 

ALIASES

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapaliases_shortref.htm)

Syntax

ALIASES alias FOR intf~comp.

Effect

In the declaration part of a class or interface, this statement declares an alias name alias for a component comp of the interface intf. The [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) apply to the name alias. The interface intf must be implemented in the same class or included in the same interface. The alias name can be used instead of intf~comp in any position in which it is visible to access the interface component comp.

An alias name is a component of the class and the interface. It shares the namespace with the other components and is inherited by subclasses. In classes, an alias name can be declared in every [visibility section](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvisibility_section_glosry.htm "Glossary Entry").

Notes

-   Within a context, such as a class declaration or method, only one name should be used to access components. The syntax check issues a warning if both the alias name and the full name intf~meth are used together.
    
-   When implementing interface methods in the implementation section of classes using METHOD and when [re-defining](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenredefinition_glosry.htm "Glossary Entry") methods using METHODS ... REDEFINITION, you are allowed to use the alias name.
    

Example

In the interfaces i2, i3 and the class c1, declares alias names for the methods of the included or implemented interfaces. In the implementation part of the class, the interface methods in the [METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm) statements are implemented using the interface component selector. The alias names of the classes can also be used here.

INTERFACE i1.
  METHODS meth.
ENDINTERFACE.
INTERFACE i2.
  INTERFACES i1.
  ALIASES m1 FOR i1~meth.
  METHODS meth.
ENDINTERFACE.
INTERFACE i3.
  INTERFACES i2.
  ALIASES: m1 FOR i2~m1,
           m2 FOR i2~meth.
  METHODS meth.
ENDINTERFACE.
CLASS c1 DEFINITION.
  PUBLIC SECTION.
    INTERFACES i3.
    ALIASES: m1 FOR i3~m1,
             m2 FOR i3~m2,
             m3 FOR i3~meth.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD i1~meth.
    ... m2( ) ...
  ENDMETHOD.
  METHOD i2~meth.
    ... m3( ) ...
  ENDMETHOD.
  METHOD i3~meth.
    ... m1( ) ....
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA dref

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA dref

Included pages: 2


### abapcreate_data_implicit.htm

---
title: "CREATE DATA dref"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm) Syntax CREATE DATA dref area_handle(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm). Effect Creates an anonymous data object with an impli
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_implicit.htm"
abapFile: "abapcreate_data_implicit.htm"
keywords: ["select", "do", "if", "try", "data", "abapcreate", "implicit"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) → 

CREATE DATA dref

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm)

Syntax

CREATE DATA dref *\[*[area\_handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm)*\]*.

Effect

Creates an anonymous data object with an implicit type. If none of the additions TYPE or LIKE is specified, data reference variable dref must be fully typed. The data object is then created with the static data type of the data reference variable.

Note

When the character # is used in an operand position with the operand type of a data reference variable, the [instance operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_operator_glosry.htm "Glossary Entry") [NEW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) works like the statement CREATE DATA dref.

Example

Creates an anonymous data object of the type SCARR from ABAP Dictionary. The type is implicitly determined using the static data type of the data reference variable.

DATA dref TYPE REF TO scarr.
CREATE DATA dref.
SELECT SINGLE \*
       FROM scarr
       WHERE  carrid = 'LH'
       INTO @dref->\*.
cl\_demo\_output=>display( |{ dref->carrid }, { dref->carrname }| ).

Executable Example

[Creating Data Objects with Implicit Type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_data_implicit_abexa.htm)

Continue
![Example](exa.gif "Example") [Creating Data Objects with Implicit Type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_data_implicit_abexa.htm)


### abencreate_data_implicit_abexa.htm

---
title: "Creating Data Objects with Implicit Type"
description: |
  This example demonstrates how data objects are created with an implicit type. Source Code REPORT demo_create_data_implicit. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. TYPES t_itab TYPE TABLE OF i WITH NON-UNIQUE KEY table_line. D
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_data_implicit_abexa.htm"
abapFile: "abencreate_data_implicit_abexa.htm"
keywords: ["select", "loop", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencreate", "implicit", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) →  [CREATE DATA dref](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_implicit.htm) → 

Creating Data Objects with Implicit Type

This example demonstrates how data objects are created with an implicit type.

Source Code

REPORT demo\_create\_data\_implicit.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES t\_itab TYPE TABLE OF i WITH NON-UNIQUE KEY table\_line.
    DATA: tab\_ref TYPE REF TO t\_itab,
          i\_ref   TYPE REF TO i.
    IF tab\_ref IS INITIAL.
      CREATE DATA tab\_ref.
    ENDIF.
    tab\_ref->\* = VALUE #( FOR j = 1 UNTIL j > 10 ( j ) ).
    IF tab\_ref IS NOT INITIAL.
      IF i\_ref IS INITIAL.
        CREATE DATA i\_ref.
      ENDIF.
      LOOP AT tab\_ref->\* INTO i\_ref->\*.
        cl\_demo\_output=>write( |{ i\_ref->\* }| ).
      ENDLOOP.
    ENDIF.
    cl\_demo\_output=>display( ).
    CLEAR: tab\_ref, i\_ref.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Creates an internal table and a data object of type i. The data types of the objects in question are the static types of the reference variables tab\_ref and i\_ref. The data objects are created directly before they are used and are then initialized by the reference variables and passed to the [garbage collector](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengarbage_collector_glosry.htm "Glossary Entry"). The data objects are accessed by dereferencing the data references.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TYPE abap_type

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TYPE abap_type

Included pages: 2


### abapcreate_data_built_in.htm

---
title: "Syntax"
description: |
  CREATE DATA dref area_handle(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm) TYPE abap_type(name) LENGTH len DECIMALS dec. Effect Creates a data object with an explicitly specified data type. For the data type, all bui
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_built_in.htm"
abapFile: "abapcreate_data_built_in.htm"
keywords: ["do", "if", "case", "try", "data", "types", "field-symbol", "abapcreate", "built"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) → 

CREATE DATA - TYPE abap\_type

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm)

Syntax

CREATE DATA dref *\[*[area\_handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm)*\]*
                 TYPE *{*abap\_type*|*(name)*}*
                      *\[*LENGTH len*\]* *\[*DECIMALS dec*\]*.

Effect

Creates a data object with an explicitly specified data type. For the data type, all [built-in data types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpredefined_data_type_glosry.htm "Glossary Entry") (apart from b and s) can be used that are more specific than the static type of dref or are identical to it. The name of the type can be specified as follows:

-   abap\_type
    

Specified directly and statically as abap\_type.

-   (name)
    

Specified as the content of a character-like data object name (not case-sensitive). The following can be specified for name:

-   Literal or constant
    If the data object name is specified as a character literal or as a constant, it can be evaluated statically and the specified type is identified as the used object.

-   Variable
    If the data object name is specified as a variable, it is specified only dynamically and the content is not evaluated statically.

When the statement is executed, name is not evaluated until runtime (in both cases).

In the ABAP types c, n, p, and x, the length of the data type dtype can be determined by specifying a numeric data object len after the addition LENGTH, which, when the statement is executed, contains a value within the [length range](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_complete.htm) defined for the type in question. If the addition LENGTH is not specified, the standard length from the table is used. For all other ABAP types, the length is determined by the value in the table and the addition LENGTH cannot be specified.

In the ABAP type p, the number of [decimal places](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfractional_portion_glosry.htm "Glossary Entry") is determined by specifying a numeric data object dec after the addition DECIMALS. If DECIMALS is specified, the same applies as in the statement [TYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_simple.htm). If the addition DECIMALS is not specified, no decimal places are created. The decimal separator is ignored in operations with packed numbers if the [program attribute](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprogram_attribute_glosry.htm "Glossary Entry") fixed point arithmetic is not set. If it is not set, the addition DECIMALS is applied only to dynpros and in the statement [WRITE *\[*TO*\]*](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_to.htm). For all other ABAP types and if name is specified dynamically, the addition DECIMALS is not permitted.

Note

When a data type abap\_type is used, the [instance operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_operator_glosry.htm "Glossary Entry") [NEW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) acts like the statement CREATE DATA dref TYPE abap\_type and can be used in [general expression positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneral_expr_position_glosry.htm "Glossary Entry"). The content of name cannot be specified dynamically here.

Example

Creation of an anonymous data object of packed number type with length specification and decimals. As the static data type of the data reference variable is generic, data referencing is only possible by assignment to a field symbol.

DATA dref TYPE REF TO data.
CREATE DATA dref TYPE p LENGTH 8 DECIMALS 3.
ASSIGN dref->\* TO FIELD-SYMBOL(<fs>).
<fs> = 1 / 3.
cl\_demo\_output=>display( <fs> ).

Executable Example

[Creating Elementary Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_simple_data_abexa.htm)

Continue
![Example](exa.gif "Example") [Creating Elementary Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_simple_data_abexa.htm)


### abencreate_simple_data_abexa.htm

---
title: "Creating Elementary Data Objects"
description: |
  This example demonstrates how elementary data objects are created. Source Code REPORT demo_create_simple_data. CLASS create_demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS create_data IMPORTING VALUE(typ) TYPE c VALUE(len) TYPE i VALUE(dec) TYPE i RETURNING V
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_simple_data_abexa.htm"
abapFile: "abencreate_simple_data_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "catch", "method", "class", "data", "types", "abencreate", "simple", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) →  [CREATE DATA - TYPE abap\_type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_built_in.htm) → 

Creating Elementary Data Objects

This example demonstrates how elementary data objects are created.

Source Code

REPORT demo\_create\_simple\_data.
CLASS create\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS create\_data IMPORTING
                                VALUE(typ) TYPE c
                                VALUE(len) TYPE i
                                VALUE(dec) TYPE i
                              RETURNING
                                VALUE(dref) TYPE REF TO data
                              RAISING cx\_sy\_create\_data\_error.
ENDCLASS.
CLASS create\_demo IMPLEMENTATION.
  METHOD main.
    DATA dref TYPE REF TO data.
    FIELD-SYMBOLS <fs> TYPE any.
    DATA: type     LENGTH 10 TYPE c,
          length   TYPE i,
          decimals TYPE i.
    cl\_demo\_input=>add\_field( EXPORTING text  = \`Builtin ABAP Type\`
                              CHANGING  field = type ).
    cl\_demo\_input=>add\_field( EXPORTING text  = \`Length\`
                              CHANGING  field = length ).
    cl\_demo\_input=>request(   EXPORTING text  = \`Decimals\`
                              CHANGING  field = decimals ).
    TRY.
        IF to\_lower( type ) = 'p' AND decimals > 2 \* length - 1.
          "Would lead to undefined state for packed number
          RAISE EXCEPTION TYPE cx\_sy\_create\_data\_error.
        ENDIF.
        dref = create\_data( typ = type
                            len = length
                            dec = decimals ).
        ASSIGN dref->\* TO <fs>.
        DESCRIBE FIELD <fs> TYPE type
                            LENGTH length IN BYTE MODE
                            DECIMALS decimals.
        cl\_demo\_output=>display( |{ type } { length } { decimals }| ).
      CATCH cx\_sy\_create\_data\_error.
        cl\_demo\_output=>display( |Error creating { type } {
                                                   length } {
                                                   decimals }| ).
    ENDTRY.
  ENDMETHOD.
  METHOD create\_data.
    TRANSLATE typ TO LOWER CASE.
    CASE typ.
      WHEN 'd' OR 'decfloat16' OR 'decfloat34' OR 'f' OR 'i'
               OR 'string' OR 't' OR 'xstring'.
        CREATE DATA dref TYPE (typ).
      WHEN 'c' OR 'n' OR 'x'.
        CREATE DATA dref TYPE (typ) LENGTH len.
      WHEN 'p'.
        CREATE DATA dref TYPE p LENGTH len DECIMALS dec.
      WHEN OTHERS.
        RAISE EXCEPTION TYPE cx\_sy\_create\_data\_error.
    ENDCASE.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  create\_demo=>main( ).

Description

The method create\_data creates all elementary data objects that are possible using built-in ABAP types, depending on the input parameters passed.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TYPE, LIKE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TYPE, LIKE

Included pages: 2


### abapcreate_data_existing.htm

---
title: "CREATE DATA - TYPE, LIKE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm) Syntax CREATE DATA dref area_handle(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm)  TYPE LINE OF type(name)
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_existing.htm"
abapFile: "abapcreate_data_existing.htm"
keywords: ["select", "do", "if", "case", "try", "class", "data", "types", "internal-table", "field-symbol", "abapcreate", "existing"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) → 

CREATE DATA - TYPE, LIKE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm)

Syntax

CREATE DATA dref *\[*[area\_handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm)*\]*
                 *{* *{*TYPE *\[*LINE OF*\]* *{*type*|*(name)*}**}*
                 *|* *{*LIKE *\[*LINE OF*\]* dobj*}* *}*.

Effect

The type of the generated data object is defined by the specified type or data object.

-   type can be any data type from ABAP Dictionary, in particular the structure of a database table , a [classic view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclassical_view_glosry.htm "Glossary Entry"), or a [CDS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_entity_glosry.htm "Glossary Entry") entity, a public data type of a global class, or any data type of the same program already defined defined using TYPES and that is either more specific than or identical to the static type of dref. Alternatively, a character-like data object name can be specified in parentheses that contains the name of the existing data type when the statement is executed. This is not case-sensitive. The name in name can also be an [absolute type name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabsolute_typename_glosry.htm "Glossary Entry"). If a standard table type with a generic primary table key is specified after TYPE, a new [bound](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbound_data_type_glosry.htm "Glossary Entry") table type with standard key is created and used.
    
-   A data object that is [visible](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlifetime_and_visibility.htm) at this point can be [specified](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_objects_usage_reading.htm) for dobj. The generated data object inherits the current data type. If dobj is specified as a formal parameter or field symbol, it can be fully or partially generic. When the statement CREATE DATA is executed, a data object must be bound to a generically typed field symbol or parameter and the type of the data object is used. In the case of a completely typed field symbol or parameter, the declared type is used. A data object does not have to be connected.
    

The optional addition LINE OF can be used if type or the name in name is a table type, or if dobj is an internal table. As a result, the generated data object inherits the attributes of the row type of the internal table.

Notes

-   LIKE can be used to reference the public attributes of global classes.
    
-   If a type of another program is specified using an [absolute type name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabsolute_typename_glosry.htm "Glossary Entry") in name, this program is loaded into a new [additional program group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadditional_prog_group_glosry.htm "Glossary Entry") or into the current [program group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprogram_group_glosry.htm "Glossary Entry"), depending on the program type (if not already loaded).
    
-   When an anonymous data object is created with an [enumerated type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_enum.htm), the same rules apply for this object as for every other data object of this type.
    
-   When a data type type is used, the [instance operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_operator_glosry.htm "Glossary Entry") [NEW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) acts like the statement CREATE DATA dref TYPE type and can be used in [general expression positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneral_expr_position_glosry.htm "Glossary Entry"). The content of name cannot be specified dynamically here.
    

Example

Creates an anonymous data object of type SCARR. The static data type of the data reference variable is generic. If can only be dereferenced and used on operand positions by means of assignment to a field symbol.

DATA dref TYPE REF TO data.
CREATE DATA dref TYPE scarr.
ASSIGN dref->\* TO FIELD-SYMBOL(<fs>).
SELECT SINGLE \*
       FROM scarr
       WHERE carrid = 'LH'
       INTO @<fs>.
ASSIGN COMPONENT 'CARRID'   OF STRUCTURE <fs> TO FIELD-SYMBOL(<fs1>).
ASSIGN COMPONENT 'CARRNAME' OF STRUCTURE <fs> TO FIELD-SYMBOL(<fs2>).
cl\_demo\_output=>display( |{ <fs1> }, { <fs2> }| ).

Executable Example

[Creating Structured Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_structured_data_abexa.htm)

Continue
![Example](exa.gif "Example") [Creating Structured Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_structured_data_abexa.htm)


### abencreate_structured_data_abexa.htm

---
title: "Creating Structured Data Objects"
description: |
  This example demonstrates how structured data objects are created. Source Code REPORT demo_create_structured_data. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA dref TYPE REF TO data. DATA: dbtab TYPE tabname VALUE 'SPFLI', rows
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_structured_data_abexa.htm"
abapFile: "abencreate_structured_data_abexa.htm"
keywords: ["select", "loop", "do", "if", "try", "catch", "method", "class", "data", "field-symbol", "abencreate", "structured", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) →  [CREATE DATA - TYPE, LIKE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_existing.htm) → 

Creating Structured Data Objects

This example demonstrates how structured data objects are created.

Source Code

REPORT demo\_create\_structured\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA dref TYPE REF TO data.
    DATA: dbtab TYPE tabname VALUE 'SPFLI',
          rows  TYPE i VALUE 100.
    FIELD-SYMBOLS <wa> TYPE any.
    cl\_demo\_input=>new(
      )->add\_field( CHANGING field = dbtab
      )->add\_field( CHANGING field = rows )->request( ).
    DATA(out) = cl\_demo\_output=>new( ).
    dbtab = to\_upper( dbtab ).
    TRY.
        dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                  val = dbtab
                  packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        out->display( 'Database table not found' ).
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        out->display(
          'Only tables from the flight data model are allowed' ).
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        CREATE DATA dref TYPE (dbtab).
        ASSIGN dref->\* TO <wa>.
        SELECT \*
               FROM (dbtab) UP TO @rows ROWS
               INTO @<wa>.
          out->write( <wa> ).
        ENDSELECT.
        out->display( ).
      CATCH cx\_sy\_create\_data\_error.
        out->display( 'Error in data creation' ).
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Creates a work area that is compatible with a database table and reads the first few rows (rows) of the database table into this work area using a [SELECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect.htm) loop. Since the data reference dref is typed dynamically, the work area can only be read using the field symbol <wa>.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG checks whether the database table specified exists and can be used.

See also the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselect_into_new_wa_abexa.htm) for SELECT INTO NEW, where the structure is created implicitly in the INTO clause.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - HANDLE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - HANDLE

Included pages: 2


### abapcreate_data_handle.htm

---
title: "CREATE DATA - HANDLE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm) Syntax CREATE DATA dref area_handle(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm) TYPE HANDLE handle. Effect The statement CREATE DATA u
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_handle.htm"
abapFile: "abapcreate_data_handle.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "internal-table", "abapcreate", "handle"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) → 

CREATE DATA - HANDLE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm)

Syntax

CREATE DATA dref *\[*[area\_handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm)*\]*
                 TYPE HANDLE handle.

Effect

The statement CREATE DATA uses the addition HANDLE to create a data object whose data type is described by an [RTTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_services_glosry.htm "Glossary Entry") [type description object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_object_glosry.htm "Glossary Entry"). handle expects a reference variable of the static type of class CL\_ABAP\_DATADESCR or its subclasses that points to a type description object. The type description object may have been created by applying the RTTS methods to existing data objects or by using the dynamic definition of a new data type.

The type description object must describe a non-generic type. Only type description objects for the generic ABAP types c, n, p, and x create a new [bound data type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbound_data_type_glosry.htm "Glossary Entry") and use it with the [standard values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_complete.htm). Similarly, a type description object for a standard table with a generic table type creates a new bound table type and uses it with a standard key.

Notes

The following are important methods for the dynamic definition of data types:

-   GET\_C, GET\_D, GET\_F ... of the class CL\_ABAP\_ELEMDESCR for type description objects of elementary data types. These methods create either a new type description object in accordance with the input parameters or reuse an existing type object.

-   GET of the classes CL\_ABAP\_STRUCTDESCR, CL\_ABAP\_TABLEDESCR, and CL\_ABAP\_REFDESCR plus GET\_BY\_NAME of the class CL\_ABAP\_REFDESCR for type description objects of structures, internal tables, and reference variables. These methods return the type description object that was specified using the input parameters. A new type description object is created or an existing one is used again.

-   CREATE of the classes CL\_ABAP\_STRUCTDESCR, CL\_ABAP\_TABLEDESCR, and CL\_ABAP\_REFDESCR for creating type description objects for structures, internal tables, and reference variables. These methods return the type description object that was specified using the input parameters. A new type description object is always created.

-   It is advisable to use the GET methods instead of CREATE to avoid creating multiple type description objects for a single type.
    

Example

Creates an anonymous data object using a type description object for a dictionary structure provided by [RTTI](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_identific_glosry.htm "Glossary Entry").

DATA dref TYPE REF TO data.
DATA(type) = CAST cl\_abap\_datadescr(
  cl\_abap\_typedescr=>describe\_by\_name( 'SCARR' ) ).
CREATE DATA dref TYPE HANDLE type.

Executable Example

[Creating a Structure Using RTTC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_data_via_rttc_abexa.htm)

Continue
![Example](exa.gif "Example") [Creating a Structure Using RTTC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_data_via_rttc_abexa.htm)


### abencreate_data_via_rttc_abexa.htm

---
title: "Creating a Structure Using RTTC"
description: |
  This example demonstrates how a structure is created using RTTC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_creation_glosry.htm 'Glossary Entry'). Source Code REPORT demo_create_data_via_handle. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLAS
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_data_via_rttc_abexa.htm"
abapFile: "abencreate_data_via_rttc_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "internal-table", "abencreate", "via", "rttc", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) →  [CREATE DATA - HANDLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_handle.htm) → 

Creating a Structure Using RTTC

This example demonstrates how a structure is created using [RTTC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_creation_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_create\_data\_via\_handle.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: struct\_type TYPE REF TO cl\_abap\_structdescr,
          dref        TYPE REF TO data,
          oref        TYPE REF TO cx\_sy\_struct\_creation.
    DATA column1 TYPE c LENGTH 30.
    DATA column2 TYPE c LENGTH 30.
    FIELD-SYMBOLS: <struc>  TYPE any,
                   <comp1>  TYPE any,
                   <comp2>  TYPE any.
    cl\_demo\_input=>add\_field( CHANGING field = column1 ).
    cl\_demo\_input=>add\_field( CHANGING field = column2 ).
    cl\_demo\_input=>request( ).
    column1 = to\_upper( column1 ).
    column2 = to\_upper( column2 ).
    TRY.
        struct\_type = cl\_abap\_structdescr=>get(
          VALUE #(
            ( name = column1 type = cl\_abap\_elemdescr=>get\_c( 40 ) )
            ( name = column2 type = cl\_abap\_elemdescr=>get\_i( )    )
                 )
                                               ).
        CREATE DATA dref TYPE HANDLE struct\_type.
      CATCH cx\_sy\_struct\_creation INTO oref.
        cl\_demo\_output=>display( oref->get\_text( ) ).
        RETURN.
    ENDTRY.
    ASSIGN dref->\* TO <struc>.
    ASSIGN COMPONENT column1 OF STRUCTURE <struc> TO <comp1>.
    <comp1> = 'Amount'.
    ASSIGN dref->\* TO <struc>.
    ASSIGN COMPONENT column2 OF STRUCTURE <struc> TO <comp2>.
    <comp2> = 11.
    cl\_demo\_output=>display( |{ column1 WIDTH = 32 } { <comp1> }\\n| &
                             |{ column2 WIDTH = 32 } { <comp2> }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Dynamic definition of a structure with two components using the GET method of the CL\_ABAP\_STRUCTDESCR class. The description of the components of the structure is provided in the internal table comp\_tab. If no type description object exists for this structure yet, it is created by the GET method.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG checks whether the database table specified exists and can be used.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - REF TO

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - REF TO

Included pages: 2


### abapcreate_data_reference.htm

---
title: "CREATE DATA - REF TO"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm) Syntax CREATE DATA dref area_handle(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm) TYPE REF TO type(name). Effect The addition T
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_reference.htm"
abapFile: "abapcreate_data_reference.htm"
keywords: ["do", "if", "case", "try", "class", "data", "types", "abapcreate", "reference"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) → 

CREATE DATA - REF TO

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm)

Syntax

CREATE DATA dref *\[*[area\_handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm)*\]*
                 TYPE REF TO *{*type*|*(name)*}*.

Effect

The addition TYPE REF TO is used by the statement CREATE DATA to create a reference variable. The static type of the reference variable can be specified either directly as type or dynamically in name.

When type is specified, the same rules apply as to the definition of reference types using the statement [TYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes.htm). For data reference variables, either the generic type data or a fully specified data type can be specified. For object reference variables, either a class or an interface can be specified.

For name, a character-like field can be specified that has to contain the name of a class, an interface, or a data type when the statement is executed. The name of the reference type in name can also be specified as an [absolute type name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabsolute_typename_glosry.htm "Glossary Entry").

Note

Object types in name can also be specified dynamically in lowercase letters.

Example

Creation of an anonymous data object as reference variable of the static type of a class. The dereferenced reference variable can be used to create an object of the class and for access to its components.

CLASS cls DEFINITION.
  PUBLIC SECTION.
    DATA attr TYPE string VALUE \`Oh my ...\`.
ENDCLASS.
TYPES reftype TYPE REF TO cls.
DATA dref TYPE REF TO reftype.
CREATE DATA dref TYPE REF TO cls.
CREATE OBJECT dref->\*.
cl\_demo\_output=>display( dref->\*->attr ).

Executable Example

[Creating Reference Variables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_reference_abexa.htm)

Continue
![Example](exa.gif "Example") [Creating Reference Variables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_reference_abexa.htm)


### abencreate_reference_abexa.htm

---
title: "Creating Reference Variables"
description: |
  This example demonstrates how reference variables are created. Source Code REPORT demo_create_reference. INTERFACE intf. CONSTANTS attr TYPE string VALUE `Interface constant`. ENDINTERFACE. CLASS cls DEFINITION. PUBLIC SECTION. INTERFACES intf. ENDCLASS. CLASS demo DEFINITION. PUBLIC SECTION. CL
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_reference_abexa.htm"
abapFile: "abencreate_reference_abexa.htm"
keywords: ["select", "do", "try", "method", "class", "data", "field-symbol", "abencreate", "reference", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) →  [CREATE DATA - REF TO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_reference.htm) → 

Creating Reference Variables

This example demonstrates how reference variables are created.

Source Code

REPORT demo\_create\_reference.
INTERFACE intf.
  CONSTANTS attr TYPE string VALUE \`Interface constant\`.
ENDINTERFACE.
CLASS cls DEFINITION.
  PUBLIC SECTION.
    INTERFACES intf.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA intf\_name TYPE string.
    DATA cls\_name  TYPE string.
    DATA dref TYPE REF TO data.
    FIELD-SYMBOLS <ref>  TYPE any.
    FIELD-SYMBOLS <attr> TYPE any.
    intf\_name = '\\PROGRAM=DEMO\_CREATE\_REFERENCE\\INTERFACE=INTF'.
    CREATE DATA dref TYPE REF TO (intf\_name).
    ASSIGN dref->\* TO <ref>.
    cls\_name = '\\PROGRAM=DEMO\_CREATE\_REFERENCE\\CLASS=CLS'.
    CREATE OBJECT <ref> TYPE (cls\_name).
    ASSIGN ('<REF>->ATTR') TO <attr>.
    cl\_demo\_output=>display\_data( <attr> ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Creates an interface reference variable dynamically. The [absolute type name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabsolute_typename_glosry.htm "Glossary Entry") is used for the name of the local interface.

The reference variable is assigned to a field symbol <ref> using dereferencing. According to the [general typing rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentyping_check_general.htm), the field symbol must either be typed in full generically or typed with reference to the interface intf.

The dynamically created reference variable is used to create and address an object of a class. Since this field symbol is fully generic, only the display variant of the [dynamic ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_mem_area_dynamic_dobj.htm) (and not a special [dynamic access](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_mem_area_dynamic_access.htm)) can be used to access the interface attribute.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TABLE OF

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - TABLE OF

Included pages: 2


### abapcreate_data_itab.htm

---
title: "CREATE DATA - TABLE OF"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm) Syntax CREATE DATA dref area_handle(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm)  TYPE STANDARDSORTEDHASHED TABLE O
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_itab.htm"
abapFile: "abapcreate_data_itab.htm"
keywords: ["select", "do", "if", "case", "try", "data", "types", "internal-table", "field-symbol", "abapcreate", "itab"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) → 

CREATE DATA - TABLE OF

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm)

Syntax

CREATE DATA dref *\[*[area\_handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm)*\]*
                 *{* *{*TYPE *\[*STANDARD*\]**|*SORTED*|*HASHED TABLE OF *\[*REF TO*\]* *{*type*|*(name)*}**}*
                 *|* *{*LIKE *\[*STANDARD*\]**|*SORTED*|*HASHED TABLE OF dobj*}* *}*
                 *\[* WITH *{* *{**\[*UNIQUE*|*NON-UNIQUE*\]*
                           *{*KEY *{*comp1 comp2 ...*}**|*(keytab)*}**|**{*DEFAULT KEY*}**}**}*
                        *|* *{*EMPTY KEY*}*  *\]*
                 *\[*INITIAL SIZE n*\]*.

Effect

The statement CREATE DATA uses the addition tabkind OF to create an internal table. The meaning of the additions is the same as when declaring internal tables using the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_itab.htm), but with special rules for [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_existing.htm) if dobj is specified after LIKE. The explicit definition of the primary table key is only optional if a [standard table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_table_glosry.htm "Glossary Entry") is being created.

Whereas the content of DATA is specified statically, the following can be specified dynamically for CREATE DATA:

-   The row type after TYPE or the static type of a row flagged as a reference variable after TYPE REF TO can have a character-like data object called name. In this case, the same rules apply as in the other variants of CREATE DATA.
    
-   The definition of the primary table key can specify a parenthesized internal table keytab instead of a static component comp1 comp2 ...:
    ... WITH *\[*UNIQUE*|*NON-UNIQUE*\]* KEY (keytab) ...
    The table keytab must have a character-like data type and must contain the name of a valid component in each row or the identifier table\_line for the primary table key in a single row.
    
-   A numeric data object can be specified for n after INITIAL SIZE.
    

Notes

-   The definition of the table key is subject to the following conditions that do not apply to DATA:
    

-   No [secondary table keys](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensecondary_table_key_glosry.htm "Glossary Entry") can be defined in the statement CREATE DATA.

-   The name [primary\_key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_primary_key.htm) and the addition [COMPONENTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_primary_key.htm) cannot be specified explicitly in the definition of the primary key.

[Runtime type creation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_creation_glosry.htm "Glossary Entry") should be used instead to create dynamic table types with secondary keys. The same applies when creating an [empty table key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenitab_empty_key.htm) dynamically, since the internal table keytab can only be used to define non-empty keys.

-   CREATE DATA cannot be used to create internal tables with [header lines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheader_line_glosry.htm "Glossary Entry").
    

Example

Creates and uses an anonymous hash table. The type of the data reference variable is generic, which means it can only be dereferenced in the case of assignment to a field symbol.

DATA dref TYPE REF TO data.
FIELD-SYMBOLS <fs> TYPE ANY TABLE.
CREATE DATA dref TYPE HASHED TABLE OF scarr
                 WITH UNIQUE KEY carrid.
ASSIGN dref->\* TO <fs>.
SELECT \*
       FROM scarr
       INTO TABLE @<fs>.
cl\_demo\_output=>display( <fs> ).

Executable Example

[Creating Tabular Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_tabular_data_abexa.htm)

Continue
![Example](exa.gif "Example") [Creating Tabular Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_tabular_data_abexa.htm)


### abencreate_tabular_data_abexa.htm

---
title: "Creating Tabular Data Objects"
description: |
  The example demonstrates the creation of tabular data objects Source Code REPORT demo_create_tabular_data. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA dref TYPE REF TO data. DATA: dbtab TYPE tabname VALUE 'SPFLI', rows  TYPE i
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_tabular_data_abexa.htm"
abapFile: "abencreate_tabular_data_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "internal-table", "field-symbol", "abencreate", "tabular", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) →  [CREATE DATA - TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_itab.htm) → 

Creating Tabular Data Objects

The example demonstrates the creation of tabular data objects

Source Code

REPORT demo\_create\_tabular\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA dref TYPE REF TO data.
    DATA: dbtab TYPE tabname VALUE 'SPFLI',
          rows  TYPE i VALUE 100.
    FIELD-SYMBOLS <table> TYPE ANY TABLE.
    cl\_demo\_input=>new(
      )->add\_field( CHANGING field = dbtab
      )->add\_field( CHANGING field = rows )->request( ).
    DATA(out) = cl\_demo\_output=>new( ).
    dbtab = to\_upper( dbtab ).
    TRY.
        cl\_abap\_dyn\_prg=>check\_table\_name\_str(
          val = dbtab
          packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        out->display( 'Database table not found' ).
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        out->display(
          'Only tables from the flight data model are allowed' ).
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        CREATE DATA dref TYPE STANDARD TABLE OF (dbtab)
                              WITH NON-UNIQUE DEFAULT KEY.
        ASSIGN dref->\* TO <table>.
        SELECT \*
               FROM (dbtab) UP TO @rows ROWS
               INTO TABLE @<table>.
        out->display( <table> ).
      CATCH cx\_sy\_create\_data\_error.
        out->display( 'Error in data creation' ).
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Creating an internal table that matches any database table and reading the first rows (rows) of the database into the internal table. Since the dref data reference is dynamically typed, access to the internal table can only take place using the <tab> field symbol.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG checks whether the database table specified exists and can be used.

See also the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselect_into_new_table_abexa.htm) for SELECT INTO NEW, where the internal table is created implicitly in the INTO clause.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - AREA HANDLE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE DATA / CREATE DATA - AREA HANDLE

Included pages: 2


### abapcreate_data_area_handle.htm

---
title: "CREATE DATA - AREA HANDLE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm) Syntax CREATE DATA dref AREA HANDLE handle ... Effect This statement creates an anonymous data object as a shared object(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm"
abapFile: "abapcreate_data_area_handle.htm"
keywords: ["update", "do", "if", "try", "method", "class", "data", "types", "abapcreate", "area", "handle"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) → 

CREATE DATA - AREA HANDLE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_shortref.htm)

Syntax

CREATE DATA dref AREA HANDLE handle ...

Effect

This statement creates an anonymous data object as a [shared object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_object_glosry.htm "Glossary Entry") in the [area instance version](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_instance_version_glosry.htm "Glossary Entry") of the [shared memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_memory_glosry.htm "Glossary Entry") to which the [area handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_handle_glosry.htm "Glossary Entry") referenced by handle is bound.

handle expects an object reference variable whose static type is [CL\_ABAP\_MEMORY\_AREA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_abap_memory_area.htm) or one of its subclasses ([area class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_class_glosry.htm "Glossary Entry")). When the statement is executed, handle must point to an [area handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_handle_glosry.htm "Glossary Entry") and the area handle must be associated with an area instance version with a change lock. A reference like this can be created in one of the following ways:

-   By inheriting the return value of the methods [ATTACH\_FOR\_WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_class.htm) or [ATTACH\_FOR\_UPDATE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_class.htm) of an area class created using transaction SHMA.
    
-   By inheriting the return value of the method [GET\_HANDLE\_BY\_...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_abap_memory_area.htm) of any area class.
    
-   By inheriting the return value of the method [GET\_IMODE\_HANDLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_imode_area.htm) of the predefined class CL\_IMODE\_AREA.
    

The latter is a reference to an area handle for the current [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry") and the statement CREATE DATA operates as if the addition AREA HANDLE is not specified.

Restrictions

The creation of anonymous data objects as shared objects is subject to the following restrictions for data references in the shared objects memory: the storage of data references in closed [area instance versions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_instance_version_glosry.htm "Glossary Entry") of the shared objects memory is restricted to those [dynamic types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynamic_type_glosry.htm "Glossary Entry") that are known when loading a program into an internal session.

Therefore, the following data types cannot be used to create anonymous data objects in the shared object memory, if these are to be preserved in a closed area instance version:

1.  All data types created in a temporary subroutine pool created using [GENERATE SUBROUTINE POOL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapgenerate_shortref.htm).
    
2.  Data types created dynamically at runtime using methods of the [RTTC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_creation_glosry.htm "Glossary Entry").
    
3.  Bound data types of anonymous data objects created at program runtime and to which a dynamic length was assigned when they were created with CREATE DATA.
    
4.  Bound data types of anonymous data objects created at program runtime and to which a dynamic type requiring length definition was assigned when the data objects were created using CREATE DATA.
    

Points 3 and 4 include the statement CREATE DATA with the addition AREA HANDLE itself. Exceptions to the restrictions listed under points 2 to 4 are:

-   The restrictions are not valid for data type p.
    
-   The restrictions are not valid for data types c, n, and x as long as the memory requirements do not exceed 100 bytes.
    

If a data reference variable that is stored in the shared objects memory refers to an anonymous data object of a dynamic type that is subject to the restrictions, the exception of the class CX\_SHM\_EXTERNAL\_TYPE is raised when the DETACH\_COMMIT method is executed.

The following can be used without restriction:

-   All visible data types of global interfaces and classes.
    
-   Data elements, structures, and database tables and table types from ABAP Dictionary.
    
-   Data types from type groups.
    
-   Bound data types of anonymous data objects created at program runtime to which a static type with a static length was assigned when they were created using CREATE DATA.
    
-   Bound data types of anonymous data objects created at program runtime to which a fully specified dynamic type was assigned when they were created using CREATE DATA.
    
-   All data types that were created statically in the same program using declarative statements. It should be noted, however, that it is no longer possible to access existing area instances once the creating program is changed.
    

The additions [REF TO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_reference.htm) and [TABLE OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_itab.htm) can be used as long as the specified types meet the above requirements. This also applies to the addition [HANDLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_handle.htm), which means the type description object must have been created with methods of the [RTTI](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_identific_glosry.htm "Glossary Entry") from allowed types.

Notes

-   The only shared object that can be addressed from an ABAP program directly after a binding is made to an area instance version is the instance of the [area root class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenroot_data_class_glosry.htm "Glossary Entry"). All other objects have to be referenced in this instance. In particular, there is no direct access to anonymous data objects possible. Instead, the instance of the area root class must contain references to these anonymous data objects, which can also be indirect.
    
-   It is best to use only global data types with AREA HANDLE. As an occasional replacement for the direct reference to data elements and table types from ABAP Dictionary, the respective types can be created in global interfaces, classes, or even type groups.
    

Example

Creates an anonymous structure in an area instance version of area CL\_DEMO\_AREA.

DATA: root   TYPE REF TO cl\_demo\_root,
      handle TYPE REF TO cl\_demo\_area.
...
handle = cl\_demo\_area=>attach\_for\_write( ).
CREATE OBJECT root AREA HANDLE handle.
handle->set\_root( root ).
CREATE DATA root->dref AREA HANDLE handle TYPE scarr.
...

Executable Example

[Creating a Data Object as a Shared Object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_shared_data_objct_abexa.htm)

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Handleable Exceptions

CX\_SHM\_WRONG\_HANDLE

-   Cause: The area handle does not hold any change locks.
    

CX\_SHM\_ALREADY\_DETACHED

-   Cause: The area handle is not bound to an area instance version.
    

CX\_SHM\_OUT\_OF\_MEMORY

-   Cause: There is not enough memory.
    

Continue
![Example](exa.gif "Example") [Creating a Data Object as a Shared Object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_shared_data_objct_abexa.htm)


### abencreate_shared_data_objct_abexa.htm

---
title: "Creating a Data Object as a Shared Object"
description: |
  This example demonstrates how a data object is created in an area instance version(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_instance_version_glosry.htm 'Glossary Entry'). Source Code REPORT demo_create_shared_data_object. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_shared_data_objct_abexa.htm"
abapFile: "abencreate_shared_data_objct_abexa.htm"
keywords: ["select", "do", "try", "catch", "method", "class", "data", "field-symbol", "abencreate", "shared", "objct", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm) →  [CREATE DATA - AREA HANDLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_area_handle.htm) → 

Creating a Data Object as a Shared Object

This example demonstrates how a data object is created in an [area instance version](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_instance_version_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_create\_shared\_data\_object.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: handle TYPE REF TO cl\_demo\_area,
          root   TYPE REF TO cl\_demo\_root,
          exc    TYPE REF TO cx\_shm\_attach\_error.
    FIELD-SYMBOLS <fs> TYPE any.
    DATA(out) = cl\_demo\_output=>new( ).
    TRY.
        handle = cl\_demo\_area=>attach\_for\_write( ).
        CREATE OBJECT root AREA HANDLE handle.
        handle->set\_root( root ).
        CREATE DATA root->dref AREA HANDLE handle TYPE string.
        ASSIGN root->dref->\* TO <fs>.
        <fs> = \`String in shared memory\`.
        handle->detach\_commit( ).
      CATCH cx\_shm\_attach\_error INTO exc.
        out->display( exc->get\_text( ) ).
        LEAVE PROGRAM.
      CATCH cx\_shm\_external\_type.
        out->display( 'Type cannot be used' ).
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        handle = cl\_demo\_area=>attach\_for\_read( ).
        ASSIGN handle->root->dref->\* TO <fs>.
        out->display( <fs> ).
        handle->detach( ).
      CATCH cx\_shm\_attach\_error INTO exc.
        out->display( exc->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The addition AREA HANDLE is used to create an anonymous data object of type string as a [shared object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_object_glosry.htm "Glossary Entry") in an [area instance version](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_instance_version_glosry.htm "Glossary Entry") of the area CL\_DEMO\_AREA. The generically typed attribute dref of the [area root class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenroot_data_class_glosry.htm "Glossary Entry") CL\_DEMO\_ROOT is used as a reference variable. A field symbol is used to dereference the data reference and assign a value to the anonymous data object.

Once the method DETACH\_COMMIT completes the write, a read is performed to demonstrate how the objects in the shared memory are accessed. An access of this type can also be made in another program, as long as the area instance version exists in the shared memory.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE OBJECT

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / CREATE OBJECT

Included pages: 8


### abapcreate_object.htm

---
title: "CREATE OBJECT"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm) Syntax Forms Defining a Class Implicitly(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_implicit.htm) 1. CREATE OBJECT oref  area_handle(https://help.s
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object.htm"
abapFile: "abapcreate_object.htm"
keywords: ["delete", "do", "if", "try", "method", "class", "data", "field-symbol", "abapcreate", "object"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) → 

CREATE OBJECT

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm)

Syntax Forms

[Defining a Class Implicitly](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_implicit.htm)
1\. CREATE OBJECT oref *\[* [area\_handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_area_handle.htm)*\]* *\[* [parameter\_list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_parameters.htm)*\]*.
[Defining a Class Explicitly](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_explicit.htm)
2\. CREATE OBJECT oref *\[* [area\_handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_area_handle.htm)*\]*
                     TYPE *{* class  *\[*[parameter\_list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_parameters.htm)*\]* *}*
                        *|* *{* (name) *\[* [parameter\_list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_parameters.htm)*|* [parameter\_tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_para_tables.htm)*\]* *}*.

Effect

The statement CREATE OBJECT creates an instance of a class or object and assigns the object reference to the reference variable oref. The instance constructor of the class is called directly after the object is created.

By default, the object is created in the [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry") (or [heap](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheap_glosry.htm "Glossary Entry")) of the current program and remains there for as long as it is required. If no more [heap references](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheap_reference_glosry.htm "Glossary Entry") point to the object, the following applies:

-   No more object references point to the object.
    
-   no data reference can no field symbol points to an instance attribute or to a part of an instance attribute,
    

Also, if no more methods of the object are registered as event handlers, the object is deleted by the [garbage collector](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengarbage_collector_glosry.htm "Glossary Entry"). The addition [area\_handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_area_handle.htm) can be used to create the object as a [shared object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_object_glosry.htm "Glossary Entry").

The reference variable oref must be declared as an object reference variable. Instance components of an object created using CREATE OBJECT can only be accessed using object reference variables (see [Data Objects in Operand Positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperands_data_objects.htm)).

The addition TYPE can be used to specify the class of the new object. The static type of the object reference variables must be more general than or identical to the class of the new object (in accordance with the rules for [Assignments Between Object Reference Variables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_references_objects.htm)).

Instances of a class can be created only where permitted by the addition CREATE of the statement [CLASS DEFINITION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass.htm). The class can be a local class of the same ABAP program or a global class from the class library permitted by the package check.

The additions [parameter\_list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_parameters.htm) and [parameter\_tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_para_tables.htm) must be used to fill the non-optional input parameters of the first explicitly implemented instance constructor in the path of the inheritance tree between the instantiated class and the root class object. These additions can also be used to assign return values to the non-class-based exceptions of the instance constructor.

If a handleable exception is raised for the object in the runtime environment, the object is not created and the object reference variable oref is initialized. If a handleable exception is raised when the object is created in the instance constructor of the class, the object is deleted and the object reference variable oref is initialized.

Return Value
If the CREATE OBJECT statement is executed successfully, sy-subrc is set to 0. Values other than 0 can occur when specifying EXCEPTIONS in parameter\_spec when non-class-based exceptions of the instance constructor are handled.

Notes

-   If the reference variable oref specified after CREATE OBJECT is passed simultaneously to the instance constructor, it points to the new object when this constructor is executed. To pass a reference to an existing object to the instance constructor, a different reference variable needs to be used.
    
-   The statement CREATE OBJECT creates a [heap reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheap_reference_glosry.htm "Glossary Entry"). All references that point to the object or its parts are also heap references and keep the object alive. The same applies to field symbols that point to instance attributes or to their parts.
    
-   When a class is used, the [instance operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_operator_glosry.htm "Glossary Entry") [NEW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) acts like the statement CREATE OBJECT oref TYPE class and can be used in [general expression positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneral_expr_position_glosry.htm "Glossary Entry").
    
-   The return code sy-subrc is set to 0 if the statement is successful because the instance constructor is called. sy-subrc is set each time a [method is called](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_static_short.htm).
    

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Handleable Exceptions

CX\_SY\_CREATE\_OBJECT\_ERROR

-   Cause: An attempt was made to instantiate an abstract class.
    Runtime error: CREATE\_OBJECT\_CLASS\_ABSTRACT
    
-   Cause: The class specified in the addition TYPE does not exist.
    Runtime error: CREATE\_OBJECT\_CLASS\_NOT\_FOUND
    
-   Cause: The class specified dynamically in TYPE does not match the type of the reference variable.
    Runtime error: MOVE\_OREF\_NOT\_CONVERTIBLE
    
-   Cause: An attempt was made to instantiate a private class externally.
    Runtime error: CREATE\_OBJECT\_CREATE\_PRIVATE
    
-   Cause: An attempt was made to instantiate a protected class externally.
    Runtime error: CREATE\_OBJECT\_CREATE\_PROTECTED
    

Non-Handleable Exceptions

-   Cause: A reference must be specified as the target variable.
    Runtime error: CREATE\_OBJECT\_NO\_REFTYPE:
    

Continue
[CREATE OBJECT oref](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_implicit.htm)
[CREATE OBJECT - TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_explicit.htm)
[CREATE OBJECT - AREA HANDLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_area_handle.htm)
[CREATE OBJECT - parameter\_list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_parameters.htm)
[CREATE OBJECT - parameter\_tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_para_tables.htm)


### abapcreate_object_implicit.htm

---
title: "CREATE OBJECT oref"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm) Syntax CREATE OBJECT oref  area_handle(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_area_handle.htm)  parameter_list(https://help.sap.com/doc
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_implicit.htm"
abapFile: "abapcreate_object_implicit.htm"
keywords: ["do", "if", "try", "class", "data", "abapcreate", "object", "implicit"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object.htm) → 

CREATE OBJECT oref

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm)

Syntax

CREATE OBJECT oref *\[* [area\_handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_area_handle.htm)*\]* *\[* [parameter\_list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_parameters.htm)*\]*.

Effect

If the addition TYPE is not specified, the object reference variable oref must be a class reference variable. An instance of the class is created that is the static type of the object reference variable. The static type of the class reference variable cannot be an [abstract](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabstract_glosry.htm "Glossary Entry") class, and in particular must not be the root class object.

Note

When the character # is used in an operand position with the operand type of a class reference variable, the [instance operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_operator_glosry.htm "Glossary Entry") [NEW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) works like the statement CREATE DATA dref.

Example

Creates an instance of a class cls using an implicit reference to the static type of the reference variables.

CLASS cls DEFINITION.
  PUBLIC SECTION.
    DATA attr type string VALUE 'Object'.
ENDCLASS.
DATA oref TYPE REF TO cls.
CREATE OBJECT oref.
cl\_demo\_output=>display( oref->attr ).


### abapcreate_object_explicit.htm

---
title: "CREATE OBJECT - TYPE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm) Syntax CREATE OBJECT oref area_handle(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_area_handle.htm) TYPE  class  parameter_list(https://he
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_explicit.htm"
abapFile: "abapcreate_object_explicit.htm"
keywords: ["do", "if", "case", "try", "class", "data", "abapcreate", "object", "explicit"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object.htm) → 

CREATE OBJECT - TYPE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm)

Syntax

CREATE OBJECT oref *\[*[area\_handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_area_handle.htm)*\]*
                   TYPE *{* class  *\[*[parameter\_list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_parameters.htm)*\]* *}*
                      *|* *{* (name) *\[* [parameter\_list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_parameters.htm)*|* [parameter\_tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_para_tables.htm)*\]* *}*.

Effect

Creates an instance of an explicitly specified class. A [concrete](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconcrete_glosry.htm "Glossary Entry") class that is more specific than or identical to the static type of the object reference variable oref can be specified. The reference variable oref can be a class reference variable or an interface reference variable. The name of the class can be specified as follows:

-   class
    

Specified directly and statically as class.

-   (name)
    

Specified as the content of a character-like data object name. The data object name must contain the name of the class in uppercase letters when the statement is executed. The class name in name can also be an [absolute type name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabsolute_typename_glosry.htm "Glossary Entry"). The following can be specified for name:

-   Literal or constant
    If the data object name is specified as a character literal or as a constant, it can be evaluated statically and the specified class is identified as the used object.

-   Variable
    If the data object name is specified as a variable, it is specified only dynamically and the content is not evaluated statically.

When the statement is executed, name is not evaluated until runtime (in both cases).

The class must be usable at the current location:

-   The addition [CREATE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_options.htm) of the class definition must permit objects to be created.
    
-   The package check must permit an object of a global class to be created.
    

Notes

-   If the class is specified dynamically, the parameters can either be specified statically in [parameter\_list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_parameters.htm) or dynamically in [parameter\_tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_para_tables.htm).
    
-   When a class is used, the [instance operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_operator_glosry.htm "Glossary Entry") [NEW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) acts like the statement CREATE OBJECT oref TYPE class and can be used in [general expression positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneral_expr_position_glosry.htm "Glossary Entry"). The content of name cannot be specified dynamically here.
    

Security Note

If used wrongly, creating objects dynamically can present a serious security risk. Names of classes that are passed to a program from the outside must be checked thoroughly before being used in dynamic statements. The system class CL\_ABAP\_DYN\_PRG, for example, can be used to do this. See [Dynamic Calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendyn_call_scrty.htm).

Example

Creates an instance of a class cls using an explicit reference to the class. The static type of the reference variable is the root class object and is therefore more general than any other class. Components must be accessed dynamically or a cast must be performed (as shown here).

CLASS cls DEFINITION.
  PUBLIC SECTION.
    DATA attr TYPE string VALUE 'Object'.
ENDCLASS.
DATA oref TYPE REF TO object.
CREATE OBJECT oref TYPE cls.
cl\_demo\_output=>display( CAST cls( oref ) ).


### abapcreate_object_area_handle.htm

---
title: "CREATE OBJECT - AREA HANDLE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm) Syntax CREATE OBJECT oref AREA HANDLE handle ... Effect This statement creates an object as a shared object(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_object_glos
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_area_handle.htm"
abapFile: "abapcreate_object_area_handle.htm"
keywords: ["update", "do", "if", "try", "method", "class", "data", "abapcreate", "object", "area", "handle"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object.htm) → 

CREATE OBJECT - AREA HANDLE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm)

Syntax

CREATE OBJECT oref AREA HANDLE handle ...

Effect

This statement creates an object as a [shared object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_object_glosry.htm "Glossary Entry") in the [area instance version](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_instance_version_glosry.htm "Glossary Entry") of the [shared memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_memory_glosry.htm "Glossary Entry"), which is bound to the [area handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_handle_glosry.htm "Glossary Entry") referenced by handle. The implicitly or explicitly specified class must be defined as a [shared-memory-enabled class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_class_glosry.htm "Glossary Entry") using the addition [SHARED MEMORY ENABLED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_options.htm) of the statement [CLASS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm).

handle expects an object reference variable whose static type is [CL\_ABAP\_MEMORY\_AREA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_abap_memory_area.htm) or one of its subclasses ([area class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_class_glosry.htm "Glossary Entry")). When the statement is executed, handle must point to an [area handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_handle_glosry.htm "Glossary Entry") and the area handle must be associated with an area instance version with a change lock. A reference like this can be created in one of the following ways:

-   By inheriting the return value of the methods [ATTACH\_FOR\_WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_class.htm) or [ATTACH\_FOR\_UPDATE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_class.htm) of an area class created using transaction SHMA.
    
-   By inheriting the return value of the method [GET\_HANDLE\_BY\_...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_abap_memory_area.htm) of any area class.
    
-   By inheriting the return value of the method [GET\_IMODE\_HANDLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_imode_area.htm) of the predefined class CL\_IMODE\_AREA.
    

The latter is a reference to an area handle for the current [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry") and the statement CREATE OBJECT operates as if the addition AREA HANDLE were not specified.

Notes

-   The only shared object that can be addressed from an ABAP program directly after a binding is made to an area instance version is the instance of the [area root class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenroot_data_class_glosry.htm "Glossary Entry"). All other objects have to be referenced in this instance.
    
-   The static attributes of a shared object are not created in the shared memory. Instead, they are created when the shared-memory-enabled class is loaded to the internal session of a program, as for every class. They can thus occur more than once and independently of one another in different programs.
    

Example

Creation of a shared object in an area instance version of area CL\_DEMO\_AREA.

CLASS cls DEFINITION
          SHARED MEMORY ENABLED.
  ...
ENDCLASS.
DATA: root   TYPE REF TO cl\_demo\_root,
      handle TYPE REF TO cl\_demo\_area.
...
handle = cl\_demo\_area=>attach\_for\_write( ).
CREATE OBJECT root AREA HANDLE handle.
handle->set\_root( root ).
CREATE OBJECT root->oref AREA HANDLE handle TYPE cls.
...

Executable Example

[Creating an Instance of a Class as a Shared Object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_shared_object_abexa.htm)

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Handleable Exceptions

CX\_SHM\_WRONG\_HANDLE

-   Cause: The area handle does not hold any change locks.
    

CX\_SHM\_ALREADY\_DETACHED

-   Cause: The area handle is not bound to an area instance version.
    

CX\_SHM\_OUT\_OF\_MEMORY

-   Cause: There is not enough memory.
    

CX\_SHM\_OBJECT\_NOT\_SERIALIZABLE

-   Cause: In an area instance displaceable using backup and recovery, an attempt was made to create an object that cannot be serialized.
    

Continue
![Example](exa.gif "Example") [Creating an Instance of a Class as a Shared Object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_shared_object_abexa.htm)


### abencreate_shared_object_abexa.htm

---
title: "Creating an Instance of a Class as a Shared Object"
description: |
  This example demonstrates how an object is created in an area instance version(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_instance_version_glosry.htm 'Glossary Entry'). Source Code REPORT demo_create_shared_object. CLASS class DEFINITION SHARED MEMORY ENABLED. PUBLIC SE
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_shared_object_abexa.htm"
abapFile: "abencreate_shared_object_abexa.htm"
keywords: ["select", "do", "try", "catch", "method", "class", "data", "abencreate", "shared", "object", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object.htm) →  [CREATE OBJECT - AREA HANDLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_area_handle.htm) → 

Creating an Instance of a Class as a Shared Object

This example demonstrates how an object is created in an [area instance version](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_instance_version_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_create\_shared\_object.
CLASS class DEFINITION
            SHARED MEMORY ENABLED.
  PUBLIC SECTION.
    DATA attr TYPE string.
    METHODS set\_attr IMPORTING text TYPE string.
ENDCLASS.
CLASS class IMPLEMENTATION.
  METHOD set\_attr.
    attr = text.
  ENDMETHOD.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: handle TYPE REF TO cl\_demo\_area,
          root   TYPE REF TO cl\_demo\_root,
          exc    TYPE REF TO cx\_shm\_attach\_error,
          oref   TYPE REF TO class.
    TRY.
        handle = cl\_demo\_area=>attach\_for\_write( ).
        CREATE OBJECT root AREA HANDLE handle.
        handle->set\_root( root ).
        CREATE OBJECT root->oref AREA HANDLE handle TYPE class.
        oref ?= root->oref.
        oref->set\_attr( \`String in shared memory\` ).
        CLEAR oref.
        handle->detach\_commit( ).
      CATCH cx\_shm\_attach\_error INTO exc.
        cl\_demo\_output=>display\_text( exc->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        handle = cl\_demo\_area=>attach\_for\_read( ).
        oref ?= handle->root->oref.
        cl\_demo\_output=>display\_data( oref->attr ).
        CLEAR oref.
        handle->detach( ).
      CATCH cx\_shm\_attach\_error INTO exc.
        cl\_demo\_output=>display\_text( exc->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The addition AREA HANDLE is used to create an instance of the local class class as a [shared object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_object_glosry.htm "Glossary Entry") in an [area instance version](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_instance_version_glosry.htm "Glossary Entry") of the area CL\_DEMO\_AREA. The generically typed attribute oref of the [area root class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenroot_data_class_glosry.htm "Glossary Entry") CL\_DEMO\_ROOT is used a a reference variable. The attribute attr of the object is given a value by calling its method set\_attr.

Once the method DETACH\_COMMIT completes the write, a read is performed to demonstrate how the objects in the shared memory are accessed. An access of this type can also be made in another program, as long as the area instance version exists in the shared memory.


### abapcreate_object_area_handle.htm

---
title: "CREATE OBJECT - AREA HANDLE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm) Syntax CREATE OBJECT oref AREA HANDLE handle ... Effect This statement creates an object as a shared object(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_object_glos
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_area_handle.htm"
abapFile: "abapcreate_object_area_handle.htm"
keywords: ["update", "do", "if", "try", "method", "class", "data", "abapcreate", "object", "area", "handle"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object.htm) → 

CREATE OBJECT - AREA HANDLE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm)

Syntax

CREATE OBJECT oref AREA HANDLE handle ...

Effect

This statement creates an object as a [shared object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_object_glosry.htm "Glossary Entry") in the [area instance version](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_instance_version_glosry.htm "Glossary Entry") of the [shared memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshared_memory_glosry.htm "Glossary Entry"), which is bound to the [area handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_handle_glosry.htm "Glossary Entry") referenced by handle. The implicitly or explicitly specified class must be defined as a [shared-memory-enabled class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_class_glosry.htm "Glossary Entry") using the addition [SHARED MEMORY ENABLED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_options.htm) of the statement [CLASS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass_definition.htm).

handle expects an object reference variable whose static type is [CL\_ABAP\_MEMORY\_AREA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_abap_memory_area.htm) or one of its subclasses ([area class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_class_glosry.htm "Glossary Entry")). When the statement is executed, handle must point to an [area handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarea_handle_glosry.htm "Glossary Entry") and the area handle must be associated with an area instance version with a change lock. A reference like this can be created in one of the following ways:

-   By inheriting the return value of the methods [ATTACH\_FOR\_WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_class.htm) or [ATTACH\_FOR\_UPDATE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_class.htm) of an area class created using transaction SHMA.
    
-   By inheriting the return value of the method [GET\_HANDLE\_BY\_...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_abap_memory_area.htm) of any area class.
    
-   By inheriting the return value of the method [GET\_IMODE\_HANDLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_imode_area.htm) of the predefined class CL\_IMODE\_AREA.
    

The latter is a reference to an area handle for the current [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry") and the statement CREATE OBJECT operates as if the addition AREA HANDLE were not specified.

Notes

-   The only shared object that can be addressed from an ABAP program directly after a binding is made to an area instance version is the instance of the [area root class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenroot_data_class_glosry.htm "Glossary Entry"). All other objects have to be referenced in this instance.
    
-   The static attributes of a shared object are not created in the shared memory. Instead, they are created when the shared-memory-enabled class is loaded to the internal session of a program, as for every class. They can thus occur more than once and independently of one another in different programs.
    

Example

Creation of a shared object in an area instance version of area CL\_DEMO\_AREA.

CLASS cls DEFINITION
          SHARED MEMORY ENABLED.
  ...
ENDCLASS.
DATA: root   TYPE REF TO cl\_demo\_root,
      handle TYPE REF TO cl\_demo\_area.
...
handle = cl\_demo\_area=>attach\_for\_write( ).
CREATE OBJECT root AREA HANDLE handle.
handle->set\_root( root ).
CREATE OBJECT root->oref AREA HANDLE handle TYPE cls.
...

Executable Example

[Creating an Instance of a Class as a Shared Object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_shared_object_abexa.htm)

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Handleable Exceptions

CX\_SHM\_WRONG\_HANDLE

-   Cause: The area handle does not hold any change locks.
    

CX\_SHM\_ALREADY\_DETACHED

-   Cause: The area handle is not bound to an area instance version.
    

CX\_SHM\_OUT\_OF\_MEMORY

-   Cause: There is not enough memory.
    

CX\_SHM\_OBJECT\_NOT\_SERIALIZABLE

-   Cause: In an area instance displaceable using backup and recovery, an attempt was made to create an object that cannot be serialized.
    

Continue
![Example](exa.gif "Example") [Creating an Instance of a Class as a Shared Object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_shared_object_abexa.htm)


### abapcreate_object_parameters.htm

---
title: "Syntax"
description: |
  ... EXPORTING  p1 = a1 p2 = a2 ... EXCEPTIONS exc1 = n1 exc2 = n2 ... OTHERS = n_others. Effect The additions EXPORTING and EXCEPTIONS are used to pass actual parameters to the instance constructor statically or to assign return values to non-class-based exceptions. -   When
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_parameters.htm"
abapFile: "abapcreate_object_parameters.htm"
keywords: ["do", "if", "case", "try", "method", "class", "data", "abapcreate", "object", "parameters"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object.htm) → 

CREATE OBJECT - parameter\_list

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm)

Syntax

... *\[*EXPORTING  p1 = a1 p2 = a2 ...*\]*
    *\[*EXCEPTIONS exc1 = n1 exc2 = n2 ... *\[*OTHERS = n\_others*\]**\]*.

Effect

The additions EXPORTING and EXCEPTIONS are used to pass actual parameters to the instance constructor statically or to assign return values to non-class-based exceptions.

-   When using the addition EXPORTING, the non-optional input parameters p1 p2 ... of the instance constructor of the instantiated class must be specified using the type-friendly actual parameters a1 a2 ... (the other input parameters are optional). As in regular method calls, a1, a2, ... are [general expression positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneral_expr_position_glosry.htm "Glossary Entry"). In other words, functions and expressions can be passed as actual parameters, alongside data objects. [Special rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentyping_arith_expr.htm) apply in this case. If a subclass does not have an instance constructor implemented explicitly, the interface of the instance constructor from the next-highest superclass that explicitly implements the instance constructor is used.
    
-   The addition EXCEPTIONS can be used to assign return values to [non-class-based exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_non_class.htm) exc1 exc2...
    

The syntax and semantics are the same as in the parameter list for [static method calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmethod_calls_static.htm).

Example

Creates a Control Framework (CFW) dialog box and passes input parameters to the instance constructor of the global class CL\_GUI\_DIALOGBOX\_CONTAINER. The class is defined implicitly using the static type of the reference variable dialog\_box.

DATA dialog\_box TYPE REF TO cl\_gui\_dialogbox\_container.
CREATE OBJECT dialog\_box
       EXPORTING parent = cl\_gui\_container=>desktop
                 width  = 1000
                 height = 350.


### abapcreate_object_para_tables.htm

---
title: "Syntax"
description: |
  ... PARAMETER-TABLE ptab EXCEPTION-TABLE etab. Effect The additions PARAMETER-TABLE and EXCEPTION-TABLE pass actual parameters dynamically to the instance constructor or assign return values to the non-class-based exceptions. These additions can be used only if the instantiated class
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_para_tables.htm"
abapFile: "abapcreate_object_para_tables.htm"
keywords: ["do", "if", "try", "catch", "method", "class", "data", "internal-table", "abapcreate", "object", "para", "tables"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object.htm) → 

CREATE OBJECT - parameter\_tables

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_shortref.htm)

Syntax

... *\[*PARAMETER-TABLE ptab*\]*
    *\[*EXCEPTION-TABLE etab*\]*.

Effect

The additions PARAMETER-TABLE and EXCEPTION-TABLE pass actual parameters dynamically to the instance constructor or assign return values to the non-class-based exceptions.

These additions can be used only if the instantiated class is specified dynamically in name. Using the special internal tables ptab and etab, they assign actual parameters to the input parameters of the instance constructor or return values to the non-class-based exceptions.

The syntax and semantics are the same as those that apply to dynamic method calls using the statement [CALL METHOD](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_dynamic.htm). The internal tables ptab and etab in particular must be defined with reference to the tables ABAP\_PARMBIND\_TAB and ABAP\_EXCPBIND\_TAB from the [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") ABAP.

Example

Creates a [Control Framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencontrol_framework_glosry.htm "Glossary Entry") (CFW) dialog box dynamically and passes input parameters dynamically to the instance constructor of the global class CL\_GUI\_DIALOGBOX\_CONTAINER. The class is defined explicitly using the addition [TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_explicit.htm).

DATA: container TYPE REF TO cl\_gui\_container,
      exc\_ref TYPE REF TO cx\_root.
DATA: class TYPE string VALUE \`CL\_GUI\_DIALOGBOX\_CONTAINER\`,
      ptab TYPE abap\_parmbind\_tab.
ptab = VALUE #( ( name  = 'PARENT'
                  kind  = cl\_abap\_objectdescr=>exporting
                  value = REF #( cl\_gui\_container=>desktop ) )
                ( name  = 'WIDTH'
                  kind  = cl\_abap\_objectdescr=>exporting
                  value = REF #( 1000 ) )
                ( name  = 'HEIGHT'
                  kind  = cl\_abap\_objectdescr=>exporting
                  value = REF #( 300 ) ) ).
TRY.
    CREATE OBJECT container TYPE (class)
      PARAMETER-TABLE ptab.
  CATCH cx\_sy\_create\_object\_error INTO exc\_ref.
    MESSAGE exc\_ref->get\_text( ) TYPE 'I'.
ENDTRY.

Example

The following program extract creates an object of a class SOME\_CLASS dynamically whose instance constructor expects a reference variable of the static type ANY\_CLASS. The syntax of the program is correct, but the object is created only in systems in which the classes exist.

CONSTANTS:
  anycls  TYPE string VALUE \`ANY\_CLASS\`,
  somecls TYPE string VALUE \`SOME\_CLASS\`,
  param   TYPE string VALUE \`PARA\`.
DATA dref TYPE REF TO data.
TRY.
    CREATE DATA dref TYPE REF TO (anycls).
    ASSIGN dref->\* TO FIELD-SYMBOL(<fs>).
    CREATE OBJECT <fs> TYPE (anycls).
  CATCH cx\_sy\_create\_data\_error
        cx\_sy\_create\_object\_error.
    ...
ENDTRY.
IF <fs> IS ASSIGNED.
  DATA(ptab) = VALUE abap\_parmbind\_tab(
    ( name = param
      kind  = cl\_abap\_objectdescr=>exporting
      value =  REF #( <fs> ) ) ).
ENDIF.
DATA oref TYPE REF TO object.
TRY.
    CREATE OBJECT oref TYPE (somecls) PARAMETER-TABLE ptab.
  CATCH cx\_sy\_create\_object\_error
        cx\_sy\_dyn\_call\_parameter\_error INTO DATA(exc).
    ...
ENDTRY.

This program can be executed in systems in which classes are declared as follows without raising exceptions.

CLASS any\_class DEFINITION.
  ...
ENDCLASS.
CLASS some\_class DEFINITION.
  PUBLIC SECTION.
    METHODS constructor IMPORTING para TYPE REF TO any\_class.
    ...
ENDCLASS.
CLASS some\_class IMPLEMENTATION.
  METHOD constructor.
    ...
  ENDMETHOD.
  ...
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / NEW - Instance Operator

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / NEW - Instance Operator

Included pages: 8


### abenconstructor_expression_new.htm

---
title: "NEW - Instance Operator"
description: |
  Syntax ... NEW type( ... ) ... Effect A constructor expression(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expressions.htm) with the instance operator NEW creates an anonymous data object(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenanonymous_data
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm"
abapFile: "abenconstructor_expression_new.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "method", "class", "data", "types", "internal-table", "field-symbol", "abenconstructor", "expression", "new"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) → 

NEW - Instance Operator

Syntax

... NEW type( ... ) ...

Effect

A [constructor expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expressions.htm) with the instance operator NEW creates an [anonymous data object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenanonymous_data_object_glosry.htm "Glossary Entry") or an [instance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_glosry.htm "Glossary Entry") of a class and assigns values to the new object. The result is a reference variable that points to the new object. The following can be specified for type:

-   A non-generic data type dtype.
    The operator NEW works in the same way as the statement [CREATE DATA dref TYPE dtype](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_existing.htm), where dref stands for the result that points to the new anonymous data object. The result is a data reference variable of the [static type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_type_glosry.htm "Glossary Entry") dtype. A constructor expression of this type cannot be extended using a [component selector](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencomponent_selector_glosry.htm "Glossary Entry").

-   A class class.
    The operator NEW works in the same way as the statement [CREATE OBJECT oref TYPE class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_explicit.htm), where oref stands for the result that points to the new object. The result is an object reference variable of the [static type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_type_glosry.htm "Glossary Entry") class. Using an object component selector \->, a constructor expression of this type can be extended in both [general expression positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneral_expression_positions.htm) and [functional positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunctional_positions.htm) (like an object reference variable) and can be used in the same operand positions. The following is also possible:

-   [Standalone method calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_static_short.htm) (including [chained method calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenchained_method_call_glosry.htm "Glossary Entry")) can be introduced.

-   A single expression that points to an attribute of the class using exactly one follow-on object component selector can also be used as the target field of assignments.

-   The # character.
    If the data type required in an operand position is unique and fully recognizable, the # character can be used instead of an explicitly specified type type and the [operand type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoperand_type_glosry.htm "Glossary Entry") is used. If the operand type is not known in full, the # character cannot be used, with the following exception: The operand can be evaluated after BASE when a [structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_struct.htm) or an [internal table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_itab.htm) is constructed.

The same descriptions apply as to the CREATE statements. Once an object is created, it is provided with values using the parameters in parentheses. The syntax used in parameter passing depends on the type used. There are specialized categories of parameter passing for complex types.

-   [Initial value for all types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_initial.htm)

-   [Initial value for all data types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_single.htm)

-   [Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_struct.htm)

-   [Internal tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_itab.htm)

-   [Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_class.htm)

When a constructor expression is [assigned](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenequals_operator.htm) to a reference variable using NEW, the information in the parentheses is evaluated before the new object is bound to the target variable.

Return Value
If an instance of a [class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_class.htm) is created successfully, the instance operator NEW sets sy-subrc to 0. Non-class-based exceptions of the instance constructor cannot be handled, which means that sy-subrc is never set to a value other than 0. The return code sy-subrc is not set when anonymous data objects are created.

Notes

-   To create the values for a new data object, the instance operator NEW uses mainly the same syntax as the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm).

-   The instance operator NEW always creates a new temporary reference variable that points to the new object. The reference variable is used as the operand of a statement and then deleted. It is deleted when the current statement is closed or after the analysis of a relational expression once the truth value is determined. The new object is passed to the garbage collector if it is not passed to a [heap reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenheap_reference_glosry.htm "Glossary Entry") or a field symbol after the temporary reference variable is deleted.

-   [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenequals_operator.htm) to a reference variable also always create a temporary reference variable that is only assigned to the target variable afterwards. This means that the object pointed to by the target variable before the assignment can be addressed using it throughout the entire expression. This is the difference between NEW and the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm).

Example

Creates an anonymous data object of the type i with the value 555 and an instance of a local class cls (derived implicitly from the static type of oref). In this case, the last statement could be written just as explicitly as oref = NEW cls( ) or it could be written as DATA(oref) = NEW cls( ), using an inline declaration instead of the preceding DATA statement.

CLASS cls DEFINITION.
  ...
ENDCLASS.
DATA: dref TYPE REF TO data,
      oref TYPE REF TO cls.
dref = NEW i( 555 ).
oref = NEW #( ).

Continue
[NEW - Initial Value for All Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_initial.htm)
[NEW - Single Value for All Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_single.htm)
[NEW - Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_struct.htm)
[NEW - Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_itab.htm)
[NEW - Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_class.htm)


### abennew_constructor_params_initial.htm

---
title: "NEW - Initial Value for All Types"
description: |
  Syntax ... NEW dtypeclass#( ) ... Effect If no parameters are specified, -   an anonymous data object retains its type-specific initial value, -   no values are passed to the instance constructor of an object. This is possible for every non-generic data type dtype. The instance constructor of
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_initial.htm"
abapFile: "abennew_constructor_params_initial.htm"
keywords: ["do", "if", "try", "class", "data", "types", "internal-table", "abennew", "constructor", "params", "initial"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [NEW - Instance Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) → 

NEW - Initial Value for All Types

Syntax

... NEW dtype*|*class*|*#( ) ...

Effect

If no parameters are specified,

-   an anonymous data object retains its type-specific initial value,

-   no values are passed to the instance constructor of an object.

This is possible for every non-generic data type dtype. The instance constructor of a class class can either have only optional input parameters or no input parameters at all. The # symbol can stand for appropriate types.

Note

If dtype or # stand for an [enumerated type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry"), its initial value is generated according to its [base type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbase_type_glosry.htm "Glossary Entry").

Example

After the following program section is executed, dref points to an empty internal table with the row type T100. Both constructor expressions have the same function.

TYPES t\_itab TYPE TABLE OF t100 WITH EMPTY KEY.
DATA dref TYPE REF TO t\_itab.
dref = NEW #( ).
dref = NEW t\_itab( ).


### abennew_constructor_params_single.htm

---
title: "NEW - Single Value for All Data Types"
description: |
  Syntax ... NEW dtype#( let_exp(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) dobj ) ... Effect If dtype is a non-generic elementary data type, a structured type, a table type, or a reference type (or # stands a type like this), a single data object dobj can be
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_single.htm"
abapFile: "abennew_constructor_params_single.htm"
keywords: ["select", "loop", "do", "if", "try", "data", "types", "internal-table", "abennew", "constructor", "params", "single"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [NEW - Instance Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) → 

NEW - Single Value for All Data Types

Syntax

... NEW dtype*|*#( *\[*[let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm)*\]* dobj ) ...

Effect

If dtype is a non-generic elementary data type, a structured type, a table type, or a reference type (or # stands a type like this), a single data object dobj can be specified as a unnamed argument (the data object either has the type dtype or is convertible to this type). dobj is a [general expression position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneral_expr_position_glosry.htm "Glossary Entry"). The value of dobj is assigned to the new anonymous data object. The assignment is made in accordance with the applicable [assignment rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_rules.htm). An optional LET expression [let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) can be specified before the data object to define local helper fields.

Notes

-   An expression specified for dobj can, more specifically, itself be a constructor expression or contain a constructor expression.

-   When a constructor expression is assigned to a reference variable using NEW, the original reference is made available in the entire expression in the target variable. The target variable is not overwritten until the expression is closed.

Example

Constructs an anonymous data object of the type string, whose value is determined using a string expression.

DATA input TYPE c LENGTH 10 VALUE 'World'.
cl\_demo\_input=>request( CHANGING field = input ).
DATA dref TYPE REF TO string.
dref =  NEW string( \`Hello \` && input && \`!\` ).
cl\_demo\_output=>display( dref->\* ).

Example

For each row read, a structured anonymous data object is created in a SELECT loop. The content of the row is assigned to this data object. The object is created in the general expression position of the statement APPEND and the new data reference is appended directly to an internal table with the appropriate row type. The result is a table that references all new anonymous data objects.

DATA dref\_tab LIKE TABLE OF REF TO t100 WITH EMPTY KEY.
DATA wa TYPE t100.
SELECT \*
       FROM t100
       WHERE sprsl = @sy-langu
       INTO @wa.
  APPEND NEW #( wa ) TO dref\_tab.
ENDSELECT.


### abennew_constructor_params_struct.htm

---
title: "NEW - Structures"
description: |
  Syntax ... NEW dtype#( let_exp(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) BASE dobj comp1 = dobj1 comp2 = dobj2 ... ) ... Effect If dtype is a structured data type or # stands for a type like this, the individual components can be specified as named
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_struct.htm"
abapFile: "abennew_constructor_params_struct.htm"
keywords: ["select", "do", "if", "case", "try", "data", "types", "internal-table", "abennew", "constructor", "params", "struct"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [NEW - Instance Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) → 

NEW - Structures

Syntax

... NEW dtype*|*#( *\[*[let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm)*\]*
                 *\[*BASE dobj*\]*
                 comp1 = dobj1 comp2 = dobj2 ... ) ...

Effect

If dtype is a structured data type or # stands for a type like this, the individual components can be specified as named arguments comp1, comp2, ... Each component of the new anonymous data object can be assigned a data object with the same data type as the component (or whose data type can be converted to this data type). This assignment is made for all data types in accordance with the appropriate [assignment rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_rules.htm).

An addition BASE can be specified in front of the individual component assignments, followed by a data object dobj. dobj is a [functional operand position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunctional_position_glosry.htm "Glossary Entry"). The type of dobj must be convertible to the type of the anonymous data object. If BASE is specified, the content of dobj is assigned to the anonymous data object before the individual components are assigned. If the character # is specified for the type of the anonymous data object and the type is not known from the operand position of the VALUE expression, the type of dobj is used for this expression (if known and structured).

dobj1, dobj2, ... are [general expression positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneral_expr_position_glosry.htm "Glossary Entry"). An optional LET expression [let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) can be specified in front of the assignments to define local helper fields that can be used on the right side of the assignments.

If a component is structured itself, either a suitable data object can be assigned to the entire substructure or its components can be specified using the structure component selector (\-). Non-specified components are ignored and keep their type-specific initial value or the value assigned using BASE. It is not possible to assign multiple values to a component, regardless of how the component is addressed. If the addition BASE is used, at least one component must be specified.

Notes

-   The assignments can be specified in any order within the parentheses.

-   If a component with a complex data type is constructed in an argument position, the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm) can be used. This affects tabular components, for example. This is also possible for structured components but is not necessary since the subcomponents can be addressed using the structure component selector.

-   When a constructor expression is assigned to a reference variable using NEW, the original reference is made available in the entire expression in the target variable. The target variable is not overwritten until the expression is closed. In the case of the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_struc.htm), however, the target variable can only be assigned to a helper variable using LET and is then no longer available.

Example

Constructs an anonymous data object with a nested structure type and tabular components. The subcomponents of col2 are addressed directly using the structure component selector. [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm) must be used to construct the tabular component col3. This is because the [syntax](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_itab.htm) used to construct internal tables cannot be specified directly as an argument.

TYPES: t\_itab TYPE TABLE OF i WITH EMPTY KEY,
       BEGIN OF t\_struct,
         col1 TYPE i,
         BEGIN OF col2,
           col1 TYPE i,
           col2 TYPE t\_itab,
         END OF col2,
         col3 TYPE t\_itab,
       END OF t\_struct.
DATA itab TYPE t\_itab.
DATA dref TYPE REF TO data.
dref = NEW t\_struct( col1 = 1
                     col2-col1 = 2
                     col2-col2 = itab
                     col3 = VALUE #( ( 1 )
                                     ( 2 )
                                     ( 3 ) ) ).

Example

Uses BASE. The type of the return value of base1 is applied in the construction of ref1. This is not possible in the construction of ref2, since base2 is not structured. In both results, col1 and col3 have the values xx or zz assigned using BASE, whereas col2 has the directly assigned value BB.

TYPES:
  BEGIN OF struct,
    col1 TYPE c LENGTH 2,
    col2 TYPE c LENGTH 2,
    col3 TYPE c LENGTH 2,
  END OF struct.
DATA(base1)   = VALUE struct( col1 = 'xx' col2 = 'yy' col3 = 'zz' ).
DATA(ref1)  = NEW #( BASE base1 col2 = 'BB' ).
DATA(base2)   = \`xxyyzz\`.
DATA(ref2)  = NEW struct( BASE base2 col2 = 'BB' ).
cl\_demo\_output=>write(   ref1->\* ).
cl\_demo\_output=>display( ref2->\* ).

Example

See also the examples for the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_struc.htm).


### abennew_constructor_params_itab.htm

---
title: "NEW - Internal Tables"
description: |
  Syntax ... NEW dtype#( let_exp(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) BASE itab FOR for_exp1(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm) FOR for_exp2(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-U
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_itab.htm"
abapFile: "abennew_constructor_params_itab.htm"
keywords: ["insert", "do", "if", "case", "try", "data", "types", "internal-table", "field-symbol", "abennew", "constructor", "params", "itab"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [NEW - Instance Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) → 

NEW - Internal Tables

Syntax

... NEW dtype*|*#( *\[*[let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm)*\]*
                 *\[*BASE itab*\]*
                 *\[*[FOR for\_exp1](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm)
                  [FOR for\_exp2](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm)
                  ... *\]*
                 ( [line\_spec1](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm) )
                 ( [line\_spec2](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm) )
                   ... ) ...

Extras:

[1\. ... BASE itab](#!ABAP_ADDITION_1@1@)
[2\. ... FOR for\_exp](#!ABAP_ADDITION_2@2@)

Effect

If dtype is a tabular data type or # stands for a type like this, the table rows of the constructed table are created as follows:

-   Firstly, an optional LET expression [let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) can be specified to define local auxiliary fields whose values can be used to construct the table rows.

-   An optional start value for the content can be specified for the content of the internal table after BASE (see below).

-   One more optional consecutive [iteration expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeniteration_expression_glosry.htm "Glossary Entry") can then be specified using [FOR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm) (see below).

-   The table rows are then constructed in one or more sets of internal parentheses by specifying [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm). Each set of inner parentheses constructs one or more rows in accordance with the information in line\_spec and inserts them into the new internal table in accordance with the rules for the statement [INSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab.htm) ... [INTO TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab_position.htm). The object is inserted in the order of the parentheses.

The constructed rows must meet the requirements of the statement [INSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab.htm) for inserting work areas using table keys and therefore be compatible with the row type. There is one exception to this: When constructing a [standard table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_table_glosry.htm "Glossary Entry"), where the rows are only appended, the value can be shorter than the row length (for row types c and x), in which case it is padded on the right with blanks or hexadecimal 0.

Notes

-   When a constructor expression is assigned to a reference variable using NEW, the original reference is made available in the entire expression in the target variable. The target variable is not overwritten until the expression is closed. In the case of the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm), however, the target variable can only be assigned to a helper variable using LET and is then no longer available.

-   The operand type for [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm) in the inner parentheses is the row type of the table type specified using dtype or #, which means it is always uniquely identifiable. Constructor expressions in this place can therefore always derive the required data type using #.
    

Example

Constructs an anonymous internal table with a structured row type with substructures and tabular components.

TYPES: BEGIN OF t\_struct1,
         col1 TYPE i,
         col2 TYPE i,
       END OF t\_struct1,
       BEGIN OF t\_struct2,
         col1 TYPE i,
         col2 TYPE t\_struct1,
         col3 TYPE TABLE OF t\_struct1 WITH EMPTY KEY,
       END OF t\_struct2,
       t\_itab TYPE TABLE OF t\_struct2 WITH EMPTY KEY.
DATA dref TYPE REF TO data.
dref = NEW t\_itab( ( col1 = 1
                     col2-col1 = 1
                     col2-col2 = 2
                     col3 = VALUE #( ( col1 = 1 col2 = 2 )
                                     ( col1 = 3 col2 = 4 ) ) )
                   ( col1 = 2
                     col2-col1 = 2
                     col2-col2 = 4
                     col3 = VALUE #( ( col1 = 2 col2 = 4 )
                                     ( col1 = 6 col2 = 8 ) ) ) ).

Examples

See also the examples for the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm).

Addition 1

... BASE itab

Effect

An addition, BASE, followed by an internal table, itab, can be specified in front of the lines that you want to insert. This is a [functional operand position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunctional_position_glosry.htm "Glossary Entry"). The row type of itab must be convertible to the row type of the return value. If BASE is specified, the content of itab is assigned to the return value before the individual rows are inserted. If the character # is specified for the type of the return value and the type cannot be determined from the operand position of the constructor expression, the type of itab is used for this expression (if identifiable).

Example

Constructs three anonymous internal tables with an elementary row type. The first table is filled with three rows. The second row is initial. The second and third tables are filled with the rows of the first table and three further rows. Using BASE and [LINES OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm) here has the same effect.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
DATA(dref1) = NEW t\_itab( ( 1 ) (  ) ( 3 ) ).
DATA(dref2) = NEW t\_itab( BASE dref1->\*
                          (   ) ( 5 ) (  ) ).
DATA(dref3) = NEW t\_itab( ( LINES OF dref1->\* )
                          (   ) ( 5 ) (  ) ).
cl\_demo\_output=>write(   dref1->\* ).
cl\_demo\_output=>write(   dref2->\* ).
cl\_demo\_output=>display( dref3->\* ).

Addition 2

... FOR for\_exp

Effect

If one or more [iteration expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeniteration_expression_glosry.htm "Glossary Entry") are specified consecutively using [FOR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm), this means that the rows constructed in [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm) for every iteration of the last FOR expression are inserted into the target table. When constructing table rows in [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm), the visible local work areas and field symbols of the iteration expressions can be used to construct table rows.

-   If [conditional iterations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor_conditional.htm) are used, the new table rows are created in freely defined iteration steps.

-   If [table iterations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor_itab.htm) are used, the rows of existing internal tables are evaluated. These are known as [table comprehensions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_comprehension_glosry.htm "Glossary Entry"), since in this case new table rows can be constructed from the rows of existing internal tables.

Notes

-   The term "table comprehension" is derived from similar concepts used in many other languages, where it is also known as "list comprehension".

-   [Table filtering](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_filtering_glosry.htm "Glossary Entry") can be implemented more efficiently using the [filter operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfilter_operator_glosry.htm "Glossary Entry") [FILTER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_filter.htm).

-   Conditional iterations and table comprehensions are also possible with [FOR expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmesh_for.htm) for [mesh paths](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmesh_path_glosry.htm "Glossary Entry").
    

Example

Constructs an anonymous internal table with an elementary row type and fills it with square numbers using an iteration expression.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
DATA(dref) = NEW t\_itab( FOR i = 1 UNTIL i > 10
                         ( ipow( base = i exp = 2 ) ) ).
cl\_demo\_output=>display( dref->\* ).

Executable Examples

[Examples of Table Comprehensions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_comprehensions_abexas.htm)

Continue
[NEW - line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm)


### abennew_constructor_params_lspc.htm

---
title: "Syntax"
description: |
  ... line  LINES OF jtab FROM idx1 TO idx2 USING KEY keyname ... Alternatives: 1. ... line(#!ABAP_ALTERNATIVE_1@1@) 2. ... LINES OF jtab FROM idx1 TO idx2 USING KEY keyname(#!ABAP_ALTERNATIVE_2@2@) Effect Specifies one or more rows to be
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm"
abapFile: "abennew_constructor_params_lspc.htm"
keywords: ["insert", "do", "if", "try", "method", "data", "types", "internal-table", "abennew", "constructor", "params", "lspc"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [NEW - Instance Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) →  [NEW - Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_itab.htm) → 

NEW - line\_spec

Syntax

... line
  *|* *{*LINES OF jtab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]**}* ...

Alternatives:

[1\. ... line](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LINES OF jtab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]*](#!ABAP_ALTERNATIVE_2@2@)

Effect

Specifies one or more rows to be inserted when constructing an internal table with the instance operator [NEW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_itab.htm).

Alternative 1

... line

Effect

Specifies a row. line can be specified in exactly the same way as in the parentheses of an expression [NEW line\_type( ... )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm). Here, line\_type is the row type of the internal table and a corresponding row is constructed. The following special features apply here:

-   If a data object is specified for line, this object must be compatible with the row type.

-   If an expression (built-in function, functional method, calculation expression, constructor expression, or table expression) is specified for line, the result of the expression must be convertible to the row type.

-   The syntax does not permit further parentheses for constructing tabular row types to be nested directly in line.

Short Form for Structured Row Types

If the row type of the internal table is a structured type, the following short form can be used:

NEW dtype*|*#( *\[*let\_exp*\]*
             *\[*BASE itab*\]*
             col1 = dobj11 ... ( col2 = dobj12 col3 = dobj13 ... )
                               ( col2 = dobj22 col3 = dobj23 ... )
                               ...
             col1 = dobj31 col2 = dobj32 ... ( col3 = dobj33 ... )
                                             ( col3 = dobj43 ... )
             ... ).

This has the same semantics as the following form:

NEW dtype*|*#( *\[*let\_exp*\]*
             *\[*BASE itab*\]*
             ( col1 = dobj11 ... col2 = dobj12 col3 = dobj13 ... )
             ( col1 = dobj11 ... col2 = dobj22 col3 = dobj23 ... )
             ...
             ( col1 = dobj31 col2 = dobj32 ... col3 = dobj33 ... )
             ( col1 = dobj31 col2 = dobj32 ... col3 = dobj43 ... )
             ... ).

Values can be assigned to individual structure components outside of the inner parentheses. An assignment of this type applies to all following inner parentheses until the next assignment is made to the component in question. Assignments outside of the inner parentheses must be followed by at least one inner parenthesis. A component cannot be assigned a value more than once in the [construction of a structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_struct.htm), which means that a component assigned a value outside of the inner parentheses can no longer be specified in an inner parenthesis. A component can be specified again outside the inner parentheses and any components previously specified in an inner parenthesis can also be listed outside the parenthesis.

Notes

-   The restriction that the content of tabular row types cannot be constructed directly in line applies for reasons of legibility (for humans and for machines) and is not a functional restriction. The expression [VALUE line\_type( ... )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm) can be specified for line to construct the content of a tabular row, where line\_type is the tabular row type.

-   Specifying [CONV line\_type( ... )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_conv.htm) for the inserted values is also a way of meeting the compatibility requirements made by the row type.

-   The short form for structured row types enables columns of internal tables that are to be given an identical value in blocks to be filled more easily.
    

Example

Constructs an anonymous internal table with a structured row type (with a short form for the first column):

TYPES:
  BEGIN OF t\_line,
    col1 TYPE i,
    col2 TYPE i,
  END OF t\_line,
  t\_itab TYPE TABLE OF t\_line WITH EMPTY KEY.
DATA(dref) = NEW t\_itab( col1 = 1 ( col2 = 11 )
                                  ( col2 = 12 )
                                  ( col2 = 13 )
                         col1 = 2 ( col2 = 21 )
                                  ( col2 = 22 )
                                  ( col2 = 23 ) ).
cl\_demo\_output=>display( dref->\* ).

Alternative 2

... LINES OF jtab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]*

Effect

Specifies multiple rows. The rows are taken from the internal table jtab and inserted into the target table as a block. The same applies to jtab and the additions FROM, TO, and USING KEY as to the addition [LINES OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab_linespec.htm) of the statement [INSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab.htm) and the block is inserted in accordance with these rules. jtab is a [functional operand position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunctional_position_glosry.htm "Glossary Entry").

Notes

-   The rows from jtab are inserted into the target table using the table key only, which means that jtab must be compatible with the target type.

-   If there is a conflict with an existing unique table key, a non-handleable exception is always raised when inserting multiple rows from an internal table using the statement [INSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab.htm).

-   When standard tables are created, the rows of the table jtab are appended to the target table in the same way as with the statement [APPEND LINES OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapappend_linespec.htm).

Example

Constructs an internal table itab containing the first three rows and last three rows of the previously constructed table alpha.

DATA:
  alpha TYPE TABLE OF string WITH EMPTY KEY,
  itab  LIKE REF TO alpha.
alpha = VALUE #(  FOR j = 0 UNTIL j >= strlen( sy-abcde )
                  ( substring( val = sy-abcde
                               off = j
                               len = 1  ) ) ).
itab = NEW #( ( LINES OF alpha FROM 1 to 3 )
              ( \`-\` )
              ( LINES OF alpha FROM lines( alpha ) - 2
                               TO   lines( alpha ) ) ).
cl\_demo\_output=>display( itab->\* ).


### abennew_constructor_params_itab.htm

---
title: "NEW - Internal Tables"
description: |
  Syntax ... NEW dtype#( let_exp(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) BASE itab FOR for_exp1(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm) FOR for_exp2(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-U
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_itab.htm"
abapFile: "abennew_constructor_params_itab.htm"
keywords: ["insert", "do", "if", "case", "try", "data", "types", "internal-table", "field-symbol", "abennew", "constructor", "params", "itab"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [NEW - Instance Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) → 

NEW - Internal Tables

Syntax

... NEW dtype*|*#( *\[*[let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm)*\]*
                 *\[*BASE itab*\]*
                 *\[*[FOR for\_exp1](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm)
                  [FOR for\_exp2](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm)
                  ... *\]*
                 ( [line\_spec1](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm) )
                 ( [line\_spec2](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm) )
                   ... ) ...

Extras:

[1\. ... BASE itab](#!ABAP_ADDITION_1@1@)
[2\. ... FOR for\_exp](#!ABAP_ADDITION_2@2@)

Effect

If dtype is a tabular data type or # stands for a type like this, the table rows of the constructed table are created as follows:

-   Firstly, an optional LET expression [let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) can be specified to define local auxiliary fields whose values can be used to construct the table rows.

-   An optional start value for the content can be specified for the content of the internal table after BASE (see below).

-   One more optional consecutive [iteration expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeniteration_expression_glosry.htm "Glossary Entry") can then be specified using [FOR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm) (see below).

-   The table rows are then constructed in one or more sets of internal parentheses by specifying [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm). Each set of inner parentheses constructs one or more rows in accordance with the information in line\_spec and inserts them into the new internal table in accordance with the rules for the statement [INSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab.htm) ... [INTO TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab_position.htm). The object is inserted in the order of the parentheses.

The constructed rows must meet the requirements of the statement [INSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab.htm) for inserting work areas using table keys and therefore be compatible with the row type. There is one exception to this: When constructing a [standard table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_table_glosry.htm "Glossary Entry"), where the rows are only appended, the value can be shorter than the row length (for row types c and x), in which case it is padded on the right with blanks or hexadecimal 0.

Notes

-   When a constructor expression is assigned to a reference variable using NEW, the original reference is made available in the entire expression in the target variable. The target variable is not overwritten until the expression is closed. In the case of the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm), however, the target variable can only be assigned to a helper variable using LET and is then no longer available.

-   The operand type for [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm) in the inner parentheses is the row type of the table type specified using dtype or #, which means it is always uniquely identifiable. Constructor expressions in this place can therefore always derive the required data type using #.
    

Example

Constructs an anonymous internal table with a structured row type with substructures and tabular components.

TYPES: BEGIN OF t\_struct1,
         col1 TYPE i,
         col2 TYPE i,
       END OF t\_struct1,
       BEGIN OF t\_struct2,
         col1 TYPE i,
         col2 TYPE t\_struct1,
         col3 TYPE TABLE OF t\_struct1 WITH EMPTY KEY,
       END OF t\_struct2,
       t\_itab TYPE TABLE OF t\_struct2 WITH EMPTY KEY.
DATA dref TYPE REF TO data.
dref = NEW t\_itab( ( col1 = 1
                     col2-col1 = 1
                     col2-col2 = 2
                     col3 = VALUE #( ( col1 = 1 col2 = 2 )
                                     ( col1 = 3 col2 = 4 ) ) )
                   ( col1 = 2
                     col2-col1 = 2
                     col2-col2 = 4
                     col3 = VALUE #( ( col1 = 2 col2 = 4 )
                                     ( col1 = 6 col2 = 8 ) ) ) ).

Examples

See also the examples for the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm).

Addition 1

... BASE itab

Effect

An addition, BASE, followed by an internal table, itab, can be specified in front of the lines that you want to insert. This is a [functional operand position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunctional_position_glosry.htm "Glossary Entry"). The row type of itab must be convertible to the row type of the return value. If BASE is specified, the content of itab is assigned to the return value before the individual rows are inserted. If the character # is specified for the type of the return value and the type cannot be determined from the operand position of the constructor expression, the type of itab is used for this expression (if identifiable).

Example

Constructs three anonymous internal tables with an elementary row type. The first table is filled with three rows. The second row is initial. The second and third tables are filled with the rows of the first table and three further rows. Using BASE and [LINES OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm) here has the same effect.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
DATA(dref1) = NEW t\_itab( ( 1 ) (  ) ( 3 ) ).
DATA(dref2) = NEW t\_itab( BASE dref1->\*
                          (   ) ( 5 ) (  ) ).
DATA(dref3) = NEW t\_itab( ( LINES OF dref1->\* )
                          (   ) ( 5 ) (  ) ).
cl\_demo\_output=>write(   dref1->\* ).
cl\_demo\_output=>write(   dref2->\* ).
cl\_demo\_output=>display( dref3->\* ).

Addition 2

... FOR for\_exp

Effect

If one or more [iteration expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeniteration_expression_glosry.htm "Glossary Entry") are specified consecutively using [FOR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm), this means that the rows constructed in [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm) for every iteration of the last FOR expression are inserted into the target table. When constructing table rows in [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm), the visible local work areas and field symbols of the iteration expressions can be used to construct table rows.

-   If [conditional iterations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor_conditional.htm) are used, the new table rows are created in freely defined iteration steps.

-   If [table iterations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor_itab.htm) are used, the rows of existing internal tables are evaluated. These are known as [table comprehensions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_comprehension_glosry.htm "Glossary Entry"), since in this case new table rows can be constructed from the rows of existing internal tables.

Notes

-   The term "table comprehension" is derived from similar concepts used in many other languages, where it is also known as "list comprehension".

-   [Table filtering](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_filtering_glosry.htm "Glossary Entry") can be implemented more efficiently using the [filter operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfilter_operator_glosry.htm "Glossary Entry") [FILTER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_filter.htm).

-   Conditional iterations and table comprehensions are also possible with [FOR expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmesh_for.htm) for [mesh paths](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmesh_path_glosry.htm "Glossary Entry").
    

Example

Constructs an anonymous internal table with an elementary row type and fills it with square numbers using an iteration expression.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
DATA(dref) = NEW t\_itab( FOR i = 1 UNTIL i > 10
                         ( ipow( base = i exp = 2 ) ) ).
cl\_demo\_output=>display( dref->\* ).

Executable Examples

[Examples of Table Comprehensions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_comprehensions_abexas.htm)

Continue
[NEW - line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_lspc.htm)


### abennew_constructor_params_class.htm

---
title: "NEW - Classes"
description: |
  Syntax ... NEW class#( let_exp(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) p1 = a1 p2 = a2 .. ) ... Effect If a class class is specified or # stands for a class like this, the non-optional input parameters p1 p2 ... of the instance constructor of the instant
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_class.htm"
abapFile: "abennew_constructor_params_class.htm"
keywords: ["select", "do", "while", "if", "case", "try", "method", "class", "data", "abennew", "constructor", "params"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [NEW - Instance Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm) → 

NEW - Classes

Syntax

... NEW class*|*#( *\[*[let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm)*\]* p1 = a1 p2 = a2 .. ) ...

Effect

If a class class is specified or # stands for a class like this, the non-optional input parameters p1 p2 ... of the instance constructor of the instantiated class must be filled using the type-friendly actual parameters a1 a2 ... The optional input parameters do not need to be filled. The description of the statement [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_parameters.htm) specifies how values are passed by parameter and which classes can be used. [No parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_initial.htm) are passed for a class without an explicit instance constructor. An optional LET expression [let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) can be specified in front of the parameter to define local helper fields.

Like an object reference variable of the type class,a constructor expression NEW class( ... ) can be specified in front of the [object component selector](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobject_component_select_glosry.htm "Glossary Entry") \-> and in [chained attribute accesses](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenchained_attribute_acc_glosry.htm "Glossary Entry") and [chained method calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenchained_method_call_glosry.htm "Glossary Entry"). A chained method call of this type can be specified as a [standalone statement](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_static_chain.htm). This persists the result for the duration of the statement. Even a single expression without a following object component selector can be specified as a standalone statement. In this case, the only constructor executed is the constructor that needs to save a reference to the new object elsewhere (if it needs to be persisted).

In the special case of an attribute access NEW class( ... )->attr, the following applies:

-   It can be specified as a [writable expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwritable_expression_glosry.htm "Glossary Entry") in a [result position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenresult_position_glosry.htm "Glossary Entry").

-   A [specified offset/length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length_specific_glosry.htm "Glossary Entry") [+off(len)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length.htm) can be appended (if the data type is suitable), except when the chaining uses the statement ASSIGN as a [memory area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_mem_area_writable_exp.htm).

[Method chainings](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmethod_chaining_glosry.htm "Glossary Entry") cannot be specified between the constructor expression and the attribute here.

Notes

-   This can be seen as a functional call of the instance constructor. As in [function calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_functional.htm) of [functional methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_functional.htm), no [non-class-based exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_non_class.htm) can be handled.

-   When the instance constructor is called, the return code sy-subrc is set to 0. Values other than 0 are not possible, since non-class-based exceptions cannot be handled.

Example

Constructs an instance of the class c1 when the method m2 of the class c2 is called. Here, an input parameter of the type in question is expected.

CLASS c1 DEFINITION.
  PUBLIC SECTION.
    METHODS constructor IMPORTING p1 TYPE i p2 TYPE i.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD constructor.
    ...
  ENDMETHOD.
ENDCLASS.
CLASS c2 DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS m2 IMPORTING oref TYPE REF TO c1.
ENDCLASS.
CLASS c2 IMPLEMENTATION.
  METHOD m2.
    ...
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  c2=>m2( NEW #( p1 = 1 p2 = 2 ) ).

Example

Uses a constructor expression with NEW in various positions. The temporary reference variable created using NEW is persisted during each statement.

CLASS c1 DEFINITION.
  PUBLIC SECTION.
    DATA     a1 TYPE i.
    METHODS: m1 RETURNING value(p) TYPE i,
             m2.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD m1.
    ...
  ENDMETHOD.
  METHOD m2.
    ...
  ENDMETHOD.
ENDCLASS.
DATA num TYPE i.
START-OF-SELECTION.
  num = NEW c1( )->a1.
  NEW c1( )->a1 = num.
  num = NEW c1( )->m1( ).
  NEW c1( )->m2( ).
  NEW c1( ).

Example

Displays a time stamp created in a constructor that only exists while the statement is being executed.

CLASS utc DEFINITION.
  PUBLIC SECTION.
    DATA ts TYPE utclong.
    METHODS constructor.
ENDCLASS.
CLASS utc IMPLEMENTATION.
  METHOD constructor.
    ts = utclong\_current( ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  cl\_demo\_output=>display\_text(
    |{ NEW utc( )->ts TIMESTAMP = ISO }| ).

Example

Constructor expression with NEW on the left side of an expression. The temporary reference variable created using NEW exists only while the statement is being executed, however the reference to the object is assigned to the reference variable oref of the class class. This persists the object.

CLASS class DEFINITION.
  PUBLIC SECTION.
    DATA attr TYPE string.
    METHODS constructor.
ENDCLASS.
DATA oref TYPE REF TO class.
CLASS class IMPLEMENTATION.
  METHOD constructor.
    oref = me.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  NEW class( )->attr = 'foo'.
  cl\_demo\_output=>display( oref->attr ).


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / VALUE - Value Operator / VALUE - Initial Value for All Types

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / VALUE - Value Operator / VALUE - Initial Value for All Types

Included pages: 2


### abenvalue_constructor_params_init.htm

---
title: "VALUE - Initial Value for All Types"
description: |
  Syntax ... VALUE dtype#( ) ... Effect If no parameters are specified in the parentheses, the return value is set to its type-specific initial value. This is possible for any non-generic data types dtype. The # character can stand for appropriate operand types known statically. When VALUE #( ) is
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_init.htm"
abapFile: "abenvalue_constructor_params_init.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "types", "internal-table", "abenvalue", "constructor", "params", "init"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [VALUE - Value Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm) → 

VALUE - Initial Value for All Types

Syntax

... VALUE dtype*|*#( ) ...

Effect

If no parameters are specified in the parentheses, the return value is set to its type-specific initial value. This is possible for any non-generic data types dtype. The # character can stand for appropriate operand types known statically. When VALUE #( ) is passed to a generically typed formal parameter, the type is also derived from the generic type of this parameter in the following cases:

-   string for csequence and clike

-   xstring for xsequence

-   decfloat34 for numeric and decfloat

-   p with the length 8 and no decimal places if p is generic

-   The [standard key](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_key_glosry.htm "Glossary Entry") for a standard table type with generic primary table key

Other generic data types (except for table types) that are explicitly generic with respect to their secondary table keys cannot be made more concrete and produce a syntax error. More specifically, this applies to the types c, n, and x with generic lengths.

Notes

-   VALUE with pass by value is used only to construct certain complex values (structures and internal tables). VALUE without pass by value, on the other hand, is a general method for creating type-dependent initial values in any operand positions.

-   Rules apply when deriving the type in cases where # is specified for actual parameters that can be passed to generically typed formal parameters. These rules prevent syntax errors in programs that call a procedure and the procedure makes the full typing of a formal parameter type more general by switching to a generic type.

-   If dtype or # stand for an [enumerated type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry"), its initial value is generated according to its [base type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbase_type_glosry.htm "Glossary Entry").

Example

Creates a suitable initial structure for a non-optional input parameter of a method.

CLASS c1 DEFINITION.
  PUBLIC SECTION.
    TYPES: BEGIN OF t\_struct,
             col1 TYPE i,
             col2 TYPE i,
           END OF t\_struct.
    CLASS-METHODS m1 IMPORTING p TYPE t\_struct.
ENDCLASS.
CLASS c1 IMPLEMENTATION.
  METHOD m1.
    ...
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  c1=>m1( VALUE #( ) ).

Executable Example

[Value Operator, Type Inference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_type_inference_abexa.htm)

Continue
![Example](exa.gif "Example") [Value Operator, Type Inference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_type_inference_abexa.htm)


### abenvalue_type_inference_abexa.htm

---
title: "Value Operator, Type Inference"
description: |
  This example demonstrates a type inference for the value operator VALUE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm). Source Code REPORT demo_value_type_inference. CLASS demo DEFINITION. PUBLIC SECTION. TYPES c10 TYPE c LENGTH 10. CLASS-METHOD
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_type_inference_abexa.htm"
abapFile: "abenvalue_type_inference_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "types", "abenvalue", "type", "inference", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [VALUE - Value Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm) →  [VALUE - Initial Value for All Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_init.htm) → 

Value Operator, Type Inference

This example demonstrates a type inference for the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm).

Source Code

REPORT demo\_value\_type\_inference.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    TYPES c10 TYPE c LENGTH 10.
    CLASS-METHODS:
      main,
      meth1 IMPORTING p TYPE c10,
      meth2 IMPORTING p TYPE c,
      meth3 IMPORTING p TYPE csequence,
      descr IMPORTING p TYPE any.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    demo=>meth1( p = VALUE #(  ) ).
    cl\_demo\_output=>line( ).
   "demo=>meth2( p = value #(  ) ). "not possible
    cl\_demo\_output=>line( ).
    demo=>meth3( p = VALUE #(  ) ) ##type.
    cl\_demo\_output=>display( ).  ENDMETHOD.
  METHOD meth1.
    descr( p ).
  ENDMETHOD.
  METHOD meth2.
    descr( p ).
  ENDMETHOD.
  METHOD meth3.
    descr( p ).
  ENDMETHOD.
  METHOD descr.
    DATA type   TYPE string.
    DATA length TYPE i.
    DESCRIBE FIELD p TYPE type.
    IF type = 'g'.
      type = 'STRING'.
      length = strlen( p ).
    ELSE.
      DESCRIBE FIELD p LENGTH length IN CHARACTER MODE.
    ENDIF.
    cl\_demo\_output=>write( |{ type } { length }| ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Passes constructor expressions with the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_init.htm) for initial values to differently typed formal parameters of methods.

-   Fully typed formal parameter

When the method meth1 is called with a fully typed formal parameter, the operand type for # is identified using this parameter and the result of the value operator is an initial field of type c with length 10.

-   Formal parameter typed generically with c

No call is possible here, since there is no inference rule for the generic type c.

-   Formal parameter typed generically with csequence

In accordance with the inference rule for csequence, the result of the value operator is an initial field of type string. This is indicated by a syntax check warning.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / VALUE - Value Operator / VALUE - Internal Tables

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / VALUE - Value Operator / VALUE - Internal Tables

Included pages: 4


### abenvalue_constructor_params_itab.htm

---
title: "VALUE - Internal Tables"
description: |
  Syntax ... VALUE dtype#( let_exp(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) BASE itab FOR for_exp1(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm) FOR for_exp2(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm"
abapFile: "abenvalue_constructor_params_itab.htm"
keywords: ["insert", "delete", "loop", "do", "if", "case", "try", "class", "data", "types", "internal-table", "field-symbol", "abenvalue", "constructor", "params", "itab"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [VALUE - Value Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm) → 

VALUE - Internal Tables

Syntax

... VALUE dtype*|*#( *\[*[let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm)*\]*
                   *\[*BASE itab*\]*
                   *\[*[FOR for\_exp1](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm)
                    [FOR for\_exp2](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm)
                    ... *\]*
                   ( [line\_spec1](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_lspc.htm) )
                   ( [line\_spec2](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_lspc.htm) )
                     ... ) ...

Extras:

[1\. ... BASE itab](#!ABAP_ADDITION_1@1@)
[2\. ... FOR for\_exp](#!ABAP_ADDITION_2@2@)

Effect

If dtype is a tabular data type or # stands for a type like this, the table rows of the constructed table are created as follows:

-   Firstly, an optional LET expression [let\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) can be specified to define local auxiliary fields whose values can be used to construct the table rows.

-   An optional start value for the content can be specified for the content of the internal table after BASE (see below).

-   One more optional consecutive [iteration expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeniteration_expression_glosry.htm "Glossary Entry") can then be specified using [FOR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm) (see below).

-   The table rows are then constructed in one or more sets of internal parentheses by specifying [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_lspc.htm). Each set of inner parentheses constructs one or more rows in accordance with the information in line\_spec and inserts them into the new internal table in accordance with the rules for the statement [INSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab.htm) ... [INTO TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab_position.htm), with one difference: Any conflicts with an existing unique primary table key raise an exception of the class CX\_SY\_ITAB\_DUPLICATE\_KEY. The object is inserted in the order of the parentheses.

The constructed rows must meet the requirements of the statement [INSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab.htm) for inserting work areas using table keys and therefore be compatible with the row type. There is one exception to this: When constructing a [standard table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_table_glosry.htm "Glossary Entry"), where the rows are only appended, the value can be shorter than the row length (for row types c and x), in which case it is padded on the right with blanks or hexadecimal 0.

If the VALUE operator is used as the source of an assignment to an internal table, this table is first initialized after the evaluation of the [LET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) expression (if available) or is assigned the content of itab. The [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_lspc.htm) data is then evaluated and inserted directly in the target table.

Notes

-   In assignments of constructor expressions to an internal table, its existing rows cannot be used directly as an argument in [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_lspc.htm). This is because this table is deleted before line\_spec is evaluated or overwritten by the content of itab. If the entire internal table or rows from the left side are needed on the right side, however, they can be saved in local helper variables using a [LET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) expression, since this expression is evaluated first.

-   The operand type for [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_lspc.htm) in the inner parentheses is the row type of the table type specified using dtype or #, which means it is always uniquely identifiable. Constructor expressions in this place can therefore always derive the required data type using #.
    

Example

Constructs an internal table with a structured row type and fills it with two rows. The structures are filled with values component by component.

TYPES: BEGIN OF t\_struct,
         col1 TYPE i,
         col2 TYPE i,
       END OF t\_struct,
       t\_itab TYPE TABLE OF t\_struct WITH EMPTY KEY.
DATA itab TYPE t\_itab.
itab = VALUE #( ( col1 = 1 col2 = 2 )
                ( col1 = 3 col2 = 4 ) ).

Example

Constructs an internal table with a tabular row type and fills it with two rows. The first row is assigned a table that is already filled. The second row is constructed using VALUE.

TYPES: t\_itab1 TYPE TABLE OF i        WITH EMPTY KEY,
       t\_itab2 TYPE TABLE OF t\_itab1 WITH EMPTY KEY.
DATA itab1 TYPE t\_itab1.
DATA itab2 TYPE t\_itab2.
itab1 = VALUE #( ( 1 ) ( 2 ) ( 3 ) ).
itab2 = VALUE #( ( itab1 )
                 ( VALUE t\_itab1( ( 4 ) ( 5 ) ( 6 ) ) ) ).

Examples

See also the examples for the instance operator [NEW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_itab.htm).

Executable Examples

-   [VALUE - Operator for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_itab_abexa.htm)

-   [VALUE Operator with LET for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_itab_let_abexa.htm)
    

Addition 1

... BASE itab

Effect

An addition, BASE, followed by an internal table, itab, can be specified in front of the lines that you want to insert. This is a [functional operand position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunctional_position_glosry.htm "Glossary Entry"). The row type of itab must be convertible to the row type of the return value. If BASE is specified, the content of itab is assigned to the return value before the individual rows are inserted. If the character # is specified for the type of the return value and the type cannot be determined from the operand position of the constructor expression, the type of itab is used for this expression (if identifiable).

Notes

-   If the addition BASE is not specified, the content of tables can only be reconstructed using the value operator and no new content can be added. If the same table is specified after BASE to which the constructor expression is assigned, further rows can be inserted in this table.

-   If the target table is specified as itab after BASE in an assignment to an existing internal table, no assignment takes place before [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_lspc.htm) is evaluated, and the target table just keeps its value instead.
    

Example

Uses BASE. The table type of base1 or base2 is applied in the construction of tab1 and tab2. This is not possible in the construction of tab3 since the row type of base2 is not structured and hence not suitable for specifying individual components in the parentheses that follow. The type itab2 is specified explicitly for tab3. This is possible since the row type of base2 can be converted into this row type. Sorted tables are constructed, which means that the rows in the results are also sorted.

TYPES:
  itab1 TYPE SORTED TABLE OF string WITH UNIQUE KEY table\_line,
  BEGIN OF struct,
    col1 TYPE c LENGTH 2,
    col2 TYPE c LENGTH 2,
    col3 TYPE c LENGTH 2,
  END OF struct,
  itab2 TYPE SORTED TABLE OF struct WITH UNIQUE KEY col1 col2 col3.
DATA(base1) = VALUE itab1(
                ( \`x1y1z1\` )
                ( \`x2y2z2\` )
                ( \`x3y3z3\` ) ).
DATA(base2) = VALUE itab2(
                ( col1 = 'x1' col2 = 'y1' col3 = 'z1' )
                ( col1 = 'x2' col2 = 'y2' col3 = 'z2' )
                ( col1 = 'x3' col2 = 'y3' col3 = 'z3' ) ).
DATA(tab1) = VALUE #( BASE base1
               ( \`A1B1B1\` )
               ( \`A2B2B2\` ) ).
DATA(tab2)  = VALUE #(
                BASE base2
                ( col1 = 'A1' col2 = 'B1' col3 = 'C1' )
                ( col1 = 'A2' col2 = 'B2' col3 = 'C2' ) ).
DATA(tab3) = VALUE itab2( BASE base1
               ( col1 = 'A1' col2 = 'B1' col3 = 'C1' )
               ( col1 = 'A2' col2 = 'B2' col3 = 'C2' ) ).
cl\_demo\_output=>write(   tab1  ).
cl\_demo\_output=>write(   tab2 ).
cl\_demo\_output=>display( tab3 ).

Example

Uses BASE to append rows to existing rows in an internal table.

TYPES itab TYPE TABLE OF string WITH EMPTY KEY.
DATA(itab) =
  VALUE itab(
    ( \`a\` ) ( \`b\` ) ( \`c\` ) ).
...
itab =
  VALUE #(
    BASE itab
    ( \`d\` ) ( \`e\` ) ( \`f\` ) ).
cl\_demo\_output=>display( itab ).

Example

Uses BASE to append rows to an internal table in a loop. After the output, it possible to see how the same function can be applied using an iteration expression with [FOR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor_conditional.htm).

DATA itab TYPE TABLE OF i WITH EMPTY KEY.
DO 10 TIMES.
  itab = VALUE #( BASE itab ( ipow( base = sy-index exp = 2 ) ) ).
ENDDO.
cl\_demo\_output=>display( itab ).
DATA jtab LIKE itab.
jtab = VALUE #( FOR j = 1 UNTIL j > 10
                ( ipow( base = j exp = 2 ) ) ).
ASSERT jtab = itab.

Addition 2

... FOR for\_exp

Effect

If one or more [iteration expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeniteration_expression_glosry.htm "Glossary Entry") are specified consecutively using [FOR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor.htm), this means that the rows constructed in [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_lspc.htm) for every iteration of the last FOR expression are inserted into the target table. When constructing table rows in [line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_lspc.htm), the visible local work areas and field symbols of the iteration expressions can be used to construct table rows.

-   If [conditional iterations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor_conditional.htm) are used, the new table rows are created in freely defined iteration steps.

-   If [table iterations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor_itab.htm) are used, the rows of existing internal tables are evaluated. These are known as [table comprehensions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_comprehension_glosry.htm "Glossary Entry"), since in this case new table rows can be constructed from the rows of existing internal tables.

Notes

-   The term "table comprehension" is derived from similar concepts used in many other languages, where it is also known as "list comprehension".

-   [Table filtering](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_filtering_glosry.htm "Glossary Entry") can be implemented more efficiently using the [filter operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfilter_operator_glosry.htm "Glossary Entry") [FILTER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_filter.htm).

-   Conditional iterations and table comprehensions are also possible with [FOR expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmesh_for.htm) for [mesh paths](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmesh_path_glosry.htm "Glossary Entry").

-   For tasks that can be solved using both table comprehensions and [special assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding.htm) for components (in particular the component operator [CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expr_corresponding.htm)), it is best to use assignments (see the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_vs_for_abexa.htm)).

-   If the VALUE operator is used, it should be noted that assignments to internal tables are also initialized (or given the content of itab after BASE) even in the case of table comprehensions after the evaluation of a [LET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) expressions. The target table is then used directly. The original table can therefore not be used directly in the FOR expressions (unless it is assigned to a helper variable after LET).

Example

Constructs a temporary internal table with an elementary row type and fills it with square numbers using an iteration expression.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
cl\_demo\_output=>display(
  VALUE t\_itab( FOR i = 1 UNTIL i > 10
                ( ipow( base = i exp = 2 ) ) ) ).

Executable Examples

-   [Examples of Table Comprehensions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_comprehensions_abexas.htm)

Continue
[VALUE - line\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_lspc.htm)
![Example](exa.gif "Example") [VALUE - Operator for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_itab_abexa.htm)
![Example](exa.gif "Example") [VALUE - Operator with LET for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_itab_let_abexa.htm)


### abenvalue_constructor_params_lspc.htm

---
title: "Syntax"
description: |
  ... line  LINES OF itab FROM idx1 TO idx2 USING KEY keyname ... Alternatives: 1. ... line(#!ABAP_ALTERNATIVE_1@1@) 2. ... LINES OF jtab FROM idx1 TO idx2 USING KEY keyname(#!ABAP_ALTERNATIVE_2@2@) Effect Specifies one or more rows to be
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_lspc.htm"
abapFile: "abenvalue_constructor_params_lspc.htm"
keywords: ["insert", "delete", "do", "while", "if", "try", "method", "data", "types", "internal-table", "abenvalue", "constructor", "params", "lspc"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [VALUE - Value Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm) →  [VALUE - Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm) → 

VALUE - line\_spec

Syntax

... line
  *|* *{*LINES OF itab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]**}* ...

Alternatives:

[1\. ... line](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LINES OF jtab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]*](#!ABAP_ALTERNATIVE_2@2@)

Effect

Specifies one or more rows to be inserted when constructing an internal table with the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm).

Note

If rows from the target table or the entire target table are used in line\_spec in an assignment of a constructor expression using the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm) to an internal table, these rows are deleted or overwritten by a start value before both variants of line\_spec are evaluated. The target table must therefore be saved in an auxiliary variable first. A [LET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm) expression can be used to do this.

Alternative 1

... line

Effect

Specifies a row. line can be specified in exactly the same way as in the parentheses of an expression [NEW line\_type( ... )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm). Here, line\_type is the row type of the internal table and a corresponding row is constructed. The following special features apply here:

-   If a data object is specified for line, this object must be compatible with the row type.

-   If an expression (built-in function, functional method, calculation expression, constructor expression, or table expression) is specified for line, the result of the expression must be convertible to the row type.

-   The syntax does not permit further parentheses for constructing tabular row types to be nested directly in line.

Short Form for Structured Row Types

If the row type of the internal table is a structured type, the following short form can be used:

VALUE dtype*|*#( *\[*let\_exp*\]*
               *\[*BASE itab*\]*
               col1 = dobj11 ... ( col2 = dobj12 col3 = dobj13 ... )
                                 ( col2 = dobj22 col3 = dobj23 ... )
                                 ...
               col1 = dobj31 col2 = dobj32 ... ( col3 = dobj33 ... )
                                               ( col3 = dobj43 ... )
               ... ).

This has the same semantics as the following:

VALUE dtype*|*#( *\[*let\_exp*\]*
               *\[*BASE itab*\]*
               ( col1 = dobj11 ... col2 = dobj12 col3 = dobj13 ... )
               ( col1 = dobj11 ... col2 = dobj22 col3 = dobj23 ... )
               ...
               ( col1 = dobj31 col2 = dobj32 ... col3 = dobj33 ... )
               ( col1 = dobj31 col2 = dobj32 ... col3 = dobj43 ... )
               ... ).

Values can be assigned to individual structure components outside of the inner parentheses. An assignment of this type applies to all following inner parentheses until the next assignment is made to the component in question. Assignments outside of the inner parentheses must be followed by at least one inner parenthesis. A component cannot be assigned a value more than once in the [construction of a structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennew_constructor_params_struct.htm), which means that a component assigned a value outside of the inner parentheses can no longer be specified in an inner parenthesis. A component can be specified again outside the inner parentheses and any components previously specified in an inner parenthesis can also be listed outside the parenthesis.

Notes

-   The restriction that the content of tabular row types cannot be constructed directly in line applies for reasons of legibility (for humans and for machines) and is not a functional restriction. The expression [VALUE line\_type( ... )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm) can be specified for line to construct the content of a tabular row, where line\_type is the tabular row type.

-   Specifying [CONV line\_type( ... )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_conv.htm) for the inserted values is also a way of meeting the compatibility requirements made by the row type.

-   The short form for structured row types enables columns of internal tables that are to be given an identical value in blocks to be filled more easily.

-   As in VALUE, the table rows are constructed in accordance with the rules for the instance operator [NEW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_new.htm), since new table rows are created here too and the restriction for VALUE dictating that no values of elementary data objects can be constructed cannot be applied.
    

Example

Constructs a [ranges table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenranges_table_glosry.htm "Glossary Entry") and fills it with four rows while using the short form for structured row types.

DATA itab TYPE RANGE OF i.
itab = VALUE #( sign = 'I'  option = 'BT' ( low = 1  high = 10 )
                                          ( low = 21 high = 30 )
                                          ( low = 41 high = 50 )
                            option = 'GE' ( low = 61 )  ).

Alternative 2

... LINES OF jtab *\[*FROM idx1*\]* *\[*TO idx2*\]* *\[*USING KEY keyname*\]*

Effect

Specifies multiple rows. The rows are taken from the internal table jtab and inserted into the target table as a block. The same applies to jtab and the additions FROM, TO, and USING KEY as to the addition [LINES OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab_linespec.htm) of the statement [INSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab.htm) and the block is inserted in accordance with these rules. jtab is a [functional operand position](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunctional_position_glosry.htm "Glossary Entry").

Notes

-   The rows from jtab are inserted into the target table using the table key only, which means that jtab must be compatible with the target type.

-   If there is a conflict with an existing unique table key, a non-handleable exception is always raised when inserting multiple rows from an internal table using the statement [INSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinsert_itab.htm).

-   When standard tables are created, the rows of the table jtab are appended to the target table in the same way as with the statement [APPEND LINES OF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapappend_linespec.htm).
    

Example

Constructs an internal table with an elementary row type. jtab is filled with three rows and itab with six rows. The first row inserted in itab is initial and the last three rows are taken from the table jtab filled previously.

TYPES t\_itab TYPE TABLE OF i WITH EMPTY KEY.
DATA(jtab) = VALUE t\_itab( ( 10 ) ( 20 ) ( 30 ) ).
DATA(itab) = VALUE t\_itab( ( ) ( 1 ) ( 2 ) ( LINES OF jtab ) ).
cl\_demo\_output=>display( itab ).


### abenvalue_itab_abexa.htm

---
title: "VALUE - Operator for Internal Tables"
description: |
  This example demonstrates the value operator VALUE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm) for internal tables. Source Code REPORT demo_value_constructor_itab. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS de
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_itab_abexa.htm"
abapFile: "abenvalue_itab_abexa.htm"
keywords: ["select", "insert", "do", "if", "method", "class", "data", "types", "internal-table", "abenvalue", "itab", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [VALUE - Value Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm) →  [VALUE - Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm) → 

VALUE - Operator for Internal Tables

This example demonstrates the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm) for internal tables.

Source Code

REPORT demo\_value\_constructor\_itab.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES itab TYPE STANDARD TABLE OF i WITH EMPTY KEY.
    DATA(itab) = VALUE itab( ( 1 ) ( 2 ) ( 3 ) ).
    DATA(itab1) = itab.
    itab1 = VALUE #(  BASE itab1
                     ( 4 )
                     ( 5 ) ).
    cl\_demo\_output=>write( itab1 ).
    DATA(itab2) = itab.
    itab2 = VALUE #( ( LINES OF itab2 )
                      ( 4 )
                      ( 5 ) ).
    cl\_demo\_output=>write( itab2 ).
    DATA(itab3) = itab.
    itab3 = VALUE #( BASE itab3
                     ( LINES OF itab3 )
                     ( 4 )
                     ( 5 ) ).
    cl\_demo\_output=>write( itab3 ).
    DATA(itab4) = itab.
    itab4 = VALUE #( LET x = itab4 IN
                     ( LINES OF x )
                     ( 4 )
                     ( 5 ) ).
    cl\_demo\_output=>write( itab4 ).
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The example shows various effects when using the left side of an assignment in specified rows of the operator VALUE in the construction of internal tables.

-   In the construction of itab1, the left side is used after BASE. Here, the original three rows are passed as a start value before the specified rows are evaluated. Two single rows are then appended to this start value.

-   In the construction of itab2, the left side is initialized before the specified rows are evaluated. This is why no rows are inserted by LINES OF itab2 and the table contains only two single rows.

-   In the construction of itab3, the left side is given its original three rows as a start row using BASE. These rows are then appended again using LINES OF, before the two single rows are appended.

-   In the construction of itab4, the left side is saved in the helper variable x before it is initialized. It is then used in LINES OF. The result is the same as when the left side is used after BASE.


### abenvalue_itab_let_abexa.htm

---
title: "VALUE - Operator with LET for Internal Tables"
description: |
  This example demonstrates the value operator VALUE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm) for internal tables with a LET expression(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm). Source Code REPORT demo_value_
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_itab_let_abexa.htm"
abapFile: "abenvalue_itab_let_abexa.htm"
keywords: ["select", "do", "method", "class", "types", "internal-table", "abenvalue", "itab", "let", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [VALUE - Value Operator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_value.htm) →  [VALUE - Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm) → 

VALUE - Operator with LET for Internal Tables

This example demonstrates the value operator [VALUE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_itab.htm) for internal tables with a [LET expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm).

Source Code

REPORT demo\_value\_constr\_itab\_let.
CLASS date DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS get RETURNING VALUE(d) TYPE d.
ENDCLASS.
CLASS date IMPLEMENTATION.
  METHOD get.
    d = sy-datlo.
  ENDMETHOD.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES t\_date\_tab TYPE TABLE OF string  WITH EMPTY KEY.
    cl\_demo\_output=>display(
      VALUE t\_date\_tab(
        LET d = date=>get( ) IN
        ( |{ CONV d( d - 1 ) DATE = ENVIRONMENT }| )
        ( |{         d       DATE = ENVIRONMENT }| )
        ( |{ CONV d( d + 1 ) DATE = ENVIRONMENT }| ) ) ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Constructs an internal table with an elementary row type with type string and fills it with three rows. The result is a table that is given the previous day, today, and the next day (all formatted for the current language environment). Today's date is produced using a method. To make sure that the method is called only once, the return value is assigned to a local helper field in a [LET expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaplet.htm).


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Areas

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Classes and Interfaces / Shared Objects - IF_SHM_BUILD_INSTANCE

Included pages: 2


### abenshm_if_shm_build_instance.htm

---
title: "Static Methods"
description: |
  BUILD Interface method for implementing the area constructor of an area. input parameter -   INST_NAME of type SHM_INST_NAME Name of the area instance version. Entering a name is optional. The default value is the value of constant CL_SHM_AREA=>DEFAULT_INSTANCE. -   INVOCATION_MODE of type i
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm"
abapFile: "abenshm_if_shm_build_instance.htm"
keywords: ["do", "while", "if", "method", "class", "abenshm", "shm", "build", "instance"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [Shared Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_shared_objects.htm) →  [Shared Objects - Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_classes.htm) → 

Shared Objects - IF\_SHM\_BUILD\_INSTANCE

Interface IF\_SHM\_BUILD\_INSTANCE must be included by an [area constructor class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm) that implements an area's optional area constructor.

Static Methods

BUILD

Interface method for implementing the area constructor of an area.

input parameter

-   INST\_NAME of type SHM\_INST\_NAME

Name of the area instance version. Entering a name is optional. The default value is the value of constant CL\_SHM\_AREA=>DEFAULT\_INSTANCE.

-   INVOCATION\_MODE of type i

This parameter can be used to determine the type of call in the area constructor. The default value CL\_SHM\_AREA=>INVOCATION\_MODE\_EXPLICIT is used for the explicit call. CL\_SHM\_AREA=>INVOCATION\_MODE\_AUTO\_BUILD is passed with the automatic call.

Exceptions

-   CX\_SHM\_BUILD\_FAILED

An error has occurred while executing the area constructor.

Note

The BUILD method does not have an input parameter for the client identifier. The area is built in the current client when the method is called.

Continue
[Shared Objects - Area Constructor Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm)


### abenshm_area_constructor_class.htm

---
title: "Shared Objects - Area Constructor Class"
description: |
  An area constructor class is a global class with a freely definable name that implements the interface IF_SHM_BUILD_INSTANCE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm). An area constructor can be implemented in the interface method BUILD. An ar
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm"
abapFile: "abenshm_area_constructor_class.htm"
keywords: ["do", "if", "case", "try", "catch", "method", "class", "data", "types", "abenshm", "area", "constructor"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [Shared Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_shared_objects.htm) →  [Shared Objects - Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_classes.htm) →  [Shared Objects - IF\_SHM\_BUILD\_INSTANCE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm) → 

Shared Objects - Area Constructor Class

An area constructor class is a global class with a freely definable name that implements the interface [IF\_SHM\_BUILD\_INSTANCE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm). An area constructor can be implemented in the interface method BUILD.

An area constructor class can be [assigned](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_dynamic_properties.htm) to an [area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_areas.htm) in transaction SHMA. This is always necessary if the area is built automatically by calling the area constructor, that is if the components BUILD\_KIND and REFRESH\_TIME of the structure PROPERTIES of the class [CL\_SHM\_AREA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_shm_area.htm) are filled accordingly. If an area is not built automatically, an area constructor class can be specified for the explicit area constructor call using the method BUILD of the [area class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_class.htm).

Structure of an Area Constructor

The following structure is recommended for the area constructor implemented in the interface method BUILD:

1.  First, the area constructor has to use the method ATTACH\_FOR\_WRITE to create an area handle with an exclusive lock for the area instance passed in the parameter INST\_NAME. The automatic area constructor is also not able to ensure that the exclusive lock can be set, which means that all exceptions have to be caught and forwarded to the caller of the constructor by raising the interface exception CX\_SHM\_BUILD\_FAILED. This should pass the original exception to the parameter PREVIOUS of the constructor of CX\_SHM\_BUILD\_FAILED.
    
2.  As is the case whenever a new area instance version is created, a root object also has to be defined in the area constructor using the method SET\_ROOT.
    
3.  The area instance version can then be built, which means that objects are stored in the shared memory.
    
4.  The new area handle has to be released again using the method DETACH\_COMMIT. If an exception is raised, it is usually caused by a programming error and should not be handled in the area constructor.
    
5.  If the area constructor was called automatically, a database commit has to be triggered when a transactional area is built.

In an area constructor, no statements can be used that exit the current [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry") (such as SUBMIT, CALL TRANSACTION, CALL SCREEN, MESSAGE for message types "W", "I", "E", and so on).

Example

The following implementation can be used as a template for new implementations.

CLASS area\_constructor IMPLEMENTATION.
  METHOD if\_shm\_build\_instance~build.
    DATA:
      my\_handle TYPE REF TO area,
      my\_data   TYPE REF TO area\_root\_class,
      my\_except TYPE REF TO cx\_root.
    TRY.
        my\_handle = cl\_my\_area=>attach\_for\_write( inst\_name ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    CREATE OBJECT my\_data AREA HANDLE my\_handle.
    my\_handle->set\_root( my\_data ).
    ... " code to build the area instance
    my\_handle->detach\_commit( ).
    IF invocation\_mode = cl\_shm\_area=>invocation\_mode\_auto\_build.
      COMMIT CONNECTION default.
    ENDIF.
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Area Instance Versions

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Classes and Interfaces / Shared Objects - IF_SHM_BUILD_INSTANCE

Included pages: 2


### abenshm_if_shm_build_instance.htm

---
title: "Static Methods"
description: |
  BUILD Interface method for implementing the area constructor of an area. input parameter -   INST_NAME of type SHM_INST_NAME Name of the area instance version. Entering a name is optional. The default value is the value of constant CL_SHM_AREA=>DEFAULT_INSTANCE. -   INVOCATION_MODE of type i
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm"
abapFile: "abenshm_if_shm_build_instance.htm"
keywords: ["do", "while", "if", "method", "class", "abenshm", "shm", "build", "instance"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [Shared Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_shared_objects.htm) →  [Shared Objects - Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_classes.htm) → 

Shared Objects - IF\_SHM\_BUILD\_INSTANCE

Interface IF\_SHM\_BUILD\_INSTANCE must be included by an [area constructor class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm) that implements an area's optional area constructor.

Static Methods

BUILD

Interface method for implementing the area constructor of an area.

input parameter

-   INST\_NAME of type SHM\_INST\_NAME

Name of the area instance version. Entering a name is optional. The default value is the value of constant CL\_SHM\_AREA=>DEFAULT\_INSTANCE.

-   INVOCATION\_MODE of type i

This parameter can be used to determine the type of call in the area constructor. The default value CL\_SHM\_AREA=>INVOCATION\_MODE\_EXPLICIT is used for the explicit call. CL\_SHM\_AREA=>INVOCATION\_MODE\_AUTO\_BUILD is passed with the automatic call.

Exceptions

-   CX\_SHM\_BUILD\_FAILED

An error has occurred while executing the area constructor.

Note

The BUILD method does not have an input parameter for the client identifier. The area is built in the current client when the method is called.

Continue
[Shared Objects - Area Constructor Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm)


### abenshm_area_constructor_class.htm

---
title: "Shared Objects - Area Constructor Class"
description: |
  An area constructor class is a global class with a freely definable name that implements the interface IF_SHM_BUILD_INSTANCE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm). An area constructor can be implemented in the interface method BUILD. An ar
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm"
abapFile: "abenshm_area_constructor_class.htm"
keywords: ["do", "if", "case", "try", "catch", "method", "class", "data", "types", "abenshm", "area", "constructor"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [Shared Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_shared_objects.htm) →  [Shared Objects - Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_classes.htm) →  [Shared Objects - IF\_SHM\_BUILD\_INSTANCE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm) → 

Shared Objects - Area Constructor Class

An area constructor class is a global class with a freely definable name that implements the interface [IF\_SHM\_BUILD\_INSTANCE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm). An area constructor can be implemented in the interface method BUILD.

An area constructor class can be [assigned](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_dynamic_properties.htm) to an [area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_areas.htm) in transaction SHMA. This is always necessary if the area is built automatically by calling the area constructor, that is if the components BUILD\_KIND and REFRESH\_TIME of the structure PROPERTIES of the class [CL\_SHM\_AREA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_shm_area.htm) are filled accordingly. If an area is not built automatically, an area constructor class can be specified for the explicit area constructor call using the method BUILD of the [area class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_class.htm).

Structure of an Area Constructor

The following structure is recommended for the area constructor implemented in the interface method BUILD:

1.  First, the area constructor has to use the method ATTACH\_FOR\_WRITE to create an area handle with an exclusive lock for the area instance passed in the parameter INST\_NAME. The automatic area constructor is also not able to ensure that the exclusive lock can be set, which means that all exceptions have to be caught and forwarded to the caller of the constructor by raising the interface exception CX\_SHM\_BUILD\_FAILED. This should pass the original exception to the parameter PREVIOUS of the constructor of CX\_SHM\_BUILD\_FAILED.
    
2.  As is the case whenever a new area instance version is created, a root object also has to be defined in the area constructor using the method SET\_ROOT.
    
3.  The area instance version can then be built, which means that objects are stored in the shared memory.
    
4.  The new area handle has to be released again using the method DETACH\_COMMIT. If an exception is raised, it is usually caused by a programming error and should not be handled in the area constructor.
    
5.  If the area constructor was called automatically, a database commit has to be triggered when a transactional area is built.

In an area constructor, no statements can be used that exit the current [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry") (such as SUBMIT, CALL TRANSACTION, CALL SCREEN, MESSAGE for message types "W", "I", "E", and so on).

Example

The following implementation can be used as a template for new implementations.

CLASS area\_constructor IMPLEMENTATION.
  METHOD if\_shm\_build\_instance~build.
    DATA:
      my\_handle TYPE REF TO area,
      my\_data   TYPE REF TO area\_root\_class,
      my\_except TYPE REF TO cx\_root.
    TRY.
        my\_handle = cl\_my\_area=>attach\_for\_write( inst\_name ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    CREATE OBJECT my\_data AREA HANDLE my\_handle.
    my\_handle->set\_root( my\_data ).
    ... " code to build the area instance
    my\_handle->detach\_commit( ).
    IF invocation\_mode = cl\_shm\_area=>invocation\_mode\_auto\_build.
      COMMIT CONNECTION default.
    ENDIF.
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Objects

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Classes and Interfaces / Shared Objects - IF_SHM_BUILD_INSTANCE

Included pages: 2


### abenshm_if_shm_build_instance.htm

---
title: "Static Methods"
description: |
  BUILD Interface method for implementing the area constructor of an area. input parameter -   INST_NAME of type SHM_INST_NAME Name of the area instance version. Entering a name is optional. The default value is the value of constant CL_SHM_AREA=>DEFAULT_INSTANCE. -   INVOCATION_MODE of type i
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm"
abapFile: "abenshm_if_shm_build_instance.htm"
keywords: ["do", "while", "if", "method", "class", "abenshm", "shm", "build", "instance"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [Shared Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_shared_objects.htm) →  [Shared Objects - Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_classes.htm) → 

Shared Objects - IF\_SHM\_BUILD\_INSTANCE

Interface IF\_SHM\_BUILD\_INSTANCE must be included by an [area constructor class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm) that implements an area's optional area constructor.

Static Methods

BUILD

Interface method for implementing the area constructor of an area.

input parameter

-   INST\_NAME of type SHM\_INST\_NAME

Name of the area instance version. Entering a name is optional. The default value is the value of constant CL\_SHM\_AREA=>DEFAULT\_INSTANCE.

-   INVOCATION\_MODE of type i

This parameter can be used to determine the type of call in the area constructor. The default value CL\_SHM\_AREA=>INVOCATION\_MODE\_EXPLICIT is used for the explicit call. CL\_SHM\_AREA=>INVOCATION\_MODE\_AUTO\_BUILD is passed with the automatic call.

Exceptions

-   CX\_SHM\_BUILD\_FAILED

An error has occurred while executing the area constructor.

Note

The BUILD method does not have an input parameter for the client identifier. The area is built in the current client when the method is called.

Continue
[Shared Objects - Area Constructor Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm)


### abenshm_area_constructor_class.htm

---
title: "Shared Objects - Area Constructor Class"
description: |
  An area constructor class is a global class with a freely definable name that implements the interface IF_SHM_BUILD_INSTANCE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm). An area constructor can be implemented in the interface method BUILD. An ar
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm"
abapFile: "abenshm_area_constructor_class.htm"
keywords: ["do", "if", "case", "try", "catch", "method", "class", "data", "types", "abenshm", "area", "constructor"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [Shared Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_shared_objects.htm) →  [Shared Objects - Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_classes.htm) →  [Shared Objects - IF\_SHM\_BUILD\_INSTANCE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm) → 

Shared Objects - Area Constructor Class

An area constructor class is a global class with a freely definable name that implements the interface [IF\_SHM\_BUILD\_INSTANCE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm). An area constructor can be implemented in the interface method BUILD.

An area constructor class can be [assigned](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_dynamic_properties.htm) to an [area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_areas.htm) in transaction SHMA. This is always necessary if the area is built automatically by calling the area constructor, that is if the components BUILD\_KIND and REFRESH\_TIME of the structure PROPERTIES of the class [CL\_SHM\_AREA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_shm_area.htm) are filled accordingly. If an area is not built automatically, an area constructor class can be specified for the explicit area constructor call using the method BUILD of the [area class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_class.htm).

Structure of an Area Constructor

The following structure is recommended for the area constructor implemented in the interface method BUILD:

1.  First, the area constructor has to use the method ATTACH\_FOR\_WRITE to create an area handle with an exclusive lock for the area instance passed in the parameter INST\_NAME. The automatic area constructor is also not able to ensure that the exclusive lock can be set, which means that all exceptions have to be caught and forwarded to the caller of the constructor by raising the interface exception CX\_SHM\_BUILD\_FAILED. This should pass the original exception to the parameter PREVIOUS of the constructor of CX\_SHM\_BUILD\_FAILED.
    
2.  As is the case whenever a new area instance version is created, a root object also has to be defined in the area constructor using the method SET\_ROOT.
    
3.  The area instance version can then be built, which means that objects are stored in the shared memory.
    
4.  The new area handle has to be released again using the method DETACH\_COMMIT. If an exception is raised, it is usually caused by a programming error and should not be handled in the area constructor.
    
5.  If the area constructor was called automatically, a database commit has to be triggered when a transactional area is built.

In an area constructor, no statements can be used that exit the current [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry") (such as SUBMIT, CALL TRANSACTION, CALL SCREEN, MESSAGE for message types "W", "I", "E", and so on).

Example

The following implementation can be used as a template for new implementations.

CLASS area\_constructor IMPLEMENTATION.
  METHOD if\_shm\_build\_instance~build.
    DATA:
      my\_handle TYPE REF TO area,
      my\_data   TYPE REF TO area\_root\_class,
      my\_except TYPE REF TO cx\_root.
    TRY.
        my\_handle = cl\_my\_area=>attach\_for\_write( inst\_name ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    CREATE OBJECT my\_data AREA HANDLE my\_handle.
    my\_handle->set\_root( my\_data ).
    ... " code to build the area instance
    my\_handle->detach\_commit( ).
    IF invocation\_mode = cl\_shm\_area=>invocation\_mode\_auto\_build.
      COMMIT CONNECTION default.
    ENDIF.
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Classes and Interfaces / Shared Objects - IF_SHM_BUILD_INSTANCE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Shared Objects / Shared Objects - Classes and Interfaces / Shared Objects - IF_SHM_BUILD_INSTANCE

Included pages: 2


### abenshm_if_shm_build_instance.htm

---
title: "Static Methods"
description: |
  BUILD Interface method for implementing the area constructor of an area. input parameter -   INST_NAME of type SHM_INST_NAME Name of the area instance version. Entering a name is optional. The default value is the value of constant CL_SHM_AREA=>DEFAULT_INSTANCE. -   INVOCATION_MODE of type i
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm"
abapFile: "abenshm_if_shm_build_instance.htm"
keywords: ["do", "while", "if", "method", "class", "abenshm", "shm", "build", "instance"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [Shared Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_shared_objects.htm) →  [Shared Objects - Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_classes.htm) → 

Shared Objects - IF\_SHM\_BUILD\_INSTANCE

Interface IF\_SHM\_BUILD\_INSTANCE must be included by an [area constructor class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm) that implements an area's optional area constructor.

Static Methods

BUILD

Interface method for implementing the area constructor of an area.

input parameter

-   INST\_NAME of type SHM\_INST\_NAME

Name of the area instance version. Entering a name is optional. The default value is the value of constant CL\_SHM\_AREA=>DEFAULT\_INSTANCE.

-   INVOCATION\_MODE of type i

This parameter can be used to determine the type of call in the area constructor. The default value CL\_SHM\_AREA=>INVOCATION\_MODE\_EXPLICIT is used for the explicit call. CL\_SHM\_AREA=>INVOCATION\_MODE\_AUTO\_BUILD is passed with the automatic call.

Exceptions

-   CX\_SHM\_BUILD\_FAILED

An error has occurred while executing the area constructor.

Note

The BUILD method does not have an input parameter for the client identifier. The area is built in the current client when the method is called.

Continue
[Shared Objects - Area Constructor Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm)


### abenshm_area_constructor_class.htm

---
title: "Shared Objects - Area Constructor Class"
description: |
  An area constructor class is a global class with a freely definable name that implements the interface IF_SHM_BUILD_INSTANCE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm). An area constructor can be implemented in the interface method BUILD. An ar
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_constructor_class.htm"
abapFile: "abenshm_area_constructor_class.htm"
keywords: ["do", "if", "case", "try", "catch", "method", "class", "data", "types", "abenshm", "area", "constructor"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [Shared Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_shared_objects.htm) →  [Shared Objects - Classes and Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_classes.htm) →  [Shared Objects - IF\_SHM\_BUILD\_INSTANCE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm) → 

Shared Objects - Area Constructor Class

An area constructor class is a global class with a freely definable name that implements the interface [IF\_SHM\_BUILD\_INSTANCE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_if_shm_build_instance.htm). An area constructor can be implemented in the interface method BUILD.

An area constructor class can be [assigned](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_dynamic_properties.htm) to an [area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_areas.htm) in transaction SHMA. This is always necessary if the area is built automatically by calling the area constructor, that is if the components BUILD\_KIND and REFRESH\_TIME of the structure PROPERTIES of the class [CL\_SHM\_AREA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_cl_shm_area.htm) are filled accordingly. If an area is not built automatically, an area constructor class can be specified for the explicit area constructor call using the method BUILD of the [area class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshm_area_class.htm).

Structure of an Area Constructor

The following structure is recommended for the area constructor implemented in the interface method BUILD:

1.  First, the area constructor has to use the method ATTACH\_FOR\_WRITE to create an area handle with an exclusive lock for the area instance passed in the parameter INST\_NAME. The automatic area constructor is also not able to ensure that the exclusive lock can be set, which means that all exceptions have to be caught and forwarded to the caller of the constructor by raising the interface exception CX\_SHM\_BUILD\_FAILED. This should pass the original exception to the parameter PREVIOUS of the constructor of CX\_SHM\_BUILD\_FAILED.
    
2.  As is the case whenever a new area instance version is created, a root object also has to be defined in the area constructor using the method SET\_ROOT.
    
3.  The area instance version can then be built, which means that objects are stored in the shared memory.
    
4.  The new area handle has to be released again using the method DETACH\_COMMIT. If an exception is raised, it is usually caused by a programming error and should not be handled in the area constructor.
    
5.  If the area constructor was called automatically, a database commit has to be triggered when a transactional area is built.

In an area constructor, no statements can be used that exit the current [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry") (such as SUBMIT, CALL TRANSACTION, CALL SCREEN, MESSAGE for message types "W", "I", "E", and so on).

Example

The following implementation can be used as a template for new implementations.

CLASS area\_constructor IMPLEMENTATION.
  METHOD if\_shm\_build\_instance~build.
    DATA:
      my\_handle TYPE REF TO area,
      my\_data   TYPE REF TO area\_root\_class,
      my\_except TYPE REF TO cx\_root.
    TRY.
        my\_handle = cl\_my\_area=>attach\_for\_write( inst\_name ).
      CATCH cx\_shm\_error INTO my\_except.
        RAISE EXCEPTION TYPE cx\_shm\_build\_failed
                        EXPORTING previous = my\_except.
    ENDTRY.
    CREATE OBJECT my\_data AREA HANDLE my\_handle.
    my\_handle->set\_root( my\_data ).
    ... " code to build the area instance
    my\_handle->detach\_commit( ).
    IF invocation\_mode = cl\_shm\_area=>invocation\_mode\_auto\_build.
      COMMIT CONNECTION default.
    ENDIF.
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Parameters in the User Memory

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Creating Objects and Values / Parameters in the User Memory

Included pages: 3


### abenmemory.htm

---
title: "Parameters in the User Memory"
description: |
  -   SPA/GPA Parameters(#abenmemory-1--------spa-gpa-parameters-and-abap-programs---@ITOC@@ABENMEMORY_2) -   Managing SPA/GPA Parameters(#abenmemory-3--------spa-gpa-parameters-and-dynpro-fields---@ITOC@@ABENMEMORY_4) SPA/GPA Parameters The user memory(https://help.sap.com/doc/abapdocu_754_inde
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmemory.htm"
abapFile: "abenmemory.htm"
keywords: ["select", "do", "while", "if", "case", "try", "data", "abenmemory"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) → 

Parameters in the User Memory

-   [SPA/GPA Parameters](#abenmemory-1--------spa-gpa-parameters-and-abap-programs---@ITOC@@ABENMEMORY_2)

-   [Managing SPA/GPA Parameters](#abenmemory-3--------spa-gpa-parameters-and-dynpro-fields---@ITOC@@ABENMEMORY_4)

SPA/GPA Parameters

The [user memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenuser_memory_glosry.htm "Glossary Entry") is a user-specific [memory area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmemory_organization.htm) of the current [AS Instance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry"), which is accessed by all [ABAP sessions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmain_session_glosry.htm "Glossary Entry") of a user session at once. ABAP programs have access to SPA/GPA parameters stored in the user memory (also called SET/GET parameters).

Each SPA/GPA parameter is identified by an ID of up to 20 characters. SPA/GPA parameters can either be created explicitly using the statement [SET PARAMETER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_parameter.htm), or implicitly in a [PAI](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpai_glosry.htm "Glossary Entry") event. Once they have been saved in the user memory, they are available to any programs and any sessions throughout the whole duration of a user session. SPA/GPA parameters are usually evaluated by the ABAP runtime environment. In ABAP programs, the parameters can be read using the statement [GET PARAMETER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_parameter.htm).

Example

One example of a program that uses SPA/GPA parameters is user maintenance (transaction SU01). In this transaction, user-specific parameters can be entered on the Parameters tab page, which are then set when the user logs on to [AS ABAP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_nw_abap_glosry.htm "Glossary Entry"), and are evaluated by other programs.

SPA/GPA Parameters and ABAP Programs

The statements [SET PARAMETER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_parameter.htm) and [GET PARAMETER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_parameter.htm) of a program do not directly access the SPA/GPA parameters of the user memory.

-   Instead, as soon as an ABAP program is rolled in to the memory, all SPA/GPA parameters in the user memory are copied to the [program memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenroll_area_glosry.htm "Glossary Entry") of the program. The statements [SET PARAMETER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_parameter.htm) and [GET PARAMETER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_parameter.htm) of a program work with the local SPA/GPA parameters of the program memory.

-   As soon as a program is rolled out of the memory, all local SPA/GPA parameters are copied to the cross-session SAP memory, where they replace all SPA/GPA parameters. Any SPA/GPA parameters that do not exist in the program memory do not exist in the user memory afterwards. A roll out is performed for various reasons, such as:

-   When exiting a program.

-   When calling a new program using [SUBMIT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapsubmit.htm), [CALL TRANSACTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transaction.htm), or [LEAVE TO TRANSACTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapleave_to_transaction.htm).

-   During any work process change A work process is changed in the same situations that cause implicit [database commits](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendb_commit.htm).

-   In the statement [COMMIT WORK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommit.htm).

Note

ABAP programs cannot access the user memory directly. Instead, all SPA/GPA parameters have to be imported or exported implicitly at given times, just like a file. This has consequences for programs run in parallel sessions of the same user:

-   If a program sets a SPA/GPA parameter using [SET PARAMETER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_parameter.htm), a program in a parallel ABAP session cannot be started until the setter program has been rolled out if it needs to access the modified parameter.

-   If a program sets a SPA/GPA parameter using [SET PARAMETER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_parameter.htm) while another program in a parallel ABAP session is active, and the latter has been running longer than the setting program, these changes are overwritten when the program that has been running longer is rolled out.

Premature rollouts can be forced by statements such as [WAIT UP TO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_up_to.htm), but the fact that the state of the user memory is always determined by the program that was last rolled out creates a serious obstacle for cross-session use of SPA/GPA parameters in programs that are running in parallel. This type of programming is therefore not recommended.

Managing SPA/GPA Parameters

The names of SPA/GPA parameters are managed in the database table TPARA. In [Object Navigator](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobject_navigator_glosry.htm "Glossary Entry") in [ABAP Workbench](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_workbench_glosry.htm "Glossary Entry"), the names of SPA/GPA parameters are created (in uppercase) in the database table TPARA and are associated with packages. The database table TPARA acts as a reservation table for SPA/GPA parameters. If SPA/GPA parameters are used in a program, the name of the parameter must be contained in the PARAMID column in the database table TPARA. Care must be taken to not overwrite SPA/GPA parameters from other applications.

Note

If a name exists in the database table TPARA, this does not automatically mean that the corresponding parameter also exists in the user memory. SPA/GPA parameters are created only during the execution of ABAP programs.

SPA/GPA Parameters and Dynpro Fields

When defining input fields, [dynpro fields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_field_glosry.htm "Glossary Entry") can be associated with SPA/GPA parameters by entering the name of an SPA/GPA parameter from the database table TPARA as an attribute PARAMETER ID. If the corresponding parameter GET PARAMETER is set and no other value is assigned to the input field, the input field is filled with the value of the SPA/GPA parameter when the [screen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscreen_glosry.htm "Glossary Entry") is sent. If the corresponding attribute SET PARAMETER is set, the content of the input field is assigned to the SPA/GPA parameter at the PAI event. If the parameter does not yet exist in the user memory, it is created implicitly in the PAI event. In [selection screens](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselection_screen_glosry.htm "Glossary Entry"), this association can be created using the addition MEMORY ID of the statements [PARAMETERS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapparameters_value.htm) and [SELECT-OPTIONS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect-options_value.htm).

Notes

-   A data transport between a dynpro field and an SPA/GPA parameter in the user memory only takes place if a global data object with the same name as the dynpro field is declared in the corresponding ABAP program.

-   If the PAI event is raised using a function of type "E", no values are assigned to the SPA/GPA parameters associated with the dynpro and no parameters are created in the user memory.

Continue
[SET PARAMETER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_parameter.htm)
[GET PARAMETER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_parameter.htm)


### abapset_parameter.htm

---
title: "SET PARAMETER"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_parameter_shortref.htm) Syntax SET PARAMETER ID pid FIELD dobj. Effect This statement sets the content of the SPA/GPA(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenspa_gpa_parameter_1_glosry.htm '
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_parameter.htm"
abapFile: "abapset_parameter.htm"
keywords: ["select", "do", "if", "case", "try", "data", "abapset", "parameter"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [Parameters in the User Memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmemory.htm) → 

SET PARAMETER

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_parameter_shortref.htm)

Syntax

SET PARAMETER ID pid FIELD dobj.

Effect

This statement sets the content of the [SPA/GPA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenspa_gpa_parameter_1_glosry.htm "Glossary Entry") parameter specified in pid [user memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenuser_memory_glosry.htm "Glossary Entry") to the content of the data object dobj. The ID pid must be a [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like field that contains no more than 20 characters and does not consist solely of blanks. pid is case-sensitive. dobj expects a flat character-like field whose binary content is passed in an unconverted format.

The statement SET PARAMETER does not access the user memory directly. Instead, it accesses a local mapping of the SPA/GPA parameter in the [program memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenroll_area_glosry.htm "Glossary Entry"), which is loaded when rolled in and saved in the user memory when rolled out (see [SPA/GPA Parameters and ABAP Programs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmemory.htm)). If the SPA/GPA parameter specified for the current user in pid does not yet exist in the [user memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenuser_memory_glosry.htm "Glossary Entry"), it is created. If the SPA/GPA parameter has already been created for the current user, its value is overwritten.

In a program, SPA/GPA parameters can only be created or assigned values if a name exists for them in the table TPARA. If it is known statically that an ID pid is not in the database table TPARA, the extended program check reports an error.

Notes

-   An SPA/GPA parameter specified in pid must be entered in uppercase to match a name in the database table TPARA.
    
-   The statements SET PARAMETER and GET PARAMETER do not work directly with the SPA/GPA parameters of the user memory, which means that they are only suitable for passing data within a single [ABAP session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmain_session_glosry.htm "Glossary Entry") and not for passing data between two main sessions in parallel. This is because programs that run in parallel can change the state of the parameters unpredictably.
    

Example

If the user selects a flight displayed in the basic list, the SPA/GPA parameters CAR and CON are set to the ID of the airline and the number of the connection at the event AT LINE-SELECTION. The names of both parameters are defined in the table TPARA for this purpose. In the initial [dynpro](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_glosry.htm "Glossary Entry") of the transaction DEMO\_TRANSACTION, two input fields are associated with these SPA/GPA parameters and are displayed with the selected values as [start values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstart_value_glosry.htm "Glossary Entry").

DATA: carrier     TYPE spfli-carrid,
      connection  TYPE spfli-connid.
START-OF-SELECTION.
  SELECT carrid, connid
         FROM spfli
         INTO (@carrier, @connection).
    WRITE: / carrier HOTSPOT, connection HOTSPOT.
    HIDE:  carrier, connection.
  ENDSELECT.
AT LINE-SELECTION.
  SET PARAMETER ID: 'CAR' FIELD carrier,
                    'CON' FIELD connection.
  CALL TRANSACTION 'DEMO\_TRANSACTION'.

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Non-Handleable Exceptions

-   Cause:: Key only contains blank characters
    Runtime error: SET\_PARAMETER\_ID\_SPACE
    
-   Cause: Key is longer than 20 characters
    Runtime error: SET\_PARAMETER\_ID\_TOO\_LONG
    
-   Cause: Value is longer than 255 characters
    Runtime error: SET\_PARAMETER\_VALUE\_TOO\_LONG
    
-   Cause: Memory limit of the user memory was reached
    Runtime error: SET\_PARAMETER\_MEMORY\_OVERFLOW


### abapget_parameter.htm

---
title: "GET PARAMETER"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_parameter_shortref.htm) Syntax GET PARAMETER ID pid FIELD dobj. Effect This statement sets the content of the data object dobj to the content of the SPA/GPA(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_parameter.htm"
abapFile: "abapget_parameter.htm"
keywords: ["select", "do", "if", "case", "try", "data", "abapget", "parameter"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Creating Objects and Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencreate_objects.htm) →  [Parameters in the User Memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmemory.htm) → 

GET PARAMETER

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_parameter_shortref.htm)

Syntax

GET PARAMETER ID pid FIELD dobj.

Effect

This statement sets the content of the data object dobj to the content of the [SPA/GPA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenspa_gpa_parameter_1_glosry.htm "Glossary Entry") parameter specified in pid in the [user memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenuser_memory_glosry.htm "Glossary Entry"). The ID pid must be a [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like field that contains no more than 20 characters and does not consist solely of blanks. The field is case-sensitive. The binary content of the SPA/GPA parameter is passed to dobj without being converted. The following can be specified for dobj:

-   An existing flat character-like variable.
    
-   An inline declaration [DATA(var)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_inline.htm), where a variable of type XUVALUE is declared.
    

The statement GET PARAMETER does not access the user memory directly. Instead, it accesses a local mapping of the SPA/GPA parameter in the [program memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenroll_area_glosry.htm "Glossary Entry"), which is loaded when rolled in and saved in the user memory when rolled out (see [SPA/GPA Parameters and ABAP Programs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmemory.htm)). If the SPA/GPA parameter specified in pid does not yet exist in the [user memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenuser_memory_glosry.htm "Glossary Entry") for the current user, the data object dobj is initialized and sy-subrc is set to 4.

A program can only read those SPA/GPA parameters for which there is a name in the table TPARA. If it is known statically that an ID pid is not in the database table TPARA, the extended program check reports an error.

System Fields

sy-subrc

Meaning

0

The SPA/GPA parameter specified in pid exists for the current user in the user memory and its value was passed to the target field.

4

The SPA/GPA parameter specified in pid does not exist for the current user in the user memory.

Notes

-   An SPA/GPA parameter that is readable using GET PARAMETER can either have been created previously in the user memory using the statement [SET PARAMETER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_parameter.htm) or created automatically in the [PAI](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpai_glosry.htm "Glossary Entry") event of a [dynpro](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_glosry.htm "Glossary Entry") or [selection screen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselection_screen_glosry.htm "Glossary Entry").
    
-   An SPA/GPA parameter specified in pid must be entered in uppercase to match a name in the database table TPARA.
    
-   The statements SET PARAMETER and GET PARAMETER do not work directly with the SPA/GPA parameters of the user memory, which means that they are only suitable for passing data within a single [ABAP session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmain_session_glosry.htm "Glossary Entry") and not for passing data between two main sessions in parallel. This is because programs that run in parallel can change the state of the parameters unpredictably.
    

Example

In this example, the current value of the SPA/GPA parameter RID is read from the user memory to the data object prog. In the dynpros in [ABAP Workbench](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_workbench_glosry.htm "Glossary Entry"), this parameter is associated with the input fields for a program name. When an ABAP Workbench tool in which an ABAP program is processed, is first called, the parameter is created in the event PAI and assigned the name of the program specified there. If, in the same user session, no dynpro is processed that sets the parameter RID and no corresponding SET PARAMETER statement was executed beforehand, RID is not found in the user memory.

DATA: para TYPE tpara-paramid VALUE 'RID',
      prog TYPE sy-repid.
GET PARAMETER ID para FIELD prog.
IF sy-subrc <> 0.
  MESSAGE 'Parameter not found' TYPE 'I'.
ENDIF.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Expressions and Functions for Conditions / log_exp - Logical Expressions / rel_exp - Comparison Expressions / rel_exp - Comparison Rules / rel_exp - Comparing Elementary Data Types / rel_exp - Comparison Type of Elementary Data Objects

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Expressions and Functions for Conditions / Logical Functions

Included pages: 2


### abenlogic_functions.htm

---
title: "Logical Functions"
description: |
  Logical functions are a type of built-in function(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions.htm). They are divided into: -   Boolean functions(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboole_functions.htm) -   Predicate functions(htt
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogic_functions.htm"
abapFile: "abenlogic_functions.htm"
keywords: ["do", "abenlogic", "functions"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Expressions and Functions for Conditions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_expr_func.htm) → 

Logical Functions

Logical functions are a type of [built-in function](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_functions.htm). They are divided into:

-   [Boolean functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboole_functions.htm)

-   [Predicate functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpredicate_functions.htm)

Note

The program DEMO\_EXPRESSIONS shows examples of how to use logical functions.

Continue
[boolc, boolx, xsdbool - Boolean Functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboole_functions.htm)


### abenboole_functions.htm

---
title: "Effect"
description: |
  The Boolean functions determine the truth value(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_value_glosry.htm 'Glossary Entry') of a logical expression log_exp(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogexp.htm) specified as an argument. For log
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboole_functions.htm"
abapFile: "abenboole_functions.htm"
keywords: ["do", "if", "try", "method", "data", "types", "abenboole", "functions"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Expressions and Functions for Conditions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_expr_func.htm) →  [Logical Functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogic_functions.htm) → 

boolc, boolx, xsdbool - Boolean Functions

Variants:

[1\. ... boolc( log\_exp ) ...](#!ABAP_VARIANT_1@1@)
[2\. ... boolx( bool = log\_exp bit = bit ) ...](#!ABAP_VARIANT_2@2@)
[3\. ... xsdbool( log\_exp ) ...](#!ABAP_VARIANT_3@3@)

Effect

The Boolean functions determine the [truth value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_value_glosry.htm "Glossary Entry") of a logical expression [log\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogexp.htm) specified as an argument. For log\_exp, any logical expression can be specified in accordance with the applicable rules. The return value of a Boolean function has a data type determined by the function and expresses the truth value of the logical expression using a value of this type.

Note

These functions can be viewed as a partial replacement for the Boolean data type for truth values not available in ABAP. In particular, xsdbool and (with restrictions) boolc can be used in many operand positions where input parameters of the type abap\_bool of the type group ABAP are expected.

Variant 1

... boolc( log\_exp ) ...

Effect

The function boolc returns a single-character character string of the type string. If the logical expression is true, "X" is returned. If the logical expression is false, a blank is returned. In principle, boolc is one of the [processing functions with character-like results](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocess_functions.htm) and can be specified in [general expression positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneral_expr_position_glosry.htm "Glossary Entry") and in [character-like expression positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencharlike_expr_position_glosry.htm "Glossary Entry").

Notes

-   If boolc requires return values other than "X" or " " (for example, "Y" and "N" or "1" and "0"), the result of boolc can be edited directly using the function [translate](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentranslate_functions.htm) or another suitable [processing function](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocess_functions.htm).

-   The result of boolc must not be compared with the constants abap\_true and abap\_false in relational expressions, since the comparison converts the latter from c to string and ignores any blanks. Comparisons of this type are not usually necessary. If a comparison of this type is required anyway, the function xsdbool can be used instead of boolc. The result of this function has the same ABAP type as abap\_bool.

-   If the logical expression is false, the result of boolc does not meet the condition [IS INITIAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogexp_initial.htm), since a blank is returned (not an empty string). If this is the required behavior, the function xsdbool can be used instead of boolc.

-   If boolc is used in inappropriate places (as specified in the points above), a syntax warning is produced (which can be hidden using a pragma).

Example

The value 0, 1, or 2 is assigned to the variable bool\_value, depending on the result of the logical expressions log\_exp1 and log\_exp2.

DATA bool\_value TYPE i.
bool\_value = strlen( condense( val = boolc( log\_exp1 ) ) ) +
             strlen( condense( val = boolc( log\_exp2 ) ) ).

Example

Calls a method, where the input parameter no\_dialog is supplied with the character-like representation of the results of a predicate expression.

PARAMETERS word TYPE c length 30.
DATA result\_tab TYPE cl\_abap\_docu=>search\_results.
cl\_abap\_docu=>start(
  EXPORTING word           = word
            no\_dialog      = boolc( sy-batch IS NOT INITIAL )
  IMPORTING search\_results = result\_tab ).

Variant 2

... boolx( bool = log\_exp bit = bit ) ...

Effect

The function boolx returns a byte chain of the type xstring. If the logical expression is true, the byte chain is filled as if the function [bit-set( bit )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbit_functions.htm) were being executed. If the logical expression is false, the byte chain is filled as if the function [bit-set( 0 )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbit_functions.htm) were being executed. bit expects a data object of the type i. In principle, boolx is one of the [bit functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbit_functions.htm) and can be used in all positions where a [bit expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbit_expression_glosry.htm "Glossary Entry") is also allowed.

Note

The function boolx can be used for efficient saving of sequences of truth values.

Example

The result of the following [bit expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbit_expression_glosry.htm "Glossary Entry") is hexadecimal 55, the same as the calculated bit string 01010101.

DATA(result) = boolx( bool = 2 > 1 bit = 8 )
        BIT-OR boolx( bool = 2 < 1 bit = 7 )
        BIT-OR boolx( bool = 2 > 1 bit = 6 )
        BIT-OR boolx( bool = 2 < 1 bit = 5 )
        BIT-OR boolx( bool = 2 > 1 bit = 4 )
        BIT-OR boolx( bool = 2 < 1 bit = 3 )
        BIT-OR boolx( bool = 2 > 1 bit = 2 )
        BIT-OR boolx( bool = 2 < 1 bit = 1 ).

The bit expression above can be expressed using the following iteration with the operator [REDUCE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_reduce.htm).

DATA(result) =
  REDUCE xstring( INIT x TYPE xstring
                  FOR j = 4 THEN j - 1 UNTIL j < 1
                  LET b1 = 2 \* j b2 = 2 \* j - 2 IN
                  NEXT x = x BIT-OR boolx( bool = 2 > 1  bit = b1 )
                             BIT-OR boolx( bool = 2 < 1  bit = b2 ) ).

Variant 3

... xsdbool( log\_exp ) ...

Effect

Like boolc, the function xsdbool returns the value "X" for true and a blank for false. The data type of the return value, however, has the type c of the length 1 here.

The return value references the type XSDBOOLEAN from ABAP Dictionary. This type (which references the identically named domain with the type CHAR and length 1) is handled like a real Boolean type in serializations and deserializations to or from [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml_schema.htm) and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_schema.htm) using [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). The XML or JSON values true and false are assigned to the values "X" and " " of this type.

xsdbool can be specified in [general](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneral_expr_position_glosry.htm "Glossary Entry") and [character-like expression positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencharlike_expr_position_glosry.htm "Glossary Entry").

Notes

-   The result of xsdbool can be used like a value of the type abap\_bool and compared with the constants abap\_true and abap\_false.

-   If the logical expression is false, the result of boolc meets the condition [IS INITIAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogexp_initial.htm), since the returned blank is the type-dependent initial value too.

-   The result of xsdbool cannot usually be implemented directly using a [processing function](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocess_functions.htm) such as [translate](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentranslate_functions.htm), since the trailing blanks here are ignored in text fields with the type c. The result of a false logical expression would be ignored. The result of the function boolc with the type string is better suited to transformations of this type.

-   The abbreviation xsd stands for [XML schema data](http://www.w3.org/TR/xmlschema-2/) types.

Example

This example sets the type and the value of the variable gui\_flag declared inline using the Boolean function xsdbool. A [predicative method call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpredicative_method_call_glosry.htm "Glossary Entry") is specified as the argument of this function. The variable is then serialized to [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") using the predefined [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") [ID](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_id.htm). This produces the value true or false. After being compared with the identically typed constant abap\_false, the result of the serializations is either read or displayed.

The result would be very different if boolc were used instead of xsdbool. Firstly, the transformations would have a different result (since the values "X" and " " are not transformed to true or false); secondly, the logical expression gui\_flag = abap\_false would always be false (since abap\_false loses its blank when converted to the type string).

DATA(gui\_flag) = xsdbool( cl\_demo\_sap\_gui=>check( ) ).
CALL TRANSFORMATION id SOURCE gui\_flag = gui\_flag
                       RESULT XML DATA(xml).
DATA(writer) =
  cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_json ).
CALL TRANSFORMATION id SOURCE gui\_flag = gui\_flag
                       RESULT XML writer.
DATA(json) = writer->get\_output( ).
cl\_demo\_output=>write\_xml( xml ).
cl\_demo\_output=>write\_json( json ).
IF gui\_flag = abap\_false.
  cl\_demo\_output=>get( ).
ELSE.
  cl\_demo\_output=>display( ).
ENDIF.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Exception Classes

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

Included pages: 4


### abenexception_abexas.htm

---
title: "Examples of Exceptions"
description: |
  !Example(exa.gif 'Example') Exceptions, RAISE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm) !Example(exa.gif 'Example') Exceptions, TRY(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm) !Example(exa.gif 'Example') Exceptions, C
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm"
abapFile: "abenexception_abexas.htm"
keywords: ["do", "if", "try", "catch", "class", "exception-handling", "abenexception", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) → 

Examples of Exceptions

Continue
![Example](exa.gif "Example") [Exceptions, RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm)
![Example](exa.gif "Example") [Exceptions, TRY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm)
![Example](exa.gif "Example") [Exceptions, CATCH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencatch_exception_abexa.htm)


### abenraise_abexa.htm

---
title: "Exceptions, RAISE"
description: |
  This example demonstrates the statement RAISE EXCEPTION. Source Code REPORT demo_raise_exception. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: oref    TYPE REF TO cx_demo_constructor, text     TYPE string, position TYPE i. TRY
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm"
abapFile: "abenraise_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "exception-handling", "abenraise", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, RAISE

This example demonstrates the statement RAISE EXCEPTION.

Source Code

REPORT demo\_raise\_exception.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: oref    TYPE REF TO cx\_demo\_constructor,
          text     TYPE string,
          position TYPE i.
    TRY.
        TRY.
            RAISE EXCEPTION TYPE cx\_demo\_constructor
              EXPORTING
                my\_text = sy-repid.
          CATCH cx\_demo\_constructor INTO oref.
            text = oref->get\_text( ).
            oref->get\_source\_position(
              IMPORTING  source\_line  = position ).
            cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
            RAISE EXCEPTION oref.
        ENDTRY.
      CATCH cx\_demo\_constructor INTO oref.
        text = oref->get\_text( ).
        oref->get\_source\_position(
          IMPORTING source\_line  = position ).
        cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
    ENDTRY.
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the two variants of the statement RAISE EXCEPTION. The first statement raises an exception of the class CX\_DEMO\_CONSTRUCTOR in the inner TRY block, creates the relevant object, and passes the program name to the instance constructor. The inner CATCH block handles the exception, provides the exception text, and raises the exception again without creating a new object. The outer CATCH block handles the exception again. The CX\_DEMO\_CONSTRUCTOR class is defined in such a way that the passed program name appears in the exception text. The generated instance constructor takes care of this.

The line number in which the exception was raised is shown to indicate that, when the existing exception object was reused, information relevant to this object was modified.


### abentry_abexa.htm

---
title: "Exceptions, TRY"
description: |
  This example demonstrates the TRY control structure. Source Code REPORT demo_try. CLASS try_demo DEFINITION. PUBLIC SECTION. CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2, oref   TYPE REF TO cx_root, text   TYPE string. CLASS-METHODS main. PRIVATE SECTION. CLASS-DATA number TYPE i. CLASS-DATA out
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm"
abapFile: "abentry_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "exception-handling", "abentry", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, TRY

This example demonstrates the TRY control structure.

Source Code

REPORT demo\_try.
CLASS try\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2,
                oref   TYPE REF TO cx\_root,
                text   TYPE string.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA number TYPE i.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS calculation
      IMPORTING  p\_number LIKE number
      CHANGING p\_result LIKE result
               p\_text   LIKE text
      RAISING  cx\_sy\_arithmetic\_error.
ENDCLASS.
CLASS try\_demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_input=>request( CHANGING field = number ).
    out = cl\_demo\_output=>new( ).
    TRY.
        IF abs( number ) > 100.
          RAISE EXCEPTION TYPE cx\_demo\_abs\_too\_large.
        ENDIF.
        calculation( EXPORTING p\_number = number
                     CHANGING  p\_result = result
                               p\_text   = text ).
      CATCH cx\_sy\_arithmetic\_error INTO oref.
        text = oref->get\_text( ).
      CATCH cx\_root INTO oref.
        text = oref->get\_text( ).
    ENDTRY.
    IF NOT text IS INITIAL.
      out->write( text ).
    ENDIF.
    out->display( |Final result: { result ALIGN = LEFT }| ).
  ENDMETHOD.
  METHOD calculation.
    DATA l\_oref TYPE REF TO cx\_root.
    TRY.
        p\_result =  1 / p\_number.
        out->write(
          |Result of division: { p\_result ALIGN = LEFT }| ).
        p\_result = sqrt( p\_number ).
        out->write(
          |Result of square root: { p\_result ALIGN = LEFT }| ).
      CATCH cx\_sy\_zerodivide INTO l\_oref.
        p\_text = l\_oref->get\_text( ).
      CLEANUP.
        CLEAR p\_result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  try\_demo=>main( ).

Description

-   If the content of number is greater than 100, the TRY control structure of the [master program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenframe_program_glosry.htm "Glossary Entry") raises an exception of the class CX\_DEMO\_ABS\_TOO\_LARGE in the TRY block. This exception is handled by the second CATCH block of the same TRY control structure, since the subclass of the most general exception is CX\_ROOT.

-   If the content of number is 0, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ZERODIVIDE. This is handled in the CATCH block of the same TRY control structure.

-   If the content of number is a negative number, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ARG\_OUT\_OF\_DOMAIN. Since there is no handler defined for this exception in this TRY control structure, the exception is propagated from the method. This is made possible by the declaration of the superclass CX\_SY\_ARITHMETIC\_ERROR using RAISING in the method interface. The CLEANUP block of the inner TRY control structure is executed first.

-   Any other exceptions are handled in the final CATCH block of the TRY control structure of the master program. This block catches all possible exceptions by specifying the most general exception class, CX\_ROOT. If, for example, CX\_SY\_ARG\_OUT\_OF\_DOMAIN or one of its superclasses is not declared in the method interface, the exception CX\_SY\_NO\_HANDLER would be raised and would be handled in the final CATCH block.


### abencatch_exception_abexa.htm

---
title: "Exceptions, CATCH"
description: |
  This example demonstrates how class-based exceptions are caught. Source Code REPORT demo_catch_exception. DATA(in) = cl_demo_input=>new( ). DATA: resumable     TYPE abap_bool VALUE abap_false, before_unwind TYPE abap_bool VALUE abap_false, resume        TYPE abap_bool VALUE abap_false. in
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencatch_exception_abexa.htm"
abapFile: "abencatch_exception_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "catch", "method", "class", "data", "exception-handling", "abencatch", "exception", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, CATCH

This example demonstrates how class-based exceptions are caught.

Source Code

REPORT demo\_catch\_exception.
DATA(in) = cl\_demo\_input=>new( ).
DATA: resumable     TYPE abap\_bool VALUE abap\_false,
      before\_unwind TYPE abap\_bool VALUE abap\_false,
      resume        TYPE abap\_bool VALUE abap\_false.
in->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RAISE RESUMABLE'
               CHANGING  field = resumable
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'CATCH BEFORE UNWIND'
               CHANGING  field = before\_unwind
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RESUME'
               CHANGING  field = resume
)->request( ).
CLASS lcx\_exception DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS exc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS: main,
      meth1 RAISING lcx\_exception,
      meth2 RAISING RESUMABLE(lcx\_exception).
ENDCLASS.
FIELD-SYMBOLS <fs> TYPE any.
CLASS exc\_demo IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    DATA exc TYPE REF TO lcx\_exception.
    IF before\_unwind = abap\_false.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH lcx\_exception.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ELSEIF before\_unwind = abap\_true.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH BEFORE UNWIND lcx\_exception INTO exc.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
          IF resume = abap\_true.
            IF exc->is\_resumable = abap\_true.
              RESUME.
            ELSE.
              out->write( 'Resumption not possible' ).
            ENDIF.
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ENDIF.
    out->display( ).
  ENDMETHOD.
  METHOD meth1.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising non-resumable exception' ).
        RAISE EXCEPTION TYPE lcx\_exception.
        out->write( 'Never executed' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
  METHOD meth2.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising resumable exception' ).
        RAISE RESUMABLE EXCEPTION TYPE lcx\_exception.
        out->write( 'Resuming method' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  exc\_demo=>main( ).

Description

The method meth1 raises a non-resumable exception and the method meth2 raises a resumable exception that is handled in the TRY control structures of the method main using CATCH.

-   If handled without BEFORE UNWIND, the CLEANUP block is executed in both cases before handling and the context of the called method does not exist during handling.

-   If handled with BEFORE UNWIND, the context of the called method exists in both cases during handling and the CLEANUP block is executed after handling.

-   When a resumable exception is raised, the statement RESUME can be executed during handling. This statement makes sure that processing in the called method is continued without its CLEANUP block being executed.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / System Response after a Class-Based Exception

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

Included pages: 4


### abenexception_abexas.htm

---
title: "Examples of Exceptions"
description: |
  !Example(exa.gif 'Example') Exceptions, RAISE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm) !Example(exa.gif 'Example') Exceptions, TRY(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm) !Example(exa.gif 'Example') Exceptions, C
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm"
abapFile: "abenexception_abexas.htm"
keywords: ["do", "if", "try", "catch", "class", "exception-handling", "abenexception", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) → 

Examples of Exceptions

Continue
![Example](exa.gif "Example") [Exceptions, RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm)
![Example](exa.gif "Example") [Exceptions, TRY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm)
![Example](exa.gif "Example") [Exceptions, CATCH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencatch_exception_abexa.htm)


### abenraise_abexa.htm

---
title: "Exceptions, RAISE"
description: |
  This example demonstrates the statement RAISE EXCEPTION. Source Code REPORT demo_raise_exception. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: oref    TYPE REF TO cx_demo_constructor, text     TYPE string, position TYPE i. TRY
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm"
abapFile: "abenraise_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "exception-handling", "abenraise", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, RAISE

This example demonstrates the statement RAISE EXCEPTION.

Source Code

REPORT demo\_raise\_exception.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: oref    TYPE REF TO cx\_demo\_constructor,
          text     TYPE string,
          position TYPE i.
    TRY.
        TRY.
            RAISE EXCEPTION TYPE cx\_demo\_constructor
              EXPORTING
                my\_text = sy-repid.
          CATCH cx\_demo\_constructor INTO oref.
            text = oref->get\_text( ).
            oref->get\_source\_position(
              IMPORTING  source\_line  = position ).
            cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
            RAISE EXCEPTION oref.
        ENDTRY.
      CATCH cx\_demo\_constructor INTO oref.
        text = oref->get\_text( ).
        oref->get\_source\_position(
          IMPORTING source\_line  = position ).
        cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
    ENDTRY.
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the two variants of the statement RAISE EXCEPTION. The first statement raises an exception of the class CX\_DEMO\_CONSTRUCTOR in the inner TRY block, creates the relevant object, and passes the program name to the instance constructor. The inner CATCH block handles the exception, provides the exception text, and raises the exception again without creating a new object. The outer CATCH block handles the exception again. The CX\_DEMO\_CONSTRUCTOR class is defined in such a way that the passed program name appears in the exception text. The generated instance constructor takes care of this.

The line number in which the exception was raised is shown to indicate that, when the existing exception object was reused, information relevant to this object was modified.


### abentry_abexa.htm

---
title: "Exceptions, TRY"
description: |
  This example demonstrates the TRY control structure. Source Code REPORT demo_try. CLASS try_demo DEFINITION. PUBLIC SECTION. CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2, oref   TYPE REF TO cx_root, text   TYPE string. CLASS-METHODS main. PRIVATE SECTION. CLASS-DATA number TYPE i. CLASS-DATA out
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm"
abapFile: "abentry_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "exception-handling", "abentry", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, TRY

This example demonstrates the TRY control structure.

Source Code

REPORT demo\_try.
CLASS try\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2,
                oref   TYPE REF TO cx\_root,
                text   TYPE string.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA number TYPE i.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS calculation
      IMPORTING  p\_number LIKE number
      CHANGING p\_result LIKE result
               p\_text   LIKE text
      RAISING  cx\_sy\_arithmetic\_error.
ENDCLASS.
CLASS try\_demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_input=>request( CHANGING field = number ).
    out = cl\_demo\_output=>new( ).
    TRY.
        IF abs( number ) > 100.
          RAISE EXCEPTION TYPE cx\_demo\_abs\_too\_large.
        ENDIF.
        calculation( EXPORTING p\_number = number
                     CHANGING  p\_result = result
                               p\_text   = text ).
      CATCH cx\_sy\_arithmetic\_error INTO oref.
        text = oref->get\_text( ).
      CATCH cx\_root INTO oref.
        text = oref->get\_text( ).
    ENDTRY.
    IF NOT text IS INITIAL.
      out->write( text ).
    ENDIF.
    out->display( |Final result: { result ALIGN = LEFT }| ).
  ENDMETHOD.
  METHOD calculation.
    DATA l\_oref TYPE REF TO cx\_root.
    TRY.
        p\_result =  1 / p\_number.
        out->write(
          |Result of division: { p\_result ALIGN = LEFT }| ).
        p\_result = sqrt( p\_number ).
        out->write(
          |Result of square root: { p\_result ALIGN = LEFT }| ).
      CATCH cx\_sy\_zerodivide INTO l\_oref.
        p\_text = l\_oref->get\_text( ).
      CLEANUP.
        CLEAR p\_result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  try\_demo=>main( ).

Description

-   If the content of number is greater than 100, the TRY control structure of the [master program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenframe_program_glosry.htm "Glossary Entry") raises an exception of the class CX\_DEMO\_ABS\_TOO\_LARGE in the TRY block. This exception is handled by the second CATCH block of the same TRY control structure, since the subclass of the most general exception is CX\_ROOT.

-   If the content of number is 0, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ZERODIVIDE. This is handled in the CATCH block of the same TRY control structure.

-   If the content of number is a negative number, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ARG\_OUT\_OF\_DOMAIN. Since there is no handler defined for this exception in this TRY control structure, the exception is propagated from the method. This is made possible by the declaration of the superclass CX\_SY\_ARITHMETIC\_ERROR using RAISING in the method interface. The CLEANUP block of the inner TRY control structure is executed first.

-   Any other exceptions are handled in the final CATCH block of the TRY control structure of the master program. This block catches all possible exceptions by specifying the most general exception class, CX\_ROOT. If, for example, CX\_SY\_ARG\_OUT\_OF\_DOMAIN or one of its superclasses is not declared in the method interface, the exception CX\_SY\_NO\_HANDLER would be raised and would be handled in the final CATCH block.


### abencatch_exception_abexa.htm

---
title: "Exceptions, CATCH"
description: |
  This example demonstrates how class-based exceptions are caught. Source Code REPORT demo_catch_exception. DATA(in) = cl_demo_input=>new( ). DATA: resumable     TYPE abap_bool VALUE abap_false, before_unwind TYPE abap_bool VALUE abap_false, resume        TYPE abap_bool VALUE abap_false. in
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencatch_exception_abexa.htm"
abapFile: "abencatch_exception_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "catch", "method", "class", "data", "exception-handling", "abencatch", "exception", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, CATCH

This example demonstrates how class-based exceptions are caught.

Source Code

REPORT demo\_catch\_exception.
DATA(in) = cl\_demo\_input=>new( ).
DATA: resumable     TYPE abap\_bool VALUE abap\_false,
      before\_unwind TYPE abap\_bool VALUE abap\_false,
      resume        TYPE abap\_bool VALUE abap\_false.
in->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RAISE RESUMABLE'
               CHANGING  field = resumable
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'CATCH BEFORE UNWIND'
               CHANGING  field = before\_unwind
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RESUME'
               CHANGING  field = resume
)->request( ).
CLASS lcx\_exception DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS exc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS: main,
      meth1 RAISING lcx\_exception,
      meth2 RAISING RESUMABLE(lcx\_exception).
ENDCLASS.
FIELD-SYMBOLS <fs> TYPE any.
CLASS exc\_demo IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    DATA exc TYPE REF TO lcx\_exception.
    IF before\_unwind = abap\_false.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH lcx\_exception.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ELSEIF before\_unwind = abap\_true.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH BEFORE UNWIND lcx\_exception INTO exc.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
          IF resume = abap\_true.
            IF exc->is\_resumable = abap\_true.
              RESUME.
            ELSE.
              out->write( 'Resumption not possible' ).
            ENDIF.
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ENDIF.
    out->display( ).
  ENDMETHOD.
  METHOD meth1.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising non-resumable exception' ).
        RAISE EXCEPTION TYPE lcx\_exception.
        out->write( 'Never executed' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
  METHOD meth2.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising resumable exception' ).
        RAISE RESUMABLE EXCEPTION TYPE lcx\_exception.
        out->write( 'Resuming method' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  exc\_demo=>main( ).

Description

The method meth1 raises a non-resumable exception and the method meth2 raises a resumable exception that is handled in the TRY control structures of the method main using CATCH.

-   If handled without BEFORE UNWIND, the CLEANUP block is executed in both cases before handling and the context of the called method does not exist during handling.

-   If handled with BEFORE UNWIND, the context of the called method exists in both cases during handling and the CLEANUP block is executed after handling.

-   When a resumable exception is raised, the statement RESUME can be executed during handling. This statement makes sure that processing in the called method is continued without its CLEANUP block being executed.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / RAISE EXCEPTION

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

Included pages: 4


### abenexception_abexas.htm

---
title: "Examples of Exceptions"
description: |
  !Example(exa.gif 'Example') Exceptions, RAISE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm) !Example(exa.gif 'Example') Exceptions, TRY(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm) !Example(exa.gif 'Example') Exceptions, C
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm"
abapFile: "abenexception_abexas.htm"
keywords: ["do", "if", "try", "catch", "class", "exception-handling", "abenexception", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) → 

Examples of Exceptions

Continue
![Example](exa.gif "Example") [Exceptions, RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm)
![Example](exa.gif "Example") [Exceptions, TRY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm)
![Example](exa.gif "Example") [Exceptions, CATCH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencatch_exception_abexa.htm)


### abenraise_abexa.htm

---
title: "Exceptions, RAISE"
description: |
  This example demonstrates the statement RAISE EXCEPTION. Source Code REPORT demo_raise_exception. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: oref    TYPE REF TO cx_demo_constructor, text     TYPE string, position TYPE i. TRY
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm"
abapFile: "abenraise_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "exception-handling", "abenraise", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, RAISE

This example demonstrates the statement RAISE EXCEPTION.

Source Code

REPORT demo\_raise\_exception.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: oref    TYPE REF TO cx\_demo\_constructor,
          text     TYPE string,
          position TYPE i.
    TRY.
        TRY.
            RAISE EXCEPTION TYPE cx\_demo\_constructor
              EXPORTING
                my\_text = sy-repid.
          CATCH cx\_demo\_constructor INTO oref.
            text = oref->get\_text( ).
            oref->get\_source\_position(
              IMPORTING  source\_line  = position ).
            cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
            RAISE EXCEPTION oref.
        ENDTRY.
      CATCH cx\_demo\_constructor INTO oref.
        text = oref->get\_text( ).
        oref->get\_source\_position(
          IMPORTING source\_line  = position ).
        cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
    ENDTRY.
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the two variants of the statement RAISE EXCEPTION. The first statement raises an exception of the class CX\_DEMO\_CONSTRUCTOR in the inner TRY block, creates the relevant object, and passes the program name to the instance constructor. The inner CATCH block handles the exception, provides the exception text, and raises the exception again without creating a new object. The outer CATCH block handles the exception again. The CX\_DEMO\_CONSTRUCTOR class is defined in such a way that the passed program name appears in the exception text. The generated instance constructor takes care of this.

The line number in which the exception was raised is shown to indicate that, when the existing exception object was reused, information relevant to this object was modified.


### abentry_abexa.htm

---
title: "Exceptions, TRY"
description: |
  This example demonstrates the TRY control structure. Source Code REPORT demo_try. CLASS try_demo DEFINITION. PUBLIC SECTION. CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2, oref   TYPE REF TO cx_root, text   TYPE string. CLASS-METHODS main. PRIVATE SECTION. CLASS-DATA number TYPE i. CLASS-DATA out
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm"
abapFile: "abentry_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "exception-handling", "abentry", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, TRY

This example demonstrates the TRY control structure.

Source Code

REPORT demo\_try.
CLASS try\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2,
                oref   TYPE REF TO cx\_root,
                text   TYPE string.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA number TYPE i.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS calculation
      IMPORTING  p\_number LIKE number
      CHANGING p\_result LIKE result
               p\_text   LIKE text
      RAISING  cx\_sy\_arithmetic\_error.
ENDCLASS.
CLASS try\_demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_input=>request( CHANGING field = number ).
    out = cl\_demo\_output=>new( ).
    TRY.
        IF abs( number ) > 100.
          RAISE EXCEPTION TYPE cx\_demo\_abs\_too\_large.
        ENDIF.
        calculation( EXPORTING p\_number = number
                     CHANGING  p\_result = result
                               p\_text   = text ).
      CATCH cx\_sy\_arithmetic\_error INTO oref.
        text = oref->get\_text( ).
      CATCH cx\_root INTO oref.
        text = oref->get\_text( ).
    ENDTRY.
    IF NOT text IS INITIAL.
      out->write( text ).
    ENDIF.
    out->display( |Final result: { result ALIGN = LEFT }| ).
  ENDMETHOD.
  METHOD calculation.
    DATA l\_oref TYPE REF TO cx\_root.
    TRY.
        p\_result =  1 / p\_number.
        out->write(
          |Result of division: { p\_result ALIGN = LEFT }| ).
        p\_result = sqrt( p\_number ).
        out->write(
          |Result of square root: { p\_result ALIGN = LEFT }| ).
      CATCH cx\_sy\_zerodivide INTO l\_oref.
        p\_text = l\_oref->get\_text( ).
      CLEANUP.
        CLEAR p\_result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  try\_demo=>main( ).

Description

-   If the content of number is greater than 100, the TRY control structure of the [master program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenframe_program_glosry.htm "Glossary Entry") raises an exception of the class CX\_DEMO\_ABS\_TOO\_LARGE in the TRY block. This exception is handled by the second CATCH block of the same TRY control structure, since the subclass of the most general exception is CX\_ROOT.

-   If the content of number is 0, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ZERODIVIDE. This is handled in the CATCH block of the same TRY control structure.

-   If the content of number is a negative number, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ARG\_OUT\_OF\_DOMAIN. Since there is no handler defined for this exception in this TRY control structure, the exception is propagated from the method. This is made possible by the declaration of the superclass CX\_SY\_ARITHMETIC\_ERROR using RAISING in the method interface. The CLEANUP block of the inner TRY control structure is executed first.

-   Any other exceptions are handled in the final CATCH block of the TRY control structure of the master program. This block catches all possible exceptions by specifying the most general exception class, CX\_ROOT. If, for example, CX\_SY\_ARG\_OUT\_OF\_DOMAIN or one of its superclasses is not declared in the method interface, the exception CX\_SY\_NO\_HANDLER would be raised and would be handled in the final CATCH block.


### abencatch_exception_abexa.htm

---
title: "Exceptions, CATCH"
description: |
  This example demonstrates how class-based exceptions are caught. Source Code REPORT demo_catch_exception. DATA(in) = cl_demo_input=>new( ). DATA: resumable     TYPE abap_bool VALUE abap_false, before_unwind TYPE abap_bool VALUE abap_false, resume        TYPE abap_bool VALUE abap_false. in
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencatch_exception_abexa.htm"
abapFile: "abencatch_exception_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "catch", "method", "class", "data", "exception-handling", "abencatch", "exception", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, CATCH

This example demonstrates how class-based exceptions are caught.

Source Code

REPORT demo\_catch\_exception.
DATA(in) = cl\_demo\_input=>new( ).
DATA: resumable     TYPE abap\_bool VALUE abap\_false,
      before\_unwind TYPE abap\_bool VALUE abap\_false,
      resume        TYPE abap\_bool VALUE abap\_false.
in->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RAISE RESUMABLE'
               CHANGING  field = resumable
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'CATCH BEFORE UNWIND'
               CHANGING  field = before\_unwind
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RESUME'
               CHANGING  field = resume
)->request( ).
CLASS lcx\_exception DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS exc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS: main,
      meth1 RAISING lcx\_exception,
      meth2 RAISING RESUMABLE(lcx\_exception).
ENDCLASS.
FIELD-SYMBOLS <fs> TYPE any.
CLASS exc\_demo IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    DATA exc TYPE REF TO lcx\_exception.
    IF before\_unwind = abap\_false.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH lcx\_exception.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ELSEIF before\_unwind = abap\_true.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH BEFORE UNWIND lcx\_exception INTO exc.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
          IF resume = abap\_true.
            IF exc->is\_resumable = abap\_true.
              RESUME.
            ELSE.
              out->write( 'Resumption not possible' ).
            ENDIF.
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ENDIF.
    out->display( ).
  ENDMETHOD.
  METHOD meth1.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising non-resumable exception' ).
        RAISE EXCEPTION TYPE lcx\_exception.
        out->write( 'Never executed' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
  METHOD meth2.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising resumable exception' ).
        RAISE RESUMABLE EXCEPTION TYPE lcx\_exception.
        out->write( 'Resuming method' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  exc\_demo=>main( ).

Description

The method meth1 raises a non-resumable exception and the method meth2 raises a resumable exception that is handled in the TRY control structures of the method main using CATCH.

-   If handled without BEFORE UNWIND, the CLEANUP block is executed in both cases before handling and the context of the called method does not exist during handling.

-   If handled with BEFORE UNWIND, the context of the called method exists in both cases during handling and the CLEANUP block is executed after handling.

-   When a resumable exception is raised, the statement RESUME can be executed during handling. This statement makes sure that processing in the called method is continued without its CLEANUP block being executed.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / TRY

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

Included pages: 4


### abenexception_abexas.htm

---
title: "Examples of Exceptions"
description: |
  !Example(exa.gif 'Example') Exceptions, RAISE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm) !Example(exa.gif 'Example') Exceptions, TRY(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm) !Example(exa.gif 'Example') Exceptions, C
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm"
abapFile: "abenexception_abexas.htm"
keywords: ["do", "if", "try", "catch", "class", "exception-handling", "abenexception", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) → 

Examples of Exceptions

Continue
![Example](exa.gif "Example") [Exceptions, RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm)
![Example](exa.gif "Example") [Exceptions, TRY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm)
![Example](exa.gif "Example") [Exceptions, CATCH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencatch_exception_abexa.htm)


### abenraise_abexa.htm

---
title: "Exceptions, RAISE"
description: |
  This example demonstrates the statement RAISE EXCEPTION. Source Code REPORT demo_raise_exception. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: oref    TYPE REF TO cx_demo_constructor, text     TYPE string, position TYPE i. TRY
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm"
abapFile: "abenraise_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "exception-handling", "abenraise", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, RAISE

This example demonstrates the statement RAISE EXCEPTION.

Source Code

REPORT demo\_raise\_exception.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: oref    TYPE REF TO cx\_demo\_constructor,
          text     TYPE string,
          position TYPE i.
    TRY.
        TRY.
            RAISE EXCEPTION TYPE cx\_demo\_constructor
              EXPORTING
                my\_text = sy-repid.
          CATCH cx\_demo\_constructor INTO oref.
            text = oref->get\_text( ).
            oref->get\_source\_position(
              IMPORTING  source\_line  = position ).
            cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
            RAISE EXCEPTION oref.
        ENDTRY.
      CATCH cx\_demo\_constructor INTO oref.
        text = oref->get\_text( ).
        oref->get\_source\_position(
          IMPORTING source\_line  = position ).
        cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
    ENDTRY.
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the two variants of the statement RAISE EXCEPTION. The first statement raises an exception of the class CX\_DEMO\_CONSTRUCTOR in the inner TRY block, creates the relevant object, and passes the program name to the instance constructor. The inner CATCH block handles the exception, provides the exception text, and raises the exception again without creating a new object. The outer CATCH block handles the exception again. The CX\_DEMO\_CONSTRUCTOR class is defined in such a way that the passed program name appears in the exception text. The generated instance constructor takes care of this.

The line number in which the exception was raised is shown to indicate that, when the existing exception object was reused, information relevant to this object was modified.


### abentry_abexa.htm

---
title: "Exceptions, TRY"
description: |
  This example demonstrates the TRY control structure. Source Code REPORT demo_try. CLASS try_demo DEFINITION. PUBLIC SECTION. CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2, oref   TYPE REF TO cx_root, text   TYPE string. CLASS-METHODS main. PRIVATE SECTION. CLASS-DATA number TYPE i. CLASS-DATA out
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm"
abapFile: "abentry_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "exception-handling", "abentry", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, TRY

This example demonstrates the TRY control structure.

Source Code

REPORT demo\_try.
CLASS try\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2,
                oref   TYPE REF TO cx\_root,
                text   TYPE string.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA number TYPE i.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS calculation
      IMPORTING  p\_number LIKE number
      CHANGING p\_result LIKE result
               p\_text   LIKE text
      RAISING  cx\_sy\_arithmetic\_error.
ENDCLASS.
CLASS try\_demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_input=>request( CHANGING field = number ).
    out = cl\_demo\_output=>new( ).
    TRY.
        IF abs( number ) > 100.
          RAISE EXCEPTION TYPE cx\_demo\_abs\_too\_large.
        ENDIF.
        calculation( EXPORTING p\_number = number
                     CHANGING  p\_result = result
                               p\_text   = text ).
      CATCH cx\_sy\_arithmetic\_error INTO oref.
        text = oref->get\_text( ).
      CATCH cx\_root INTO oref.
        text = oref->get\_text( ).
    ENDTRY.
    IF NOT text IS INITIAL.
      out->write( text ).
    ENDIF.
    out->display( |Final result: { result ALIGN = LEFT }| ).
  ENDMETHOD.
  METHOD calculation.
    DATA l\_oref TYPE REF TO cx\_root.
    TRY.
        p\_result =  1 / p\_number.
        out->write(
          |Result of division: { p\_result ALIGN = LEFT }| ).
        p\_result = sqrt( p\_number ).
        out->write(
          |Result of square root: { p\_result ALIGN = LEFT }| ).
      CATCH cx\_sy\_zerodivide INTO l\_oref.
        p\_text = l\_oref->get\_text( ).
      CLEANUP.
        CLEAR p\_result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  try\_demo=>main( ).

Description

-   If the content of number is greater than 100, the TRY control structure of the [master program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenframe_program_glosry.htm "Glossary Entry") raises an exception of the class CX\_DEMO\_ABS\_TOO\_LARGE in the TRY block. This exception is handled by the second CATCH block of the same TRY control structure, since the subclass of the most general exception is CX\_ROOT.

-   If the content of number is 0, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ZERODIVIDE. This is handled in the CATCH block of the same TRY control structure.

-   If the content of number is a negative number, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ARG\_OUT\_OF\_DOMAIN. Since there is no handler defined for this exception in this TRY control structure, the exception is propagated from the method. This is made possible by the declaration of the superclass CX\_SY\_ARITHMETIC\_ERROR using RAISING in the method interface. The CLEANUP block of the inner TRY control structure is executed first.

-   Any other exceptions are handled in the final CATCH block of the TRY control structure of the master program. This block catches all possible exceptions by specifying the most general exception class, CX\_ROOT. If, for example, CX\_SY\_ARG\_OUT\_OF\_DOMAIN or one of its superclasses is not declared in the method interface, the exception CX\_SY\_NO\_HANDLER would be raised and would be handled in the final CATCH block.


### abencatch_exception_abexa.htm

---
title: "Exceptions, CATCH"
description: |
  This example demonstrates how class-based exceptions are caught. Source Code REPORT demo_catch_exception. DATA(in) = cl_demo_input=>new( ). DATA: resumable     TYPE abap_bool VALUE abap_false, before_unwind TYPE abap_bool VALUE abap_false, resume        TYPE abap_bool VALUE abap_false. in
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencatch_exception_abexa.htm"
abapFile: "abencatch_exception_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "catch", "method", "class", "data", "exception-handling", "abencatch", "exception", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, CATCH

This example demonstrates how class-based exceptions are caught.

Source Code

REPORT demo\_catch\_exception.
DATA(in) = cl\_demo\_input=>new( ).
DATA: resumable     TYPE abap\_bool VALUE abap\_false,
      before\_unwind TYPE abap\_bool VALUE abap\_false,
      resume        TYPE abap\_bool VALUE abap\_false.
in->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RAISE RESUMABLE'
               CHANGING  field = resumable
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'CATCH BEFORE UNWIND'
               CHANGING  field = before\_unwind
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RESUME'
               CHANGING  field = resume
)->request( ).
CLASS lcx\_exception DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS exc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS: main,
      meth1 RAISING lcx\_exception,
      meth2 RAISING RESUMABLE(lcx\_exception).
ENDCLASS.
FIELD-SYMBOLS <fs> TYPE any.
CLASS exc\_demo IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    DATA exc TYPE REF TO lcx\_exception.
    IF before\_unwind = abap\_false.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH lcx\_exception.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ELSEIF before\_unwind = abap\_true.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH BEFORE UNWIND lcx\_exception INTO exc.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
          IF resume = abap\_true.
            IF exc->is\_resumable = abap\_true.
              RESUME.
            ELSE.
              out->write( 'Resumption not possible' ).
            ENDIF.
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ENDIF.
    out->display( ).
  ENDMETHOD.
  METHOD meth1.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising non-resumable exception' ).
        RAISE EXCEPTION TYPE lcx\_exception.
        out->write( 'Never executed' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
  METHOD meth2.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising resumable exception' ).
        RAISE RESUMABLE EXCEPTION TYPE lcx\_exception.
        out->write( 'Resuming method' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  exc\_demo=>main( ).

Description

The method meth1 raises a non-resumable exception and the method meth2 raises a resumable exception that is handled in the TRY control structures of the method main using CATCH.

-   If handled without BEFORE UNWIND, the CLEANUP block is executed in both cases before handling and the context of the called method does not exist during handling.

-   If handled with BEFORE UNWIND, the context of the called method exists in both cases during handling and the CLEANUP block is executed after handling.

-   When a resumable exception is raised, the statement RESUME can be executed during handling. This statement makes sure that processing in the called method is continued without its CLEANUP block being executed.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Class-Based Exceptions / Examples of Exceptions

Included pages: 4


### abenexception_abexas.htm

---
title: "Examples of Exceptions"
description: |
  !Example(exa.gif 'Example') Exceptions, RAISE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm) !Example(exa.gif 'Example') Exceptions, TRY(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm) !Example(exa.gif 'Example') Exceptions, C
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm"
abapFile: "abenexception_abexas.htm"
keywords: ["do", "if", "try", "catch", "class", "exception-handling", "abenexception", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) → 

Examples of Exceptions

Continue
![Example](exa.gif "Example") [Exceptions, RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm)
![Example](exa.gif "Example") [Exceptions, TRY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm)
![Example](exa.gif "Example") [Exceptions, CATCH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencatch_exception_abexa.htm)


### abenraise_abexa.htm

---
title: "Exceptions, RAISE"
description: |
  This example demonstrates the statement RAISE EXCEPTION. Source Code REPORT demo_raise_exception. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: oref    TYPE REF TO cx_demo_constructor, text     TYPE string, position TYPE i. TRY
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_abexa.htm"
abapFile: "abenraise_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "exception-handling", "abenraise", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, RAISE

This example demonstrates the statement RAISE EXCEPTION.

Source Code

REPORT demo\_raise\_exception.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: oref    TYPE REF TO cx\_demo\_constructor,
          text     TYPE string,
          position TYPE i.
    TRY.
        TRY.
            RAISE EXCEPTION TYPE cx\_demo\_constructor
              EXPORTING
                my\_text = sy-repid.
          CATCH cx\_demo\_constructor INTO oref.
            text = oref->get\_text( ).
            oref->get\_source\_position(
              IMPORTING  source\_line  = position ).
            cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
            RAISE EXCEPTION oref.
        ENDTRY.
      CATCH cx\_demo\_constructor INTO oref.
        text = oref->get\_text( ).
        oref->get\_source\_position(
          IMPORTING source\_line  = position ).
        cl\_demo\_output=>WRITE\_text( |{ position } { text }| ).
    ENDTRY.
    cl\_demo\_output=>display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the two variants of the statement RAISE EXCEPTION. The first statement raises an exception of the class CX\_DEMO\_CONSTRUCTOR in the inner TRY block, creates the relevant object, and passes the program name to the instance constructor. The inner CATCH block handles the exception, provides the exception text, and raises the exception again without creating a new object. The outer CATCH block handles the exception again. The CX\_DEMO\_CONSTRUCTOR class is defined in such a way that the passed program name appears in the exception text. The generated instance constructor takes care of this.

The line number in which the exception was raised is shown to indicate that, when the existing exception object was reused, information relevant to this object was modified.


### abentry_abexa.htm

---
title: "Exceptions, TRY"
description: |
  This example demonstrates the TRY control structure. Source Code REPORT demo_try. CLASS try_demo DEFINITION. PUBLIC SECTION. CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2, oref   TYPE REF TO cx_root, text   TYPE string. CLASS-METHODS main. PRIVATE SECTION. CLASS-DATA number TYPE i. CLASS-DATA out
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentry_abexa.htm"
abapFile: "abentry_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "exception-handling", "abentry", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, TRY

This example demonstrates the TRY control structure.

Source Code

REPORT demo\_try.
CLASS try\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA: result TYPE p LENGTH 8 DECIMALS 2,
                oref   TYPE REF TO cx\_root,
                text   TYPE string.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA number TYPE i.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS calculation
      IMPORTING  p\_number LIKE number
      CHANGING p\_result LIKE result
               p\_text   LIKE text
      RAISING  cx\_sy\_arithmetic\_error.
ENDCLASS.
CLASS try\_demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_input=>request( CHANGING field = number ).
    out = cl\_demo\_output=>new( ).
    TRY.
        IF abs( number ) > 100.
          RAISE EXCEPTION TYPE cx\_demo\_abs\_too\_large.
        ENDIF.
        calculation( EXPORTING p\_number = number
                     CHANGING  p\_result = result
                               p\_text   = text ).
      CATCH cx\_sy\_arithmetic\_error INTO oref.
        text = oref->get\_text( ).
      CATCH cx\_root INTO oref.
        text = oref->get\_text( ).
    ENDTRY.
    IF NOT text IS INITIAL.
      out->write( text ).
    ENDIF.
    out->display( |Final result: { result ALIGN = LEFT }| ).
  ENDMETHOD.
  METHOD calculation.
    DATA l\_oref TYPE REF TO cx\_root.
    TRY.
        p\_result =  1 / p\_number.
        out->write(
          |Result of division: { p\_result ALIGN = LEFT }| ).
        p\_result = sqrt( p\_number ).
        out->write(
          |Result of square root: { p\_result ALIGN = LEFT }| ).
      CATCH cx\_sy\_zerodivide INTO l\_oref.
        p\_text = l\_oref->get\_text( ).
      CLEANUP.
        CLEAR p\_result.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  try\_demo=>main( ).

Description

-   If the content of number is greater than 100, the TRY control structure of the [master program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenframe_program_glosry.htm "Glossary Entry") raises an exception of the class CX\_DEMO\_ABS\_TOO\_LARGE in the TRY block. This exception is handled by the second CATCH block of the same TRY control structure, since the subclass of the most general exception is CX\_ROOT.

-   If the content of number is 0, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ZERODIVIDE. This is handled in the CATCH block of the same TRY control structure.

-   If the content of number is a negative number, the runtime environment in the TRY block of the TRY control structure of the called method calculation raises an exception of the predefined class CX\_SY\_ARG\_OUT\_OF\_DOMAIN. Since there is no handler defined for this exception in this TRY control structure, the exception is propagated from the method. This is made possible by the declaration of the superclass CX\_SY\_ARITHMETIC\_ERROR using RAISING in the method interface. The CLEANUP block of the inner TRY control structure is executed first.

-   Any other exceptions are handled in the final CATCH block of the TRY control structure of the master program. This block catches all possible exceptions by specifying the most general exception class, CX\_ROOT. If, for example, CX\_SY\_ARG\_OUT\_OF\_DOMAIN or one of its superclasses is not declared in the method interface, the exception CX\_SY\_NO\_HANDLER would be raised and would be handled in the final CATCH block.


### abencatch_exception_abexa.htm

---
title: "Exceptions, CATCH"
description: |
  This example demonstrates how class-based exceptions are caught. Source Code REPORT demo_catch_exception. DATA(in) = cl_demo_input=>new( ). DATA: resumable     TYPE abap_bool VALUE abap_false, before_unwind TYPE abap_bool VALUE abap_false, resume        TYPE abap_bool VALUE abap_false. in
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencatch_exception_abexa.htm"
abapFile: "abencatch_exception_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "catch", "method", "class", "data", "exception-handling", "abencatch", "exception", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm) →  [Examples of Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexception_abexas.htm) → 

Exceptions, CATCH

This example demonstrates how class-based exceptions are caught.

Source Code

REPORT demo\_catch\_exception.
DATA(in) = cl\_demo\_input=>new( ).
DATA: resumable     TYPE abap\_bool VALUE abap\_false,
      before\_unwind TYPE abap\_bool VALUE abap\_false,
      resume        TYPE abap\_bool VALUE abap\_false.
in->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RAISE RESUMABLE'
               CHANGING  field = resumable
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'CATCH BEFORE UNWIND'
               CHANGING  field = before\_unwind
)->add\_field( EXPORTING as\_checkbox = 'X'
                         text = 'RESUME'
               CHANGING  field = resume
)->request( ).
CLASS lcx\_exception DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS exc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA out TYPE REF TO if\_demo\_output.
    CLASS-METHODS: main,
      meth1 RAISING lcx\_exception,
      meth2 RAISING RESUMABLE(lcx\_exception).
ENDCLASS.
FIELD-SYMBOLS <fs> TYPE any.
CLASS exc\_demo IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    DATA exc TYPE REF TO lcx\_exception.
    IF before\_unwind = abap\_false.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH lcx\_exception.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ELSEIF before\_unwind = abap\_true.
      TRY.
          out->write( 'Trying method call' ).
          IF resumable = abap\_false.
            exc\_demo=>meth1( ).
          ELSEIF resumable = abap\_true.
            exc\_demo=>meth2( ).
          ENDIF.
        CATCH BEFORE UNWIND lcx\_exception INTO exc.
          IF <fs> IS ASSIGNED.
            out->write( 'Context of method available' ).
          ELSE.
            out->write( 'Context of method not available' ).
          ENDIF.
          IF resume = abap\_true.
            IF exc->is\_resumable = abap\_true.
              RESUME.
            ELSE.
              out->write( 'Resumption not possible' ).
            ENDIF.
          ENDIF.
      ENDTRY.
      out->write( 'Continue after main TRY block' ).
    ENDIF.
    out->display( ).
  ENDMETHOD.
  METHOD meth1.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising non-resumable exception' ).
        RAISE EXCEPTION TYPE lcx\_exception.
        out->write( 'Never executed' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
  METHOD meth2.
    DATA loc TYPE i.
    ASSIGN loc TO <fs>.
    TRY.
        out->write( 'Raising resumable exception' ).
        RAISE RESUMABLE EXCEPTION TYPE lcx\_exception.
        out->write( 'Resuming method' ).
      CLEANUP.
        out->write( 'Cleanup in method' ).
    ENDTRY.
    out->write( 'Continue after TRY block in method' ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  exc\_demo=>main( ).

Description

The method meth1 raises a non-resumable exception and the method meth2 raises a resumable exception that is handled in the TRY control structures of the method main using CATCH.

-   If handled without BEFORE UNWIND, the CLEANUP block is executed in both cases before handling and the context of the called method does not exist during handling.

-   If handled with BEFORE UNWIND, the context of the called method exists in both cases during handling and the CLEANUP block is executed after handling.

-   When a resumable exception is raised, the statement RESUME can be executed during handling. This statement makes sure that processing in the called method is continued without its CLEANUP block being executed.


---


## ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Exceptions Before Class-Based Exceptions

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Program Flow Logic / Exception Handling / Exceptions Before Class-Based Exceptions

Included pages: 5


### abenexceptions_pre_610.htm

---
title: "Exceptions Before Class-Based Exceptions"
description: |
  Exceptions are class-based(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm). Before the introduction of exception classes, there were the following types of exceptions: -   Exception situations detected by the system (and whose causes could be handled effectively by t
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_pre_610.htm"
abapFile: "abenexceptions_pre_610.htm"
keywords: ["do", "if", "try", "catch", "method", "class", "types", "exception-handling", "abenexceptions", "pre", "610"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) → 

Exceptions Before Class-Based Exceptions

Exceptions are [class-based](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions.htm). Before the introduction of exception classes, there were the following types of exceptions:

-   Exception situations detected by the system (and whose causes could be handled effectively by the program) raised [catchable runtime errors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem-exceptions.htm) that could be handled by the statement [CATCH SYSTEM-EXCEPTIONS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcatch_sys.htm). Catchable runtime errors are now obsolete. Each catchable runtime error is assigned an exception class instead, which is handled in a [TRY block](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptry.htm). Conversely, not all predefined class-based exceptions are assigned to a catchable runtime error. No new catchable runtime errors are created and existing runtime errors that are to be made handleable are no longer transformed to catchable runtime errors. Instead, exception classes are assigned to them.

-   [Self-defined handleable exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_non_class.htm) were allowed only in the interfaces of function modules and methods. These types of exceptions can be raised within the [procedure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocedure_glosry.htm "Glossary Entry") by the statement [RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception.htm) or [MESSAGE RAISING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_raising.htm) as soon as an exception situation is detected. The caller of the procedure can use the addition EXCEPTIONS of the statement [CALL FUNCTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function.htm) or [meth( ... )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_static_short.htm) to assign return codes for the system field sy-subrc to the exceptions the caller wants to handle and evaluate them after the call. However, this is not true exception handling in the sense of reacting to an event.

Interaction of the Exception Concepts

The class-based exceptions replace and enhance the previous concepts in full. Class-based exceptions can be raised and handled in all ABAP contexts (programs, processing blocks). In particular, all previously catchable runtime errors can be handled as class-based exceptions, with the previous exception groups being mapped to shared superclasses. For reasons of downward-compatibility, the catchable runtime errors and the non-class-based exceptions defined in the interfaces of methods and function modules have not been abolished, but their use has been restricted as follows:

-   Within a [processing block](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocessing_block_glosry.htm "Glossary Entry"), only one kind of exception can be raised.

-   Within a procedure interface, the declaration of class-based exceptions and the definition of non-class-based exceptions exclude one another.

-   Within a processing block, catchable runtime errors cannot be caught using [CATCH SYSTEM-EXCEPTIONS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcatch_sys.htm) if class-based exceptions are handled there in [TRY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptry.htm) blocks or are raised using [RAISE EXCEPTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception.htm) or the addition [THROW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expression_result.htm) in a [conditional expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expressions.htm). Instead, catchable runtime errors must be caught when handling the associated class-based exception.

For reasons of interoperability, class-based exceptions can be handled within a processing block and return codes of function modules and methods evaluated there using non-class-based exceptions.

Continue
[Non-Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_non_class.htm)


### abenexceptions_non_class.htm

---
title: "Non-Class-Based Exceptions"
description: |
  Definition Non-class-based exceptions can be defined in the interfaces of function modules and methods. These exceptions are defined as follows: -   In methods of local classes, by assigning a name for the exception after the addition EXCEPTIONS(https://help.sap.com/doc/abapdocu_754_index_htm/7.54
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_non_class.htm"
abapFile: "abenexceptions_non_class.htm"
keywords: ["select", "do", "if", "try", "method", "class", "exception-handling", "abenexceptions", "non"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Exceptions Before Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_pre_610.htm) → 

Non-Class-Based Exceptions

Definition

Non-class-based exceptions can be defined in the interfaces of function modules and methods. These exceptions are defined as follows:

-   In methods of local classes, by assigning a name for the exception after the addition [EXCEPTIONS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_general.htm) of the statement [*\[*CLASS-*\]*](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass-methods.htm)[METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm).

-   In methods of global classes or function modules, by assigning a name for the exception in [Class Builder](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_builder_glosry.htm "Glossary Entry") or [Function Builder](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunction_builder_glosry.htm "Glossary Entry"). Here, the radio button for exception classes is not selected.

The statement [RAISE EXCEPTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_class.htm) or the addition [THROW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expression_result.htm) in a [conditional expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expressions.htm) cannot be used to raise class-based exceptions in a method or a function module in whose interface non-class-based exceptions are defined.

Note

Before class-based exceptions were introduced, all exceptions defined in the interface of methods of global classes or function modules were non-class-based.

Raising

Non-class-based exceptions are raised by the following statements:

-   [RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception.htm)

-   [MESSAGE ... RAISING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_raising.htm)

Handling

The handling of non-class-based exceptions is made possible by the addition EXCEPTIONS in [method calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmethod_calls.htm) and [function module calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function.htm). Number values are assigned to the exceptions and are used to fill the system field sy-subrc when the exception is raised. The actual error handling takes place after the call, when sy-subrc is evaluated.

Programming Guideline

[Using Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_exception_guidl.htm "Guideline")

Notes

-   The exceptions that can be defined in the interfaces of methods and function modules are not real exceptions, since they do not modify the control flow and they just end the processing of the [procedure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocedure_glosry.htm "Glossary Entry") prematurely and set the return code sy-subrc instead.

-   [RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_glosry.htm "Glossary Entry") currently allows only classic exception handling. Class-based exception handling is only possible in a different release track.

Continue
[RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception.htm)
[MESSAGE - RAISING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_raising.htm)


### abapraise_exception.htm

---
title: "RAISE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_shortref.htm) Syntax RAISE exception. Effect This statement raises the non-class-based exception(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_non_class.htm) exception. -   RAISE can
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception.htm"
abapFile: "abapraise_exception.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "exception-handling", "abapraise", "exception"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Exceptions Before Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_pre_610.htm) →  [Non-Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_non_class.htm) → 

RAISE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_shortref.htm)

Syntax

RAISE exception.

Effect

This statement raises the [non-class-based exception](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_non_class.htm) exception.

-   RAISE can be specified in a method only if the non-class-based exception is defined in the interface of the method.
    
-   Specify RAISE in function modules only if the non-class-based exception is defined in the interface of the function module.
    
-   It is possible to specify RAISE in all other positions, but this is not recommended.
    

After the exception exception is raised, the system proceeds as follows:

-   If the exception is raised in a method or function module whose caller assigns a return value to the exception, the [procedure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocedure_glosry.htm "Glossary Entry") ends immediately, the system returns to the calling position, and the system field sy-subrc is set according to the assignment.
    
-   If the exception is raised in a method or function module whose caller does not assign a return value to the exception, a runtime error is then triggered whose [short dump](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshort_dump_glosry.htm "Glossary Entry") contains the name of the exception.
    
-   If the exception is raised in a subroutine, the system searches for the first function module in the procedures of the preceding call stack. If it finds a function module of this type and the exception is defined in it, the system acts as though the exception was raised in this function module. Otherwise, a runtime error occurs.
    
-   In all other processing blocks, raising a non class-based exception produces a runtime error that immediately ends the program.
    

This form of the statement RAISE cannot be used in the same [processing block](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocessing_block_glosry.htm "Glossary Entry") as the statement [RAISE EXCEPTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_class.htm) or the addition [THROW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expression_result.htm) in a [conditional expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expressions.htm) to raise class-based exceptions.

Notes

-   The statement MESSAGE with the addition [RAISING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_raising.htm) also raises a non-class-based exception. In cases in which non-class-based exceptions are still used, this statement is preferred instead of RAISE, because it offers the option of adding a text to the exception.
    
-   If a [procedure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocedure_glosry.htm "Glossary Entry") is exited by raising an exception, the content of the formal parameter for which the [pass by value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpass_by_value_glosry.htm "Glossary Entry") is defined is not assigned to the respective actual parameters.
    

Example

Raising a non-class-based exception in a method.

CLASS cls DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS meth EXCEPTIONS exc.
ENDCLASS.
CLASS cls IMPLEMENTATION.
  METHOD meth.
    ...
    RAISE exc.
    ...
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  cls=>meth( EXCEPTIONS exc = 4 ).
  CASE sy-subrc.
    WHEN 4.
      cl\_demo\_output=>display( 'Exception' ).
    WHEN OTHERS.
      ...
  ENDCASE.

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Non-Handleable Exceptions

-   Cause: The raised exception was not handled by the caller.
    Runtime error: RAISE\_EXCEPTION


### abapmessage_raising.htm

---
title: "MESSAGE - RAISING"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_shortref.htm) Syntax MESSAGE  msg(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_msg.htm)  text(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_text.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_raising.htm"
abapFile: "abapmessage_raising.htm"
keywords: ["do", "if", "case", "try", "method", "class", "types", "exception-handling", "abapmessage", "raising"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Exceptions Before Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_pre_610.htm) →  [Non-Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_non_class.htm) → 

MESSAGE - RAISING

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_shortref.htm)

Syntax

MESSAGE *{* [msg](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_msg.htm) *|* [text](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_text.htm) *}* [*\[*DISPLAY LIKE dtype*\]*](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage.htm) [*\[*WITH dobj1... dobj4*\]*](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage.htm)
        RAISING exception.

Effect

The statement [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage.htm) with the addition RAISING raises a non-class-based exception exception and only sends a message if the exception is not handled. The semantics of [msg](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_msg.htm), [text](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_text.htm), and [WITH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage.htm) is the same as in the statement MESSAGE without the addition RAISING.

This addition only makes sense during the processing of methods and function modules in which the non-class-based exception exception is defined. Furthermore, it cannot be used in the same [processing block](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocessing_block_glosry.htm "Glossary Entry") as the statement RAISE EXCEPTION or the addition [THROW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expression_result.htm) in a [conditional expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expressions.htm) to raise class-based exceptions.

-   If the MESSAGE statement is executed with the addition RAISING during processing of a method or a function module, and the caller of the method or function module assigns a return code to the [exception](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_non_class.htm) exception using the addition EXCEPTIONS of the statement CALL, the statement works in the same way as the statement [RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception.htm).
    
-   If no return code is assigned to the exception exception, the addition RAISING is ignored and the message is sent using the statement [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage.htm) and [processed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messages_types.htm) in accordance with its [message type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_type_glosry.htm "Glossary Entry").
    

The system fields of the statement MESSAGE are filled in both cases and are available in the calling program after an exception raised using MESSAGE ...RAISING is handled. This is especially true if a function module was called using Remote Function Call ([RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenremote_function_call_glosry.htm "Glossary Entry")).

Notes

-   The statement MESSAGE ... RAISING is primarily a statement for raising exceptions and not for sending messages. An exception of this type should always be handled like an exception raised using RAISE, since the behavior of the message depends strongly on the context and is usually unpredictable when the function module is created.
    
-   Using MESSAGE ... RAISING in cases in which non class-based exceptions must still be used is preferable to using the RAISE statement, because it offers the option of providing additional text information with an exception.
    
-   A return code can be assigned to messages that are sent in function modules without the addition RAISING by using the predefined exception [error\_message](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_parameter.htm).
    
-   Messages sent as messages when a function module is called and not caught (despite RAISING) are processed as with [error\_message](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_parameter.htm).
    
-   If a [procedure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocedure_glosry.htm "Glossary Entry") is exited by raising an exception, the content of the formal parameter for which the [pass by value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpass_by_value_glosry.htm "Glossary Entry") is defined is not assigned to the respective actual parameters.
    

Example

When the message is called for the first time, an [information message](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninformation_message_glosry.htm "Glossary Entry") is sent. The second time, an exception is raised instead, which is handled by sy-subrc.

     CLASS c1 DEFINITION.
       PUBLIC SECTION.
         CLASS-METHODS m1 EXCEPTIONS exc1.
     ENDCLASS.
     CLASS c1 IMPLEMENTATION.
       METHOD m1.
         MESSAGE 'Message in a Method' TYPE 'I' RAISING exc1.
       ENDMETHOD.
     ENDCLASS.
     ...
       c1=>m1( ).
       c1=>m1( EXCEPTIONS exc1 = 4 ).
     IF sy-subrc = 4.
       ...
     ENDIF.


### abenexceptions_non_class.htm

---
title: "Non-Class-Based Exceptions"
description: |
  Definition Non-class-based exceptions can be defined in the interfaces of function modules and methods. These exceptions are defined as follows: -   In methods of local classes, by assigning a name for the exception after the addition EXCEPTIONS(https://help.sap.com/doc/abapdocu_754_index_htm/7.54
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_non_class.htm"
abapFile: "abenexceptions_non_class.htm"
keywords: ["select", "do", "if", "try", "method", "class", "exception-handling", "abenexceptions", "non"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Program Flow Logic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_flow_logic.htm) →  [Exception Handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_exceptions.htm) →  [Exceptions Before Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_pre_610.htm) → 

Non-Class-Based Exceptions

Definition

Non-class-based exceptions can be defined in the interfaces of function modules and methods. These exceptions are defined as follows:

-   In methods of local classes, by assigning a name for the exception after the addition [EXCEPTIONS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods_general.htm) of the statement [*\[*CLASS-*\]*](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclass-methods.htm)[METHODS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmethods.htm).

-   In methods of global classes or function modules, by assigning a name for the exception in [Class Builder](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_builder_glosry.htm "Glossary Entry") or [Function Builder](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunction_builder_glosry.htm "Glossary Entry"). Here, the radio button for exception classes is not selected.

The statement [RAISE EXCEPTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_class.htm) or the addition [THROW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expression_result.htm) in a [conditional expression](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expressions.htm) cannot be used to raise class-based exceptions in a method or a function module in whose interface non-class-based exceptions are defined.

Note

Before class-based exceptions were introduced, all exceptions defined in the interface of methods of global classes or function modules were non-class-based.

Raising

Non-class-based exceptions are raised by the following statements:

-   [RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception.htm)

-   [MESSAGE ... RAISING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_raising.htm)

Handling

The handling of non-class-based exceptions is made possible by the addition EXCEPTIONS in [method calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmethod_calls.htm) and [function module calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function.htm). Number values are assigned to the exceptions and are used to fill the system field sy-subrc when the exception is raised. The actual error handling takes place after the call, when sy-subrc is evaluated.

Programming Guideline

[Using Class-Based Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_exception_guidl.htm "Guideline")

Notes

-   The exceptions that can be defined in the interfaces of methods and function modules are not real exceptions, since they do not modify the control flow and they just end the processing of the [procedure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocedure_glosry.htm "Glossary Entry") prematurely and set the return code sy-subrc instead.

-   [RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_glosry.htm "Glossary Entry") currently allows only classic exception handling. Class-based exception handling is only possible in a different release track.

Continue
[RAISE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception.htm)
[MESSAGE - RAISING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_raising.htm)


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversion Rules for Elementary Data Objects / Numeric Source Fields

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversions - Performance Notes

Included pages: 2


### abenconversion_perfo.htm

---
title: "Conversions - Performance Notes"
description: |
  Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type shou
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_perfo.htm"
abapFile: "abenconversion_perfo.htm"
keywords: ["do", "if", "data", "types", "abenconversion", "perfo"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assignment and Conversion Rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_rules.htm) → 

Conversions - Performance Notes

Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type should be assigned to one another.

Executable Example

[Conversion Costs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm)

Continue
![Example](exa.gif "Example") [Conversion Costs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm)


### abenconversion_costs_abexa.htm

---
title: "Conversion Costs"
description: |
  This example demonstrates costs for type conversions in assignments and operand positions. Source Code REPORT demo_conversion_costs. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: num   TYPE n LENGTH 10, int   TYPE i, itab  TYPE S
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm"
abapFile: "abenconversion_costs_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenconversion", "costs", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assignment and Conversion Rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_rules.htm) →  [Conversions - Performance Notes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_perfo.htm) → 

Conversion Costs

This example demonstrates costs for type conversions in assignments and operand positions.

Source Code

REPORT demo\_conversion\_costs.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: num   TYPE n LENGTH 10,
          int   TYPE i,
          itab  TYPE STANDARD TABLE OF i,
          t1    TYPE i,
          t2    TYPE i,
          toff  TYPE i,
          tn    TYPE i,
          ti    TYPE i,
          msg   TYPE string.
    CONSTANTS n TYPE i VALUE 100000.
    GET RUN TIME FIELD t1.
    DO n TIMES.
    ENDDO.
    GET RUN TIME FIELD t2.
    toff = t2 - t1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      num = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      int = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>write(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).
    itab = VALUE #( ( 1 ) ).
    CLEAR: tn, ti.
    num = '1'.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX num.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    int = 1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX int.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>display(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The program calculates the relationship between the costs of a conversion from type n to i and the costs of a direct memory copy from type i to i. The conversion is much slower than the unconverted copy, which can be seen directly in the assignment. The difference is not so clear in an operand position (here when specifying the index of a READ statement). This is because the conversion costs are not as high as for a table access.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversion Rules for Elementary Data Objects / Character-Like Source Fields

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversions - Performance Notes

Included pages: 2


### abenconversion_perfo.htm

---
title: "Conversions - Performance Notes"
description: |
  Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type shou
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_perfo.htm"
abapFile: "abenconversion_perfo.htm"
keywords: ["do", "if", "data", "types", "abenconversion", "perfo"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assignment and Conversion Rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_rules.htm) → 

Conversions - Performance Notes

Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type should be assigned to one another.

Executable Example

[Conversion Costs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm)

Continue
![Example](exa.gif "Example") [Conversion Costs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm)


### abenconversion_costs_abexa.htm

---
title: "Conversion Costs"
description: |
  This example demonstrates costs for type conversions in assignments and operand positions. Source Code REPORT demo_conversion_costs. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: num   TYPE n LENGTH 10, int   TYPE i, itab  TYPE S
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm"
abapFile: "abenconversion_costs_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenconversion", "costs", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assignment and Conversion Rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_rules.htm) →  [Conversions - Performance Notes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_perfo.htm) → 

Conversion Costs

This example demonstrates costs for type conversions in assignments and operand positions.

Source Code

REPORT demo\_conversion\_costs.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: num   TYPE n LENGTH 10,
          int   TYPE i,
          itab  TYPE STANDARD TABLE OF i,
          t1    TYPE i,
          t2    TYPE i,
          toff  TYPE i,
          tn    TYPE i,
          ti    TYPE i,
          msg   TYPE string.
    CONSTANTS n TYPE i VALUE 100000.
    GET RUN TIME FIELD t1.
    DO n TIMES.
    ENDDO.
    GET RUN TIME FIELD t2.
    toff = t2 - t1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      num = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      int = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>write(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).
    itab = VALUE #( ( 1 ) ).
    CLEAR: tn, ti.
    num = '1'.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX num.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    int = 1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX int.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>display(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The program calculates the relationship between the costs of a conversion from type n to i and the costs of a direct memory copy from type i to i. The conversion is much slower than the unconverted copy, which can be seen directly in the assignment. The difference is not so clear in an operand position (here when specifying the index of a READ statement). This is because the conversion costs are not as high as for a table access.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversion Rules for Elementary Data Objects / Byte-Like Source Fields

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversions - Performance Notes

Included pages: 2


### abenconversion_perfo.htm

---
title: "Conversions - Performance Notes"
description: |
  Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type shou
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_perfo.htm"
abapFile: "abenconversion_perfo.htm"
keywords: ["do", "if", "data", "types", "abenconversion", "perfo"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assignment and Conversion Rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_rules.htm) → 

Conversions - Performance Notes

Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type should be assigned to one another.

Executable Example

[Conversion Costs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm)

Continue
![Example](exa.gif "Example") [Conversion Costs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm)


### abenconversion_costs_abexa.htm

---
title: "Conversion Costs"
description: |
  This example demonstrates costs for type conversions in assignments and operand positions. Source Code REPORT demo_conversion_costs. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: num   TYPE n LENGTH 10, int   TYPE i, itab  TYPE S
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm"
abapFile: "abenconversion_costs_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenconversion", "costs", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assignment and Conversion Rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_rules.htm) →  [Conversions - Performance Notes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_perfo.htm) → 

Conversion Costs

This example demonstrates costs for type conversions in assignments and operand positions.

Source Code

REPORT demo\_conversion\_costs.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: num   TYPE n LENGTH 10,
          int   TYPE i,
          itab  TYPE STANDARD TABLE OF i,
          t1    TYPE i,
          t2    TYPE i,
          toff  TYPE i,
          tn    TYPE i,
          ti    TYPE i,
          msg   TYPE string.
    CONSTANTS n TYPE i VALUE 100000.
    GET RUN TIME FIELD t1.
    DO n TIMES.
    ENDDO.
    GET RUN TIME FIELD t2.
    toff = t2 - t1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      num = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      int = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>write(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).
    itab = VALUE #( ( 1 ) ).
    CLEAR: tn, ti.
    num = '1'.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX num.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    int = 1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX int.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>display(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The program calculates the relationship between the costs of a conversion from type n to i and the costs of a direct memory copy from type i to i. The conversion is much slower than the unconverted copy, which can be seen directly in the assignment. The difference is not so clear in an operand position (here when specifying the index of a READ statement). This is because the conversion costs are not as high as for a table access.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversion Rules for Elementary Data Objects / Date fields, time fields, and time stamp fields as source fields

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assignment and Conversion Rules / Conversions - Performance Notes

Included pages: 2


### abenconversion_perfo.htm

---
title: "Conversions - Performance Notes"
description: |
  Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type shou
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_perfo.htm"
abapFile: "abenconversion_perfo.htm"
keywords: ["do", "if", "data", "types", "abenconversion", "perfo"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assignment and Conversion Rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_rules.htm) → 

Conversions - Performance Notes

Conversions in assignments between data objects with different data types, or specifying a data object in an operand position where a different data type is expected, produce runtime costs. To avoid these costs, conversions should be avoided where possible and only data objects of the same type should be assigned to one another.

Executable Example

[Conversion Costs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm)

Continue
![Example](exa.gif "Example") [Conversion Costs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm)


### abenconversion_costs_abexa.htm

---
title: "Conversion Costs"
description: |
  This example demonstrates costs for type conversions in assignments and operand positions. Source Code REPORT demo_conversion_costs. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: num   TYPE n LENGTH 10, int   TYPE i, itab  TYPE S
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_costs_abexa.htm"
abapFile: "abenconversion_costs_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenconversion", "costs", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assignment and Conversion Rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_rules.htm) →  [Conversions - Performance Notes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_perfo.htm) → 

Conversion Costs

This example demonstrates costs for type conversions in assignments and operand positions.

Source Code

REPORT demo\_conversion\_costs.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: num   TYPE n LENGTH 10,
          int   TYPE i,
          itab  TYPE STANDARD TABLE OF i,
          t1    TYPE i,
          t2    TYPE i,
          toff  TYPE i,
          tn    TYPE i,
          ti    TYPE i,
          msg   TYPE string.
    CONSTANTS n TYPE i VALUE 100000.
    GET RUN TIME FIELD t1.
    DO n TIMES.
    ENDDO.
    GET RUN TIME FIELD t2.
    toff = t2 - t1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      num = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      int = sy-index.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>write(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).
    itab = VALUE #( ( 1 ) ).
    CLEAR: tn, ti.
    num = '1'.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX num.
    ENDDO.
    GET RUN TIME FIELD t2.
    tn = t2 - t1 - toff.
    int = 1.
    GET RUN TIME FIELD t1.
    DO n TIMES.
      READ TABLE itab TRANSPORTING NO FIELDS INDEX int.
    ENDDO.
    GET RUN TIME FIELD t2.
    ti = t2 - t1 - toff.
    cl\_demo\_output=>display(
      |Ratio of conversion to copy during assignment: | &&
      |{ tn / ti DECIMALS = 2 }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The program calculates the relationship between the costs of a conversion from type n to i and the costs of a direct memory copy from type i to i. The conversion is much slower than the unconverted copy, which can be seen directly in the assignment. The difference is not so clear in an operand position (here when specifying the index of a READ statement). This is because the conversion costs are not as high as for a table access.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assigning Structure Components / CL_ABAP_CORRESPONDING - System Class

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Assignments / Assigning Structure Components / CL_ABAP_CORRESPONDING - System Class

Included pages: 4


### abencl_abap_corresponding.htm

---
title: "Continue"
description: |
  CL_ABAP_CORRESPONDING - Simple Assignment(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_1.htm) CL_ABAP_CORRESPONDING - Assignment of Values(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_3.htm) CL_ABAP_CORRESPOND
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding.htm"
abapFile: "abencl_abap_corresponding.htm"
keywords: ["do", "if", "method", "class", "data", "internal-table", "abencl", "abap", "corresponding"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assigning Structure Components](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding.htm) → 

CL\_ABAP\_CORRESPONDING - System Class

The system class CL\_ABAP\_CORRESPONDING enables assignments of components between structures or between internal tables with dynamically specified mapping rules. Methods are available for simple assignments, assignments of default values, and for using a lookup table.

-   [CL\_ABAP\_CORRESPONDING - Simple Assignment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_1.htm)

-   [CL\_ABAP\_CORRESPONDING - Assignment of Default Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_3.htm)

-   [CL\_ABAP\_CORRESPONDING - Lookup Table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_2.htm)

Continue
[CL\_ABAP\_CORRESPONDING - Simple Assignment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_1.htm)
[CL\_ABAP\_CORRESPONDING - Assignment of Values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_3.htm)
[CL\_ABAP\_CORRESPONDING - Lookup Table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_2.htm)


### abencl_abap_corresponding_1.htm

---
title: "The assignment is performed component by component"
description: |
  -   between the components specified in the mapping rule -   between the remaining identically named components at the same level (if not excluded in the mapping rule). In assignments between structures, components of the target structure to which no components of the source structure are assigned k
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_1.htm"
abapFile: "abencl_abap_corresponding_1.htm"
keywords: ["do", "if", "case", "try", "method", "class", "data", "types", "internal-table", "abencl", "abap", "corresponding"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assigning Structure Components](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding.htm) →  [CL\_ABAP\_CORRESPONDING - System Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding.htm) → 

CL\_ABAP\_CORRESPONDING - Simple Assignment

The methods CREATE and EXECUTE of the system class CL\_ABAP\_CORRESPONDING can be used to assigned components between structure or between internal tables with a dynamically specified mapping rule.

The factory method CREATE is used to create a mapping object:

DATA(mapper) = cl\_abap\_corresponding=>create( source                = struct*|*itab
                                              destination           = struct*|*itab
                                              mapping               = mapping\_tab
                                              discarding\_duplicates = flag ).

Structures struct or internal tables itab of the assigned data types must be passed to the parameters source and destination. An internal table of the type CL\_ABAP\_CORRESPONDING=>MAPPING\_TABLE, containing the mapping rule, must be passed to the parameter mapping. If an initial mapping table is passed, only the identically named components are assigned. The mapping table has the following components:

-   LEVEL

Level of the components in the structure or row structure. The value 0 stands for the top level.

-   KIND

Mapping type. The possible values are:

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_COMPONENT (1) (The components specified in this row are mapped to each other.)

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_EXCEPT\_COMPONENT (2) (The component of the source structure specified in this row is excluded from the mapping of identically named components.)

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_EXCEPT\_ALL (3) (All components of the current source structure are excluded from the mapping of identically name components.)

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_DISCARDING\_DUPLICATES (9) (In a source table, duplicate rows are ignored as when using [DISCARDING DUPLICATES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_dupl.htm) in a mapping rule of the component operator. The target table must have a unique table key.)

-   SRCNAME

Component of the source structure.

-   DSTNAME

Component of the target (destination) structure.

The rows of the internal table must be constructed so that they produce a mapping rule in the correct order. Components of the source structure for which no mapping is defined and that were not excluded are assigned to identically named components of the target structure.

The method EXECUTE of a mapping object can be used to perform any number of assignments between structures or internal tables src and dst whose data type matches the source type or target type specified when the object was created:

mapper->execute( EXPORTING source      = src
                 CHANGING  destination = dst ).

The assignment is performed component by component

-   between the components specified in the mapping rule

-   between the remaining identically named components at the same level (if not excluded in the mapping rule).

In assignments between structures, components of the target structure to which no components of the source structure are assigned keep their previous value, like the statement [MOVE-CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmove-corresponding.htm) and like the operator [CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_arg_type.htm) with the addition BASE. Any nested internal tables are always resolved, as when the addition EXPANDING NESTED TABLES is specified in MOVE-CORRESPONDING or the addition DEEP for the operator CORRESPONDING. In assignments between internal tables, the target table is always initialized first. There is no matching addition for the addition KEEPING TARGET LINES in MOVE-CORRESPONDING or BASE in CORRESPONDING.

If the value "X" was passed to the parameter DISCARDING\_DUPLICATES of the method CREATE, duplicate rows are handled in tabular component assignments in the same way as when using the addition [DISCARDING DUPLICATES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_dupl.htm) in the basic form of the component operator. Here, the target table must have a unique table key.

The source and the target may be the same. It should be noted, however, the target object is used directly (like in the statement [MOVE-CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmove-corresponding.htm)) and that no temporary intermediate result is created (unlike with the operator [CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_arg_type.htm)).

Incorrect parameters passed to the methods of the class CL\_ABAP\_CORRESPONDING raised exceptions of the class CX\_CORR\_DYN\_ERROR.

Notes

-   The methods CREATE and EXECUTE of the system class CL\_ABAP\_CORRESPONDING produce an assignment similar to the statement

dst = [CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_arg_type.htm)  #( BASE ( dst ) struct*|*itab [MAPPING ... EXCEPT ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_mapping.htm) ).

Here, the [mapping rule](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_mapping.htm) is specified dynamically, however, as the content of a special internal table.

-   The same restrictions apply as in the operator [CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_arg_type.htm). Components can only be mapped to each other if they are on the same level. Components in a substructure cannot be assigned to the components at higher levels, nor higher level components to components in a substructure.

-   The class CL\_ABAP\_CORRESPONDING always resolves tabular components, which is the same behavior as the operator [CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_arg_type.htm) when a mapping rule is specified. In this case, the addition DEEP is also set implicitly.

-   To achieve the same results for standalone in assignments between structures as in the operator [CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_arg_type.htm) without BASE, an initial structure can be assigned to the parameter destination.

-   In reflexive assignments between components of the same object, it should be noted that (like in [MOVE-CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmove-corresponding.htm)) the editing order is not defined and that a call of the method EXECUTE cannot be used to switch the content of two components. See the executable example [Reflexive Component Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreflexive_corresponding_abexa.htm).

-   The [pseudo component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpseudo_component_glosry.htm "Glossary Entry") table\_line cannot be addressed in the mapping table.

Example

Uses the class CL\_ABAP\_CORRESPONDING for assignments of components to a simple structure. The mapping rule dictates that the components a3 are assigned to b1 and a1 to b3. The component a2 is ignored since there are no identically named components in the target structure and b2 keeps its value. a4 and a5 in the target structure also keep their values, however, even though the source structure contains identically named components. This is because the value of CL\_ABAP\_CORRESPONDING=>MAPPING\_EXCEPT\_ALL is specified for the mapping type for all non-specified components. The executable [example for simple structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corr_dyn_abexa.htm) enables interactive input of the component names that are mapped to each other.

DATA:
  BEGIN OF struct1,
    a1 TYPE string VALUE 'a1',
    a2 TYPE string VALUE 'a2',
    a3 TYPE string VALUE 'a3',
    a4 TYPE string VALUE 'a4',
    a5 TYPE string VALUE 'a5',
  END OF struct1,
  BEGIN OF struct2,
    b1 TYPE string VALUE 'b1',
    b2 TYPE string VALUE 'b2',
    b3 TYPE string VALUE 'b3',
    a4 TYPE string VALUE 'b4',
    a5 TYPE string VALUE 'b5',
  END OF struct2.
DATA(mapper) =
  cl\_abap\_corresponding=>create(
    source            = struct1
    destination       = struct2
    mapping           = VALUE cl\_abap\_corresponding=>mapping\_table(
      ( level = 0 kind = 1 srcname = 'a1' dstname = 'b3' )
      ( level = 0 kind = 1 srcname = 'a3' dstname = 'b1' )
      ( level = 0 kind = 3 ) ) ).
mapper->execute( EXPORTING source      = struct1
                 CHANGING  destination = struct2 ).
cl\_demo\_output=>display( struct2 ).

Executable Examples

-   [CL\_ABAP\_CORRESPONDING for Simple Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corr_dyn_abexa.htm)

-   [CL\_ABAP\_CORRESPONDING for Nested Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corr_struc_abexa.htm)

-   [CL\_ABAP\_CORRESPONDING for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corr_itab_abexa.htm)

-   [CL\_ABAP\_CORRESPONDING for Tabular Components](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corr_deep_abexa.htm)


### abencl_abap_corresponding_3.htm

---
title: "Example"
description: |
  The component b2 is given the value xxx and the component b3 is given the value yyy. The components b1 and b4 are given the values of the associated components a1 and a4 of the source structure. DATA: BEGIN OF struct1, a1 TYPE string VALUE 'a1', a2 TYPE string VALUE 'a2', a3 TYPE string VALUE '  ',
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_3.htm"
abapFile: "abencl_abap_corresponding_3.htm"
keywords: ["do", "if", "method", "class", "data", "internal-table", "abencl", "abap", "corresponding"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assigning Structure Components](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding.htm) →  [CL\_ABAP\_CORRESPONDING - System Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding.htm) → 

CL\_ABAP\_CORRESPONDING - Assignment of Values

The method CREATE\_WITH\_VALUE of the system class CL\_ABAP\_CORRESPONDING has essentially the same function as the method [CREATE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_1.htm). Additionally, the values of any data objects can be assigned to the components of the target structure or target table.

The factory method CREATE\_WITH\_VALUE is used to create a mapping object:

DATA(mapper) =
  cl\_abap\_corresponding=>create\_with\_value( source                = struct*|*itab
                                            destination           = struct*|*itab
                                            mapping               = mapping\_tab
                                            discarding\_duplicates = flag ).

For the parameters source and destination, the same applies as to the method [CREATE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_1.htm). An internal table of the type CL\_ABAP\_CORRESPONDING=>MAPPING\_TABLE\_VALUE, containing the mapping rule, must be passed to the parameter mapping. This mapping table has the same components, with the same meaning, as a mapping table of type [CL\_ABAP\_CORRESPONDING=>MAPPING\_TABLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_1.htm), with an additional column and further values for the column KIND:

-   VALUE

In this column, a reference to a suitable data object can be specified, whose value is assigned to the component of the target structure that is specified in DSTNAME.

-   KIND

The additional values for the mapping type are:

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_VALUE (16), the value specified in VALUE is always assigned. The column SRCNAME must be initial

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_DEFAULT\_VALUE (32), the value specified in VALUE is only assigned if the component specified in the column SRCNAME is initial. The component name in SRCNAME must exist in the source structure.

A mapping object created with CREATE\_WITH\_VALUE is used like a mapping object created with [CREATE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_1.htm) with the method EXECUTE.

Example

The component b2 is given the value xxx and the component b3 is given the value yyy. The components b1 and b4 are given the values of the associated components a1 and a4 of the source structure.

DATA:
  BEGIN OF struct1,
    a1 TYPE string VALUE 'a1',
    a2 TYPE string VALUE 'a2',
    a3 TYPE string VALUE '  ',
    a4 TYPE string VALUE 'a4',
  END OF struct1,
  BEGIN OF struct2,
    b1 TYPE string VALUE 'b1',
    b2 TYPE string VALUE 'b2',
    b3 TYPE string VALUE 'b3',
    b4 TYPE string VALUE 'b4',
  END OF struct2.
DATA(mapper) =
  cl\_abap\_corresponding=>create\_with\_value(
    source            = struct1
    destination       = struct2
    mapping           = VALUE
      cl\_abap\_corresponding=>mapping\_table\_value(
        ( level = 0 kind = 1  srcname = 'a1' dstname = 'b1' )
        ( level = 0 kind = 16                dstname = 'b2'
                                             value = REF #( \`xxx\` ) )
        ( level = 0 kind = 32 srcname = 'a3' dstname = 'b3'
                                             value = REF #( \`yyy\` ) )
        ( level = 0 kind = 32 srcname = 'a4' dstname = 'b4'
                                             value = REF #( \`zzz\` ) )
         ) ).
mapper->execute( EXPORTING source      = struct1
                 CHANGING  destination = struct2 ).
cl\_demo\_output=>display( struct2 ).


### abencl_abap_corresponding_2.htm

---
title: "Notes"
description: |
  -   The methods CREATE_USING and EXECUTE_USING of the system class CL_ABAP_CORRESPONDING produce an assignment similar to the statement dst = CORRESPONDING(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_using.htm) #( dst FROM lookup_tab KEY key_name ... )
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_2.htm"
abapFile: "abencl_abap_corresponding_2.htm"
keywords: ["do", "if", "method", "class", "data", "types", "internal-table", "abencl", "abap", "corresponding"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_assignments.htm) →  [Assigning Structure Components](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding.htm) →  [CL\_ABAP\_CORRESPONDING - System Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding.htm) → 

CL\_ABAP\_CORRESPONDING - Lookup Table

The methods CREATE\_USING and EXECUTE\_USING of the system class CL\_ABAP\_CORRESPONDING can be used to assign components between internal tables with a dynamically specified mapping rule. The source table is used as a lookup table.

The factory method CREATE\_USING is used to create a mapping object:

DATA(mapper) = cl\_abap\_corresponding=>create\_using( destination = itab
                                                    using       = lookup\_tab
                                                    mapping     = mapping\_tab ).

Internal tables itab and lookup\_table, with the table types to which the assignment applies, must be passed to the parameters destination and using. An internal table of the type CL\_ABAP\_CORRESPONDING=>MAPPING\_TABLE, containing the mapping rule, must be passed to the parameter mapping. The mapping table has the same components as the methods for [simple assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_1.htm) with the following special semantics:

-   KIND

Mapping type. The additional possible values are:

-   CL\_ABAP\_CORRESPONDING=>USING\_KEY (4), the table key of the lookup table used for the evaluation is specified in the component SRCNAME in this row. The table must contain a row like this.

-   CL\_ABAP\_CORRESPONDING=>MAPPING\_USING\_COMPONENT (5), the name of a column of the lookup table in SRCNAME is associated with the name of a column of the target table in DSTNAME in a row like this. All key fields of the table key used must be covered by a row like this.

The mapping types for [simple assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_1.htm) can also be used and have the same semantics as described here.

The method EXECUTE\_USING of a mapping object can be used to perform any number of assignments between tables lookup\_src and dst whose data type matches the source type or target type lookup\_tab or itab specified when the object was created:

mapper->execute\_using( EXPORTING using       = lookup\_src
                       CHANGING  destination = dst ).

For each row in dst, a row is found in the lookup table lookup\_src that matches this row in accordance with the relationship defined using the mapping type CL\_ABAP\_CORRESPONDING=>MAPPING\_USING\_COMPONENT in the mapping table. If the key is not unique, the first row found is used. If no row like this is found, the row from dst remains unchanged. If a row like this is found in lookup\_src, it is assigned to the row from dst in accordance with the rules of [MOVE-CORRESPONDING for structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmove-corresponding_structure.htm) using the addition EXPANDING NESTED TABLES, with the following exception. The components used for the search are not assigned by default. The rows in the mapping table with mapping types for [simple assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corresponding_1.htm) can be used to override the default assignment of identically named components and the default exclusion of the components used for the search. It is not possible to specify the same table for dst and lookup\_src; if specified, the runtime error CORRESPONDING\_SELF occurs.

Notes

-   The methods CREATE\_USING and EXECUTE\_USING of the system class CL\_ABAP\_CORRESPONDING produce an assignment similar to the statement

dst = [CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_using.htm) #( dst FROM lookup\_tab KEY key\_name ... ).

Here, however. the columns used to synchronize the target table and lookup table, plus the [mapping rule](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_mapping.htm) are specified dynamically as the content of a special internal table.

-   In the mapping table, the columns of the target table dst are part of the column DSTNAME, regardless of the mapping type, and the columns of the lookup table are part of the column SRCNAME. In the [CORRESPONDING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_using.htm) operator, however, the arrangement of the operands after USING is different from the arrangement after MAPPING.

Example

The example displays the implementation of an example for component operator [CORRESPONDING with lookup table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorresponding_constr_using.htm) to class CL\_ABAP\_CORRESPONDING.

TYPES:
  BEGIN OF line,
    value   TYPE i,
    comment TYPE string,
  END OF line,
  itab1 TYPE STANDARD TABLE OF line WITH EMPTY KEY,
  itab2 TYPE HASHED TABLE OF line WITH UNIQUE KEY value.
DATA(itab1) = VALUE itab1( FOR i = 1 UNTIL i >= 10 ( value = i ) ).
DATA(itab2) = VALUE itab2( ( value = 2 comment = \`...\` )
                           ( value = 3 comment = \`...\` )
                           ( value = 5 comment = \`...\` )
                           ( value = 8 comment = \`...\` ) ).
DATA(mapping\_tab) = VALUE cl\_abap\_corresponding=>mapping\_table(
  ( level = 0 kind = 4 srcname = 'PRIMARY\_KEY' )
  ( level = 0 kind = 5 srcname = 'VALUE' dstname = 'VALUE' ) ).
cl\_abap\_corresponding=>create\_using(
     destination       = itab1
     using             = itab2
     mapping               = mapping\_tab
     )->execute\_using( EXPORTING using       = itab2
                       CHANGING  destination = itab1 ).
cl\_demo\_output=>display( itab1 ).

Executable Example

[CL\_ABAP\_CORRESPONDING with Lookup Table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_corr_lookup_abexa.htm)


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Numeric Calculations / System Classes for Numbers

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Numeric Calculations / System Classes for Numbers

Included pages: 4


### abencl_abap_math.htm

---
title: "System Classes for Numbers"
description: |
  -   System Class CL_ABAP_MATH(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_class.htm) -   System Class CL_ABAP_DECFLOAT(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_decfloat_doc.htm) -   Random Numbers(https://help.sap.com/doc/abap
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_math.htm"
abapFile: "abencl_abap_math.htm"
keywords: ["do", "class", "data", "abencl", "abap", "math"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Numeric Calculations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencompute_expressions.htm) → 

System Classes for Numbers

-   [System Class CL\_ABAP\_MATH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_class.htm)

-   [System Class CL\_ABAP\_DECFLOAT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_decfloat_doc.htm)

-   [Random Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrandom_number_class.htm)

Continue
[System Class CL\_ABAP\_MATH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_class.htm)
[System Class CL\_ABAP\_DECFLOAT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_decfloat_doc.htm)
[Random Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrandom_number_class.htm)


### abenfloating_point_class.htm

---
title: "Constants for Minimum and Maximum Values"
description: |
  The class CL_ABAP_MATH contains constants with the limits of the value ranges built-in numeric types(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm). Example Displays the minimum values and maximum values of numeric types. cl_demo_output=>display( i:
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfloating_point_class.htm"
abapFile: "abenfloating_point_class.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "abenfloating", "point"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Numeric Calculations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencompute_expressions.htm) →  [System Classes for Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_math.htm) → 

System Class CL\_ABAP\_MATH

-   [Constants for Minimum and Maximum Values](#abenfloating-point-class-1--------operations-with-floating-point-numbers---@ITOC@@ABENFLOATING_POINT_CLASS_2)

-   [Rounding Binary Floating Point Numbers](#abenfloating-point-class-3--------operations-with-decimal-floating-point-numbers---@ITOC@@ABENFLOATING_POINT_CLASS_4)

Constants for Minimum and Maximum Values

The class CL\_ABAP\_MATH contains constants with the limits of the value ranges [built-in numeric types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm).

Example

Displays the minimum values and maximum values of numeric types.

cl\_demo\_output=>display(
  |i:          { cl\_abap\_math=>min\_int4 WIDTH = 20
          } to { cl\_abap\_math=>max\_int4 WIDTH = 20 } \\n| &&
  |int8:       { cl\_abap\_math=>min\_int8 WIDTH = 20
          } to { cl\_abap\_math=>max\_int8 WIDTH = 20 } \\n| &&
  |decfloat16: { cl\_abap\_math=>min\_decfloat16 STYLE = SCIENTIFIC
                                              WIDTH = 20
          } to { cl\_abap\_math=>max\_decfloat16 STYLE = SCIENTIFIC
                                              WIDTH = 20 } \\n| &&
  |decfloat34: { cl\_abap\_math=>min\_decfloat34 STYLE = SCIENTIFIC
                                              WIDTH = 20
          } to { cl\_abap\_math=>max\_decfloat34 STYLE = SCIENTIFIC
                                              WIDTH = 20 } \\n| ).

Operations with Floating Point Numbers

The class CL\_ABAP\_MATH contains methods for operations with floating point numbers.

Rounding Binary Floating Point Numbers

The method ROUND\_F\_TO\_15\_DECS rounds a [binary floating point number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbinfloat_glosry.htm "Glossary Entry") to 15 places using commercial rounding.

Note

Commercial rounding to 15 digits can also be done using the built-in function [round](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendec_floating_point_functions.htm), the result of which then has the decfloat34 type.

Example

The example shows how rounding errors in the output formatting of binary floating point numbers can be prevented by two-step rounding using the method ROUND\_F\_TO\_15\_DECS. Instead of the method call, the function call round( val = float dec = 15 ) can be used here.

DATA float TYPE f VALUE '1.005'.
cl\_demo\_output=>display(
  |{ float DECIMALS = 2 }\\n| &&
  |{ cl\_abap\_math=>round\_f\_to\_15\_decs( float ) DECIMALS = 2 }\\n| ).

Operations with Decimal Floating Point Numbers

-   The method GET\_SCALE gets the [scaling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscale_glosry.htm "Glossary Entry") of a [decimal floating point number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendecfloat_glosry.htm "Glossary Entry").

-   The method GET\_NUMBER\_OF\_DIGITS gets the [precision](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprecision_glosry.htm "Glossary Entry") of a [decimal floating point number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendecfloat_glosry.htm "Glossary Entry").

-   The method NORMALIZE gets a normalized floating point number. This means that the [scaling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscale_glosry.htm "Glossary Entry") and [precision](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprecision_glosry.htm "Glossary Entry") of an input value are changed so that the mantissa has no trailing zeroes.

-   The method GET\_SCALE\_NORMALIZED gets the [scaling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscale_glosry.htm "Glossary Entry") of a normalized [decimal floating point number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendecfloat_glosry.htm "Glossary Entry"). If the input value has decimal places, the return value is the number of decimal places without trailing zeroes.

-   The method GET\_MAX\_DB\_VALUE gets the maximum value of a number of the type DF16\_DEC or DF34\_DEC on the database.

-   The method GET\_DB\_LENGTH\_DECS gets the length and number of decimal places of a number of the type DF16\_DEC or DF34\_DEC on the database.

Note

The [rounding functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrounding_function_glosry.htm "Glossary Entry") round and rescale can be used to round and rescale decimal floating point numbers.

Example

Displays the scaling and precision of a decimal floating point number.

DATA(decf) = CONV decfloat34( '1234.56789' ).
cl\_demo\_output=>display(
|value = { decf
}\\nscale = { cl\_abap\_math=>get\_scale( decf )
}\\nprecision = { cl\_abap\_math=>get\_number\_of\_digits( decf ) }| ).

This translation does not reflect the current version of the documentation.


### abencl_abap_decfloat_doc.htm

---
title: "cl_abap_decfloat_doc"
description: |
  cl_abap_decfloat_doc - ABAP 7.54 language reference documentation
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_decfloat_doc.htm"
abapFile: "abencl_abap_decfloat_doc.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abencl", "abap", "decfloat", "doc"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Numeric Calculations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencompute_expressions.htm) →  [System Classes for Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_math.htm) → 

System Class CL\_ABAP\_DECFLOAT

The system class CL\_ABAP\_DECFLOAT contains methods for handling [decimal floating point numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendecfloat_glosry.htm "Glossary Entry").

-   The methods READ\_DECFLOAT34 and READ\_DECFLOAT16 convert strings to decimal floating point numbers. The exceptions of these methods are more significant than those of a normal assignment. Furthermore, the methods return a return value that reveals information about the roundings performed.

-   The methods CONVERT\_CURR\_TO\_DECFLOAT and CONVERT\_DECFLOAT\_TO\_CURR convert currency amounts to decimal floating point numbers (and back) as specified by a currency key.


### abenrandom_number_class.htm

---
title: "Random Numbers"
description: |
  The class CL_ABAP_RANDOM calls the pseudo random number generator Mersenne Twister for different numeric types. For the one-dimensional case, the following special classes generate random numbers for the different numeric types: -   CL_ABAP_RANDOM_INT for type i -   CL_ABAP_RANDOM_INT8 for t
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrandom_number_class.htm"
abapFile: "abenrandom_number_class.htm"
keywords: ["do", "if", "case", "class", "data", "types", "abenrandom", "number"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Numeric Calculations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencompute_expressions.htm) →  [System Classes for Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_math.htm) → 

Random Numbers

The class CL\_ABAP\_RANDOM calls the pseudo random number generator Mersenne Twister for different numeric types.

For the one-dimensional case, the following special classes generate random numbers for the different numeric types:

-   CL\_ABAP\_RANDOM\_INT for type i

-   CL\_ABAP\_RANDOM\_INT8 for type int8

-   CL\_ABAP\_RANDOM\_FLOAT für Typ f

-   CL\_ABAP\_RANDOM\_PACKED for type p

-   CL\_ABAP\_RANDOM\_PACKED\_DEC1 to CL\_ABAP\_RANDOM\_PACKED\_DEC14 für Typ p with 1 to 14 decimal places.

-   CL\_ABAP\_RANDOM\_DECFLOAT16 for type decfloat16

-   CL\_ABAP\_RANDOM\_DECFLOAT34 for type decfloat34

Example

Creates a pseudo random number of the type i between 1 and 100 (initialized by the system time).

DATA(r) = cl\_abap\_random\_int=>create( seed = CONV i( sy-uzeit )
                                      min  = 1
                                      max  = 100 ).


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Character String and Byte String Processing / System Classes for Character String and Byte String Processing

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Character String and Byte String Processing / System Classes for Character String and Byte String Processing

Included pages: 5


### abencl_abap_string_utilities.htm

---
title: "System Classes for Character String and Byte String Processing"
description: |
  -   Class for Trailing Blanks(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_util.htm) -   Class for Compressing Character Strings and Byte Strings(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_gzip.htm) -   Class with Utilities for String Process
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_string_utilities.htm"
abapFile: "abencl_abap_string_utilities.htm"
keywords: ["do", "method", "class", "data", "abencl", "abap", "string", "utilities"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Character String and Byte String Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_string.htm) → 

System Classes for Character String and Byte String Processing

-   [Class for Trailing Blanks](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_util.htm)

-   [Class for Compressing Character Strings and Byte Strings](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_gzip.htm)

-   [Class with Utilities for String Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_char_utilities.htm)

-   [Methods for Handling Code Pages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_conv_codepage.htm)

Continue
[Class for Trailing Blanks](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_util.htm)
[Class for Compressing Character Strings and Byte Strings](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_gzip.htm)
[Class with Utilities for String Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_char_utilities.htm)
[Methods for Handling Code Pages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_conv_codepage.htm)


### abenstring_util.htm

---
title: "Class for Trailing Blanks"
description: |
  The class CL_ABAP_STRING_UTILITIES contains methods for processing text strings(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_string_glosry.htm 'Glossary Entry'). -   C2STR_PRESERVING_BLANKS assigns text fields while preserving the trailing blanks. -   DEL_TRAILING_BLA
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_util.htm"
abapFile: "abenstring_util.htm"
keywords: ["delete", "do", "while", "if", "try", "method", "class", "data", "abenstring", "util"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Character String and Byte String Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_string.htm) →  [System Classes for Character String and Byte String Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_string_utilities.htm) → 

Class for Trailing Blanks

The class CL\_ABAP\_STRING\_UTILITIES contains methods for processing [text strings](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_string_glosry.htm "Glossary Entry").

-   C2STR\_PRESERVING\_BLANKS assigns text fields while preserving the trailing blanks.

-   DEL\_TRAILING\_BLANKS deletes the trailing blanks from strings.

Note

Tasks like this can now also be performed using statements and built-in functions.

Example

The program compares the method C2STR\_PRESERVING\_BLANKS with the built-in function [shift\_right](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshift_functions.htm). The implementation of the method now consists of nothing more than this function.

DATA(str) = \`abc   \`.
DATA(rslt) = str.
cl\_abap\_string\_utilities=>del\_trailing\_blanks( CHANGING str = rslt ).
ASSERT rslt =  shift\_right( str ).

This translation does not reflect the current version of the documentation.


### abencl_abap_gzip.htm

---
title: "Class for Compressing Character Strings and Byte Strings"
description: |
  These classes offer a range of methods that enable text in text fields or text strings, or binary data in byte fields or byte strings to be compressed or decompressed using GZIP. -   CL_ABAP_GZIP -   CL_ABAP_GZIP_BINARY_STREAM -   CL_ABAP_GZIP_TEXT_STREAM -   CL_ABAP_UNGZIP_BINARY_STRE
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_gzip.htm"
abapFile: "abencl_abap_gzip.htm"
keywords: ["do", "method", "class", "data", "abencl", "abap", "gzip"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Character String and Byte String Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_string.htm) →  [System Classes for Character String and Byte String Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_string_utilities.htm) → 

Class for Compressing Character Strings and Byte Strings

These classes offer a range of methods that enable text in text fields or text strings, or binary data in byte fields or byte strings to be compressed or decompressed using GZIP.

-   CL\_ABAP\_GZIP

-   CL\_ABAP\_GZIP\_BINARY\_STREAM

-   CL\_ABAP\_GZIP\_TEXT\_STREAM

-   CL\_ABAP\_UNGZIP\_BINARY\_STREAM

-   CL\_ABAP\_UNGZIP\_TEXT\_STREAM

For more information, see the individual classes and methods.

Example

Compression and decompression of text.

DATA zip TYPE xstring.
cl\_abap\_gzip=>compress\_text(
  EXPORTING text\_in  = \`Hello!\`
  IMPORTING gzip\_out = zip ).
DATA txt TYPE string.
cl\_abap\_gzip=>decompress\_text(
  EXPORTING gzip\_in  = zip
  IMPORTING text\_out = txt ).
ASSERT txt = \`Hello!\`.


### abencl_abap_char_utilities.htm

---
title: "Class with Utilities for String Processing"
description: |
  The class CL_ABAP_CHAR_UTILITIES provides attributes and methods as utilities for string processing. The components of this class are all static and public. The attributes are read-only and are initialized in the class constructor. Details about the attributes and methods of this class are descri
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_char_utilities.htm"
abapFile: "abencl_abap_char_utilities.htm"
keywords: ["do", "try", "method", "class", "data", "abencl", "abap", "char", "utilities"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Character String and Byte String Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_string.htm) →  [System Classes for Character String and Byte String Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_string_utilities.htm) → 

Class with Utilities for String Processing

The class CL\_ABAP\_CHAR\_UTILITIES provides attributes and methods as utilities for string processing.

The components of this class are all static and public. The attributes are read-only and are initialized in the class constructor. Details about the attributes and methods of this class are described in the class documentation.

Example

The following rows demonstrate that attributes of the class CL\_ABAP\_CHAR\_UTILITIES containing control characters can be replaced by a representation of the [control characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_templates_separators.htm) in a [string template](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_template_glosry.htm "Glossary Entry") .

ASSERT cl\_abap\_char\_utilities=>newline        = |\\n|.
ASSERT cl\_abap\_char\_utilities=>horizontal\_tab = |\\t|.
ASSERT cl\_abap\_char\_utilities=>cr\_lf          = |\\r\\n|.


### abencl_abap_conv_codepage.htm

---
title: "Methods for Handling Code Pages"
description: |
  The methods CONVERT of the interfaces IF_ABAP_CONV_OUT and IF_ABAP_CONV_IN of objects created with the class CL_ABAP_CONV_CODEPAGE make it possible to convert strings to the binary representation of various code pages (and back again). Example Converts the content of a string into its UTF-8
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_conv_codepage.htm"
abapFile: "abencl_abap_conv_codepage.htm"
keywords: ["do", "if", "method", "class", "data", "abencl", "abap", "conv", "codepage"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Character String and Byte String Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_string.htm) →  [System Classes for Character String and Byte String Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_string_utilities.htm) → 

Methods for Handling Code Pages

The methods CONVERT of the interfaces IF\_ABAP\_CONV\_OUT and IF\_ABAP\_CONV\_IN of objects created with the class CL\_ABAP\_CONV\_CODEPAGE make it possible to convert strings to the binary representation of various code pages (and back again).

Example

Converts the content of a string into its UTF-8 representation. The value "UTF-8" is the default value for the parameter CODEPAGE and can be omitted if required. The statement [ASSERT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassert.htm) shows that the reverse conversion creates the original text.

DATA(str) = \`Blah blah ...\`.
DATA(xstr) =
  cl\_abap\_conv\_codepage=>create\_out( codepage = \`UTF-8\`
    )->convert( source = str ).
ASSERT
  cl\_abap\_conv\_codepage=>create\_in( codepage = \`UTF-8\`
    )->convert( source = xstr ) = str.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Date and Time Processing / Time Stamps / Time Stamp Field with Time Stamp Type / System Class for Time Stamp Fields

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Date and Time Processing / Time Stamps / Time Stamps in Packed Numbers

Included pages: 6


### abentime_stamps_packed.htm

---
title: "Time Stamps in Packed Numbers"
description: |
  In this format, time stamps(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamp_glosry.htm 'Glossary Entry') are represented using packed numbers of the type p(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm). -   Representation of
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm"
abapFile: "abentime_stamps_packed.htm"
keywords: ["do", "if", "case", "try", "method", "class", "data", "types", "abentime", "stamps", "packed"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Date and Time Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendate_time_processing.htm) →  [Time Stamps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps.htm) → 

Time Stamps in Packed Numbers

In this format, [time stamps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamp_glosry.htm "Glossary Entry") are represented using packed numbers of the type [p](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuiltin_types_numeric.htm).

-   [Representation of Time Stamps in Packed Numbers](#abentime-stamps-packed-1--------accessing-time-stamps-in-packed-numbers---@ITOC@@ABENTIME_STAMPS_PACKED_2)

-   [Notes on Handling Time Stamps in Packed Numbers](#abentime-stamps-packed-3--------examples-for-time-stamps-in-packed-numbers---@ITOC@@ABENTIME_STAMPS_PACKED_4)

Representation of Time Stamps in Packed Numbers

There is a short form and a long form.

-   In the short form, a time stamp is represented precisely to the second using a packed number with length 8, and the ABAP Dictionary type TIMESTAMP. The digits of the packed number show the time stamp in the format "yyyymmddhhmmss", where "yyyy" is the year, "mm" is the month, "dd" is the day, "hh" is the hour, "mm" are the minutes, and "ss" are the seconds.

-   In the long form, a time stamp is represented precisely to 100 ns using a packed number with length 11 and seven decimal places, and the ABAP Dictionary type TIMESTAMPL The digits of the packed number show the time stamp in the format "yyyymmddhhmmss.sssssss", where, in addition to the short form, the seven decimal places "sssssss" are the fractions of a second. The maximum time resolution depends on the operating system of the [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") of the current [AS Instance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry") and can be less.

In its integer part, a valid time stamp must contain valid dates and times:

-   When specifying the date, only the values 01 to 9999 for the year, 01 to 12 for the month, and 01 to 31 for the day are valid.

-   When specifying the time, only the values 00 to 23 for the hours, and 00 to 59 for the minutes and seconds are valid.

A time valid in the Gregorian calendar must be represented. [Leap seconds](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenleap_second_glosry.htm "Glossary Entry") are not supported.

Notes

-   An initial packed number with the value 0 does not contain a valid time stamp.

-   The method NORMALIZE of class CL\_ABAP\_TSTMP can be used to convert invalid values in time stamps to valid values.

Accessing Time Stamps in Packed Numbers

Only a few statements recognize that packed numbers of the types TIMESTAMP and TIMESTAMPL are time stamps. All other statements interpret the content of these data types numerically and, with the exception of direct comparisons, are not suitable for handling time stamps. The statements for handling time stamps in packed numbers are as follows:

-   [GET TIME STAMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_time-stamp.htm) creates a current time stamp.

-   [CONVERT TIME STAMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_time-stamp.htm) converts a time stamp to a local date and a local time.

-   [CONVERT INTO TIME STAMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_date_time-stamp.htm) converts a local date and a local time to a time stamp.

Furthermore, time stamps in packed numbers are handled in specified ways in the following output formats:

-   Use of the options [TIMESTAMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcompute_string_format_options.htm) and [TIMEZONE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcompute_string_format_options.htm) for [embedded expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_templates_expressions.htm) in [string templates](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_templates.htm)

-   Use of the addition [TIME ZONE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_to_options.htm) of the statement WRITE *\[*TO*\]*.

-   The domains XSDDATETIME\_Z and XSDDATETIME\_LONG\_Z support the serialization and deserialization of ABAP time stamps in [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml_schema.htm) and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_schema.htm).

The system class [CL\_ABAP\_TSTMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_tstmp.htm) provides methods for adding, subtracting, converting, and comparing time stamps in packed numbers.

Note

Special [time stamp functions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_cds_glosry.htm "Glossary Entry") can be used in and the CDS DDL of the ABAP CDS for editing time stamps saved as packed numbers in database tables.

Notes on Handling Time Stamps in Packed Numbers

Time stamps in packed numbers are only interpreted as such when they are accessed by the statements, methods, and functions listed above. When being assigned or converted, they behave like packed numbers of the type p, which means they are not suitable for direct calculations. Comparisons produce a meaningful result only when two time stamps are compared with each other. In programs for which the program attribute [Fixed Point Arithmetic](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfixed_point_arithmetic_glosry.htm "Glossary Entry") is not set, note the rules applying to the data type p. In particular, direct comparisons of time stamps in the long form with the short form produce a meaningful result only when the program attribute fixed point arithmetic is set. Otherwise, the system class CL\_ABAP\_TSTMP must be used for comparisons as well.

A time stamp in its short form is the integer part of a time stamp in its long form. When assigning time stamps in the long form to time stamps in the short form, unwanted rounding effects occur. For this reason, always use the method MOVE of the system class [CL\_ABAP\_TSTMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_tstmp.htm).

When time stamps in packed numbers are used in operand positions where they are not supposed to be used, no warnings are given by the syntax check or by the extended program check (not even in [lossless assignments](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlossless_assignment_glosry.htm "Glossary Entry")).

Examples for Time Stamps in Packed Numbers

Example

Directly compares time stamps in packed numbers with the same data type.

GET TIME STAMP FIELD DATA(ts2).
WAIT UP TO 1 SECONDS.
GET TIME STAMP FIELD DATA(ts1).
ASSERT ts2 < ts1.

Example

Converts a time stamp in a packed number to a date and a time field, and determines the summer time marker.

GET TIME STAMP FIELD DATA(ts).
CONVERT TIME STAMP ts TIME ZONE sy-zonlo
        INTO DATE DATA(date) TIME DATA(time)
        DAYLIGHT SAVING TIME DATA(dst).
cl\_demo\_output=>display( |{ date }\\n{
                            time }\\n{
                            dst } | ).

Example

Formats a time stamp in a packed number in a string template in a type-friendly way.

GET TIME STAMP FIELD DATA(ts).
cl\_demo\_output=>display( |{ ts TIMESTAMP = ISO } | ).

Example

Serializes a time stamp in a packed number by using a special domain.

DATA ts TYPE xsddatetime\_z.
GET TIME STAMP FIELD ts.
CALL TRANSFORMATION id SOURCE ts = ts
                       RESULT XML DATA(xml).
cl\_demo\_output=>display\_xml( xml ).

Example

Calculates the difference between two time stamps in packed numbers using the class CL\_ABAP\_TSTMP.

DATA: ts1 TYPE timestampl,
      ts2 TYPE timestampl.
GET TIME STAMP FIELD ts2.
WAIT UP TO 1 SECONDS.
GET TIME STAMP FIELD ts1.
DATA(seconds) = cl\_abap\_tstmp=>subtract(
    EXPORTING
      tstmp1 = ts1
      tstmp2 = ts2 ).
cl\_demo\_output=>display( seconds ).

Example

Calculates directly using time stamps in packed numbers. If, for example, ts1 has the value 20161004130733, adding 3600 s in ts2 produces the value 20161004140733. Since the time stamps are interpreted as numbers of type p in the calculation, the result is 10000, which would generally be unexpected.

GET TIME STAMP FIELD DATA(ts1).
DATA(ts2) = cl\_abap\_tstmp=>add( tstmp = ts1
                                secs  = 3600 ).
cl\_demo\_output=>display( ts2 - ts1 ).

Example

Calculates incorrectly using time stamps in packed numbers. The assumption here is that time stamps are interpreted as a number of seconds in calculations. This is not the case here. The result does not meet expectations and is generally not a valid time stamp. For example, if 20161004131906 is calculated, this produces the invalid value 20161004315506.

GET TIME STAMP FIELD DATA(ts).
ts = ts + 86400 \* 2 + 3600 \* 3.
cl\_demo\_output=>display( ts ).

Continue
[GET TIME STAMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_time-stamp.htm)
[CONVERT TIME STAMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_time-stamp.htm)
[CONVERT INTO TIME STAMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_date_time-stamp.htm)
[System Class for Time Stamps in Packed Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_tstmp.htm)
![Example](exa.gif "Example") [Convert Time Stamps in Packed Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconvert_time_stamp_abexa.htm)


### abapget_time-stamp.htm

---
title: "GET TIME STAMP"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_time_stamp_shortref.htm) Syntax GET TIME STAMP FIELD time_stamp. Effect This statement uses the system time(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_time_glosry.htm 'Glossary Entry')
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_time-stamp.htm"
abapFile: "abapget_time-stamp.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abapget", "time", "stamp"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Date and Time Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendate_time_processing.htm) →  [Time Stamps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps.htm) →  [Time Stamps in Packed Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm) → 

GET TIME STAMP

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_time_stamp_shortref.htm)

Syntax

GET TIME STAMP FIELD time\_stamp.

Effect

This statement uses the [system time](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_time_glosry.htm "Glossary Entry") and [system date](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_date_glosry.htm "Glossary Entry") of the AS ABAP to generate a [UTC time stamp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutc_timestamp_glosry.htm "Glossary Entry") according to the [POSIX](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenposix_timestamp_glosry.htm "Glossary Entry") standard and assigns it to the variable time\_stamp of type p as a [time stamp in a packed number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm).

The following can be specified for time\_stamp:

-   An existing variable of the data type TIMESTAMP or TIMESTAMPL from ABAP Dictionary, in accordance with ABAP type p with length 8 or p with length 11, with seven decimal places. Depending on the data type, the time stamp is generated either in the [short form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm) or in the [long form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm).
    
-   An inline declaration [DATA(var)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_inline.htm), where a variable of type TIMESTAMP is declared.
    

Notes

-   The precision of the decimal places of the long form depends on the hardware (processor) of the current [AS Instance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry") [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry"). The maximum resolution of 100 ns is not always reached. A resolution of a single-figure or two-figure number of microseconds is realistic.
    
-   A time stamp in its short form is the integer part of a time stamp in its long form. A long form time stamp cannot be used to generate the associated short form time stamp simply by making an assignment, since this would involve commercial rounding. The method MOVE of the system class [CL\_ABAP\_TSTMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_tstmp.htm) can be used instead.
    

Example

Generates two time stamps. An existing variable of the type TIMESTAMPL must be used for the long form. An inline declaration can be used for the short form. The time stamps must be given a special format for the output, since otherwise only numbers of type p would be displayed.

DATA tsl TYPE timestampl.
GET TIME STAMP FIELD DATA(ts).
GET TIME STAMP FIELD tsl.
cl\_demo\_output=>new(
  )->write( |{ ts  TIMESTAMP = ISO
                   TIMEZONE = 'UTC' }|
  )->write( |{ tsl TIMESTAMP = ISO
                   TIMEZONE = 'UTC' }|
  )->display( ).

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Non-Handleable Exceptions

-   Cause: The target field differs from TIMESTAMP or TIMESTAMPL with respect to type, length, and decimal places.
    Runtime error: GET\_TIMESTAMP\_FORMAT


### abapconvert_time-stamp.htm

---
title: "CONVERT TIME STAMP"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_time_stamp_shortref.htm) Syntax CONVERT TIME STAMP time_stamp TIME ZONE tz INTO DATE dat TIME tim DAYLIGHT SAVING TIME dst. Effect This statement interprets the content of a packed numbe
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_time-stamp.htm"
abapFile: "abapconvert_time-stamp.htm"
keywords: ["do", "if", "case", "try", "data", "types", "abapconvert", "time", "stamp"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Date and Time Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendate_time_processing.htm) →  [Time Stamps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps.htm) →  [Time Stamps in Packed Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm) → 

CONVERT TIME STAMP

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_time_stamp_shortref.htm)

Syntax

CONVERT TIME STAMP time\_stamp TIME ZONE tz
        INTO *\[*DATE dat*\]*
             *\[*TIME tim*\]* *\[*DAYLIGHT SAVING TIME dst*\]*.

Effect

This statement interprets the content of a packed number time\_stamp as a [time stamp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm), converts it to the local date and the local time in the time zone specified in tz, and assigns the result to the variables dat, tim, and dst. There must be at least one of the additions. At least one of the additions DATE or TIME must be specified. The conversion is made in accordance with the [rules for time zones](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_zone_rules.htm).

time\_stamp and tz are [functional operand positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunctional_position_glosry.htm "Glossary Entry").

-   The operand time\_stamp must have the type TIMESTAMP or TIMESTAMPL from ABAP Dictionary, in accordance with the ABAP type p with length 8 or p with length 11 with seven decimal places. Depending on the data type, the content is interpreted either as a time stamp in the [short form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm) or as a time stamp in the [long form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm). No other data types can be specified. If time\_stamp does not contain a valid time stamp, the content of dat and tim is not changed, and sy-subrc is set to 12.
    
-   The operand tz must be character-like and contain a [time zone](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_zone_glosry.htm "Glossary Entry") from the database table TTZZ.
    

-   If tz is initial, the UTC time stamp is not converted to a different time zone. The local date and the local time in the target fields match the UTC reference time. In this case, sy-subrc is set to 4.

-   If the specified time zone is not found in the database table TTZZ, the content of dat and tim is not changed and sy-subrc is set to 8.

-   If the [rule set](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_zone_rules.htm) for the specified time zone is incomplete, a non-handleable exception is raised.

-   The local date is assigned to dat as a return value of the data type d. The following can be specified for dat:
    

-   An existing variable to which the return value can be [converted](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_type_d.htm).

-   An inline declaration [DATA(var)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_inline.htm), where a variable of data type d is declared.

-   The local time is assigned to tim as a return value of data type t. If the time stamp in time\_stamp is in the long form, the seconds fractions in the decimal places are ignored. The following can be specified for tim:
    

-   An existing variable to which the return value can be [converted](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_type_t.htm).

-   An inline declaration [DATA(var)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_inline.htm), where a variable of data type t is declared.

-   If the time stamp in time\_stamp for the time zone specified in tz is in summer time, dst is given the value "X". Otherwise it is given the value " ". The following can be specified for dst:
    

-   An existing variable of the type c with length 1

-   An inline declaration [DATA(var)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_inline.htm), where a variable of data type c with length 1 is declared.

When time stamps are converted to reflect the conversion from the Julian calendar to the Gregorian calendar and the non-existence of the days between 5.10.1582 and 14.10.1582, this returns the same results as the conversion for the days from 15.10.1582 to 24.10.1582 (which do exist).

If time\_stamp contains a valid value but produces an invalid date when combined with a valid time zone in tz, dat and tim are not modified and sy-subrc is set to 12.

System Fields

sy-subrc

Meaning

0

Time stamp was converted into the local time of the specified time zone and assigned to the target fields.

4

Time stamp was assigned to the target fields without conversion into the local time.

8

Time stamp could not be converted, because the specified time zone is not in the database table TTZZ.

12

Time stamp could not be converted since time\_stamp contains an invalid value or produces an invalid date when combined with the time zone.

Notes

-   A current UTC time stamp can be created using the statement [GET TIME STAMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_time-stamp.htm).
    
-   The current user time zone can be found in the system field [sy-zonlo](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_system_fields.htm).
    
-   It is now possible to use the return value for the summer time in dst to distinguish duplicate local time specifications that occur when UTC time stamps are converted into local time during the double hour in the changeover between summer and winter time.
    
-   Usually, an invalid date can be created from a valid time stamp only by combining the first valid day with time zones west of UTC or the last valid day with time zones east of UTC.
    
-   An initially packed number with the value 0 is not a valid time stamp, rather it results in the value 12 in sy-subrc.
    
-   An initial time zone tz matches UTC only if the tables of the [rules for time zones](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_zone_rules.htm) are filled correctly for the time zone UTC.
    

Example

The following example for CONVERT TIME STAMP for time stamps in packed numbers functions in exactly the same way as the example for [CONVERT UTCLONG](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_utclong.htm) for time stamps in time stamp fields.

CONVERT TIME STAMP CONV time stamp( '20191103' && '053000' )
        TIME ZONE 'EST'
        INTO DATE DATA(dat) TIME DATA(tim)
        DAYLIGHT SAVING TIME DATA(dst).
cl\_demo\_output=>write( |{ dat DATE = ISO } {
                          tim TIME = ISO } { dst }| ).
CONVERT TIME STAMP CONV time stamp( '20191103' && '063000' )
        TIME ZONE 'EST'
        INTO DATE dat TIME tim
        DAYLIGHT SAVING TIME dst.
cl\_demo\_output=>write( |{ dat DATE = ISO } {
                          tim TIME = ISO } { dst }| ).
cl\_demo\_output=>display( ).

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Non-Handleable Exceptions

-   Cause: Inconsistent control tables for the conversion.
    Runtime error: CONVERT\_TSTMP\_INCONSISTENT\_TAB


### abapconvert_date_time-stamp.htm

---
title: "CONVERT INTO TIME STAMP"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_time_stamp_shortref.htm) Syntax CONVERT DATE dat TIME tim DAYLIGHT SAVING TIME dst INTO TIME STAMP time_stamp TIME ZONE tz. Effect This statement converts a date specified in dat, a time specifi
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_date_time-stamp.htm"
abapFile: "abapconvert_date_time-stamp.htm"
keywords: ["do", "if", "case", "try", "data", "types", "abapconvert", "date", "time", "stamp"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Date and Time Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendate_time_processing.htm) →  [Time Stamps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps.htm) →  [Time Stamps in Packed Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm) → 

CONVERT INTO TIME STAMP

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_time_stamp_shortref.htm)

Syntax

CONVERT DATE dat
        *\[*TIME tim *\[*DAYLIGHT SAVING TIME dst*\]**\]*
        INTO TIME STAMP time\_stamp TIME ZONE tz.

Effect

This statement converts a date specified in dat, a time specified in tim, and a summer time marker specified in dst of the time zone specified in tz into a [time stamp in a packed number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm) and assigns the result to the variable time\_stamp. The conversion is made in accordance with the [rules for time zones](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_zone_rules.htm).

dat, tim, dst, and tz are [functional operand positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunctional_position_glosry.htm "Glossary Entry").

-   dat expects a data object of the type d containing a valid date. Operands of other types are converted to d. If dat contains an [invalid value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenchar_date_time_fields_validity.htm), time\_stamp is not changed and sy-subrc is set to 12. The days from October 5, 1582 through October 14, 1582 missing due to the switch from the Julian to the Gregorian calendar are not considered invalid values here. The provide the same results as the conversion of the available days from October 15, 1582 through October 24, 1582.
    
-   tim expects a data object of the type t containing a valid time. Operands of other types are converted to t. If the addition TIME is not specified, the system implicitly uses the initial time "000000" for tim. In tim, only the values 00 to 23 for the hours, and 00 to 59 for the minutes are valid. If tim contains an [invalid value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenchar_date_time_fields_validity.htm), time\_stamp is not changed and sy-subrc is set to 12.
    
-   dst can be specified as a data object of the type c with length 1 containing the value "X" or " ". This controls the behavior of the statement with respect to summer time.
    

-   If dst has the value "X", the value of tim is applied as the specified time in daylight saving time.

-   If dst has the value “ ", the value of tim is applied as the specified time in winter time.

-   If dst has neither the value "X" nor " ", time\_stamp is not changed and sy-subrc is set to 12.

If the time zone specified in tz does not have a summer time rule (for example when "UTC" is specified), the addition DAYLIGHT SAVING TIME is ignored. If the addition DAYLIGHT SAVING TIME is not specified, the value of dst is set to "X" implicitly if the data in tim and dat is in summer time and is set to " " for data in winter time. In the extra hour that is caused by switching from summer time to winter time, tim and dat are interpreted as a time in summer time and dst is set to the value "X". If the value in dst does not match the data in tim and dat (that is, if the value "X" is specified in winter time and the value " " in summer time, time\_stamp is not changed and sy-subrc is set to 12.

-   tz expects a character-like data object containing a [time zone](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_zone_glosry.htm "Glossary Entry") from the database table TTZZ.
    

-   If tz is initial, no time shift is calculated when converting to the time stamp. In this case, sy-subrc is set to 4.

-   If the specified time zone is not found in the database table TTZZ, time\_stamp remains unchanged and sy-subrc is set to 8.

-   If the [rule set](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_zone_rules.htm) for the specified time zone is incomplete, a non-handleable exception is raised.

The following can be specified for time\_stamp:

-   An existing variable of the data type TIMESTAMP or TIMESTAMPL from ABAP Dictionary, in accordance with ABAP type p with length 8 or p with length 11, with seven decimal places. If time\_stamp has the data type TIMESTAMPL for the long form, the seconds fractions in the decimal places are initialized when the assignment is made.
    
-   An inline declaration [DATA(var)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_inline.htm), where a variable of type TIMESTAMP is declared.
    

If dat and tim contain valid values but produce an invalid time stamp when combined with a valid time zone in tz, time\_stamp is not modified and sy-subrc is set to 12.

System Fields

sy-subrc

Meaning

0

Local time of specified time zone was converted to time stamp and assigned to the target field

4

The specified time was converted to a time stamp without time shift and assigned to the target field.

8

The specified time could not be converted, because the specified time zone is not in the database table TTZZ

12

The specified time could not be converted, because dat, tim, or dst contain invalid or inconsistent values.

Notes

-   Current user-specific local times and the corresponding local time zones are stored in the system fields [sy-datlo](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_system_fields.htm), [sy-timlo](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_system_fields.htm), and [sy-zonlo](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_system_fields.htm).
    
-   Specifying daylight saving time and winter time after DAYLIGHT SAVING TIME enables different UTC time stamps to be created from matching local time stamps within the extra hour when switching from daylight saving time to winter time.
    
-   When the switch is made from winter to daylight saving time, an hour is lost. For example, in the "CET" time zone in the year 2009, on March 29, the hour between 02:00 and 03:00 does not exist. If an attempt is made to convert a time during this missing hour, the statement is always terminated with the value 12 for sy-subrc because this time or this local time stamp does not exist.
    
-   Usually, an invalid time stamp can be created from a valid date and time only by combining the first valid date 00010101 with time zones east of UTC or the last valid date 99991231 with time zones west of UTC.
    
-   An initial time zone tz matches UTC only if the tables of the [rules for time zones](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_zone_rules.htm) are filled correctly for the time zone UTC.
    

Example

The following example for CONVERT INTO TIME STAMP for time stamps in packed numbers functions in exactly the same way as the example for [CONVERT INTO UTCLONG](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_date_utclong.htm) for time stamps in time stamp fields.

DATA(dat) = CONV d( '20191103' ).
DATA(tim) = CONV t( '013000' ).
CONVERT DATE dat TIME tim DAYLIGHT SAVING TIME 'X'
        INTO TIME STAMP DATA(time\_stamp) TIME ZONE 'EST'.
cl\_demo\_output=>write\_data( time\_stamp ).
CONVERT DATE dat TIME tim DAYLIGHT SAVING TIME ' '
        INTO TIME STAMP time\_stamp TIME ZONE 'EST'.
cl\_demo\_output=>write\_data( time\_stamp ).
CONVERT DATE dat TIME tim
        INTO TIME STAMP time\_stamp TIME ZONE 'EST'.
cl\_demo\_output=>write\_data( time\_stamp ).
cl\_demo\_output=>display( ).

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Non-Handleable Exceptions

-   Cause: Inconsistent control tables for the conversion.
    Runtime error: CONVERT\_TSTMP\_INCONSISTENT\_TAB


### abencl_abap_tstmp.htm

---
title: "System Class for Time Stamps in Packed Numbers"
description: |
  The class CL_ABAP_TSTMP is used to calculate and convert time stamps in packed numbers(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm). Important methods include: -   The method ADD or SUBTRACTSECS adds or subtracts seconds from time stamps. -   The method
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_tstmp.htm"
abapFile: "abencl_abap_tstmp.htm"
keywords: ["do", "if", "method", "class", "data", "abencl", "abap", "tstmp"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Date and Time Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendate_time_processing.htm) →  [Time Stamps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps.htm) →  [Time Stamps in Packed Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm) → 

System Class for Time Stamps in Packed Numbers

The class CL\_ABAP\_TSTMP is used to calculate and convert [time stamps in packed numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm). Important methods include:

-   The method ADD or SUBTRACTSECS adds or subtracts seconds from time stamps.

-   The method TD\_SUBTRACT calculates the difference between two time stamps.

-   The method MOVE converts the long form of time stamps to the short form, and back, avoiding unwanted rounding effects.

-   The method NORMALIZE normalizes time stamps. Invalid time stamps are converted into valid time stamps.

-   The methods UTCLONG2TSTMP, UTCLONG2TSTMP\_SHORT, and TSTMP2UTCLONG convert the content of time stamp fields to representation in packed numbers and back.

Note

Conversions between time stamp fields and packed numbers are necessary for work with time stamp fields in new programs, but existing repositories or interfaces need to be accessed at the same time.

Example

Creation of a one hour earlier time stamp by subtracting 3600 seconds.

GET TIME STAMP FIELD DATA(ts1).
DATA(ts2) = cl\_abap\_tstmp=>subtractsecs( tstmp = ts1
                                         secs  = 3600 ).
cl\_demo\_output=>display( |{ ts1 TIMESTAMP = ISO
                       }\\n{ ts2 TIMESTAMP = ISO }| ).

Example

Converts a time stamp field to time stamps in packed numbers. In formatting using string templates, the formatting option [TIMESTAMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcompute_string_format_options.htm) must be specified for the packed numbers to define a representation as time stamps.

DATA(ts) = utclong\_current( ).
cl\_demo\_output=>display(
  |{ ts }\\n{
     cl\_abap\_tstmp=>utclong2tstmp( ts ) TIMESTAMP = ISO }\\n{
     cl\_abap\_tstmp=>utclong2tstmp\_short( ts ) TIMESTAMP = ISO }| ).


### abenconvert_time_stamp_abexa.htm

---
title: "Convert Time Stamps in Packed Numbers"
description: |
  This example demonstrates the statements CONVERT TIME STAMP(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_time-stamp.htm) and CONVERT INTO TIME STAMP(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_date_time-stamp.htm). Source Code REPORT demo_con
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconvert_time_stamp_abexa.htm"
abapFile: "abenconvert_time_stamp_abexa.htm"
keywords: ["select", "loop", "do", "if", "case", "method", "class", "data", "abenconvert", "time", "stamp", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Date and Time Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendate_time_processing.htm) →  [Time Stamps](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps.htm) →  [Time Stamps in Packed Numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm) → 

Convert Time Stamps in Packed Numbers

This example demonstrates the statements [CONVERT TIME STAMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_time-stamp.htm) and [CONVERT INTO TIME STAMP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapconvert_date_time-stamp.htm).

Source Code

REPORT demo\_convert\_time\_stamp.
SELECTION-SCREEN: BEGIN OF SCREEN 100 AS WINDOW,
                  BEGIN OF BLOCK bl1 WITH FRAME.
PARAMETERS: date1 TYPE d,
            time1 TYPE t,
            tz1   TYPE ttzz-tzone.
SELECTION-SCREEN  BEGIN OF LINE.
PARAMETERS  dst\_flag AS CHECKBOX.
SELECTION-SCREEN: COMMENT 3(29) text-dst,
                  POSITION POS\_LOW.
PARAMETERS  dst1  TYPE abap\_bool.
SELECTION-SCREEN: END OF LINE,
                  END OF BLOCK bl1,
                  BEGIN OF BLOCK bl2 WITH FRAME.
PARAMETERS  tsout TYPE c LENGTH 19 MODIF ID out.
SELECTION-SCREEN: END OF BLOCK bl2,
                  BEGIN OF BLOCK bl3 WITH FRAME.
PARAMETERS  tz2   TYPE ttzz-tzone.
PARAMETERS: date2 TYPE d         MODIF ID out,
            time2 TYPE t         MODIF ID out,
            dst2  TYPE abap\_bool MODIF ID out.
SELECTION-SCREEN: END OF BLOCK bl3,
                  END OF SCREEN 100.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: date TYPE d,
          time TYPE t,
          ts   TYPE timestamp.
    date1 = sy-datlo.
    time1 = sy-timlo.
    tz1 = tz2 = 'UTC'.
    DO.
      IF sy-index > 1.
        CALL SELECTION-SCREEN 100 STARTING AT 10 10.
        IF sy-subrc <> 0.
          EXIT.
        ENDIF.
      ENDIF.
      date = date1.
      time = time1.
      IF dst\_flag = abap\_false.
        CONVERT DATE date TIME time
                INTO TIME STAMP ts TIME ZONE tz1.
      ELSE.
        CONVERT DATE date TIME time DAYLIGHT SAVING TIME dst1
                INTO TIME STAMP ts TIME ZONE tz1.
      ENDIF.
      CASE sy-subrc.
        WHEN 4.
          MESSAGE 'Time zone set to UTC'
                  TYPE 'I' DISPLAY LIKE 'W'.
        WHEN 8.
          MESSAGE 'Invalid time zone'
                  TYPE 'I' DISPLAY LIKE 'E'.
          CONTINUE.
        WHEN 12.
          MESSAGE 'Invalid input values for date,'
                & ' time or daylight saving time'
                   TYPE 'I' DISPLAY LIKE 'E'.
          CONTINUE.
      ENDCASE.
      CONVERT TIME STAMP ts TIME ZONE tz2
              INTO DATE date TIME time DAYLIGHT SAVING TIME dst2.
      CASE sy-subrc.
        WHEN 4.
          MESSAGE 'Time zone set to UTC'
                  TYPE 'I' DISPLAY LIKE 'W'.
        WHEN 8.
          MESSAGE 'Invalid time zone'
                  TYPE 'I' DISPLAY LIKE 'E'.
          CONTINUE.
        WHEN 12.
          MESSAGE 'Invalid time stamp'
                  TYPE 'I' DISPLAY LIKE 'E'.
          CONTINUE.
      ENDCASE.
      tsout = |{ ts TIMESTAMP = ISO TIMEZONE = 'UTC   ' }|.
      date2 = date.
      time2 = time.
    ENDDO.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).
AT SELECTION-SCREEN OUTPUT.
  LOOP AT SCREEN INTO DATA(screen\_wa).
    IF screen\_wa-group1 = 'OUT'.
      screen\_wa-input   = '0'.
      screen\_wa-output  = '1'.
    ENDIF.
    MODIFY SCREEN FROM screen\_wa.
  ENDLOOP.

Description

The program is given a date, a time, and a time zone and converts this information into a time stamp in a [time stamp in a packed number](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentime_stamps_packed.htm). The program can also include summer time in its calculations. The resulting time stamp is then converted to the local date and local time of another time zone. The following table shows several possible combinations of input and output, where spc stands for a space and \- for no input or output.

date1

time1

tz1

dst1

ts

tz2

date2

time2

dst2

sy-subrc

16.07.2010

9:10:00 AM

CET

\-

2010-07-16T07:10:00

CET

16.07.2010

9:10:00 AM

X

\-

16.07.2010

9:10:00 AM

CET

X

2010-07-16T07:10:00

CET

16.07.2010

9:10:00 AM

X

\-

16.07.2010

9:10:00 AM

CET

spc

\-

CET

\-

\-

\-

12

16.12.2010

9:10:00 AM

CET

spc

2010-12-16T08:10:00

CET

16.12.2010

9:10:00 AM

\-

\-

16.12.2010

9:10:00 AM

CET

X

\-

CET

\-

\-

\-

12

16.12.2010

9:10:00 AM

AUSTAS

\-

2010-12-15T22:10:00

AUSTAS

16.12.2010

9:10:00 AM

X

\-

The third and fifth rows demonstrate that invalid summer time data produces the value 12 in sy-subrc.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Enumerated Objects

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Enumerated Objects

Included pages: 4


### abenenumerated_types_usage.htm

---
title: "Enumerated Objects"
description: |
  This section summarizes the use of enumerated objects(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_object_glosry.htm 'Glossary Entry') (data objects with enumerated types(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm 'Gloss
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_types_usage.htm"
abapFile: "abenenumerated_types_usage.htm"
keywords: ["select", "do", "while", "if", "case", "try", "method", "class", "data", "types", "field-symbol", "abenenumerated", "usage"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) → 

Enumerated Objects

This section summarizes the use of [enumerated objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_object_glosry.htm "Glossary Entry") (data objects with [enumerated types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry").

-   [Declaration](#abenenumerated-types-usage-1--------processing-of-enumerated-objects---@ITOC@@ABENENUMERATED_TYPES_USAGE_2)

-   [Operand Positions for Enumerated Objects](#abenenumerated-types-usage-3--------value-assignments---@ITOC@@ABENENUMERATED_TYPES_USAGE_4)

-   [Comparisons](#abenenumerated-types-usage-5--------typing-of-formal-parameters-and-field-symbols---@ITOC@@ABENENUMERATED_TYPES_USAGE_6)

-   [Access to the Enumerated Value](#abenenumerated-types-usage-7--------type-descriptions---@ITOC@@ABENENUMERATED_TYPES_USAGE_8)

-   [Data interfaces](#abenenumerated-types-usage-9--------forbidden-uses---@ITOC@@ABENENUMERATED_TYPES_USAGE_10)

Executable Example

[Enumerated Objects, Use](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenum_usage_abexa.htm)

Declaration

An enumerated object is a data object with an [enumerated type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry") defined by one of the following TYPES statements:

[TYPES BEGIN OF ENUM enum\_type ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_enum.htm)
  [TYPES val1 ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_enum.htm)
  [TYPES val2 ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_enum.htm)
  ...
[TYPES END OF ENUM enum\_type ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_enum.htm)

The technical data type of the content of an enumerated object is the [base type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbase_type_glosry.htm "Glossary Entry") of the enumerated type. The potential content is defined by the [enumerated values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_value_glosry.htm "Glossary Entry") defined using TYPES val1, TYPES val2, ..., of which at least one value must have the type-dependent initial value. The base type is i by default but it can be a different elementary data type. The following enumerated objects exist:

-   Enumerated variables

An [enumerated variable](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_variable_glosry.htm "Glossary Entry") is a variable defined using

[DATA enum\_var TYPE enum\_type ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_enum.htm)

that can contain only [enumerated values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_value_glosry.htm "Glossary Entry") of the enumerated type. This is ensured by the ABAP runtime environment and the rules for using enumerated types.

-   Enumeration constants

An [enumeration constant](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_constant_glosry.htm "Glossary Entry") is used to define a value in the value set of an enumerated type. In the definition of an enumerated type, it is defined using

[TYPES val ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_enum.htm)

under the name val. This constant is a constant of the context of its definition and contains the [enumerated value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_value_glosry.htm "Glossary Entry") assigned in the definition. It can be specified in all reading positions in which enumerated objects are possible. Its enumerated value is either determined automatically as a whole number or can be specified explicitly in the definition.

-   Components of enumeration structures

A component of an [enumeration structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_structure_glosry.htm "Glossary Entry") is a special form of an enumeration constant that exists as a component of a constant structure and not as a single data object. The enumeration structure struc is defined using

[TYPES BEGIN OF ENUM enum\_type STRUCTURE struc ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_enum.htm)

. This makes the enumeration constants defined using

[TYPES val ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_enum.htm)

into their structure components. Otherwise, the same applies as to regular enumeration constants.

Notes

-   Enumerated objects are mainly used to check permitted values. This usually restricts the actual parameters passed to methods to the enumerated values defined in the class.

-   The base type and the actual enumerated value are almost always ignored when enumerated objects are used. Assignments and comparisons are usually only made between enumerated objects with the same enumerated type.

-   Base types other than i and the actual enumerated values may be significant in transformations between enumerated type or in migrations of predecessor concepts.

-   Enumeration structures can be used to avoid naming conflicts if there are multiple enumerated types in a single namespace. Enumeration structures can be used to enable the use of the same enumeration constant name in multiple enumerated types.

Example

Declares an enumerated type size in a class. The method parameter size has the enumerated type and only enumerated objects of this type can be passed to this parameter. This example show how the enumeration constant demo=>l is passed. This guarantees that only enumerated values of the enumerated type can be passed to the parameter. These values can be evaluated in comparisons with the enumeration constants. In the CASE control structure shown here, the statement block after WHEN OTHERS can be reached only when demo=>xl and demo=>xxl are passed.

CLASS demo DEFINITION.
  PUBLIC SECTION.
    TYPES:
      BEGIN OF ENUM size,
        s, m, l, xl, xxl,
      END OF ENUM size.
    CLASS-METHODS main
      IMPORTING size TYPE size.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    CASE size.
      WHEN s.
        ...
      WHEN m.
        ...
      WHEN l.
        ...
      WHEN OTHERS.
        ...
    ENDCASE.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( demo=>l ).

Processing of Enumerated Objects

Enumerated objects are almost always processed independently of the base type of the enumerated type. Only the enumerated type itself is of relevance for all rules specified here. Assignments of enumerated objects with a numeric base type, for example, cannot be assigned to numeric target fields and cannot be compared with numeric fields. The enumerated vale in the base type can be accessed using the constructor operators [CONV](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconv_constructor_enum.htm) and [EXACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexact_constructor_enum.htm) only.

Operand Positions for Enumerated Objects

-   Reading positions

Enumerated objects can be used in all [reading positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_objects_usage_reading.htm) in which the operand type is their enumerated type or in which the operand is converted to one of the character-like types c or string. [Substring access](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length.htm) is not possible.

-   Writing positions

Enumerated variables can only be used in [writing positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_objects_usage_writing.htm) in which the operand type is the enumerated type and only the associated enumerated values can be written. If known statically, an attempt to assign a value other than a valid enumerated value to an enumerated variable produces a syntax error. If not known statically, an exception is raised.

Example

In the first assignment, the enumeration constant xl in a reading position is assigned to the enumerated variable size in a writing position. The string expression in the second half exploits the fact that the enumeration constants are converted implicitly to the type string before the chaining. The result is SMLXLXXL.

TYPES:
  BEGIN OF ENUM size,
    s, m, l, xl, xxl,
  END OF ENUM size.
DATA size TYPE size.
size = xl.
DATA(str) = s && m && l && xl && xxl.

Value Assignments

Only enumerated objects with the same enumerated type can be assigned to an enumerated variable. In the assignment, the target field is given the enumerated value of the source field.

The initial value of the base type is always a valid enumerated value of an enumerated type. Accordingly, an enumerated variable can be set to the initial value of its base type using [CLEAR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapclear.htm). Assignments of [VALUE enum\_type( )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_init.htm) are also possible.

In the reverse case, enumerated objects can only be assigned to compatible enumerated variables, with the following exception: There is a [conversion rule](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconversion_enumerated.htm) for assignments of enumerated objects to character-like variables of the types c and string. In this case, the target field is assigned the name of the enumeration constant or of the component of the enumeration structure under which the enumerated value of the source field is defined in the enumerated type-

In structures, each component comprises a separate fragment of the [Unicode fragment view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenunicode_fragment_view.htm) using an enumerated type. In assignments between structures of this type, the fragment views must match. This makes sure that only components with the same enumerated type can be assigned to each other.

Example

In the first assignment, the enumeration constant sz-xl is assigned to the enumerated variable size of its enumerated type. This variable then contains the associated enumerated value 3. In the second assignment, the enumeration constant is assigned to the text string size\_string. This string is given the value XL in accordance with the conversion rule.

TYPES:
  BEGIN OF ENUM size STRUCTURE sz,
    s, m, l, xl, xxl,
  END OF ENUM size STRUCTURE sz.
DATA size TYPE size.
size = sz-xl.
DATA size\_string TYPE string.
size\_string = sz-xl.

Comparisons

In comparisons between enumerated objects, the [comparison rule](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogexp_rules_operands_enum.htm) applies that an enumerated object can only be compared with an enumerated object with the same enumerated type. Here, the values of the operands are compared in accordance with their base type.

Each enumerated type has an initial enumerated value, which makes checks with the predicate expression [IS INITIAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogexp_initial.htm) possible.

Example

The first comparison shows a typical case where an enumerated variable is compared with an enumeration constant. The syntax of the second comparison (in a comment) is not possible. In the third comparison, the enumerated variable is converted explicitly to the type string before the comparison with a text string.

TYPES:
  BEGIN OF ENUM size,
    s, m, l, xl, xxl,
  END OF ENUM size.
DATA size TYPE size.
...
IF size = xl.
ENDIF.
"IF size = \`XL\`. "<--- Syntax error
"ENDIF.
IF CONV string( size ) = \`XL\`.
ENDIF.

Typing of Formal Parameters and Field Symbols

If [formal parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenformal_parameter_glosry.htm "Glossary Entry") of procedures or [field symbols](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfield_symbol_glosry.htm "Glossary Entry") are [typed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentyping.htm) with an enumerated type, only enumerated objects with the same enumerated type can be assigned to them. As usual, an exception to this are return values of functional methods that can also be assigned to character-like objects of the types c and string.

Enumerated types are covered by the generic types [any](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_generic.htm), [data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_generic.htm), and [simple](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_generic.htm). When an enumerated object is passed to generically typed formal parameters or in assignments to generically typed field symbols, these are given the enumerated type. In assignments to field symbols, castings with the [CASTING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_casting.htm) addition are not possible and an enumerated type cannot be specified after this addition.

When generically typed formal parameters or field symbols are used for enumerated objects, the restriction applies that only statically known operands with the same [enumerated type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry") are permitted in [reading positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreading_position_glosry.htm "Glossary Entry") in which an [enumerated object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_object_glosry.htm "Glossary Entry") is expected and this is known statically. This affects, for example, the source field of an assignment to an [enumerated variable](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_variable_glosry.htm "Glossary Entry") or an operand compared with an enumerated object. In [writing positions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwriting_position_glosry.htm "Glossary Entry") for enumerated objects, however, generic formal parameters or field symbols are allowed for enumerated types. If the operand type is not known statically, the check is only made at runtime in reading positions too.

Example

The field symbol fs1 typed generically with simple cannot be assigned to an enumerated variable size known statically or compared with it. An assignment of size to the field symbol and fully generic handling are, however, possible.

TYPES:
  BEGIN OF ENUM size,
    s, m, l, xl, xxl,
  END OF ENUM size.
FIELD-SYMBOLS <fs1> TYPE simple.
FIELD-SYMBOLS <fs2> TYPE simple.
DATA(size) = xl.
ASSIGN size TO <fs1>.
ASSIGN size TO <fs2>.
<fs1> = size.
"size = <fs1>.        "<--- Syntax error
"ASSERT size = <fs1>. "<--- Syntax error
<fs2> = <fs1>.
ASSERT <fs1> = <fs2>.

Access to the Enumerated Value

A special [rule](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconv_constructor_enum.htm) for the conversion operator [CONV](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_conv.htm) applies when accessing the enumerated value of an enumerated object:

[... CONV base\_type( enum\_dobj ) ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconv_constructor_enum.htm)

When the base type base\_type of an enumerated object enum\_dobj specified as an argument is specified directly or indirectly, CONV returns its enumerated value.

In the reverse case, a valid enumerated value can be converted to an enumerated object:

[... CONV enum\_type( dobj ) ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconv_constructor_enum.htm)

The argument dobj is converted to the base type of the enumerated type enum\_type and CONV returns an enumerated object with this value. Any invalid values raise an exception.

In combinations of these two variants (in which CONV base\_type( enum\_dobj ) is used as an argument dobj of CONV enum\_type( dobj )), there is a short form:

[... CONV enum\_type( enum\_dobj ) ...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconv_constructor_enum.htm)

If different enumerated types can have the same base type, an enumerated object of an enumerated type can be converted to the corresponding enumerated object of a different enumerated type.

Note

The corresponding [rules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexact_constructor_enum.htm) applies to the lossless operator [EXACT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconstructor_expression_exact.htm). Here, additional losslessness checks are made.

Example

The inner conversion operator CONV accesses the current enumerated value of the enumerated object size and returns it in the type i. The outer conversion operator CONV converts the result of the addition back to an enumerated type and assigns this enumerated value to the enumerated variable size. The enumerated value in size is raised by one in each iteration. The final result is the value of the enumeration constant xxl.

TYPES:
  BEGIN OF ENUM size,
    s, m, l, xl, xxl,
  END OF ENUM size.
DATA size TYPE size.
DO 4 TIMES.
  size = CONV #( CONV i( size ) + 1 ).
ENDDO.

Type Descriptions

The type returned for an enumerated object by the statement [DESCRIBE FIELD](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field.htm) is k. The length is the length of the enumerated value in the base type in bytes.

In [RTTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_services_glosry.htm "Glossary Entry"), enumerated objects are described by objects of the class CL\_ABAP\_ENUMDESCR. This class can be used for [RTTI](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_identific_glosry.htm "Glossary Entry") and [RTTC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_creation_glosry.htm "Glossary Entry") purposes. Like any enumerated type, an enumerated type created using RTTC is only compatible with itself.

The following attributes exist in a type description of the class CL\_ABAP\_ENUMDESCR:

-   KIND always has the value E for the elementary base type

-   TYPE\_KIND always has the value k (as in the statement DESCRIBE FIELD)

-   BASE\_TYPE\_KIND describes the base type

-   MEMBERS is a table of the enumeration constants and the associated enumerated values

Executable Example

[Enumerated Objects, Type Description](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenum_description_abexa.htm)

Data interfaces

The following data interfaces support enumerated types:

The character-like representation of enumerated objects (namely the result of a c or string) is used for their output and serialization. The output consists of the name (with a maximum of thirty characters) of the enumeration constant of the current enumerated value in uppercase. Deserializations are performed in the reverse direction. The following are supported:

-   [Data clusters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_cluster_glosry.htm "Glossary Entry") with the statements [EXPORT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapexport_data_cluster.htm) and [IMPORT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapimport_data_cluster.htm). When an enumerated object is exported, the enumerated value is saved in the base type and flagged as an enumerated value. Both enumerated objects and exported data objects of the base type can be imported to a suitable enumerated object (the value is checked here). No exported enumerated objects, however, can be exported to data objects of the base type.

-   [ABAP file interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_glosry.htm "Glossary Entry") with the statements [TRANSFER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptransfer.htm) and [READ DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapread_dataset.htm). In writes to a file and reads from a file, enumerated objects are handled like data objects of its base type. In reads from a file to an enumerated object, the value is checked to see whether it is a valid enumerated value.

-   Serializations and deserializations from and to [XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenxml_glosry.htm "Glossary Entry") and [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_glosry.htm "Glossary Entry"). The formats [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml_enum.htm) and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_enum.htm) represent the content of enumerated objects in their character-like representation (the name of the enumeration constant of the current enumerated value). Only valid names are allowed in deserializations to an enumerated object.

-   List output with the statement [WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite-.htm). Like [WRITE TO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_to.htm), this statement converts an enumerated object to its character-like representation (the name of the enumeration constant of the current enumerated value). The [output length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwrite_output_length.htm) is the same as the maximum length of the name (30 characters).

Note

A deserialization of a name of an enumeration constant is one of the few ways of creating an enumerated value from the name in full and dynamically.

Example

WRITE output of the enumeration constants of an enumeration structure.

TYPES:
  BEGIN OF ENUM size STRUCTURE sz,
    s, m, l, xl, xxl,
  END OF ENUM size STRUCTURE sz.
WHILE sy-subrc = 0.
  ASSIGN COMPONENT sy-index OF STRUCTURE sz TO FIELD-SYMBOL(<fs>).
  IF sy-subrc = 0.
    WRITE / <fs>.
  ENDIF.
ENDWHILE.

Executable Example

[Enumerated Objects, Deserialization](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenum_deserialization_abexa.htm)

Forbidden Uses

The following uses are forbidden to ensure that an enumerated object only ever contains a single valid enumerated value:

-   Within ABAP, enumerated objects are never interpreted in accordance with their base type. This means that they cannot be used in operand positions that expect numeric, character-like, or byte-like data types. The only exception to this are the operand positions in which an implicit conversion to a character-like type takes place.

-   Enumerated types are not currently supported by [ABAP Dictionary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dictionary.htm). Accordingly, no database tables whose columns have an enumerated type can be defined in ABAP Dictionary.

-   In both ABAP SQL and Native SQL ([EXEC SQL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapexec.htm), [ADBC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadbc_glosry.htm "Glossary Entry")), no [host variables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_variable_glosry.htm "Glossary Entry") or references to ABAP variables with enumerated type can be used. The actual parameters of [AMDP methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamdp_method_glosry.htm "Glossary Entry") cannot be typed using enumerated types.

-   No enumerated types are supported for the input fields of [selection screens](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselection_screen_glosry.htm "Glossary Entry").

-   It is not possible to use enumerated values from [lists in the list buffer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_complex.htm), since there are no conversion rules between character-like types and enumerated types.

If an enumerated object is provided with an invalid value due to a gap in the rules, this results in the following behavior:

-   The result of a conversion to c or string is the string <illegal enum value>, which is displayed accordingly in the ABAP Debugger.

-   An enumerated object with an invalid value can be assigned to other enumerated objects with the same enumerated type without being checked.

-   The expressions [CONV base\_type( enum\_dobj )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconv_constructor_enum.htm) and [EXACT base\_type( enum\_dobj )](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexact_constructor_enum.htm) return the invalid value.

An invalid value must be viewed as an error and should never occur.

Note

Classic [Dynpros](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_glosry.htm "Glossary Entry") represent a known gap. Enumerated types are not supported by dynpros. When dynpro input fields are taken from a program by using enumerated objects, they are handled like an object of the base type. Any invalid values are passed to the associated enumerated object in the event [PAI](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpai_glosry.htm "Glossary Entry") without being checked. For this reason, enumerated objects should never be associated with classic dynpros.

Example

The program DEMO\_ENUM\_DYNPRO uses an enumerated object on a dynpro. This can produce invalid values in the program.

Continue
![Example](exa.gif "Example") [Enumerated Objects, Use](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenum_usage_abexa.htm)
![Example](exa.gif "Example") [Enumerated Objects, Type Description](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenum_description_abexa.htm)
![Example](exa.gif "Example") [Enumerated Objects, Deserialization](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenum_deserialization_abexa.htm)


### abenenum_usage_abexa.htm

---
title: "Enumerated Objects, Use"
description: |
  This example demonstrates the use of enumerated types(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm 'Glossary Entry'). Source Code REPORT demo_enumerated_types. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-DATA html TYPE string. CLASS-METHODS: class_c
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenum_usage_abexa.htm"
abapFile: "abenenum_usage_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abenenum", "usage", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Enumerated Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_types_usage.htm) → 

Enumerated Objects, Use

This example demonstrates the use of [enumerated types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_enumerated\_types.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA html TYPE string.
    CLASS-METHODS:
      class\_constructor,
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: size   TYPE  cl\_demo\_wrap\_browser=>size
                 VALUE cl\_demo\_wrap\_browser=>sz-l,
          format TYPE  cl\_demo\_wrap\_browser=>format
                 VALUE cl\_demo\_wrap\_browser=>fmt-l.
    cl\_demo\_input=>add\_field( EXPORTING text = \`Size (S, M, L, XL)\`
                              CHANGING  field = size ).
    cl\_demo\_input=>request(   EXPORTING text  = \`Format (L, P)\`
                              CHANGING  field = format ).
    cl\_demo\_wrap\_browser=>show( html   = html
                                size   = size
                                format = format ).  ENDMETHOD.
  METHOD class\_constructor.
    cl\_abap\_docu\_external=>get\_abap\_docu\_for\_adt(
       EXPORTING
        language = COND #( WHEN sy-langu = 'D' THEN 'DE' ELSE 'EN' )
      IMPORTING
        html     = html  ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The program calls the method SHOW of class CL\_DEMO\_WRAP\_BROWSER . Two enumerated types are defined as follows in this class:

TYPES:
  BEGIN OF ENUM size STRUCTURE sz,
    s, m, l, xl,
  END OF ENUM size STRUCTURE sz.
TYPES:
  BEGIN OF ENUM format STRUCTURE fmt,
    l, p,
  END OF ENUM format STRUCTURE fmt.

The use of [enumeration structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_structure_glosry.htm "Glossary Entry") means that the same name l can occur twice. Method SHOW wraps method SHOW\_HTML of class CL\_ABAP\_BROWSER:

METHOD show.
  cl\_abap\_browser=>show\_html(
    html\_string = html
    size    = SWITCH #(  size
                         WHEN sz-s  THEN cl\_abap\_browser=>small
                         WHEN sz-m  THEN cl\_abap\_browser=>medium
                         WHEN sz-l  THEN cl\_abap\_browser=>large
                         WHEN sz-xl THEN cl\_abap\_browser=>xlarge )
    format  = SWITCH #(  format
                         WHEN fmt-l THEN cl\_abap\_browser=>landscape
                         WHEN fmt-p THEN cl\_abap\_browser=>portrait )
    buttons = abap\_true ).
ENDMETHOD.

The input parameters size and format format of the method have the same enumerated types and can only contain their enumerated values. These are mapped to the corresponding constants of class CL\_ABAP\_BROWSER. These constants can be regarded as a workaround for real enumerated types, which were not available when CL\_ABAP\_BROWSER was developed.

Enumerated values can be specified for the size and format when the program is executed. The values are passed internally to the program by deserializing the character-like values into the local enumerated variables size and format. The exception for invalid values is caught internally; here the enumerated variables are initialized, which corresponds to the values of the enumeration constants sz-s and fmt-l.


### abenenum_description_abexa.htm

---
title: "Enumerated Objects, Type Description"
description: |
  This example demonstrates type description in enumerated objects(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_object_glosry.htm 'Glossary Entry'). Source Code REPORT demo_describe_enums. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenum_description_abexa.htm"
abapFile: "abenenum_description_abexa.htm"
keywords: ["select", "do", "try", "method", "class", "data", "types", "abenenum", "description", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Enumerated Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_types_usage.htm) → 

Enumerated Objects, Type Description

This example demonstrates type description in [enumerated objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_object_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_describe\_enums.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    TYPES:
      BEGIN OF ENUM size,
        s, m, l, xl, xxl,
      END OF ENUM size.
    DATA(size) = VALUE size( ).
    out->begin\_section( 'DESCRIBE FIELD' ).
    DESCRIBE FIELD size TYPE DATA(type)
                        LENGTH DATA(length) IN BYTE MODE
                        OUTPUT-LENGTH DATA(output\_length).
    out->write\_data( type
      )->write\_data( length
      )->write\_data( output\_length ).
    out->next\_section( 'CL\_ABAP\_ENUMDESCR' ).
    DATA(enum\_descr) = CAST cl\_abap\_enumdescr(
      cl\_abap\_typedescr=>describe\_by\_data( size ) ).
    out->write\_data( enum\_descr->kind
      )->write\_data( enum\_descr->type\_kind
      )->write\_data( enum\_descr->base\_type\_kind
      )->write\_data( enum\_descr->members ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The statement [DESCRIBE FIELD](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field.htm) and the type description class CL\_ABAP\_ENUMDESCR are applied to an enumerated variable size of the enumerated type with the same name.


### abenenum_deserialization_abexa.htm

---
title: "Enumerated Objects, Deserialization"
description: |
  This example demonstrates how a dynamically created XML file is deserialized to an enumerated object(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_object_glosry.htm 'Glossary Entry'). Source Code REPORT. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLAS
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenum_deserialization_abexa.htm"
abapFile: "abenenum_deserialization_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "types", "field-symbol", "abenenum", "deserialization", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Enumerated Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_types_usage.htm) → 

Enumerated Objects, Deserialization

This example demonstrates how a dynamically created XML file is deserialized to an [enumerated object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_object_glosry.htm "Glossary Entry").

Source Code

REPORT.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA input TYPE c LENGTH 3 VALUE 'XL'.
    cl\_demo\_input=>request( CHANGING field = input ).
    input = to\_upper( input ).
    TYPES:
      BEGIN OF ENUM size,
        s, m, l, xl, xxl,
      END OF ENUM size.
    DATA(xml) =
      cl\_abap\_conv\_codepage=>create\_out( )->convert(
        \`<asx:abap version="1.0"\` &&
        \` xmlns:asx="http://www.sap.com/abapxml">\` &&
        \`  <asx:values>\` &&
        \`  <ENUM>\` && input && \`</ENUM>\` &&
        \`  </asx:values>\` &&
        \`</asx:abap>\` ) ##no\_text.
    DATA size TYPE size.
    TRY.
        CALL TRANSFORMATION id
                            SOURCE XML xml
                            RESULT enum = size.
      CATCH cx\_transformation\_error INTO DATA(exc).
        cl\_demo\_output=>display( exc->previous->get\_text( ) ).
        RETURN.
    ENDTRY.
    cl\_demo\_output=>display( |Name:  { size
                           }\\nValue: { CONV i( size ) }| ).
    FIELD-SYMBOLS <fs> TYPE size.
    ASSIGN (input) TO <fs>.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( \`Wrong name\` ).
      RETURN.
    ENDIF.
    ASSERT size = <fs>.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The composition of a a byte string means that it can represent an XML file in asXML format for an enumerated object of the enumerated type size and is deserialized as such. Any invalid entries raise an exception.

Next, the dynamic assignment of a name to a field symbol is displayed. This is successful but the prerequisite here is that the enumerated type size is known in the current context. However, the XML file can be serialized in an enumerated object without static knowledge of the enumerated type.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Internal Tables / System Class for Internal Tables

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Internal Tables / System Class for Internal Tables

Included pages: 7


### abencl_abap_itab.htm

---
title: "System Class for Internal Tables"
description: |
  The class CL_ABAP_ITAB_UTILITIES contains the following methods: -   FLUSH_ITAB_KEY and FLUSH_ITAB_KEYS can be used to update individual secondary table keys(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensecondary_table_key_glosry.htm 'Glossary Entry') or all secondary tabl
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_itab.htm"
abapFile: "abencl_abap_itab.htm"
keywords: ["update", "do", "if", "try", "method", "class", "data", "internal-table", "abencl", "abap", "itab"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenitab.htm) → 

System Class for Internal Tables

The class CL\_ABAP\_ITAB\_UTILITIES contains the following methods:

-   FLUSH\_ITAB\_KEY and FLUSH\_ITAB\_KEYS can be used to update individual [secondary table keys](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensecondary_table_key_glosry.htm "Glossary Entry") or all secondary table keys of an internal table explicitly. Otherwise the update takes place as a [delayed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendelayed_update_glosry.htm "Glossary Entry") or [lazy update](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlazy_update_glosry.htm "Glossary Entry").

-   READ\_BINARY\_SEARCH\_CHECK can be used with the addition [BINARY SEARCH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapread_table_free.htm) to activate checks on the required sort for test purposes. If the required sort does not exist, the runtime error ITAB\_ILLEGAL\_ORDER is raised when the check is activated.

-   HAS\_COLLECT\_HASH\_ADMIN can be used to check whether the temporary hash management of the statement [COLLECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcollect.htm) exists for a standard table.

-   INDEX\_HEALTH\_CHECK can be used to check the consistency of [primary](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprimary_table_index_glosry.htm "Glossary Entry") and [secondary table indexes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensecondary_table_index_glosry.htm "Glossary Entry").

-   VIRTUAL\_SORT can be used to apply virtual sorts to a set of internal tables with the same number of rows. The internal tables are treated internally like a single combined table containing all the columns of the involved internal tables. The result is an array of row numbers of the virtually sorted combined table. See the related [executable examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_abexas.htm).

Continue
[Examples of Virtual Sorting of Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_abexas.htm)


### abenvirtual_sort_abexas.htm

---
title: "Examples of Virtual Sorting of Internal Tables"
description: |
  !Example(exa.gif 'Example') Virtual Sorting of an Internal Table(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_simple_abexa.htm) !Example(exa.gif 'Example') Virtual Sorting of Two Internal Tables(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvir
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_abexas.htm"
abapFile: "abenvirtual_sort_abexas.htm"
keywords: ["do", "if", "class", "data", "internal-table", "abenvirtual", "sort", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenitab.htm) →  [System Class for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_itab.htm) → 

Examples of Virtual Sorting of Internal Tables

Continue
![Example](exa.gif "Example") [Virtual Sorting of an Internal Table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_simple_abexa.htm)
![Example](exa.gif "Example") [Virtual Sorting of Two Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_combined_abexa.htm)
![Example](exa.gif "Example") [Virtual Sorting of an Internal Table with Filters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_filter_abexa.htm)
![Example](exa.gif "Example") [Virtual Sorting of Flight Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_flights_abexa.htm)


### abenvirtual_sort_simple_abexa.htm

---
title: "Virtual Sorting of an Internal Table"
description: |
  This example demonstrates the virtual sorting of a single internal table. Source Code REPORT demo_virtual_sort_simple. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. TYPES: BEGIN OF line, col1 TYPE i, col2 TYPE i, col3 TYPE string, col
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_simple_abexa.htm"
abapFile: "abenvirtual_sort_simple_abexa.htm"
keywords: ["select", "do", "case", "method", "class", "data", "types", "internal-table", "abenvirtual", "sort", "simple", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenitab.htm) →  [System Class for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_itab.htm) →  [Examples of Virtual Sorting of Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_abexas.htm) → 

Virtual Sorting of an Internal Table

This example demonstrates the virtual sorting of a single internal table.

Source Code

REPORT demo\_virtual\_sort\_simple.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES:
      BEGIN OF line,
        col1 TYPE i,
        col2 TYPE i,
        col3 TYPE string,
        col4 TYPE string,
      END OF line,
      itab TYPE STANDARD TABLE OF line WITH EMPTY KEY.
    DATA(rnd) = cl\_abap\_random\_int=>create( seed = + sy-uzeit
                                            min  = 1
                                            max  = 10 ).
    DATA(itab) = VALUE itab( FOR i = 1 UNTIL i > 10
                             ( col1 = rnd->get\_next( )
                               col2 = rnd->get\_next( )
                               col3 = substring(
                                        val = sy-abcde
                                        off = rnd->get\_next( ) - 1
                                        len = 1 )
                               col4 = substring(
                                        val = sy-abcde
                                        off = rnd->get\_next( ) - 1
                                        len = 1 ) ) ).
    DATA(out) = cl\_demo\_output=>new( ).
    out->write( itab ).
    out->next\_section( \`Virtual Sort by col1, col2, Ascending\` ).
    DATA(v\_index) =
      cl\_abap\_itab\_utilities=>virtual\_sort(
        im\_virtual\_source = VALUE #(
         ( source     = REF #( itab )
           components = VALUE #( ( name = 'col1' )
                                 ( name = 'col2' ) ) ) ) ).
    out->write( v\_index ).
    DATA sorted\_tab TYPE itab.
    sorted\_tab = VALUE #( FOR idx IN v\_index ( itab\[ idx \] ) ).
    DATA(test\_tab) = itab.
    SORT test\_tab STABLE BY col1 col2.
    ASSERT sorted\_tab = test\_tab.
    out->write( sorted\_tab ).
    out->next\_section( \`Virtual Sort by col3, col4, Descending\` ).
    v\_index =
      cl\_abap\_itab\_utilities=>virtual\_sort(
        im\_virtual\_source = VALUE #(
         ( source     = REF #( itab )
           components = VALUE #(
                         ( name = 'col3'
                           astext = abap\_true
                           descending = abap\_true )
                         ( name = 'col4'
                           astext = abap\_true
                           descending = abap\_true ) ) ) ) ).
    out->write( v\_index ).
    sorted\_tab = VALUE #( FOR idx IN v\_index ( itab\[ idx \] ) ).
    test\_tab = itab.
    SORT test\_tab STABLE BY col3 AS TEXT DESCENDING
                            col4 AS TEXT DESCENDING.
    ASSERT sorted\_tab = test\_tab.
    out->write( sorted\_tab ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An internal table filled with random numbers and letters is sorted virtually using the method VIRTUAL\_SORT of system class CL\_ABAP\_ITAB\_UTILITIES, first in ascending order by the first two columns and then in descending alphabetical order by the last two columns. The returned array contains the row numbers in the respective sort order. This array is used to fill an internal table sorted\_tab according to the sorting. To compare, an internal table test\_tab with the same content is constructed and sorted with the statement [SORT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapsort_itab.htm). The results are the same in both cases.


### abenvirtual_sort_combined_abexa.htm

---
title: "Virtual Sorting of Two Internal Tables"
description: |
  This example demonstrates the virtual sorting of two internal tables. Source Code REPORT demo_virtual_sort_combined. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. TYPES: BEGIN OF line1, col1 TYPE i, col2 TYPE i, END OF line1, itab1 TY
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_combined_abexa.htm"
abapFile: "abenvirtual_sort_combined_abexa.htm"
keywords: ["select", "do", "method", "class", "data", "types", "internal-table", "abenvirtual", "sort", "combined", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenitab.htm) →  [System Class for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_itab.htm) →  [Examples of Virtual Sorting of Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_abexas.htm) → 

Virtual Sorting of Two Internal Tables

This example demonstrates the virtual sorting of two internal tables.

Source Code

REPORT demo\_virtual\_sort\_combined.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES:
      BEGIN OF line1,
        col1 TYPE i,
        col2 TYPE i,
      END OF line1,
      itab1 TYPE STANDARD TABLE OF line1 WITH EMPTY KEY,
      BEGIN OF line2,
        col1 TYPE string,
        col2 TYPE string,
      END OF line2,
      itab2 TYPE STANDARD TABLE OF line2 WITH EMPTY KEY.
    TYPES:
      BEGIN OF test\_line,
        col11 TYPE i,
        col12 TYPE i,
        col21 TYPE string,
        col22 TYPE string,
      END OF test\_line,
      test\_tab TYPE STANDARD TABLE OF test\_line WITH EMPTY KEY.
    DATA(rnd) = cl\_abap\_random\_int=>create( seed = + sy-uzeit
                                            min  = 0
                                            max  = 1 ).
    DATA(itab1) = VALUE itab1( FOR i = 1 UNTIL i > 10
                               ( col1 = rnd->get\_next( )
                                 col2 = rnd->get\_next( ) ) ).
    DATA(itab2) =
      VALUE itab2( FOR i = 1 UNTIL i > 10
        ( col1 = cond #( when rnd->get\_next( ) = 0 THEN \`X\`
                                                   ELSE \`Y\` )
          col2 = cond #( when rnd->get\_next( ) = 0 THEN \`X\`
                                                   ELSE \`Y\` ) ) ).
    DATA(out) = cl\_demo\_output=>new( ).
    out->write( itab1
      )->write( itab2 ).
    out->next\_section(  \`Virtual Sort of Combined Tables\`
      )->begin\_section( \`itab1 by col1, col2, Ascending\`
      )->next\_section(  \`itab2 by col1, col2, Descending\` ).
    DATA(v\_index) =
      cl\_abap\_itab\_utilities=>virtual\_sort(
        im\_virtual\_source = VALUE #(
         ( source     = REF #( itab1 )
           components = VALUE #( ( name = 'col1' )
                                 ( name = 'col2' ) ) )
         ( source     = REF #( itab2 )
           components = VALUE #( ( name = 'col1'
                                   astext = abap\_true
                                   descending = abap\_true )
                                 ( name = 'col2'
                                   astext = abap\_true
                                   descending = abap\_true ) ) ) ) ).
    out->write( v\_index ).
    DATA sorted\_tab1 TYPE itab1.
    sorted\_tab1 = VALUE #( FOR idx IN v\_index ( itab1\[ idx \] ) ).
    DATA sorted\_tab2 TYPE itab2.
    sorted\_tab2 = VALUE #( FOR idx IN v\_index ( itab2\[ idx \] ) ).
    DATA(comb\_tab) = VALUE test\_tab( FOR i = 1 UNTIL i > 10
                        ( col11 = sorted\_tab1\[ i \]-col1
                          col12 = sorted\_tab1\[ i \]-col2
                          col21 = sorted\_tab2\[ i \]-col1
                          col22 = sorted\_tab2\[ i \]-col2 ) ).
    DATA(test\_tab) = VALUE test\_tab( FOR i = 1 UNTIL i > 10
                        ( col11 = itab1\[ i \]-col1
                          col12 = itab1\[ i \]-col2
                          col21 = itab2\[ i \]-col1
                          col22 = itab2\[ i \]-col2 ) ).
    SORT test\_tab STABLE BY col11
                            col12
                            col21 DESCENDING AS TEXT
                            col22 DESCENDING AS TEXT.
    ASSERT comb\_tab = test\_tab.
    out->write( comb\_tab ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An internal table itab1 containing random numbers and an internal table itab2 containing random letters are sorted together virtually using the method VIRTUAL\_SORT of system class CL\_ABAP\_ITAB\_UTILITIES, which sorts both columns of itab1 in ascending order and both columns of itab2 in descending alphabetical order. The returned array contains the row numbers in the sort order. This array is used to fill the internal table comb\_tab, which combines the columns of the involved tables, according to the sorting. To compare, another table test\_tab, which combines the content from itab1 and itab2, is constructed and sorted using the statement [SORT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapsort_itab.htm). The results are the same. However, in a real example the combined tables are not usually of interest. See the executable example [Virtual Sorting of Flight Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_flights_abexa.htm).


### abenvirtual_sort_filter_abexa.htm

---
title: "Virtual Sorting of an Internal Table with Filters"
description: |
  This example demonstrates the virtual sorting of an internal table with row filtering. Source Code REPORT demo_virtual_sort_filter. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. TYPES itab TYPE STANDARD TABLE OF i WITH EMPTY KEY. DATA
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_filter_abexa.htm"
abapFile: "abenvirtual_sort_filter_abexa.htm"
keywords: ["select", "do", "method", "class", "data", "types", "internal-table", "abenvirtual", "sort", "filter", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenitab.htm) →  [System Class for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_itab.htm) →  [Examples of Virtual Sorting of Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_abexas.htm) → 

Virtual Sorting of an Internal Table with Filters

This example demonstrates the virtual sorting of an internal table with row filtering.

Source Code

REPORT demo\_virtual\_sort\_filter.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TYPES
      itab TYPE STANDARD TABLE OF i WITH EMPTY KEY.
    DATA(rnd) = cl\_abap\_random\_int=>create( seed = + sy-uzeit
                                            min  = 1
                                            max  = 10 ).
    DATA(itab) = VALUE itab( FOR i = 1 UNTIL i > 10
                             ( rnd->get\_next( ) ) ).
    DATA(out) = cl\_demo\_output=>new( ).
    out->write( itab ).
    out->next\_section( \`Virtual Sort by table\_line with Filter\` ).
    DATA(v\_index) =
      cl\_abap\_itab\_utilities=>virtual\_sort(
        im\_virtual\_source = VALUE #(
         ( source     = REF #( itab )
           components = VALUE #( ( name = 'table\_line' ) ) ) )
        im\_filter\_index =  VALUE #( ( 1 ) ( 3 ) ( 5 ) ( 7 ) ( 9 ) ) ).
    out->write( v\_index ).
    DATA sorted\_tab TYPE itab.
    sorted\_tab = VALUE #( FOR idx IN v\_index ( itab\[ idx \] ) ).
    out->write( sorted\_tab ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An internal table filled with random numbers is sorted in ascending order by its row content using the method VIRTUAL\_SORT of system class CL\_ABAP\_ITAB\_UTILITIES. This passes a table filter\_tab containing the row numbers to be sorted. The returned array contains exactly these row numbers in the sort order. A table sorted\_tab is constructed in this order from the respective rows of itab.


### abenvirtual_sort_flights_abexa.htm

---
title: "Virtual Sorting of Flight Data"
description: |
  This example demonstrates the virtual sorting of an internal table containing flight data. Source Code REPORT demo_virtual_sort_flights. CLASS demo DEFINITION. PUBLIC SECTION. TYPES: BEGIN OF flight, carrid   TYPE s_carr_id, connid   TYPE s_conn_id, cityfrom TYPE s_city, cityto   TYPE s_cit
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_flights_abexa.htm"
abapFile: "abenvirtual_sort_flights_abexa.htm"
keywords: ["select", "do", "try", "catch", "method", "class", "data", "types", "internal-table", "abenvirtual", "sort", "flights", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenitab.htm) →  [System Class for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_itab.htm) →  [Examples of Virtual Sorting of Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_abexas.htm) → 

Virtual Sorting of Flight Data

This example demonstrates the virtual sorting of an internal table containing flight data.

Source Code

REPORT demo\_virtual\_sort\_flights.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    TYPES:
      BEGIN OF flight,
        carrid   TYPE s\_carr\_id,
        connid   TYPE s\_conn\_id,
        cityfrom TYPE s\_city,
        cityto   TYPE s\_city,
      END OF flight,
      flights TYPE STANDARD TABLE OF flight
              WITH EMPTY KEY,
      BEGIN OF city,
        city      TYPE  s\_city,
        latitude  TYPE  s\_lati,
        longitude TYPE  s\_long,
      END OF city,
      cities TYPE STANDARD TABLE OF city
                  WITH EMPTY KEY.
    CLASS-DATA:
      flight\_tab    TYPE flights,
      from\_city\_tab TYPE cities,
      to\_city\_tab   TYPE cities.
    CLASS-METHODS:
      main,
      class\_constructor.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    cl\_demo\_output=>new(
      )->next\_section(
      \`Ascending Sort by Latitude, Longitude of CITYFROM, CITYTO\`
      )->write( VALUE flights(
                  FOR <idx>
                  IN cl\_abap\_itab\_utilities=>virtual\_sort(
                       im\_virtual\_source =
                         VALUE #(
                           ( source     = REF #( from\_city\_tab )
                             components =
                               VALUE #( ( name = 'latitude' )
                                        ( name = 'longitude' ) ) )
                           ( source     = REF #( to\_city\_tab )
                             components =
                               VALUE #( ( name = 'latitude' )
                                        ( name = 'longitude' ) ) )
                           ( source     = REF #( flight\_tab )
                             components =
                               VALUE #( ( name = 'carrid' )
                                        ( name = 'connid' ) ) ) ) )
                  ( flight\_tab\[ <idx> \] ) )
      )->next\_section(
      \`Descending Sort by Latitude, Longitude of CITYFROM, CITYTO\`
      )->write( VALUE flights(
                  FOR <idx>
                  IN cl\_abap\_itab\_utilities=>virtual\_sort(
                       im\_virtual\_source =
                         VALUE #(
                           ( source     = REF #( from\_city\_tab )
                             components =
                               VALUE #( ( name = 'latitude'
                                          descending = abap\_true )
                                        ( name = 'longitude'
                                          descending = abap\_true ) ) )
                           ( source     = REF #( to\_city\_tab )
                             components =
                               VALUE #( ( name = 'latitude'
                                          descending = abap\_true )
                                        ( name = 'longitude'
                                          descending = abap\_true ) ) )
                           ( source     = REF #( flight\_tab )
                             components =
                               VALUE #( ( name = 'carrid' )
                                        ( name = 'connid' ) ) ) ) )
                  ( flight\_tab\[ <idx> \] ) )
      )->display( ).  ENDMETHOD.
  METHOD class\_constructor.
    SELECT carrid, connid, cityfrom, cityto
           FROM spfli
           INTO CORRESPONDING FIELDS OF TABLE @flight\_tab.
    SELECT city, latitude, longitude
           FROM sgeocity
           INTO TABLE @DATA(cities).
    TRY.
        from\_city\_tab = VALUE #( FOR <fs> IN flight\_tab
                                 ( cities\[ city = <fs>-cityfrom \] ) ).
        to\_city\_tab   = VALUE #( FOR <fs> IN flight\_tab
                                 ( cities\[ city = <fs>-cityto \] ) ).
      CATCH cx\_sy\_itab\_line\_not\_found.
        MESSAGE 'Flight model data not consistent,' &&
                ' use program SAPBC\_DATA\_GENERATOR' &&
                ' to create the data.' TYPE 'X'.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In this example, an internal table flight\_tab containing flight data is sorted virtually by the longitudes and latitudes of the departure and arrival cities. To do this, two additional tables from\_city\_tab and to\_city\_tab are constructed. The rows of these tables contain the longitudes and latitudes of the departure and arrival cities from the respective rows of flight\_tab.

Virtual sorting with the method VIRTUAL\_SORT of class CL\_ABAP\_ITAB\_UTILITIES takes place at the operand position of a [FOR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfor_itab.htm) expression for a table iteration. The virtual sorting involves all three internal tables. The temporary result of the sorting is used to construct a sorted internal table from the rows of flight\_tab. This table is only temporary, and is an input parameter of the method WRITE of class CL\_DEMO\_OUTPUT.

It is sorted once in ascending order and once in descending order. This does not change the order of the rows in the internal tables that are involved. These remain in their original unsorted state. Virtual sorting makes it possible to generate various sorted output data without affecting the original data.


### abenvirtual_sort_abexas.htm

---
title: "Examples of Virtual Sorting of Internal Tables"
description: |
  !Example(exa.gif 'Example') Virtual Sorting of an Internal Table(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_simple_abexa.htm) !Example(exa.gif 'Example') Virtual Sorting of Two Internal Tables(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvir
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_abexas.htm"
abapFile: "abenvirtual_sort_abexas.htm"
keywords: ["do", "if", "class", "data", "internal-table", "abenvirtual", "sort", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenitab.htm) →  [System Class for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencl_abap_itab.htm) → 

Examples of Virtual Sorting of Internal Tables

Continue
![Example](exa.gif "Example") [Virtual Sorting of an Internal Table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_simple_abexa.htm)
![Example](exa.gif "Example") [Virtual Sorting of Two Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_combined_abexa.htm)
![Example](exa.gif "Example") [Virtual Sorting of an Internal Table with Filters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_filter_abexa.htm)
![Example](exa.gif "Example") [Virtual Sorting of Flight Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvirtual_sort_flights_abexa.htm)


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / DESCRIBE / DESCRIBE FIELD

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / DESCRIBE / DESCRIBE - internal variant

Included pages: 2


### abendescribe_internal.htm

---
title: "DESCRIBE - internal variant"
description: |
  This statement is for internal use only. It must not be used in application programs. -   DESCRIBE FIELD INTO(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm) DESCRIBE FIELD INTO(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_internal.htm"
abapFile: "abendescribe_internal.htm"
keywords: ["do", "data", "abendescribe", "internal"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Attributes of Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_field.htm) →  [DESCRIBE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe.htm) → 

DESCRIBE - internal variant

This statement is for internal use only.
It must not be used in application programs.

-   [DESCRIBE FIELD INTO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm)

Continue
[DESCRIBE FIELD INTO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm)


### abapdescribe_field_into.htm

---
title: "DESCRIBE FIELD INTO"
description: |
  This statement is for internal use only. It must not be used in application programs. Syntax DESCRIBE FIELD dobj INTO td. Effect All attributes of the field f, its components, subcomponents, and so on, are in the output of the field td (type description). td must have the type SYDES_DESC, defined i
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm"
abapFile: "abapdescribe_field_into.htm"
keywords: ["select", "do", "if", "try", "method", "data", "types", "internal-table", "abapdescribe", "field", "into"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Attributes of Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_field.htm) →  [DESCRIBE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe.htm) →  [DESCRIBE - internal variant](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_internal.htm) → 

DESCRIBE FIELD INTO

This statement is for internal use only.
It must not be used in application programs.

Syntax

DESCRIBE FIELD dobj INTO td.

Effect

All attributes of the field f, its components, subcomponents, and so on, are in the output of the field td (type description). td must have the type SYDES\_DESC, defined in the [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") SYDES.

The structure SYDES\_DESC has two table-like components TYPES and NAMES:

-   The tree structure of the type belonging to f is mapped to TYPES. The components of a node are stored in the table TYPES in a continuous manner. The beginning and end of the row area that represents the components are stored in TYPES-FROM and TYPES-TO. The reference to the superior node can be found in TYPES-BACK. If no superior or subordinate node exists, then this is marked by the value 0 (for the relevance of further components, see the following sections).
    
-   The names of components, types, and so on. are not stored directly in TYPES. Instead, the components TYPES-IDX\_... hold an index in the name table NAMES. The value 0 indicates that there is no reference to the name table.
    NAMES contains the names in the component NAMES-NAME, possibly in parts. If a name continues in the following row, this is indicated by an asterisk ('\*') in the component NAMES-CONTINUE.
    

The type description table (TYPES) not only stores information about the tree structure but also further information about the type of f or its components. In particular, this includes all information that can be determined using the usual additions of DESCRIBE FIELD. In detail, TYPES contains the following columns:

IDX\_NAME

Component name

IDX\_USER\_TYPE

Name of a user-defined type, in other words a type defined by a [TYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes.htm) statement. Derived types (... TYPE A-B) and structures from ABAP Dictionary are not considered to be user-defined types.

CONTEXT

For user-defined types only: The context in which the type is defined. Possible values are defined in the constant SYDES\_CONTEXT of the type group SYDES. Only use these constants to carry out a comparison. The following type contexts are distinguished:
SYDES\_CONTEXT-PROGRAM: Program-global type
SYDES\_CONTEXT-FORM : FORM\-local type
SYDES\_CONTEXT-FUNCTION: FUNCTION\-local type
SYDES\_CONTEXT-METHOD : METHOD\-local type

IDX\_CONTEXT\_NAME

For user-defined types only:
In a local context: The name of the FORM or FUNCTION in which the type was defined. The name of the associated program is then the first entry in the name table.
In a global context: The name of the program in which the type was defined.

IDX\_EDIT\_MASK

Conversion routine from ABAP Dictionary, like the addition EDIT MASK in a simple DESCRIBE.

IDX\_HELP\_ID

Help ID when referencing fields from ABAP Dictionary

LENGTH

Internal length, like the addition LENGTH in a simple DESCRIBE

OUTPUT\_LENGTH

Output length, like the addition OUTPUT-LENGTH in a simple DESCRIBE

DECIMALS

Number of [decimal digits](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendecimal_place_glosry.htm "Glossary Entry"), like the addition DECIMALS in a simple DESCRIBE

TYPE

ABAP type, like the addition TYPE in a simple DESCRIBE. If DESCRIBE INTO is applied to a nested structure which contains a [boxed component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboxed_component_glosry.htm "Glossary Entry"), the type is returned with the internal ID j ([static box](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_box_glosry.htm "Glossary Entry")).

TABLE\_KIND

A [table category](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_tabkind.htm) is stored here for the components which represent an internal table. The same values are returned as with the variant [DESCRIBE TABLE itab KIND k](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_table.htm). For components which do not represent a table, the return code is set to SYDES\_KIND-UNDEFINED (see type group SYDES).

Example

Take the following definition of the complex data type EMPLOYEE\_STRUC:

PROGRAM DESCTEST.
TYPES: BEGIN OF name\_struc,
         first  TYPE c LENGTH 20,
         last   TYPE c LENGTH 20,
       END OF name\_struc,
       BEGIN OF absence\_time\_struc,
         day        TYPE d,
         from       TYPE t,
         to         TYPE t,
       END OF absence\_time\_struc,
       phone\_number TYPE n LENGTH 20,
       BEGIN OF employee\_struc,
         id         LIKE sbook-customid,
         name       TYPE name\_struc,
         BEGIN OF address,
           street  TYPE c LENGTH 30,
           zipcode TYPE n LENGTH 4,
           place   TYPE c LENGTH 30,
         END OF address,
         salary\_per\_month TYPE p LENGTH 10 DECIMALS 3,
         absent           TYPE STANDARD TABLE OF absence\_time\_struc
                               WITH NON-UNIQUE DEFAULT KEY,
         phone            TYPE STANDARD TABLE OF phone\_number
                               WITH NON-UNIQUE DEFAULT KEY,
       END OF employee\_struc.

The structure of the type can be determined by collecting the type group SYDES as follows:

DATA: employee TYPE employee\_struc,
      td       TYPE sydes\_desc.
DESCRIBE FIELD employee INTO td.

The following table shows a few selected columns of the type description table TD-TYPES. To make it easier to read, the names of the columns IDX\_NAME, IDX\_UERR\_TYPE, and IDX\_EDIT\_MASK have been shortened:

   |FROM| TO |BACK|NAME|UTYP|EMSK|TYPE
\---|----|----|----|----|----|----|----
01 |  2 |  7 |  0 |  0 |  2 |  0 |  v
02 |  0 |  0 |  1 |  6 |  0 |  4 |  N
03 |  8 |  9 |  1 |  7 |  5 |  0 |  u
04 | 10 | 12 |  1 |  8 |  0 |  0 |  u
05 |  0 |  0 |  1 |  9 |  0 |  0 |  P
06 | 13 | 13 |  1 | 11 |  0 |  0 |  h
07 | 17 | 17 |  1 | 12 |  0 |  0 |  h
08 |  0 |  0 |  3 | 13 |  0 |  0 |  C
09 |  0 |  0 |  3 | 14 |  0 |  0 |  C
10 |  0 |  0 |  4 | 15 |  0 |  0 |  C
11 |  0 |  0 |  4 | 16 |  0 |  0 |  N
12 |  0 |  0 |  4 | 17 |  0 |  0 |  C
13 | 14 | 16 |  6 |  0 | 18 |  0 |  u
14 |  0 |  0 | 13 | 20 |  0 |  0 |  D
15 |  0 |  0 | 13 | 21 |  0 |  0 |  T
16 |  0 |  0 | 13 | 22 |  0 |  0 |  T
17 |  0 |  0 |  7 |  0 |  0 |  0 |  N

Note that the entries in rows 6 and 7 represent internal tables (ABAP type h). In an internal table, there is always an entry for the associated row type (rows 13 and 17).
The indexes in the rows 5 to 7 refer to entries in the name table TD-NAMES. Taking, for example, row 3, the associated component name in TD-NAMES is found from row 7 (NAME) onward and the associated user type from row 5 (NAME\_STRUC) onward.
The name table TD-NAMES contains the following entries. Note that the names SALARY\_PER\_MONTH and ABSENCE\_TIME\_STRUC are stored in two parts:

   |CONTINUE|NAME                   |CONTINUE|NAME
\---|--------|--------------     ----|--------|--------------
01 |        |DESCTEST            12 |        |PHONE
02 |        |EMPLOYEE\_STRUC      13 |        |FIRST
03 |        |SBOOK-CUSTOMID      14 |        |LAST
04 |        |==ALPHA             15 |        |STREET
05 |        |NAME\_STRUC          16 |        |ZIPCODE
06 |        |ID                  17 |        |PLACE
07 |        |NAME                18 |   \*    |ABSENCE\_TIME\_ST
08 |        |ADDRESS             19 |        |RUC
09 |   \*    |SALARY\_PER\_MONT     20 |        |DAY
10 |        |H                   21 |        |FROM
11 |        |ABSENT              22 |        |TO


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / DESCRIBE / DESCRIBE DISTANCE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / DESCRIBE / DESCRIBE - internal variant

Included pages: 2


### abendescribe_internal.htm

---
title: "DESCRIBE - internal variant"
description: |
  This statement is for internal use only. It must not be used in application programs. -   DESCRIBE FIELD INTO(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm) DESCRIBE FIELD INTO(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_internal.htm"
abapFile: "abendescribe_internal.htm"
keywords: ["do", "data", "abendescribe", "internal"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Attributes of Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_field.htm) →  [DESCRIBE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe.htm) → 

DESCRIBE - internal variant

This statement is for internal use only.
It must not be used in application programs.

-   [DESCRIBE FIELD INTO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm)

Continue
[DESCRIBE FIELD INTO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm)


### abapdescribe_field_into.htm

---
title: "DESCRIBE FIELD INTO"
description: |
  This statement is for internal use only. It must not be used in application programs. Syntax DESCRIBE FIELD dobj INTO td. Effect All attributes of the field f, its components, subcomponents, and so on, are in the output of the field td (type description). td must have the type SYDES_DESC, defined i
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm"
abapFile: "abapdescribe_field_into.htm"
keywords: ["select", "do", "if", "try", "method", "data", "types", "internal-table", "abapdescribe", "field", "into"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Attributes of Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_field.htm) →  [DESCRIBE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe.htm) →  [DESCRIBE - internal variant](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_internal.htm) → 

DESCRIBE FIELD INTO

This statement is for internal use only.
It must not be used in application programs.

Syntax

DESCRIBE FIELD dobj INTO td.

Effect

All attributes of the field f, its components, subcomponents, and so on, are in the output of the field td (type description). td must have the type SYDES\_DESC, defined in the [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") SYDES.

The structure SYDES\_DESC has two table-like components TYPES and NAMES:

-   The tree structure of the type belonging to f is mapped to TYPES. The components of a node are stored in the table TYPES in a continuous manner. The beginning and end of the row area that represents the components are stored in TYPES-FROM and TYPES-TO. The reference to the superior node can be found in TYPES-BACK. If no superior or subordinate node exists, then this is marked by the value 0 (for the relevance of further components, see the following sections).
    
-   The names of components, types, and so on. are not stored directly in TYPES. Instead, the components TYPES-IDX\_... hold an index in the name table NAMES. The value 0 indicates that there is no reference to the name table.
    NAMES contains the names in the component NAMES-NAME, possibly in parts. If a name continues in the following row, this is indicated by an asterisk ('\*') in the component NAMES-CONTINUE.
    

The type description table (TYPES) not only stores information about the tree structure but also further information about the type of f or its components. In particular, this includes all information that can be determined using the usual additions of DESCRIBE FIELD. In detail, TYPES contains the following columns:

IDX\_NAME

Component name

IDX\_USER\_TYPE

Name of a user-defined type, in other words a type defined by a [TYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes.htm) statement. Derived types (... TYPE A-B) and structures from ABAP Dictionary are not considered to be user-defined types.

CONTEXT

For user-defined types only: The context in which the type is defined. Possible values are defined in the constant SYDES\_CONTEXT of the type group SYDES. Only use these constants to carry out a comparison. The following type contexts are distinguished:
SYDES\_CONTEXT-PROGRAM: Program-global type
SYDES\_CONTEXT-FORM : FORM\-local type
SYDES\_CONTEXT-FUNCTION: FUNCTION\-local type
SYDES\_CONTEXT-METHOD : METHOD\-local type

IDX\_CONTEXT\_NAME

For user-defined types only:
In a local context: The name of the FORM or FUNCTION in which the type was defined. The name of the associated program is then the first entry in the name table.
In a global context: The name of the program in which the type was defined.

IDX\_EDIT\_MASK

Conversion routine from ABAP Dictionary, like the addition EDIT MASK in a simple DESCRIBE.

IDX\_HELP\_ID

Help ID when referencing fields from ABAP Dictionary

LENGTH

Internal length, like the addition LENGTH in a simple DESCRIBE

OUTPUT\_LENGTH

Output length, like the addition OUTPUT-LENGTH in a simple DESCRIBE

DECIMALS

Number of [decimal digits](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendecimal_place_glosry.htm "Glossary Entry"), like the addition DECIMALS in a simple DESCRIBE

TYPE

ABAP type, like the addition TYPE in a simple DESCRIBE. If DESCRIBE INTO is applied to a nested structure which contains a [boxed component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboxed_component_glosry.htm "Glossary Entry"), the type is returned with the internal ID j ([static box](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_box_glosry.htm "Glossary Entry")).

TABLE\_KIND

A [table category](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_tabkind.htm) is stored here for the components which represent an internal table. The same values are returned as with the variant [DESCRIBE TABLE itab KIND k](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_table.htm). For components which do not represent a table, the return code is set to SYDES\_KIND-UNDEFINED (see type group SYDES).

Example

Take the following definition of the complex data type EMPLOYEE\_STRUC:

PROGRAM DESCTEST.
TYPES: BEGIN OF name\_struc,
         first  TYPE c LENGTH 20,
         last   TYPE c LENGTH 20,
       END OF name\_struc,
       BEGIN OF absence\_time\_struc,
         day        TYPE d,
         from       TYPE t,
         to         TYPE t,
       END OF absence\_time\_struc,
       phone\_number TYPE n LENGTH 20,
       BEGIN OF employee\_struc,
         id         LIKE sbook-customid,
         name       TYPE name\_struc,
         BEGIN OF address,
           street  TYPE c LENGTH 30,
           zipcode TYPE n LENGTH 4,
           place   TYPE c LENGTH 30,
         END OF address,
         salary\_per\_month TYPE p LENGTH 10 DECIMALS 3,
         absent           TYPE STANDARD TABLE OF absence\_time\_struc
                               WITH NON-UNIQUE DEFAULT KEY,
         phone            TYPE STANDARD TABLE OF phone\_number
                               WITH NON-UNIQUE DEFAULT KEY,
       END OF employee\_struc.

The structure of the type can be determined by collecting the type group SYDES as follows:

DATA: employee TYPE employee\_struc,
      td       TYPE sydes\_desc.
DESCRIBE FIELD employee INTO td.

The following table shows a few selected columns of the type description table TD-TYPES. To make it easier to read, the names of the columns IDX\_NAME, IDX\_UERR\_TYPE, and IDX\_EDIT\_MASK have been shortened:

   |FROM| TO |BACK|NAME|UTYP|EMSK|TYPE
\---|----|----|----|----|----|----|----
01 |  2 |  7 |  0 |  0 |  2 |  0 |  v
02 |  0 |  0 |  1 |  6 |  0 |  4 |  N
03 |  8 |  9 |  1 |  7 |  5 |  0 |  u
04 | 10 | 12 |  1 |  8 |  0 |  0 |  u
05 |  0 |  0 |  1 |  9 |  0 |  0 |  P
06 | 13 | 13 |  1 | 11 |  0 |  0 |  h
07 | 17 | 17 |  1 | 12 |  0 |  0 |  h
08 |  0 |  0 |  3 | 13 |  0 |  0 |  C
09 |  0 |  0 |  3 | 14 |  0 |  0 |  C
10 |  0 |  0 |  4 | 15 |  0 |  0 |  C
11 |  0 |  0 |  4 | 16 |  0 |  0 |  N
12 |  0 |  0 |  4 | 17 |  0 |  0 |  C
13 | 14 | 16 |  6 |  0 | 18 |  0 |  u
14 |  0 |  0 | 13 | 20 |  0 |  0 |  D
15 |  0 |  0 | 13 | 21 |  0 |  0 |  T
16 |  0 |  0 | 13 | 22 |  0 |  0 |  T
17 |  0 |  0 |  7 |  0 |  0 |  0 |  N

Note that the entries in rows 6 and 7 represent internal tables (ABAP type h). In an internal table, there is always an entry for the associated row type (rows 13 and 17).
The indexes in the rows 5 to 7 refer to entries in the name table TD-NAMES. Taking, for example, row 3, the associated component name in TD-NAMES is found from row 7 (NAME) onward and the associated user type from row 5 (NAME\_STRUC) onward.
The name table TD-NAMES contains the following entries. Note that the names SALARY\_PER\_MONTH and ABSENCE\_TIME\_STRUC are stored in two parts:

   |CONTINUE|NAME                   |CONTINUE|NAME
\---|--------|--------------     ----|--------|--------------
01 |        |DESCTEST            12 |        |PHONE
02 |        |EMPLOYEE\_STRUC      13 |        |FIRST
03 |        |SBOOK-CUSTOMID      14 |        |LAST
04 |        |==ALPHA             15 |        |STREET
05 |        |NAME\_STRUC          16 |        |ZIPCODE
06 |        |ID                  17 |        |PLACE
07 |        |NAME                18 |   \*    |ABSENCE\_TIME\_ST
08 |        |ADDRESS             19 |        |RUC
09 |   \*    |SALARY\_PER\_MONT     20 |        |DAY
10 |        |H                   21 |        |FROM
11 |        |ABSENT              22 |        |TO


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / DESCRIBE / DESCRIBE - internal variant

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / DESCRIBE / DESCRIBE - internal variant

Included pages: 2


### abendescribe_internal.htm

---
title: "DESCRIBE - internal variant"
description: |
  This statement is for internal use only. It must not be used in application programs. -   DESCRIBE FIELD INTO(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm) DESCRIBE FIELD INTO(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_internal.htm"
abapFile: "abendescribe_internal.htm"
keywords: ["do", "data", "abendescribe", "internal"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Attributes of Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_field.htm) →  [DESCRIBE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe.htm) → 

DESCRIBE - internal variant

This statement is for internal use only.
It must not be used in application programs.

-   [DESCRIBE FIELD INTO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm)

Continue
[DESCRIBE FIELD INTO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm)


### abapdescribe_field_into.htm

---
title: "DESCRIBE FIELD INTO"
description: |
  This statement is for internal use only. It must not be used in application programs. Syntax DESCRIBE FIELD dobj INTO td. Effect All attributes of the field f, its components, subcomponents, and so on, are in the output of the field td (type description). td must have the type SYDES_DESC, defined i
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_field_into.htm"
abapFile: "abapdescribe_field_into.htm"
keywords: ["select", "do", "if", "try", "method", "data", "types", "internal-table", "abapdescribe", "field", "into"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Attributes of Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_field.htm) →  [DESCRIBE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe.htm) →  [DESCRIBE - internal variant](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_internal.htm) → 

DESCRIBE FIELD INTO

This statement is for internal use only.
It must not be used in application programs.

Syntax

DESCRIBE FIELD dobj INTO td.

Effect

All attributes of the field f, its components, subcomponents, and so on, are in the output of the field td (type description). td must have the type SYDES\_DESC, defined in the [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") SYDES.

The structure SYDES\_DESC has two table-like components TYPES and NAMES:

-   The tree structure of the type belonging to f is mapped to TYPES. The components of a node are stored in the table TYPES in a continuous manner. The beginning and end of the row area that represents the components are stored in TYPES-FROM and TYPES-TO. The reference to the superior node can be found in TYPES-BACK. If no superior or subordinate node exists, then this is marked by the value 0 (for the relevance of further components, see the following sections).
    
-   The names of components, types, and so on. are not stored directly in TYPES. Instead, the components TYPES-IDX\_... hold an index in the name table NAMES. The value 0 indicates that there is no reference to the name table.
    NAMES contains the names in the component NAMES-NAME, possibly in parts. If a name continues in the following row, this is indicated by an asterisk ('\*') in the component NAMES-CONTINUE.
    

The type description table (TYPES) not only stores information about the tree structure but also further information about the type of f or its components. In particular, this includes all information that can be determined using the usual additions of DESCRIBE FIELD. In detail, TYPES contains the following columns:

IDX\_NAME

Component name

IDX\_USER\_TYPE

Name of a user-defined type, in other words a type defined by a [TYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes.htm) statement. Derived types (... TYPE A-B) and structures from ABAP Dictionary are not considered to be user-defined types.

CONTEXT

For user-defined types only: The context in which the type is defined. Possible values are defined in the constant SYDES\_CONTEXT of the type group SYDES. Only use these constants to carry out a comparison. The following type contexts are distinguished:
SYDES\_CONTEXT-PROGRAM: Program-global type
SYDES\_CONTEXT-FORM : FORM\-local type
SYDES\_CONTEXT-FUNCTION: FUNCTION\-local type
SYDES\_CONTEXT-METHOD : METHOD\-local type

IDX\_CONTEXT\_NAME

For user-defined types only:
In a local context: The name of the FORM or FUNCTION in which the type was defined. The name of the associated program is then the first entry in the name table.
In a global context: The name of the program in which the type was defined.

IDX\_EDIT\_MASK

Conversion routine from ABAP Dictionary, like the addition EDIT MASK in a simple DESCRIBE.

IDX\_HELP\_ID

Help ID when referencing fields from ABAP Dictionary

LENGTH

Internal length, like the addition LENGTH in a simple DESCRIBE

OUTPUT\_LENGTH

Output length, like the addition OUTPUT-LENGTH in a simple DESCRIBE

DECIMALS

Number of [decimal digits](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendecimal_place_glosry.htm "Glossary Entry"), like the addition DECIMALS in a simple DESCRIBE

TYPE

ABAP type, like the addition TYPE in a simple DESCRIBE. If DESCRIBE INTO is applied to a nested structure which contains a [boxed component](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboxed_component_glosry.htm "Glossary Entry"), the type is returned with the internal ID j ([static box](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_box_glosry.htm "Glossary Entry")).

TABLE\_KIND

A [table category](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_tabkind.htm) is stored here for the components which represent an internal table. The same values are returned as with the variant [DESCRIBE TABLE itab KIND k](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_table.htm). For components which do not represent a table, the return code is set to SYDES\_KIND-UNDEFINED (see type group SYDES).

Example

Take the following definition of the complex data type EMPLOYEE\_STRUC:

PROGRAM DESCTEST.
TYPES: BEGIN OF name\_struc,
         first  TYPE c LENGTH 20,
         last   TYPE c LENGTH 20,
       END OF name\_struc,
       BEGIN OF absence\_time\_struc,
         day        TYPE d,
         from       TYPE t,
         to         TYPE t,
       END OF absence\_time\_struc,
       phone\_number TYPE n LENGTH 20,
       BEGIN OF employee\_struc,
         id         LIKE sbook-customid,
         name       TYPE name\_struc,
         BEGIN OF address,
           street  TYPE c LENGTH 30,
           zipcode TYPE n LENGTH 4,
           place   TYPE c LENGTH 30,
         END OF address,
         salary\_per\_month TYPE p LENGTH 10 DECIMALS 3,
         absent           TYPE STANDARD TABLE OF absence\_time\_struc
                               WITH NON-UNIQUE DEFAULT KEY,
         phone            TYPE STANDARD TABLE OF phone\_number
                               WITH NON-UNIQUE DEFAULT KEY,
       END OF employee\_struc.

The structure of the type can be determined by collecting the type group SYDES as follows:

DATA: employee TYPE employee\_struc,
      td       TYPE sydes\_desc.
DESCRIBE FIELD employee INTO td.

The following table shows a few selected columns of the type description table TD-TYPES. To make it easier to read, the names of the columns IDX\_NAME, IDX\_UERR\_TYPE, and IDX\_EDIT\_MASK have been shortened:

   |FROM| TO |BACK|NAME|UTYP|EMSK|TYPE
\---|----|----|----|----|----|----|----
01 |  2 |  7 |  0 |  0 |  2 |  0 |  v
02 |  0 |  0 |  1 |  6 |  0 |  4 |  N
03 |  8 |  9 |  1 |  7 |  5 |  0 |  u
04 | 10 | 12 |  1 |  8 |  0 |  0 |  u
05 |  0 |  0 |  1 |  9 |  0 |  0 |  P
06 | 13 | 13 |  1 | 11 |  0 |  0 |  h
07 | 17 | 17 |  1 | 12 |  0 |  0 |  h
08 |  0 |  0 |  3 | 13 |  0 |  0 |  C
09 |  0 |  0 |  3 | 14 |  0 |  0 |  C
10 |  0 |  0 |  4 | 15 |  0 |  0 |  C
11 |  0 |  0 |  4 | 16 |  0 |  0 |  N
12 |  0 |  0 |  4 | 17 |  0 |  0 |  C
13 | 14 | 16 |  6 |  0 | 18 |  0 |  u
14 |  0 |  0 | 13 | 20 |  0 |  0 |  D
15 |  0 |  0 | 13 | 21 |  0 |  0 |  T
16 |  0 |  0 | 13 | 22 |  0 |  0 |  T
17 |  0 |  0 |  7 |  0 |  0 |  0 |  N

Note that the entries in rows 6 and 7 represent internal tables (ABAP type h). In an internal table, there is always an entry for the associated row type (rows 13 and 17).
The indexes in the rows 5 to 7 refer to entries in the name table TD-NAMES. Taking, for example, row 3, the associated component name in TD-NAMES is found from row 7 (NAME) onward and the associated user type from row 5 (NAME\_STRUC) onward.
The name table TD-NAMES contains the following entries. Note that the names SALARY\_PER\_MONTH and ABSENCE\_TIME\_STRUC are stored in two parts:

   |CONTINUE|NAME                   |CONTINUE|NAME
\---|--------|--------------     ----|--------|--------------
01 |        |DESCTEST            12 |        |PHONE
02 |        |EMPLOYEE\_STRUC      13 |        |FIRST
03 |        |SBOOK-CUSTOMID      14 |        |LAST
04 |        |==ALPHA             15 |        |STREET
05 |        |NAME\_STRUC          16 |        |ZIPCODE
06 |        |ID                  17 |        |PLACE
07 |        |NAME                18 |   \*    |ABSENCE\_TIME\_ST
08 |        |ADDRESS             19 |        |RUC
09 |   \*    |SALARY\_PER\_MONT     20 |        |DAY
10 |        |H                   21 |        |FROM
11 |        |ABSENT              22 |        |TO


---


## ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / RTTS - Runtime Type Services

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing Internal Data / Attributes of Data Objects / RTTS - Runtime Type Services

Included pages: 3


### abenrtti.htm

---
title: "RTTS - Runtime Type Services"
description: |
  The RTTS(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_services_glosry.htm 'Glossary Entry') are implemented using a hierarchy of type description classes(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_class_glosry.htm 'Glossary Entry') that co
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrtti.htm"
abapFile: "abenrtti.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "abenrtti"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Attributes of Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_field.htm) → 

RTTS - Runtime Type Services

The [RTTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_services_glosry.htm "Glossary Entry") are implemented using a hierarchy of [type description classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_class_glosry.htm "Glossary Entry") that contain the methods for [Runtime Type Creation (RTTC)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_creation_glosry.htm "Glossary Entry") and [Runtime Type Identification (RTTI)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrun_time_type_identific_glosry.htm "Glossary Entry"). Using these system classes it is possible to

-   determine type information of existing [instances](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_glosry.htm "Glossary Entry") and [type names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_names.htm) in the [ABAP type system](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_objects_oview.htm) at runtime.

-   define new data types at runtime.

Concept

The properties of the types are represented by the attributes of [type description objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_object_glosry.htm "Glossary Entry"). For each type there is exactly one type description object. The attributes of the type description object contain information about the properties of the type. For each category of type (elementary type, table, class, and so on), there is a type description class with special attributes for the special type properties. The class hierarchy of the type description classes corresponds to the hierarchy of the type categories in the [ABAP type system](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_objects_oview.htm).

In addition, type description classes for complex types, references, classes, and interfaces have special methods for specifying references to partial types. These methods can be used can navigate to all partial types using a composite type.

Type description objects can only be created using the methods of type description classes. To get a reference to a type description object of a type, the static methods of the class CL\_ABAP\_TYPEDESCR can be used or call methods of the special type description classes.

Note

In the statement [CREATE DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data.htm), type description objects can be specified after the addition [HANDLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_data_handle.htm) to create data objects with dynamically created data types.

Hierarchy of Type Description Classes

CL\_ABAP\_TYPEDESCR
  |
  |--CL\_ABAP\_DATADESCR
  |   |
  |   |--CL\_ABAP\_ELEMDESCR
  |   |   |
  |   |   |--CL\_ABAP\_ENUMDESCR
  |   |
  |   |--CL\_ABAP\_REFDESCR
  |   |--CL\_ABAP\_COMPLEXDESCR
  |       |
  |       |--CL\_ABAP\_STRUCTDESCR
  |       |--CL\_ABAP\_TABLEDESCR
  |
  |--CL\_ABAP\_OBJECTDESCR
     |
     |--CL\_ABAP\_CLASSDESCR
     |--CL\_ABAP\_INTFDESCR

Example

Reading the type attributes of an elementary type from a type object generated with the method DESCRIBE\_BY\_DATA.

TYPES my\_type TYPE p LENGTH 16 DECIMALS 6.
DATA  my\_data TYPE my\_type.
DATA(descr) = cl\_abap\_typedescr=>describe\_by\_data( my\_data ).
cl\_demo\_output=>display(
  |Typename: { descr->absolute\_name }\\n| &&
  |Kind:     { descr->type\_kind     }\\n| &&
  |Length:   { descr->length        }\\n| &&
  |Decimals: { descr->decimals      }\\n| ).

Example

Reading the attributes of the components of a structure. The reference to the type object is assigned using a down cast to a reference variable of type CL\_ABAP\_STRUCT\_DESCR.

cl\_demo\_output=>display( CAST cl\_abap\_structdescr(
  cl\_abap\_typedescr=>describe\_by\_name( 'SYST' ) )->components ).

Continue
![Example](exa.gif "Example") [Determining Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrtti_data_type_abexa.htm)
![Example](exa.gif "Example") [Determining Object Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrtti_object_type_abexa.htm)


### abenrtti_data_type_abexa.htm

---
title: "Determining Data Types"
description: |
  This example demonstrates how the attributes of data types can be determined at runtime. Source Code REPORT demo_rtti_data_types. CLASS conv_exc DEFINITION INHERITING FROM cx_static_check. ENDCLASS. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION.
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrtti_data_type_abexa.htm"
abapFile: "abenrtti_data_type_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "types", "abenrtti", "type", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Attributes of Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_field.htm) →  [RTTS - Runtime Type Services](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrtti.htm) → 

Determining Data Types

This example demonstrates how the attributes of data types can be determined at runtime.

Source Code

REPORT demo\_rtti\_data\_types.
CLASS conv\_exc DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: type1 TYPE c LENGTH 30 VALUE 'SCARR',
          type2 TYPE c LENGTH 30 VALUE 'SPFLI'.
    DATA: dref1 TYPE REF TO data,
          dref2 TYPE REF TO data.
    FIELD-SYMBOLS: <data1> TYPE any,
                   <data2> TYPE any.
    DATA: descr\_ref1 TYPE REF TO cl\_abap\_typedescr,
          descr\_ref2 TYPE REF TO cl\_abap\_typedescr.
    cl\_demo\_input=>add\_field( CHANGING field = type1 ).
    cl\_demo\_input=>request(   CHANGING field = type2 ).
    TRY.
        CREATE DATA: dref1 TYPE (type1),
                     dref2 TYPE (type2).
        ASSIGN: dref1->\* TO <data1>,
                dref2->\* TO <data2>.
      CATCH cx\_sy\_create\_data\_error.
        cl\_demo\_output=>display( 'Create data error!' ).
        LEAVE PROGRAM.
    ENDTRY.
    descr\_ref1 = cl\_abap\_typedescr=>describe\_by\_data( <data1> ).
    descr\_ref2 = cl\_abap\_typedescr=>describe\_by\_data( <data2> ).
    TRY.
        IF descr\_ref1 <> descr\_ref2.
          RAISE EXCEPTION TYPE conv\_exc.
        ELSE.
          <data2> = <data1>.
        ENDIF.
      CATCH conv\_exc.
        cl\_demo\_output=>display(
          \`Assignment from type \`    &&
          descr\_ref2->absolute\_name  &&
          \` to \`                     &&
          descr\_ref1->absolute\_name  &&
          \` not allowed!\` ).
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example expands on the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_field_abexa.htm) for DESCRIBE FIELD, where the correct way to check any data type is described.

When complex types, such as SCARR and SPFLI, are entered in the input fields, the RTTI determines the full [absolute type name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabsolute_typename_glosry.htm "Glossary Entry").


### abenrtti_object_type_abexa.htm

---
title: "Determining Object Types"
description: |
  This example demonstrates how the dynamic types of objects can be determined at runtime. Source Code REPORT demo_rtti_object_types. CLASS conv_exc DEFINITION INHERITING FROM cx_static_check. ENDCLASS. CLASS c1 DEFINITION. ENDCLASS. CLASS c2 DEFINITION. ENDCLASS. CLASS demo DEFINITION. PUBLIC S
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrtti_object_type_abexa.htm"
abapFile: "abenrtti_object_type_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "types", "abenrtti", "object", "type", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing Internal Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_working.htm) →  [Attributes of Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendescribe_field.htm) →  [RTTS - Runtime Type Services](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrtti.htm) → 

Determining Object Types

This example demonstrates how the dynamic types of objects can be determined at runtime.

Source Code

REPORT demo\_rtti\_object\_types.
CLASS conv\_exc DEFINITION INHERITING FROM cx\_static\_check.
ENDCLASS.
CLASS c1 DEFINITION.
ENDCLASS.
CLASS c2 DEFINITION.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: otype1 TYPE c LENGTH 30 VALUE 'C1',
          otype2 TYPE c LENGTH 30 VALUE 'C2'.
    DATA: oref1 TYPE REF TO object,
          oref2 TYPE REF TO object.
    DATA: descr\_ref1 TYPE REF TO cl\_abap\_typedescr,
          descr\_ref2 TYPE REF TO cl\_abap\_typedescr.
    cl\_demo\_input=>add\_field( CHANGING field = otype1 ).
    cl\_demo\_input=>request(   CHANGING field = otype2 ).
    TRY.
        otype1 = cl\_abap\_dyn\_prg=>check\_whitelist\_str(
          EXPORTING
            val                      = otype1
            whitelist                =  \`C1,C2\` ).
        otype2 = cl\_abap\_dyn\_prg=>check\_whitelist\_str(
          EXPORTING
            val                      = otype2
            whitelist                =  \`C1,C2\` ).
      CATCH cx\_abap\_not\_in\_whitelist.
        cl\_demo\_output=>display( 'Input not allowed' ).
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        CREATE OBJECT: oref1 TYPE (otype1),
                       oref2 TYPE (otype2).
      CATCH cx\_sy\_create\_object\_error.
        cl\_demo\_output=>display( 'Create object error!' ).
        LEAVE PROGRAM.
      CATCH cx\_root.
        cl\_demo\_output=>display( 'Other error!' ).
        LEAVE PROGRAM.
    ENDTRY.
    descr\_ref1 = cl\_abap\_typedescr=>describe\_by\_object\_ref( oref1 ).
    descr\_ref2 = cl\_abap\_typedescr=>describe\_by\_object\_ref( oref2 ).
    TRY.
        IF descr\_ref1 <> descr\_ref2.
          RAISE EXCEPTION TYPE conv\_exc.
        ELSE.
          oref1 = oref2.
        ENDIF.
      CATCH conv\_exc.
        cl\_demo\_output=>display(
          \`Assignment from type \`   && |\\n| &&
          descr\_ref2->absolute\_name && |\\n| &&
          \`to \`                     && |\\n| &&
          descr\_ref1->absolute\_name && |\\n| &&
          \`not allowed!\` ).
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example is the object type counterpart of the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrtti_data_type_abexa.htm) for data types. Here, the dynamic type of reference variables is determined, namely the [absolute type name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabsolute_typename_glosry.htm "Glossary Entry") of the class of the referenced object.


---


## ABAP Keyword Documentation / ABAP − Reference / Processing External Data / ABAP File Interface / Authorization for File Access

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing External Data / ABAP File Interface / Authorization for File Access

Included pages: 3


### abendataset_auth.htm

---
title: "Authorization for File Access"
description: |
  -   Automatic Authorization Checks(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_authority.htm) -   Validation of File Names(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendataset_auth_self.htm) Automatic Authorization Checks(https://help.sap.com
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendataset_auth.htm"
abapFile: "abendataset_auth.htm"
keywords: ["do", "data", "abendataset", "auth"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing External Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_external_data.htm) →  [ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_files.htm) → 

Authorization for File Access

-   [Automatic Authorization Checks](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_authority.htm)

-   [Validation of File Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendataset_auth_self.htm)

Continue
[Automatic Authorization Checks](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_authority.htm)
[Validation of File Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendataset_auth_self.htm)


### abenfile_interface_authority.htm

---
title: "Automatic Authorization Checks"
description: |
  The following authorization checks take place automatically when data is accessed: -   Authorization Check in the Operating System(#abenfile-interface-authority-1--------authorization-checks-for-special-files---@ITOC@@ABENFILE_INTERFACE_AUTHORITY_2) -   Authorization Object S_DATASET(#abenfile-
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_authority.htm"
abapFile: "abenfile_interface_authority.htm"
keywords: ["delete", "do", "if", "case", "try", "class", "data", "abenfile", "interface", "authority"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing External Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_external_data.htm) →  [ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_files.htm) →  [Authorization for File Access](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendataset_auth.htm) → 

Automatic Authorization Checks

The following authorization checks take place automatically when data is accessed:

-   [Authorization Check in the Operating System](#abenfile-interface-authority-1--------authorization-checks-for-special-files---@ITOC@@ABENFILE_INTERFACE_AUTHORITY_2)

-   [Authorization Object S\_DATASET](#abenfile-interface-authority-3--------database-table-spth-and-authorization-object-s--path---@ITOC@@ABENFILE_INTERFACE_AUTHORITY_4)

Authorization Check in the Operating System

From the point of view of the operating system on the [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") of a AS Instance, all files are accessed from [AS ABAP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_nw_abap_glosry.htm "Glossary Entry"). As a consequence, the user of the operating system that creates an instance of the [AS ABAP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_nw_abap_glosry.htm "Glossary Entry") AS Instance must have the authority to read and write to all files and directories that are handled by the ABAP file interface. If this authorization does not exist, the file interface statements can only be partially carried out, or not at all. If a statement cannot be executed because of lack of authorization in the operating system, the return value sy-subrc is set to not equal to 0.

Authorization Checks for Special Files

Every time a PSE file (file with the extension .pse for a Personal Security Environment) is accessed, an automatic authorization check for the current user is performed with the value "01" for the field ACTVT of the authorization object S\_RZL\_ADM of the system administrator.

Authorization Object S\_DATASET

An authorization check is performed for the current user each time a file is opened or deleted using the following:

-   [OPEN DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset.htm)

-   [DELETE DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdelete_dataset.htm)

Also, the current program is executed using the predefined authorization object S\_DATASET. This authorization object contains the authorization fields PROGRAM for the program names, FILENAME for the opened files, and ACTVT with the activities Delete, Read, Write, Read with Filter, and Write with Filter. If the user or program does not have the necessary authorization, a handleable exception of the class CX\_SY\_FILE\_AUTHORITY is raised. To avoid this, the function module AUTHORITY\_CHECK\_DATASET can be called before the relevant ABAP statement to check whether the authorization exists.

Note

In the authorization check with the authorization object S\_DATASET, the [physical file name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenphysical_filename_glosry.htm "Glossary Entry") used in the statements above and the values of the authorization field FILENAME are subject to a literal comparison. Any relative paths specified are not transformed to absolute paths. To avoid unexpected results, it is best to specify only absolute paths in physical file names.

Database Table SPTH and Authorization Object S\_PATH

An automatic check is made when the following statements access files:

-   [OPEN DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset.htm)

-   [DELETE DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdelete_dataset.htm)

This check is made on entries in the database tables SPTH. The entries in the database table SPTH control the general read and write accesses from ABAP programs to files and whether files should be backed up or not.

In the database table SPTH, reads and writes can be forbidden on all files specified absolutely or relatively, regardless of the [authorization objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenauthorization_object_glosry.htm "Glossary Entry"). For the remaining files (those that are generally allowed to be accessed for read or write according to the database table SPTH), authorization checks can be carried out on the basis of authorization objects. In the database table SPTH, authorization groups from the table SPTHB (texts in SPTHT, shared view V\_SPT) for program-independent authorization checks can be defined. The following table shows the columns of the database table SPTH. If the check on the database table SPTH has a negative result, a handleable exception of the class CX\_SY\_FILE\_AUTHORITY is raised.

Column

Meaning

PATH

Absolute or relative path specified for directory names or file names. The content specified in the other columns of this row applies to all the files of the AS Instance that are best described by the entry in this column.

SAVEFLAG

The value "X" in this column can be evaluated by backups. The ABAP runtime environment does not itself make any backups.

FS\_NOREAD

If this column contains the value "X", the files specified in the column PATH cannot be accessed from ABAP. This setting overrides the setting in the columns FS\_NOWRITE and FS\_BRGRU as well as the authorization check on the authorization object S\_DATASET.

FS\_NOWRITE

If this column contains the value "X", writes cannot be performed on the files specified in the column PATH from ABAP. This setting overrides the setting in the column FS\_BRGRU as well as the authorization check on the authorization object S\_DATASET.

FS\_BRGRU

In this column, an authorization group can be specified that is defined in the table SPTHB. The files of multiple rows can be grouped together in this way. When the database table SPTH is evaluated, an authorization check for the current user is made against the authorization object S\_PATH (which contains an authorization field FS\_BRGRU and an authorization field ACTVT with the possible values "03" (Display), "02" (Change), "A6" (Display with Addition [FILTER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_os_addition.htm) ), and "A7" (Change with Addition [FILTER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_os_addition.htm)). This makes it possible to grant access to the files specified in PATH to specific users. If no authorization group is entered, no authorization check is made against the authorization object S\_PATH.

In the paths specified in the column PATH, placeholders can be specified for specific [profile parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprofile_parameter_glosry.htm "Glossary Entry") or for the current [client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclient_glosry.htm "Glossary Entry"):

... <P=name> ...

When evaluated, a placeholder is replaced by the value of the profile parameter specified in name or by the current [client ID](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclient_identifier_glosry.htm "Glossary Entry"). The possible values for name are specified in the documentation of the table SPTH.

When a file is accessed using the statements [OPEN DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset.htm) and [DELETE DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdelete_dataset.htm), a [physical file name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenphysical_filename_glosry.htm "Glossary Entry") is used. When the content of the database table SPTH is transformed, a check is made to see whether the physical file name starts with an entry in the column PATH and the row with the longest matching path is used. Before the check, a specified path in the physical file name is standardized as follows:

-   Any ../ segments are removed. For example, a path specified as /tmp/sub1/../sub2/file is transformed to /tmp/sub2/file.

-   If the operating system is not an MS Windows operating system, the / characters are converted to \\ characters and all letters are changed to uppercase letters.

If no matching path is specified in the column PATH, the row is used in which the column PATH contains the entry "\*". If this entry does not exist either, no automatic authorization check is made.

The character "\*" in the column PATH is relevant only if it is the only character entered here. When specified within paths, is subject to literal comparisons and is not used as a wildcard character.

Notes

-   In comparison to the authorization check using the authorization object S\_DATASET (see above), an authorization check using the authorization object S\_PATH is independent of the ABAP program in which it occurs.

-   Paths specified in the column PATH should usually exist in a standardized form.

-   When the path specified is standardized to a physical file name, any relative paths specified are not transformed to absolute paths. Any links and any other changeable information are not resolved.

-   The comparison rule for a path specified in the column PATH with a physical file name used to access a file is both literal and (due to the check on whether the initial segment matches) generic too. The following aspects should be noted to avoid unexpected results:

-   The character "\*" only has a special function if it is the only character in the column PATH.

-   The table SPTH should always contain an entry with the value "\*" for the column PATH. This entry is used whenever no other entries match.

-   The names of directories should always be closed with the character "/". If this is not the case, a path specified as "/tmp" in the column PATH specifies all files and directories that start with "/tmp" (like "/tmpxxx") and not just the directory "/tmp/".

-   Any path specified in the column PATH is not unique. It can contain hard links and soft links. Mount points, network paths, and similar entries can also be specified. This means the following must be noted:

-   A combination of paths specified in the column PATH with values "X" in the columns FS\_NOREAD and FS\_NOWRITE defines non-user-specific blacklists of forbidden paths. The access rights are not necessarily unique, which makes them difficult to delimit sufficiently.

-   A combination of paths specified in the column PATH with authorization groups in the column FS\_BRGRU defines whitelists of valid paths for authorized users. In this case, the lack of uniqueness of the access rights is not critical.

For this reason, is recommended that the authorization groups in the column FS\_BRGRU and the authorization object S\_PATH are used instead of the columns FS\_NOREAD and FS\_NOWRITE.

-   Unlike in an authorization check using the authorization object S\_PATH, checks made on the columns FS\_NOREAD and FS\_NOWRITE are not made as part of the general [authorization concept](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbc_authority_check.htm) and none of the associated log entries are written.

-   For compatibility reasons, even empty values are accepted for the activity when the authorization object S\_PATH is checked, which means that files can be opened using the addition [FILTER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_os_addition.htm).

-   The column SAVEFLAG, used for backups, should only be used together with a value in another column, preferably FS\_BRGRU. If not, no authorization check is made on files covered by the path specified in PATH.

Example

The table SPTH is filled as follows:

PATH

SAVEFLAG

FS\_NOREAD

FS\_NOWRITE

FS\_BRGRU

\*

\-

\-

\-

SUPR

/

\-

\-

\-

ROOT

/dir\_open/

\-

\-

\-

\-

/tmp/sub/data/

\-

\-

\-

UDAT

/tmp/sub/data/work/

\-

\-

\-

UWRK

/tmp/sub/prefix

\-

\-

\-

UPRE

These entries have the following effects:

-   Every user can make reads and writes on files in the directory /dir\_open and its subdirectories, since no restrictions are entered.

-   Only users with an authorization for the authorization group UWRK can access files in the directory /tmp/sub/data/work/ and its subdirectories.

-   Only users with an authorization for the authorization group UDAT can access files in the directory /tmp/sub/data/ and its subdirectories (with the exception of /tmp/sub/data/work/). Instead, an authorization for the authorization group UWRK is required for /tmp/sub/data/work/.

-   Users with an authorization for the authorization group UPRE can access not just those files in the directory /tmp/sub whose names start with prefix but also all files in subdirectories whose names start with /tmp/sub/prefix. If restricted access to files in a subdirectory /tmp/sub/prefix is required, the entry made in PATH must be closed using "/".

-   User with an authorization for the authorization group ROOT can access files in any directory, as long as the physical file name is specified with "/" at the start or is absolute.

-   Users with an authorization for the authorization group SUPR can access files in any directories specified as relative directories as long as the directories are not specified with "/" at the start.

Example

The table SPTH is filled as follows:

PATH

SAVEFLAG

FS\_NOREAD

FS\_NOWRITE

FS\_BRGRU

\*

\-

X

X

\-

/

\-

\-

\-

ROOT

/tmp/

\-

\-

\-

\-

/tmp/myfiles/

\-

\-

\-

FILE

The entries have the following properties:

-   The entries in the first row apply to all fields on the AS Instance except for those in the paths /, /tmp/, and their subdirectories.

-   The entries in the second row apply to all fields on the AS Instance in the path / except for the files in the path /tmp and its subdirectories.

-   The entries in the third row apply to all fields on the AS Instance in the path /tmp except for the files in the path /tmp/myfiles and its subdirectories.

-   The entries in the fourth row apply to the fields in the path /tmp/myfiles and its subdirectories.

The entries dictate that no user can make reads or writes on files specified using relative paths. Users with authorization for the authorization group ROOT can access all files specified using absolute paths except for the files in the path /tmp/myfiles. All users can make both reads and writes on the files in the path /tmp. Only users who have an authorization for the authorization group FILE can make reads and writes on the files in the path /tmp/myfiles. When the table above is applied, this means that the following program lines produce a runtime error for all users except those with authorization for the authorization group ROOT,

DATA fname TYPE string.
fname = \`/system/files\`.
OPEN DATASET fname FOR OUTPUT IN BINARY MODE.

This configuration forbids the use of any relative paths when files are accessed. This rule is generally only advisable if this behavior is explicitly required.

-   All permitted paths should be specified in the table SPTH and associated with the appropriate authorization groups.

-   Access to the path specified as "\* should also be subject to an authorization group permitting access using any relative paths for authorized users.


### abendataset_auth_self.htm

---
title: "Validation of File Names"
description: |
  Alongside the automatic authorization checks(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_authority.htm), it may be necessary to validate file names before they are used to prevent directory traversals(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/ab
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendataset_auth_self.htm"
abapFile: "abendataset_auth_self.htm"
keywords: ["do", "while", "if", "case", "try", "method", "class", "data", "abendataset", "auth", "self"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing External Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_external_data.htm) →  [ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_files.htm) →  [Authorization for File Access](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendataset_auth.htm) → 

Validation of File Names

Alongside the [automatic authorization checks](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_authority.htm), it may be necessary to validate file names before they are used to prevent [directory traversals](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendirectory_traversal_glosry.htm "Glossary Entry"). This is particularly important if

-   the automatic authorization checks are not enough, for example because the database table SPTH or the authorizations for the authorization object S\_DATASET have not been defined in full.

-   programs with [physical file names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenphysical_filename_glosry.htm "Glossary Entry") are used, and these file names are provided using external interfaces such as APIs or UIs.

However if logical file names are consistently used, there is no need for validation.

-   [Using Logical File Names](#abendataset-auth-self-1--------using-physical-file-names---@ITOC@@ABENDATASET_AUTH_SELF_2)

-   [Self-Programmed Validation](#abendataset-auth-self-3--------validation-with-logical-file-names---@ITOC@@ABENDATASET_AUTH_SELF_4)

Using Logical File Names

File names do not usually need to be validated if a program is consistent in using only [logical file names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogical_filename_glosry.htm "Glossary Entry") created by the system administrator in the transactions FILE or SF01. Next, the set of logical file names available to an application defines the set of possible physical file names. The associated physical file names are not edited explicitly in the program. Instead, the function module FILE\_GET\_NAME is used to create the physical file name from the logical file name directly before it is used in a [statement of the file interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_statements.htm) and used for file access.

Example

The following program works with a logical file name in field log\_name. The function module FILE\_GET\_NAME uses this file name to create a platform-specific physical file name in phys\_name (for use in the statement OPEN DATASET). As the value abap\_true is passed to parameter INCLUDING\_DIR, the physical file name is absolute; in other words, it contains an absolute path.

DATA: log\_name  TYPE filename-fileintern,
      phys\_name TYPE string.
...
CALL FUNCTION 'FILE\_GET\_NAME'
  EXPORTING
    logical\_filename = log\_name
    including\_dir    = abap\_true
  IMPORTING
    file\_name        = phys\_name
  EXCEPTIONS
    file\_not\_found   = 2
    OTHERS           = 4.
IF sy-subrc <> 0.
  MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                      DISPLAY LIKE sy-msgty.
  RETURN.
ENDIF.
OPEN DATASET phys\_name FOR OUTPUT IN TEXT MODE ENCODING UTF-8 .
...

Using Physical File Names

If a program uses [physical file names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenphysical_filename_glosry.htm "Glossary Entry"), the name almost always needs to be validated.

Self-Programmed Validation

If valid directories and file names are defined precisely (as is often the case in programs from the technical infrastructure), this type of validation can be skipped. The following can be used, for example:

-   Methods from [character string processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_string.htm),

-   Methods from class CL\_ABAP\_DYN\_PRG for checking whitelists,

-   Methods in the class CL\_FS\_PATH

However, self-programmed validations (especially when using character string processing) is suitable only for simple cases. For all other cases, validation with logical file names is usually recommended.

Validation with logical file names

In many cases, directories and file names are generic, and are predefined by the system administrator when configuring the system. They can be modified or enhanced while the system is running. In these cases, the concept of logical file names should be employed when handling physical file names explicitly.

In addition to the case above, where a program uses only logical file names, the associations between logical and physical file names can also be useful when handling physical file names for validation purposes. As long as the list of logical file names is complete, the function module FILE\_VALIDATE\_NAME can be called before a file is accessed. This module checks whether the physical file name is associated with a logical file name or whether the directory is valid. In this way, the function module checks whether the physical file exists in the set defined by the logical file names.

Note

The function module FILE\_VALIDATE\_NAME always checks absolute file names with specified paths. If a relative file name is passed for checking, the default path is implicitly added as a prefix to DIR\_HOME in accordance with the [profile parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprofile_parameter_glosry.htm "Glossary Entry").

Example

Validation of a directory. For a directory, the logical file name contained in log\_name must have been created in the format DIR using transaction FILE. The function module FILE\_GET\_NAME provides the platform-specific path for this directory in path. For a directory, the value abap\_true must be passed to parameter INCLUDING\_DIR, otherwise the function module is terminated with an exception. The method IS\_RELATIVE of class CL\_FS\_PATH is used to check whether a file name phys\_name entered by a user is relative or contains an absolute path. An existing absolute file name is applied without being modified. Relative file names are concatenated with the path. This is done using the method APPEND\_PATH\_NAME of a path object from the class CL\_FS\_PATH created from path. This object is platform-independent and works regardless of whether path contains a closing separator like \\. Finally, phys\_name with FILE\_VALIDATE\_NAME is validated by checking the directory of log\_name. This check is also necessary when creating a chain from the path and relative file name. This is because the specified relative file name can contains parts such as \\..\\, which can point to path locations outside of the permitted directory.

DATA: phys\_name TYPE string,
      log\_name  TYPE filename-fileintern,
      path      TYPE string.
...
CALL FUNCTION 'FILE\_GET\_NAME'
  EXPORTING
    logical\_filename = log\_name
    including\_dir    = abap\_true
  IMPORTING
    file\_name        = path
  EXCEPTIONS
    file\_not\_found   = 2
    OTHERS           = 4.
IF sy-subrc <> 0.
  MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno DISPLAY LIKE sy-msgty.
  RETURN.
ENDIF.
cl\_demo\_input=>request( CHANGING field = phys\_name ).
IF cl\_fs\_path=>create( phys\_name )->is\_relative( ) = abap\_true.
  DATA(pref) = cl\_fs\_path=>create( path ).
  pref->append\_path\_name( phys\_name ).
  phys\_name = pref->get\_path\_name( ).
ENDIF.
CALL FUNCTION 'FILE\_VALIDATE\_NAME'
  EXPORTING
    logical\_filename           = log\_name
  CHANGING
    physical\_filename          = phys\_name
  EXCEPTIONS
    logical\_filename\_not\_found = 1
    validation\_failed          = 2
    OTHERS                     = 4.
IF sy-subrc <> 0.
  MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                      DISPLAY LIKE sy-msgty.
  RETURN.
ENDIF.
OPEN DATASET phys\_name FOR OUTPUT IN TEXT MODE ENCODING UTF-8 .


---


## ABAP Keyword Documentation / ABAP − Reference / Processing External Data / ABAP File Interface / Statements for the ABAP File Interface / OPEN DATASET / OPEN DATASET - mode

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Processing External Data / ABAP File Interface / Statements for the ABAP File Interface / OPEN DATASET / OPEN DATASET - mode

Included pages: 5


### abapopen_dataset_mode.htm

---
title: "OPEN DATASET - mode"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_shortref.htm) Syntax ... BINARY MODE  TEXT MODE encoding(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_encoding.htm) linefeed(https://help.sap.com/doc/abapd
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_mode.htm"
abapFile: "abapopen_dataset_mode.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "data", "abapopen", "dataset", "mode"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing External Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_external_data.htm) →  [ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_files.htm) →  [Statements for the ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_statements.htm) →  [OPEN DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset.htm) → 

OPEN DATASET - mode

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_shortref.htm)

Syntax

... *{*BINARY MODE*}*
  *|* *{*TEXT MODE [encoding](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_encoding.htm) *\[*[linefeed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_linefeed.htm)*\]**}*
  *|* *{*LEGACY BINARY MODE *\[* [endian](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_endian.htm)*\]**\[* [CODE PAGE cp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_code_page.htm)*\]**}*
  *|* *{*LEGACY TEXT MODE *\[* [endian](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_endian.htm)*\]* *\[* [CODE PAGE cp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_code_page.htm)*\]* *\[* [linefeed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_linefeed.htm)*\]**}* ...

Alternatives:

[1\. ... BINARY MODE](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... TEXT MODE](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... LEGACY BINARY MODE](#!ABAP_ALTERNATIVE_3@3@)
[4\. ... LEGACY TEXT MODE](#!ABAP_ALTERNATIVE_4@4@)

Effect

These mandatory additions define whether the file is handled as a binary file or as a text file. By specifying LEGACY, files can be written in the format that is expected by a non- [Unicode system](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenunicode_system_glosry.htm "Glossary Entry"), and files that have been created by a non-Unicode-system can be read. The [byte order](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbyte_order_glosry.htm "Glossary Entry") or the [code page](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencodepage_glosry.htm "Glossary Entry") must be specified explicitly.

Alternative 1

... BINARY MODE

Effect

The addition IN BINARY MODE opens the file as a binary file. When writing to a binary file, the binary content of a data object is passed in unchanged form to the file. When reading from a binary file, the binary content of the file is passed in unchanged form to a data object.

Example

Opens a binary file for reads and writes. The binary data is created by converting a string to [UTF-8](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutf8_glosry.htm "Glossary Entry").

DATA(utf8) =
  cl\_abap\_conv\_codepage=>create\_out( )->convert( 'Blahblahblah ...' ).
DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN BINARY MODE.
TRANSFER utf8 TO dset.
CLOSE DATASET dset.
...
CLEAR utf8.
OPEN DATASET dset FOR INPUT IN BINARY MODE
READ DATASET dset INTO utf8.
CLOSE DATASET dset.
cl\_demo\_output=>display(
  cl\_abap\_conv\_codepage=>create\_in( )->convert( utf8 ) ).
DELETE DATASET dset.

Alternative 2

... TEXT MODE

Effect

The addition IN TEXT MODE opens the file as a text file. Only the content of character-like data objects can be passed to text files and read from text files.

The addition [encoding](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_encoding.htm) defines how the characters are represented in the text file. When writing to a text file, the content of a data object is converted to the representation entered after encoding, and passed to the file. If the data type is character-like and [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry"), any trailing blanks are cut off. In the data type string, trailing blanks are not cut off.

The end-of-line selection of the relevant platform is applied to the passed data by default. When reading from a text file, the content of the file is read until the next end-of-line selection, converted from the format specified after ENCODING into the current character format, and passed to a data object. The end-of-line selection used is controlled using the addition [linefeed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_linefeed.htm).

Example

Opens a text file for reads and writes. A line end marking is appended in every write in every TRANSFER statement. Any reads are performed row by row. Compare the example for the addition NO END OF LINE of the statement [TRANSFER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptransfer.htm).

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING DEFAULT.
DO 5 TIMES.
  TRANSFER 'Blah' TO dset.
ENDDO.
CLOSE DATASET dset.
...
DATA text TYPE string.
OPEN DATASET dset FOR INPUT IN TEXT MODE ENCODING UTF-8
                               SKIPPING BYTE-ORDER MARK.
DO.
  READ DATASET dset INTO text.
  IF sy-subrc <> 0.
    EXIT.
  ENDIF.
  cl\_demo\_output=>write( text ).
ENDDO.
CLOSE DATASET dset.
cl\_demo\_output=>display( ).
DELETE DATASET dset.

Alternative 3

... LEGACY BINARY MODE

Effect

Opening a [legacy file](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlegacy_file_glosry.htm "Glossary Entry"). The addition IN LEGACY BINARY MODE opens the file as a legacy binary file, where [endian](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_endian.htm) can be used to specify the [byte order](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbyte_order_glosry.htm "Glossary Entry") and [CODE PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_code_page.htm) can be used to specify the [code page](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencodepage_glosry.htm "Glossary Entry") that handle the content of the file.

Note

When a flat character-like field is written to the legacy binary files, the number of bytes written to the file is the same as the number of characters in the source field. The field content can be influenced by this when writing texts in Eastern Asian languages. It is therefore best to only write texts opened without the addition LEGACY to text files.

Example

See the example for the addition [endian](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_endian.htm).

Alternative 4

... LEGACY TEXT MODE

Effect

Opening a [legacy file](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlegacy_file_glosry.htm "Glossary Entry"). The addition IN LEGACY TEXT MODE opens the file as a legacy text file, where (in legacy binary files) [endian](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_endian.htm) can be used to specify the byte order and [CODE PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_code_page.htm) can be used to specify the code page that handle the content of the file. The syntax and semantics of *{*BIG*|*LITTLE*}* ENDIAN and CODE PAGE cp are the same as in legacy binary files. The syntax and meaning of [linefeed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_linefeed.htm) are the same as for regular text files.

In contrast to legacy binary files, the trailing blanks are cut off when writing character-like [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") data objects to a legacy text file. Also, as in the case of a text file, an [end-of-line selection](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_linefeed.htm) is appended to the passed data by default. Unlike the text files opened by the addition IN TEXT MODE, there is no check on whether the data objects used in writing or reading are character-like. Also, the LENGTH additions of the statements READ DATASET and TRANSFER are used for counting. In legacy text files these additions count in bytes, and an text files they count in the units of a character represented in the memory.

Notes

-   As is the case with legacy binary files, it is possible to access text files written in non-Unicode systems as legacy text files. In this case, the content is converted accordingly.
    
-   When writing to a flat character-like field in legacy text files, the maximum number of bytes that can be written to the file is the maximum number of characters in the source field. The field content can be influenced by this when writing texts in Eastern Asian languages. It is therefore best to only write texts opened without the addition LEGACY to text files.
    

Example

See the example for the addition [CODE PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_code_page.htm).

Continue
[OPEN DATASET - encoding](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_encoding.htm)
[OPEN DATASET - WITH LINEFEED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_linefeed.htm)
[OPEN DATASET - endian](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_endian.htm)
[OPEN DATASET - CODE PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_code_page.htm)


### abapopen_dataset_encoding.htm

---
title: "OPEN DATASET - encoding"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_shortref.htm) Syntax ... ENCODING  DEFAULT  UTF-8 SKIPPINGWITH BYTE-ORDER MARK  NON-UNICODE  ... Alternatives: 1. ... DEFAULT(#!ABAP_ALTERNATIVE_1@1@) 2. ... UTF-8 SKIP
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_encoding.htm"
abapFile: "abapopen_dataset_encoding.htm"
keywords: ["select", "insert", "update", "delete", "do", "if", "try", "catch", "method", "class", "data", "abapopen", "dataset", "encoding"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing External Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_external_data.htm) →  [ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_files.htm) →  [Statements for the ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_statements.htm) →  [OPEN DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset.htm) →  [OPEN DATASET - mode](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_mode.htm) → 

OPEN DATASET - encoding

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_shortref.htm)

Syntax

... ENCODING *{* DEFAULT
             *|* *{*UTF-8 *\[*SKIPPING*|*WITH BYTE-ORDER MARK*\]**}*
             *|* NON-UNICODE *}* ...

Alternatives:

[1\. ... DEFAULT](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... UTF-8 *\[*SKIPPING*|*WITH BYTE-ORDER MARK*\]*](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... NON-UNICODE](#!ABAP_ALTERNATIVE_3@3@)

Effect

The additions after the mandatory addition ENCODING define the character representation in which the content of a text file is handled.

Programming Guideline

[Write text files in UTF-8 and with a byte order mark.](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencodepage_file_guidl.htm "Guideline")

Note

It is best to always write files in UTF-8 (if all readers can process this format). Otherwise, the code page can depend on the [text environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_environment_glosry.htm "Glossary Entry") and it is difficult to identify the code page from the file content.

Alternative 1

... DEFAULT

Effect

If specified, DEFAULT is the same as specifying UTF-8.

Alternative 2

... UTF-8 *\[*SKIPPING*|*WITH BYTE-ORDER MARK*\]*

Addition:

[... SKIPPING*|*WITH BYTE-ORDER MARK](#!ABAP_ONE_ADD@1@)

Effect

The characters in the file are handled in accordance with the Unicode character representation [UTF-8](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutf8_glosry.htm "Glossary Entry").

Notes

-   The class CL\_ABAP\_FILE\_UTILITIES contains the method CHECK\_UTF8 for determining whether a file is a UTF-8 file.
    
-   A UTF-16 file can only be opened as a binary file.
    

Example

Opens a text file as a UTF-8 file and writes a string containing German umlaut characters to the file. The file is read to a byte string and this byte string is converted from UTF-8 to a character string. This is done using an object created by the class CL\_ABAP\_CONV\_CODEPAGE and the method CONVERT of the interface IF\_ABAP\_CONV\_IN.

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING UTF-8.
TRANSFER 'ÄäÖöÜü' TO dset.
CLOSE DATASET dset.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
cl\_demo\_output=>display(
  cl\_abap\_conv\_codepage=>create\_in( )->convert( xstr ) ).
DELETE DATASET dset.

Addition

... SKIPPING*|*WITH BYTE-ORDER MARK

Effect

This addition defines how the byte order mark (BOM), with which a file encoded in the UTF-8 format can begin, is handled. The BOM is a sequence of three bytes that indicates that a file is encoded in [UTF-8](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenutf8_glosry.htm "Glossary Entry").

-   SKIPPING BYTE-ORDER MARK
    is only permitted if the file is opened for reads or writes using [FOR INPUT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_access.htm) or [FOR UPDATE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_access.htm). If there is a BOM at the start of the file, this is ignored and the file pointer is set after it. Without the addition, the BOM is handled as normal file content.
    
-   WITH BYTE-ORDER MARK
    is only permitted if the file is opened for writing using [FOR OUTPUT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_access.htm). When the file is opened, a BOM is inserted at the start of the file. Without the addition, no BOM is inserted.
    

The addition BYTE-ORDER MARK cannot be used together with the [AT POSITION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_position.htm) addition.

Notes

-   When opening UTF-8 files for reading, it is best to always enter the addition SKIPPING BYTE-ORDER MARK to prevent a BOM from being handled as file content.
    
-   It is recommended that a file for reading is always opened as a UTF-8 file using the addition WITH BYTE-ORDER MARK (as long as all readers can process this format).
    
-   The method CREATE\_UTF8\_FILE\_WITH\_BOM in the system class CL\_ABAP\_FILE\_UTILITIES can be used to create a file with BOM.
    

Example

The binary content of the text file opened using WITH BYTE-ORDER MARK is EFBBBF616263. EFBBBF is specified as a BOM at the start of the file. This is followed by the UTF-8 representation 616263 of the actual characters abc.

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE
                  ENCODING UTF-8 WITH BYTE-ORDER MARK.
TRANSFER 'aaa' TO dset NO END OF LINE.
CLOSE DATASET dset.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
cl\_demo\_output=>display( xstr ).
DELETE DATASET dset.

Alternative 3

... NON-UNICODE

Effect

The characters of the file are handled in accordance with the non-Unicode code page that would be assigned when reading or writing data in a non-Unicode system (as specified by the entry in the database table TCP0C in the current [text environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_environment_glosry.htm "Glossary Entry")).

Example

Writes German umlaut characters to a non-Unicode code page. This code page is then extracted from the database table TCP0C and used to open the file as a a legacy text file.

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING NON-UNICODE.
TRY.
    TRANSFER 'ÄäÖöÜü' TO dset.
  CATCH cx\_sy\_conversion\_codepage INTO DATA(exc).
    cl\_demo\_output=>display( 'Error writing to non-unicode codepage' ).
    RETURN.
ENDTRY.
CLOSE DATASET dset.
SELECT SINGLE charco
       FROM tcp0c
       WHERE platform = @sy-opsys AND
             langu   = @sy-langu AND
             country  = ' '
       INTO @DATA(cp).
DATA text TYPE string.
OPEN DATASET dset FOR INPUT IN LEGACY TEXT MODE CODE PAGE cp.
READ DATASET dset INTO text.
CLOSE DATASET dset.
cl\_demo\_output=>display( text ).
DELETE DATASET dset.


### abapopen_dataset_linefeed.htm

---
title: "OPEN DATASET - WITH LINEFEED"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_shortref.htm) Syntax ... WITH  NATIVE  SMART  UNIX  WINDOWS  LINEFEED ... Alternatives: 1. ... WITH NATIVE LINEFEED(#!ABAP_ALTERNATIVE_1@1@) 2. ... WITH SMART LINEFEED(#!ABAP_ALTERNATIV
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_linefeed.htm"
abapFile: "abapopen_dataset_linefeed.htm"
keywords: ["update", "delete", "do", "while", "if", "case", "try", "data", "abapopen", "dataset", "linefeed"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing External Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_external_data.htm) →  [ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_files.htm) →  [Statements for the ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_statements.htm) →  [OPEN DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset.htm) →  [OPEN DATASET - mode](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_mode.htm) → 

OPEN DATASET - WITH LINEFEED

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_shortref.htm)

Syntax

... WITH *{* NATIVE
         *|* SMART
         *|* UNIX
         *|* WINDOWS *}* LINEFEED ...

Alternatives:

[1\. ... WITH NATIVE LINEFEED](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... WITH SMART LINEFEED](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... WITH UNIX LINEFEED](#!ABAP_ALTERNATIVE_3@3@)
[4\. ... WITH WINDOWS LINEFEED](#!ABAP_ALTERNATIVE_4@4@)

Effect

These additions determine which line end marker is used for [text files](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_file_glosry.htm "Glossary Entry") or [legacy](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlegacy_file_glosry.htm "Glossary Entry") text files. If these additions are used, the [profile parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprofile_parameter_glosry.htm "Glossary Entry") abap/NTfmode is ignored. The two values "UNIX" or "NT" cannot both be specified in the addition [TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_os_addition.htm) at the same time.

If these additions are not used, the line end marker is determined as follows, depending on the operating system of the current [AS Instance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry") [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry"):

-   The line end marker for Unix is "LF". On Unix, OS/390, and IBM i5/OS (previously known as OS/400), only "LF" is used for reading and writing.
    
-   The line end marker for MS Windows is "CRLF". On MS Windows, however, the values of the [profile parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprofile_parameter_glosry.htm "Glossary Entry") abap/NTfmode can also be used to specify whether new files are handled according to Unix conventions or Windows conventions. If the profile parameter has the value "b", the Unix line end marker "LF" is used. If the profile parameter has the value "t" or is initial, the Windows line end marker "CRLF" is used. The setting in the profile parameter can be overridden with the addition [TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_os_addition.htm) and the value "UNIX" or "NT". If an existing file is opened without the addition TYPE, this file is searched for the first line end marker ("LF" or "CRLF"), and this is used for the whole file. If no line end marker is found, the profile parameter is used. This applies particularly if an existing file is completely overwritten with [FOR OUTPUT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_access.htm).
    

If an addition WITH NATIVE*|*SMART*|*UNIX*|*WINDOWS LINEFEED is used, this setting can be changed for the open file using the statement [SET DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_dataset.htm). If neither of the additions is used, the line end marker cannot be changed using SET DATASET either.

Notes

-   Without the use of an addition WITH LINEFEED, the line end marker is dependent on various implicit factors such as the operating system of the current AS Instance [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry"), a profile parameter, and line end markings that are already used. For this reason, the explicit use of WITH LINEFEED is recommended, which renders the use of the addition [TYPE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_os_addition.htm) for setting the line end marker obsolete.
    
-   The line end marker that is currently used can be determined for every open file using [GET DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_dataset.htm).
    

Alternative 1

... WITH NATIVE LINEFEED

Effect

This addition defines the line end marker independently of the [access type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_access.htm) in accordance with the operating system of the current AS Instance [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry"), in other words "LF” for Unix, OS/390, and IBM i5/OS (previously known as OS/400), and "CRLF” for MS Windows.

The line end marker is interpreted in accordance with the current code page. If a code page is specified explicitly using the addition [CODE PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_mode.htm), the control characters of the line end marker must be available or be written according to this code page.

Note

The addition WITH NATIVE LINEFEED is intended for editing files on a host computer that can also be accessed by other means. The addition receives the appropriate line end marker without the program needing to know the operating system.

Example

The following example shows the UTF 8 representation of the current line end marking. Comparisons with the corresponding control characters in [string templates](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_template_glosry.htm "Glossary Entry") ensure that it is either "LF" or "CRLF".

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING DEFAULT
                  WITH NATIVE LINEFEED.
TRANSFER 'abc' TO dset.
CLOSE DATASET dset.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
SHIFT xstr BY 3 PLACES LEFT IN BYTE MODE.
cl\_demo\_output=>display( xstr ).
DELETE DATASET dset.
ASSERT xstr = cl\_abap\_conv\_codepage=>create\_out( )->convert( |\\n| ) OR
       xstr = cl\_abap\_conv\_codepage=>create\_out( )->convert( |\\r\\n| ).

Alternative 2

... WITH SMART LINEFEED

Effect

This addition depends on the [access type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_access.htm):

-   In files that are opened for reading using FOR INPUT, both "LF" and "CRLF" are interpreted as a line end marker. When opening an EBCDIC file with the addition [CODEPAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_mode.htm), the corresponding ASCII control characters are recognized alongside the "LF", "CRLF", and EBCDIC control characters. In addition, the EBCDIC control characters "NL" (line separator) is also interpreted as a line end marker.
    
-   In files opened for appending or changing with FOR APPENDING or FOR UPDATE, the program searches for a line end marker that is already used in the file. The end of the file is identified first. If no line end marker is found here, a number of characters at the beginning is analyzed. If a line end marker is found, this is used when writing to the file. This is also affected by the addition [CODE PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_mode.htm). For example, ASCII line end markers are recognized and used in a file opened with EBCDIC, but not the other way round. If no line end marker is found or no search is possible (for example, if the file is opened with the addition [FILTER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_os_addition.htm)), the line end marker is defined in accordance with the operating system of the current AS Instance [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry"), as with the addition WITH NATIVE LINEFEED.
    
-   In files opened for writing using FOR OUTPUT, the line end marker is determined in accordance with the operating system the current AS Instance [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry"), as with the addition WITH NATIVE LINEFEED.
    

Note

The addition WITH SMART LINEFEED is intended for the generic editing of files in heterogeneous environments. The line end marker is recognized and set for different formats. Using this addition is the best solution for most application cases.

Example

Writes a text file with the line end marking "CRLF". Using the addition WITH SMART LINEFEED (open to read), this marking is also detected on platforms that expect "LF".

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING DEFAULT
                  WITH WINDOWS LINEFEED.
TRANSFER 'abc' TO dset.
TRANSFER 'def' TO dset.
CLOSE DATASET dset.
DATA str TYPE string.
OPEN DATASET dset FOR INPUT IN TEXT MODE ENCODING DEFAULT
                  WITH SMART LINEFEED.
DATA out TYPE string.
WHILE sy-subrc = 0.
  READ DATASET dset INTO str.
  out &&= str.
ENDWHILE.
CLOSE DATASET dset.
cl\_demo\_output=>display( out ).
DELETE DATASET dset.

Alternative 3

... WITH UNIX LINEFEED

Effect

The line end marker is set to ["LF"](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") regardless of the [access type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_access.htm) and operating system of the current AS Instance [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry").

The line end marker is interpreted in accordance with the current code page. If a code page is specified explicitly using the addition [CODE PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_mode.htm), the control character for the line end marker must be available or be written according to this code page.

Note

The addition WITH UNIX LINEFEED is intended for editing Unix files in which the specific line end markers are to be retained, even if the operating system of the current AS Instance [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") is [MS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") Windows.

Example

The following example sets the line end marking to "LF". This marking is detected after it is read to a binary file and compared with the corresponding control character in a [string template](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_template_glosry.htm "Glossary Entry").

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING DEFAULT
                  WITH UNIX LINEFEED.
TRANSFER 'abc' TO dset.
CLOSE DATASET dset.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
SHIFT xstr BY 3 PLACES LEFT IN BYTE MODE.
cl\_demo\_output=>display( xstr ).
DELETE DATASET dset.
ASSERT xstr = cl\_abap\_conv\_codepage=>create\_out( )->convert( |\\n| ).

Alternative 4

... WITH WINDOWS LINEFEED

Effect

The line end marker is set to "CRLF" regardless of the [access type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_access.htm) and operating system of the current AS Instance [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry").

The line end marker is interpreted in accordance with the current code page. If a code page is specified explicitly using the addition [CODE PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_mode.htm), the control character for the line end marker must be available or be written according to this code page.

Note

The addition WITH WINDOWS LINEFEED is intended for use with MS Windows files in which the specific line end marker is to be retained, even if the operating system of the current AS Instance [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") is Unix, OS/390, or IBM i5/OS (previously known as OS/400).

Example

The following example sets the line end marking to "CRLF". This marking is detected after it is read to a binary file and compared with the corresponding control character in a [string template](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstring_template_glosry.htm "Glossary Entry").

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN TEXT MODE ENCODING DEFAULT
                  WITH WINDOWS LINEFEED.
TRANSFER 'abc' TO dset.
CLOSE DATASET dset.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
SHIFT xstr BY 3 PLACES LEFT IN BYTE MODE.
cl\_demo\_output=>display( xstr ).
DELETE DATASET dset.
ASSERT xstr = cl\_abap\_conv\_codepage=>create\_out( )->convert( |\\r\\n| ).


### abapopen_dataset_endian.htm

---
title: "OPEN DATASET - endian"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_shortref.htm) Syntax ... BIGLITTLE ENDIAN ... Effect This addition specifies that, when a legacy file(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlegacy_file_glosry.htm 'Glossa
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_endian.htm"
abapFile: "abapopen_dataset_endian.htm"
keywords: ["delete", "do", "if", "case", "try", "data", "types", "abapopen", "dataset", "endian"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing External Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_external_data.htm) →  [ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_files.htm) →  [Statements for the ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_statements.htm) →  [OPEN DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset.htm) →  [OPEN DATASET - mode](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_mode.htm) → 

OPEN DATASET - endian

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_shortref.htm)

Syntax

... *{*BIG*|*LITTLE*}* ENDIAN ...

Effect

This addition specifies that, when a [legacy file](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlegacy_file_glosry.htm "Glossary Entry") is opened, numeric data objects of the type i, int8, decfloat16, decfloat34, f, or s are stored in the file in the [byte order](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbyte_order_glosry.htm "Glossary Entry") Big Endian or Little Endian. When a data object of these types is written or read, a conversion between these orders and the byte order of the current platform is performed, if necessary. If the addition is not specified, the byte order of the [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") of the current [AS Instance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry") is used.

Notes

-   The statement [SET DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_dataset.htm) can be used to specify a different byte order for an opened legacy file.
    
-   The addition *{*BIG*|*LITTLE*}* ENDIAN replaces the use of the obsolete statement [TRANSLATE NUMBER FORMAT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptranslate.htm) in the case of file accesses.
    

Example

Opens a legacy binary file with different byte orders for writing. In each case, the integer 111 is written to the file and the content is read in binary format to a byte string. The results are 0000006F and 6F000000, that is, 111 in binary format in Big Endian and Little Endian.

DATA(dset) = 'test.dat'.
DATA xstr TYPE xstring.
OPEN DATASET dset FOR OUTPUT IN LEGACY BINARY MODE BIG ENDIAN.
TRANSFER 111 TO dset.
CLOSE DATASET dset.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
cl\_demo\_output=>write( xstr ).
OPEN DATASET dset FOR OUTPUT IN LEGACY BINARY MODE LITTLE ENDIAN.
TRANSFER 111 TO dset.
CLOSE DATASET dset.
OPEN DATASET dset FOR INPUT IN BINARY MODE.
READ DATASET dset INTO xstr.
CLOSE DATASET dset.
cl\_demo\_output=>write( xstr ).
cl\_demo\_output=>display( ).
DELETE DATASET dset.


### abapopen_dataset_code_page.htm

---
title: "OPEN DATASET - CODE PAGE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_shortref.htm) Syntax ...  CODE PAGE cp ... Effect This addition specifies that, when a legacy file(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlegacy_file_glosry.htm 'Glossary Entry') i
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_code_page.htm"
abapFile: "abapopen_dataset_code_page.htm"
keywords: ["delete", "do", "if", "try", "catch", "class", "data", "abapopen", "dataset", "code", "page"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Processing External Data](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_external_data.htm) →  [ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_files.htm) →  [Statements for the ABAP File Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_interface_statements.htm) →  [OPEN DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset.htm) →  [OPEN DATASET - mode](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_mode.htm) → 

OPEN DATASET - CODE PAGE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_shortref.htm)

Syntax

...  CODE PAGE cp ...

Effect

This addition specifies that, when a [legacy file](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlegacy_file_glosry.htm "Glossary Entry") is opened, the representation of character-like data objects in the file is based on the code page specified in cp. When a character-like data object is written or read, a conversion between this code page and the current character representation is performed, if necessary. If this addition is not specified, the characters in the file are handled in accordance with the non-Unicode code page that would be assigned when reading or writing data in a non-Unicode system (as specified by the entry in the database table TCP0C in the current [text environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_environment_glosry.htm "Glossary Entry")).

If specified, the code page cp expects a character-like data object that must contain, when the statement is executed, the name of a non-Unicode page from the column CPCODEPAGE in the database table TCP00. Unicode code pages cannot be specified.

Notes

-   This addition enables the automatic conversion of file content to the current Unicode character representation [UCS-2](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenucs2_glosry.htm "Glossary Entry") when reading and writing files. In this way, files saved in any non-Unicode systems can be imported.
    
-   The statement [SET DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_dataset.htm) can be used to specify a different code page for an opened legacy file.
    
-   The addition CODE PAGE replaces the use of the obsolete statement [TRANSLATE CODE PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptranslate.htm) in when accessing files.
    

Example

Opens legacy text files with the IDs 1101 for 7-Bit USA ASCII and 1102 for 7-Bit German ASCII from the table TCP00. When a German umlaut character is written to the open file with the ID 1101, an exception of the class CX\_SY\_CONVERSION\_CODEPAGE is raised. When the character is written to the open file with the ID 1102, this exception is not raised. See also the example for the addition [REPLACEMENT CHARACTER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_error_handling.htm).

DATA(dset) = 'test.dat'.
OPEN DATASET dset FOR OUTPUT IN LEGACY TEXT MODE CODE PAGE '1101'.
TRY.
    TRANSFER 'ÄaÖöÜü' TO dset.
  CATCH cx\_sy\_conversion\_codepage INTO DATA(exc).
    cl\_demo\_output=>write( 'Error writing to 7-Bit USA ASCII' ).
ENDTRY.
CLOSE DATASET dset.
OPEN DATASET dset FOR OUTPUT IN LEGACY TEXT MODE CODE PAGE '1102'.
TRY.
    TRANSFER 'ÄaÖöÜü' TO dset.
  CATCH cx\_sy\_conversion\_codepage INTO exc.
    cl\_demo\_output=>write( 'Error writing to 7-Bit German ASCII' ).
ENDTRY.
CLOSE DATASET dset.
cl\_demo\_output=>display( ).
DELETE DATASET dset.


---


## ABAP Keyword Documentation / ABAP − Reference / ABAP RESTful Programming Model / Behavior Implementations / Handler Class

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / ABAP RESTful Programming Model / Behavior Implementations / Handler Class

Included pages: 5


### abenrpm_handler_class.htm

---
title: "Handler Class"
description: |
  Syntax CLASS lcl_handler_name DEFINITION INHERITING FROM cl_abap_behavior_handler ABSTRACT FINAL. PRIVATE SECTION. TYPES ... DATA ... CONSTANTS ... METHODS method_name FOR MODIFY IMPORTING create_import_parameter FOR CREATE entity_name create_import_parameter FOR C
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handler_class.htm"
abapFile: "abenrpm_handler_class.htm"
keywords: ["update", "delete", "do", "if", "case", "try", "method", "class", "data", "types", "abenrpm", "handler"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP RESTful Programming Model](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrestful_abap_programming.htm) →  [Behavior Implementations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_behavior_implementations.htm) → 

Handler Class

Syntax

CLASS lcl\_handler\_name DEFINITION
       INHERITING FROM cl\_abap\_behavior\_handler
       *\[*ABSTRACT*\]* *\[*FINAL*\]*.
  PRIVATE SECTION.
    TYPES ...
    DATA ...
    CONSTANTS ...
    METHODS method\_name FOR MODIFY
      *\[*IMPORTING*\]*
        create\_import\_parameter FOR CREATE entity\_name
        create\_import\_parameter FOR CREATE entity\_name\\association
        update\_import\_parameter FOR UPDATE entity\_name
        delete\_import\_parameter FOR DELETE entity\_name
        action\_import\_parameter FOR ACTION entity\_name~action\_name
                                *\[*RESULT action\_export\_parameter*\]*.
    METHODS method\_name FOR LOCK
      *\[*IMPORTING*\]*
        lock\_import\_parameter FOR LOCK entity\_name.
    METHODS method\_name FOR READ
      *\[*IMPORTING*\]*
        read\_import\_parameter FOR READ entity\_name
                              *\[*RESULT read\_export\_parameter*\]*.
ENDCLASS.
CLASS lcl\_handler\_name IMPLEMENTATION.
  METHOD modify\_method\_name.
   ...
  ENDMETHOD.
  METHOD lock\_method\_name.
   ...
  ENDMETHOD.
  METHOD read\_method\_name.
   ...
  ENDMETHOD.
ENDCLASS.

Effect

Within the [behavior pool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbehavior_pool_glosry.htm "Glossary Entry"), one or more local handler classes for handling the [behavior](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbehavior_glosry.htm "Glossary Entry") of the business object are defined. In this interaction phase of the [behavior implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbehavior_implement_glosry.htm "Glossary Entry") of a business object, the application performs writes and reads that need to be evaluated and whose effects (if without errors) need to be saved to a transactional buffer. Here, it is defined for which operations a method is responsible. In extreme cases, this is the full set of all write (MODIFY) or read (READ) operations permitted by the [behavior definition](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbehavior_definition_glosry.htm "Glossary Entry").

A handler class is defined implicitly as ABSTRACT and FINAL and derived from the basis class CL\_ABAP\_BEHAVIOR\_HANDLER. There are no special rules for the name lcl\_handler\_name of the handler classes.

To make a reference to the entities entity\_name, the [alias](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_alias.htm) granted in the behavior definition (if available) is used.

The method name method\_name can be specified freely in handler classes. The category of the method is specified for the FOR clause (FOR MODIFY*|*LOCK*|*READ).

Here, a single operation (also known as a trigger) consists of the combination of an operation (CREATE, UPDATE, DELETE, LOCK, READ, orACTION) with an entity of an entity part (namely an action or association), for example update SalesOrderItem or read SalesOrderItem\\\_Product.

The trigger is associated with a freely specified parameter name (for example, update\_import\_parameter). The trigger is also associated with one or more further parameter names, if the trigger is associated with output data (for example, with the parameter action\_export\_parameter for an action with the addition RESULT or read\_export\_parameter for the operation READ).

The following transactional methods can be implemented in the handler class:

-   [FOR MODIFY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_modify.htm)
    Covers all change operations (CREATE, UPDATE, DELETE, and certain actions specified in the behavior definition) of an entity.

-   [FOR LOCK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_lock.htm)
    Implements entity locks. Based on the [lock properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlate_numbering_glosry.htm "Glossary Entry") defined in the behavior definition.

-   [FOR READ](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_read.htm)
    Processes reads.

Note

Exceptions cannot be raised in handler methods. The statement RAISE EXCEPTION produces a [runtime error](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenruntime_error_glosry.htm "Glossary Entry").

Example

In the following example, the data from the ABAP flight data reference scenario (or flight data scenario for short) is used. It represents a legacy business logic that can be used to create and edit flight bookings. The root entity Travel represents the business object for managing flight trips. The underlying data model and the behavior of the root entity Travel are described in [ABAP BDL - Example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_example.htm).

The following example shows the definition and the schema of the implementation of the handler class of the business object. The handler class implements the handler that processes:

-   Standard operations create, update, and delete (methods modify\_create, modify\_update, and modify\_delete)

-   Read requests for the entity Travel (method read\_travel)

-   Lock method lock\_travel

-   Application-specific action set\_status\_booked

CLASS lcl\_travel\_handler DEFINITION
      INHERITING FROM cl\_abap\_behavior\_handler.
  PRIVATE SECTION.
    METHODS modify\_create  FOR MODIFY
      IMPORTING
        it\_travel\_create       FOR CREATE travel.
    METHODS modify\_update  FOR MODIFY
      IMPORTING
        it\_travel\_update       FOR UPDATE travel.
    METHODS modify\_delete  FOR MODIFY
      IMPORTING
        it\_travel\_delete       FOR DELETE travel.
    METHODS set\_status     FOR MODIFY
      IMPORTING
        it\_travel\_set\_status\_booked
                               FOR ACTION travel~set\_status\_booked
      RESULT
        et\_travel\_set\_status\_booked.
    METHODS lock\_travel    FOR LOCK
      IMPORTING
        it\_travel\_key          FOR LOCK travel.
    METHODS read\_travel    FOR READ
      IMPORTING
        it\_travel\_read         FOR READ travel
      RESULT
        et\_travel.
ENDCLASS.

CLASS lcl\_travel\_handler IMPLEMENTATION.
  METHOD modify\_create.
    ...
  ENDMETHOD.
  METHOD modify\_update.
    ...
  ENDMETHOD.
  METHOD modify\_delete.
    ...
  ENDMETHOD.
  METHOD set\_status.
    ...
  ENDMETHOD.
  METHOD read\_travel.
    ...
  ENDMETHOD.
  METHOD lock\_travel.
    ...
  ENDMETHOD.
ENDCLASS.

Continue
[FOR MODIFY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_modify.htm)
[FOR READ](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_read.htm)
[FOR LOCK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_lock.htm)
[Example - Handling of Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handling_messages.htm)


### abenhandler_method_modify.htm

---
title: "FOR MODIFY"
description: |
  Syntax METHODS method_name FOR MODIFY IMPORTING create_import_parameter FOR CREATE entity_name create_import_parameter FOR CREATE entity_nameassociation update_import_parameter FOR UPDATE entity_name delete_import_parameter FOR DELETE entity_name action_import_parameter FOR
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_modify.htm"
abapFile: "abenhandler_method_modify.htm"
keywords: ["insert", "update", "delete", "loop", "do", "while", "if", "try", "method", "class", "data", "types", "abenhandler", "modify"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP RESTful Programming Model](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrestful_abap_programming.htm) →  [Behavior Implementations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_behavior_implementations.htm) →  [Handler Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handler_class.htm) → 

FOR MODIFY

Syntax

METHODS method\_name FOR MODIFY
  *\[*IMPORTING*\]*
    create\_import\_parameter FOR CREATE entity\_name
    create\_import\_parameter FOR CREATE entity\_name\\association
    update\_import\_parameter FOR UPDATE entity\_name
    delete\_import\_parameter FOR DELETE entity\_name
    action\_import\_parameter FOR ACTION entity\_name~action
          \[RESULT action\_export\_parameter\]
   ...
   *\[*CHANGING  failed   TYPE DATA
              mapped   TYPE DATA
              reported TYPE DATA*\]*.

Effect

The method MODIFY implements the handler that makes changes to the entities in the context of the ABAP RESTful programming model. This method is called if the application is processing a change request containing at least one of the change operations (CREATE, UPDATE, DELETE, or ACTION) specified in the [behavior definition](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbehavior_definition_glosry.htm "Glossary Entry"). The command ... parameter IS \[NOT\] INITIAL can be used to determine which operations are actually used.

Like the method [READ](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_read.htm), the method MODIFY is mass-enabled and bundle-enabled (which means it can handle mass requests and can implement multiple operations). Multiple operations in a MODIFY method, however, are not permitted.

No rules apply to the order in which individual operations are processed within a MODIFY method. The application processes all individual passed operations in an appropriate order, for example create operations before update operations.

The method name method\_name can be specified freely. Using this generalization, it is possible to accommodate multiple MODIFY methods in a single [handler class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handler_class.htm). For example, each action can be defined as a method in the same handler class. This enables the behavior implementation of a business object without introducing a corresponding number of handler classes.

entity\_name refers to the name of the entity or the [alias](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_alias.htm), if one is defined in the behavior definition.

Input Parameters

The name of the input parameter (for example, create\_import\_parameter) can be specified freely.

The row type of the input parameters for the corresponding operations contains the following (the associated [parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencomponents_derived_types.htm) are flagged with "x"):

Operation

ID

%CID

%CID\_REF

%KEY

%PID

%CONTROL

%DATA

%PARAM

CREATE

\-

x

\-

\-

\-

x

\-

\-

UPDATE

\-

\-

x

x

x

x

x

\-

DELETE

x

\-

x

\-

x

\-

\-

\-

ACTION

x

\-

x

\-

x

\-

\-

x

Output Parameters

The name of the output parameter (for example, create\_export\_parameter) can be specified freely.

For an action with the addition RESULT, a named output parameter must be filled. Other operations do not necessarily have visible results. If they do, the results are written implicitly to three return structures (failed, mapped, and reported for errors, mappings, or messages). They can, however, be declared explicitly as [CHANGING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenchanging_type_data.htm) parameters in the method signature using the generic type DATA:

CHANGING failed   TYPE DATA
         mapped   TYPE DATA
         reported TYPE DATA

The parameters failed, mapped and reported don’t have fixed data types and are assigned with [derived types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_derived_types.htm) from the behavior definition instead.

Remarks

-   The old syntax METHODS modify FOR BEHAVIOR ... is also valid but is not recommended.

-   The keyword IMPORTING in the syntax of the method method\_name is not mandatory and can be specified in front of the input parameter.

-   The parameters can also be declared explicitly as REFERENCE (...).

-   A declaration as VALUE (...) is not allowed. This means that the input parameters in a MODIFY method cannot be changed.

Example

In the following example, the data from the ABAP flight data reference scenario (or flight data scenario for short) is used. It represents a legacy business logic that can be used to create and edit flight bookings. The root entity Travel represents the business object for managing flight trips. The underlying data model and the behavior of the root entity Travel are described in [ABAP BDL - Example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_example.htm).

The following example shows the definitions and implementations

-   of the standard operations create, update, and delete (for creating, updating, and deleting instances of the entity Travel) and

-   the application-specific action set\_status\_booked (for setting the trip status to booked).

In the example, each of the operations and the action are implemented in the methods modify\_create, modify\_update, modify\_delete, and set\_status. The basic structure of the implementation of the methods is similar. For example, the implementation of the method modify\_create includes

-   a loop for all new instances of the entity Travel to be created,

-   calling the function module of the legacy business logic /DMO/FLIGHT\_TRAVEL\_CREATE for creating new Travel instances, and

-   message handling for processing instance-specific messages if an error occurs (msgty = 'E' for an error, msgty = 'A' for an abortion).

The second step can generate failed keys (ls\_travel\_create-%cid) and messages (lt\_messages). Failed keys are saved in the table failed while all instance-specific messages are saved in the table reported. If successful (lt\_messages IS INITIAL), the content ID (%CID) and the new key travel\_id are written to the table mapped.

For the sake of readability, the methods for handling the messages are implemented in the separate class zcl\_messages. The class zcl\_messages is described in [Example - Handling of Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handling_messages.htm).

CLASS lcl\_travel\_handler DEFINITION
    INHERITING FROM cl\_abap\_behavior\_handler.
  PRIVATE SECTION.
    METHODS modify\_create FOR MODIFY
      IMPORTING
        it\_travel\_create    FOR CREATE travel.
    METHODS modify\_update FOR MODIFY
      IMPORTING
        it\_travel\_update    FOR UPDATE travel.
    METHODS modify\_delete FOR MODIFY
      IMPORTING
        it\_travel\_delete    FOR DELETE travel.
    METHODS set\_status    FOR MODIFY
      IMPORTING
        it\_travel\_set\_status\_booked
                            FOR ACTION travel~set\_status\_booked
      RESULT
        et\_travel\_set\_status\_booked.
ENDCLASS.

CLASS lcl\_travel\_handler IMPLEMENTATION.
  METHOD modify\_create.
    DATA ls\_travel\_out TYPE /dmo/travel.
    DATA lt\_messages   TYPE /dmo/if\_flight\_legacy=>tt\_message.
    LOOP AT it\_travel\_create INTO DATA(ls\_travel\_create).
      CALL FUNCTION '/DMO/FLIGHT\_TRAVEL\_CREATE'
        EXPORTING
          is\_travel   = CORRESPONDING
            /dmo/if\_flight\_legacy=>ts\_travel\_in( ls\_travel\_create )
        IMPORTING
          es\_travel   = ls\_travel\_out
          et\_messages = lt\_messages.
      IF lt\_messages IS NOT INITIAL.
        zcl\_messages=>handle\_messages(
          EXPORTING
            iv\_cid      = ls\_travel\_create-%cid
            it\_messages = lt\_messages
          CHANGING
            failed   = failed-travel
            reported = reported-travel ).
        CONTINUE.
      ENDIF.
      INSERT VALUE #( %cid    = ls\_travel\_create-%cid
                    travel\_id = ls\_travel\_out-travel\_id )
        INTO TABLE mapped-travel.
    ENDLOOP.
  ENDMETHOD.
  METHOD modify\_update.
    DATA ls\_travel\_out TYPE /dmo/travel.
    DATA lt\_messages   TYPE /dmo/if\_flight\_legacy=>tt\_message.
    LOOP AT it\_travel\_update INTO DATA(ls\_travel\_update).
      ls\_travel\_update-travel\_id = COND #(
        WHEN ls\_travel\_update-travel\_id IS INITIAL
        OR ls\_travel\_update-travel\_id = ''
        THEN mapped-travel\[ %cid = ls\_travel\_update-%cid\_ref \]-travel\_id
        ELSE ls\_travel\_update-travel\_id ).
      DATA(ls\_travelx) = zcl\_messages=>map\_travel\_control(
        is\_travel = ls\_travel\_update ).
      CALL FUNCTION '/DMO/FLIGHT\_TRAVEL\_UPDATE'
        EXPORTING
          is\_travel   = CORRESPONDING
            /dmo/if\_flight\_legacy=>ts\_travel\_in( ls\_travel\_update )
          is\_travelx  = ls\_travelx
        IMPORTING
          et\_messages = lt\_messages.
      LOOP AT lt\_messages INTO DATA(ls\_message)
          WHERE msgty = 'E' OR msgty = 'A'.
        zcl\_messages=>handle\_messages(
          EXPORTING
            iv\_cid       = ls\_travel\_update-%cid\_ref
            iv\_travel\_id = ls\_travel\_update-travel\_id
            it\_messages  = lt\_messages
          CHANGING
            failed   = failed-travel
            reported = reported-travel ).
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.
  METHOD modify\_delete.
    DATA: lt\_messages   TYPE /dmo/if\_flight\_legacy=>tt\_message,
          ls\_travel\_out TYPE /dmo/travel.
    LOOP AT it\_travel\_delete INTO DATA(ls\_travel\_delete).
      ls\_travel\_delete-travel\_id = COND #(
        WHEN ls\_travel\_delete-travel\_id IS INITIAL
        OR ls\_travel\_delete-travel\_id = ''
        THEN mapped-travel\[ %cid = ls\_travel\_delete-%cid\_ref \]-travel\_id
        ELSE ls\_travel\_delete-travel\_id ).
      CALL FUNCTION '/DMO/FLIGHT\_TRAVEL\_DELETE'
        EXPORTING
          iv\_travel\_id = ls\_travel\_delete-travel\_id
        IMPORTING
          et\_messages  = lt\_messages.
      zcl\_messages=>handle\_messages(
        EXPORTING
          iv\_cid       = ls\_travel\_delete-%cid\_ref
          iv\_travel\_id = ls\_travel\_delete-travel\_id
          it\_messages  = lt\_messages
        CHANGING
          failed       = failed-travel
          reported     = reported-travel ).
    ENDLOOP.
  ENDMETHOD.
  METHOD set\_status.
    DATA lt\_messages TYPE /dmo/if\_flight\_legacy=>tt\_message.
    CLEAR et\_travel\_set\_status\_booked.
    LOOP AT it\_travel\_set\_status\_booked
        ASSIGNING FIELD-SYMBOL(<fs\_travel\_set\_status\_booked>).
      DATA(lv\_travel\_id) =
        <fs\_travel\_set\_status\_booked>-travel\_id.
      IF lv\_travel\_id IS INITIAL OR lv\_travel\_id = ''.
        lv\_travel\_id = mapped-travel\[
          %cid = <fs\_travel\_set\_status\_booked>-%cid\_ref
                                    \]-travel\_id.
      ENDIF.
      CALL FUNCTION '/DMO/FLIGHT\_TRAVEL\_SET\_BOOKING'
        EXPORTING
          iv\_travel\_id = lv\_travel\_id
        IMPORTING
          et\_messages  = lt\_messages.
      zcl\_messages=>handle\_messages(
        EXPORTING
          iv\_cid       = <fs\_travel\_set\_status\_booked>-%cid\_ref
          iv\_travel\_id = lv\_travel\_id
          it\_messages  = lt\_messages
        CHANGING
          failed       = failed-travel
          reported     = reported-travel ).
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.


### abenhandler_method_read.htm

---
title: "FOR READ"
description: |
  Syntax METHODS method_name FOR READ IMPORTING read_import_parameter   FOR READ entity_name RESULT read_export_parameter read_import_param_assoc FOR READ entity_name_assoc FULL   read_export_param_full RESULT read_export_param_assoc LINK   read_export_param_link
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_read.htm"
abapFile: "abenhandler_method_read.htm"
keywords: ["insert", "update", "loop", "do", "if", "try", "method", "class", "data", "types", "abenhandler", "read"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP RESTful Programming Model](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrestful_abap_programming.htm) →  [Behavior Implementations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_behavior_implementations.htm) →  [Handler Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handler_class.htm) → 

FOR READ

Syntax

METHODS method\_name FOR READ
  *\[*IMPORTING*\]*
     read\_import\_parameter   FOR READ entity\_name
       *\[*RESULT read\_export\_parameter*\]*
     read\_import\_param\_assoc FOR READ entity\_name\\\_assoc
        FULL   read\_export\_param\_full
        RESULT read\_export\_param\_assoc
        LINK   read\_export\_param\_link
     ...
  *\[*image TYPE if\_abap\_behv=>t\_image*\]*
  ...
  *\[*CHANGING failed   TYPE DATA
            reported TYPE DATA*\]*.

Effect

The READ method implements the handler that processes read requests for the entities in the context of the ABAP RESTful programming model. The method is used to return data from the application buffer. If the buffer is empty, the data must be read from the database.

The READ method can be called to support handling of an [ETag](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenentity_tag_glosry.htm "Glossary Entry"). A change operation (such as update) is triggered by the if match condition. First the [LOCK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_lock.htm) method is called. If the LOCK method was successful, the READ method is triggered to request the current ETag value. The structure [%CONTROL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencomponents_derived_types.htm) requests the ID fields and the ETag attributes. The data is then checked using the if match condition. If the check is passed, the change method is called.

Like [MODIFY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_modify.htm) methods, the READmethod is mass-enabled and bundle-enabled. This means that it can handle mass requests and implement multiple operations. Multiple operations in a READ method, however, are not permitted.

The method name method\_name is arbitrary. Using this generalization, it is possible to accommodate multiple READ methods in a single [handler class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handler_class.htm). This enables the [behavior implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbehavior_implement_glosry.htm "Glossary Entry") of a [business object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbusiness_object_glosry.htm "Glossary Entry") without introducing a corresponding number of handler classes.

entity\_name refers to the name of the entity or the [alias](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_alias.htm), if one is defined in the [behavior definition](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbehavior_definition_glosry.htm "Glossary Entry").

Just like the direct operation read, the operation read-by-association uses a table with instance keys of the source entity as input parameter read\_import\_param\_assoc. The output is as follows:

-   FULL
    Boolean parameter indicating whether the consumer is making a query based only on the links or whether full results are queried.

-   RESULT
    A table with the full row type of the target entity.

-   LINK
    A table in which source keys and target keys are set in relationship with each other.

Input Parameters

The name of the input parameter (for example, read\_import\_parameter) can be specified freely.

The row structure of the input parameter contains the following [components](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencomponents_derived_types.htm):

-   %PID

-   ID fields

-   %CONTROL.

Furthermore, the implicit input parameter image can be declared explicitly as an optional parameter:

  *\[*IMPORTING*\]* image TYPE if\_abap\_behv=>t\_image

The values of the parameter image are as follows:

-   transactional
    This is the parameter's default value. The state of the entities is queried from the transactional buffer.

-   before
    The state of the entities is queried from the database.

Output Parameters

The name of the output parameter (for example, read\_export\_parameter) can be specified freely.

The output parameter read\_export\_parameter, which can be declared explicitly, has the successfully read data as its output. Its row structure contains the following components:

-   %PID

-   All fields of the entity.

The output parameters failed and reported for errors or messages are added implicitly (automatically). They can, however, be declared explicitly as [CHANGING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenchanging_type_data.htm) parameters in the method signature using the generic type DATA:

CHANGING failed   TYPE DATA
         reported TYPE DATA

The parameters failed and reported don’t have fixed data types and are assigned with [derived types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_derived_types.htm) from the behavior definition instead. The parameter mapped is part of the method signature, but it is not used in the method.

Tip

The control structure %CONTROL shows which elements are requested by the consumer. It may, however, be a good idea to return all elements and not just the requested elements.

Remarks

-   The old syntax METHODS read FOR BEHAVIOR ... is also valid but is not recommended.

-   The keyword IMPORTING is not mandatory and can be specified in front of the input parameter.

Example

In the following example, the data from the ABAP flight data reference scenario (or flight data scenario for short) is used. It represents a legacy business logic that can be used to create and edit flight bookings. The root entity Travel represents the business object for managing flight trips. The underlying data model and the behavior of the root entity Travel are described in [ABAP BDL - Example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_example.htm).

The following example shows the definition and the implementation of the READ method read\_travel for processing read requests for the entity Travel. The implementation of the method includes

-   a loop for all instances of the entity Travel to be read,

-   calling the function module of the legacy business logic /DMO/FLIGHT\_TRAVEL\_READ for reading Travel instances, and

-   message handling for processing instance-specific messages if an error occurs. For the sake of readability, the methods for handling the messages are implemented in the separate class zcl\_messages. The class zcl\_messages is described in [Example - Handling of Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handling_messages.htm).

CLASS lcl\_travel\_handler DEFINITION
    INHERITING FROM cl\_abap\_behavior\_handler.
  PRIVATE SECTION.
    METHODS read\_travel FOR READ
      IMPORTING
        it\_travel\_read FOR READ travel
      RESULT et\_travel.
ENDCLASS.

CLASS lcl\_travel\_handler IMPLEMENTATION.
  METHOD read\_travel.
    DATA: lt\_messages   TYPE /dmo/if\_flight\_legacy=>tt\_message,
          ls\_travel\_out TYPE /dmo/travel.
    LOOP AT it\_travel\_read INTO DATA(ls\_travel\_read).
      CALL FUNCTION '/DMO/FLIGHT\_TRAVEL\_READ'
        EXPORTING
          iv\_travel\_id = ls\_travel\_read-travel\_id
        IMPORTING
          es\_travel    = ls\_travel\_out
          et\_messages  = lt\_messages.
      IF lt\_messages IS NOT INITIAL.
        zcl\_messages=>handle\_messages(
          EXPORTING
            iv\_travel\_id = ls\_travel\_read-travel\_id
            it\_messages  = lt\_messages
          CHANGING
            failed       = failed-travel
            reported     = reported-travel
        ).
        CONTINUE.
      ENDIF.
      INSERT CORRESPONDING #( ls\_travel\_out ) INTO TABLE et\_travel.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.


### abenhandler_method_lock.htm

---
title: "FOR LOCK"
description: |
  Syntax METHODS method_name FOR LOCK IMPORTING lock_import_parameter FOR LOCK entity_name. ... CHANGING failed   TYPE DATA reported TYPE DATA. Effect The LOCK implements the handler that locks entities. However, the lock properties(https://help.sap.com/doc/abapdocu_754_index_htm
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhandler_method_lock.htm"
abapFile: "abenhandler_method_lock.htm"
keywords: ["insert", "update", "loop", "do", "if", "try", "method", "class", "data", "types", "abenhandler", "lock"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP RESTful Programming Model](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrestful_abap_programming.htm) →  [Behavior Implementations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_behavior_implementations.htm) →  [Handler Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handler_class.htm) → 

FOR LOCK

Syntax

METHODS method\_name FOR LOCK
    *\[*IMPORTING*\]*
        lock\_import\_parameter FOR LOCK entity\_name.
     ...
    *\[*CHANGING failed   TYPE DATA
              reported TYPE DATA*\]*.

Effect

The LOCK implements the handler that locks entities. However, the [lock properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_lock.htm) lock master or lock dependent must be specified in the [behavior definition](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbehavior_definition_glosry.htm "Glossary Entry") of a [business object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbusiness_object_glosry.htm "Glossary Entry"). The method lock is called automatically before a change operation (for example, update).

The method name method\_name is arbitrary. Using this generalization, it is possible to accommodate multiple LOCK methods in a single [handler class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handler_class.htm).

entity\_name refers to the name of the entity or the [alias](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_alias.htm), if it exists, as defined in the behavior definition.

Input Parameters

The following points apply to the input parameter lock\_import\_parameter:

-   The name of the input parameter can be freely defined.

-   The row type of the input parameter provides the ID fields. This structure contains the fields of the entity that are specified as keys.

-   The [fields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencomponents_derived_types.htm) %CID, %CID\_REF, and %PID generated by ABAP Compiler are not required in the context of locks, since locks are only relevant for instances saved in the database.

Output Parameters

The output parameters failed and reported for errors or messages are added automatically. They can, however, be declared explicitly as [CHANGING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenchanging_type_data.htm) parameters in the method signature using the generic type DATA:

CHANGING failed   TYPE DATA
         reported TYPE DATA

The parameters failed and reported don’t have fixed data types and are assigned with derived types from the behavior definition instead. The parameter mapped is part of the method signature, but it is not used in the method.

Remarks

-   The old syntax METHODS lock FOR BEHAVIOR ... is also valid but is no longer recommended.

-   The keyword IMPORTING is not mandatory and can be specified in front of the input parameter.

Example

In the following example, the data from the ABAP flight data reference scenario (or flight data scenario for short) is used. It represents a legacy business logic that can be used to create and edit flight bookings. The root entity Travel represents the business object for managing flight trips. The underlying data model and the behavior of the root entity Travel are described in [ABAP BDL - Example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_example.htm).

The following example shows the definition and implementation of the LOCK method lock\_travel. The implementation of the method includes

-   a loop for all instances of the entity Travel to be locked,

-   calling the function module of the legacy business logic ENQUEUE\_/DMO/ETRAVEL, and

-   message handling for processing instance-specific messages. For the sake of readability, the methods for handling the messages are implemented in the separate class zcl\_messages. The class zcl\_messages is described in [Example - Handling of Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handling_messages.htm).

CLASS lcl\_travel\_handler DEFINITION
    INHERITING FROM cl\_abap\_behavior\_handler.
  PRIVATE SECTION.
    METHODS lock\_travel FOR LOCK
      IMPORTING
        it\_travel\_key FOR LOCK travel.
ENDCLASS.

CLASS lcl\_travel\_handler IMPLEMENTATION.
  METHOD lock\_travel.
    LOOP AT it\_travel\_key ASSIGNING FIELD-SYMBOL(<fs\_travel>).
      CALL FUNCTION 'ENQUEUE\_/DMO/ETRAVEL'
        EXPORTING
          travel\_id      = <fs\_travel>-travel\_id
        EXCEPTIONS
          foreign\_lock   = 1
          system\_failure = 2
          OTHERS         = 3.
      ASSERT sy-subrc < 2.
      IF sy-subrc = 1.
        INSERT zcl\_messages=>map\_travel\_message(
           iv\_travel\_id = <fs\_travel>-travel\_id
           is\_message   = VALUE #( msgid = '/DMO/CM\_FLIGHT\_LEGAC'
                                   msgty = 'E'
                                   msgno = '032'
                                   msgv1 = <fs\_travel>-travel\_id
                                   msgv2 = sy-msgv1 ) )
          INTO TABLE reported-travel.
        APPEND VALUE #( travel\_id = <fs\_travel>-travel\_id )
               TO failed-travel.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.


### abenrpm_handling_messages.htm

---
title: "Example - Handling of Messages"
description: |
  Example For the sake of readability, the methods for handling the messages are implemented in the separate class zcl_messages. These methods are used to handle the messages in the methods of the handler class. Messages that come from the legacy business logic must be assigned to the messages of the
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handling_messages.htm"
abapFile: "abenrpm_handling_messages.htm"
keywords: ["insert", "update", "loop", "do", "if", "method", "class", "data", "types", "abenrpm", "handling", "messages"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP RESTful Programming Model](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrestful_abap_programming.htm) →  [Behavior Implementations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_behavior_implementations.htm) →  [Handler Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handler_class.htm) → 

Example - Handling of Messages

Example

For the sake of readability, the methods for handling the messages are implemented in the separate class zcl\_messages. These methods are used to handle the messages in the methods of the handler class.

Messages that come from the legacy business logic must be assigned to the messages of the business object Travel. This is implemented in the method map\_travel\_message.

CLASS zcl\_messages DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC.
  PUBLIC SECTION.
    TYPES:
      ts\_travel\_control\_map TYPE STRUCTURE FOR UPDATE /DMO/I\_Travel,
      tt\_travel\_reported    TYPE TABLE FOR REPORTED   /DMO/I\_Travel,
      tt\_travel\_failed      TYPE TABLE FOR FAILED     /DMO/I\_Travel.
    CLASS-METHODS:
      handle\_messages
        IMPORTING
          iv\_cid       TYPE abp\_behv\_cid   OPTIONAL
          iv\_travel\_id TYPE /dmo/travel\_id OPTIONAL
          it\_messages  TYPE /dmo/if\_flight\_legacy=>tt\_message
        CHANGING
          failed       TYPE tt\_travel\_failed
          reported     TYPE tt\_travel\_reported,
      map\_travel\_message
        IMPORTING
          iv\_cid           TYPE string OPTIONAL
          iv\_travel\_id     TYPE /dmo/travel\_id OPTIONAL
          is\_message       TYPE LINE OF
            /dmo/if\_flight\_legacy=>tt\_message
        RETURNING VALUE(rs\_report) TYPE LINE OF tt\_travel\_reported,
      map\_travel\_control
        IMPORTING
          is\_travel         TYPE ts\_travel\_control\_map
        RETURNING VALUE(rs\_travelx) TYPE
           /dmo/if\_flight\_legacy=>ts\_travel\_inx.
  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-METHODS:
      new\_message
        IMPORTING
          id         TYPE symsgid
          number     TYPE symsgno
          severity   TYPE if\_abap\_behv\_message=>t\_severity
          v1         TYPE simple OPTIONAL
          v2         TYPE simple OPTIONAL
          v3         TYPE simple OPTIONAL
          v4         TYPE simple OPTIONAL
        RETURNING VALUE(obj) TYPE REF TO if\_abap\_behv\_message.
ENDCLASS.

CLASS zcl\_messages IMPLEMENTATION.
  METHOD handle\_messages.
    LOOP AT it\_messages INTO DATA(ls\_message)
         WHERE msgty = 'E' OR msgty = 'A'.
      INSERT VALUE #(
             %cid         = iv\_cid
             travel\_id    = iv\_travel\_id )
         INTO TABLE failed.
      INSERT map\_travel\_message(
             iv\_travel\_id = iv\_travel\_id
             is\_message   = ls\_message )
         INTO TABLE reported.
    ENDLOOP.
  ENDMETHOD.
  METHOD map\_travel\_control.
    rs\_travelx-travel\_id     = is\_travel-travel\_id.
    rs\_travelx-agency\_id     = xsdbool(
      is\_travel-%control-agency\_id     = cl\_abap\_behv=>flag\_changed ).
    rs\_travelx-customer\_id   = xsdbool(
      is\_travel-%control-customer\_id   = cl\_abap\_behv=>flag\_changed ).
    rs\_travelx-begin\_date    = xsdbool(
      is\_travel-%control-begin\_date    = cl\_abap\_behv=>flag\_changed ).
    rs\_travelx-end\_date      = xsdbool(
      is\_travel-%control-end\_date      = cl\_abap\_behv=>flag\_changed ).
    rs\_travelx-booking\_fee   = xsdbool(
      is\_travel-%control-booking\_fee   = cl\_abap\_behv=>flag\_changed ).
    rs\_travelx-total\_price   = xsdbool(
      is\_travel-%control-total\_price   = cl\_abap\_behv=>flag\_changed ).
    rs\_travelx-currency\_code = xsdbool(
      is\_travel-%control-currency\_code = cl\_abap\_behv=>flag\_changed ).
    rs\_travelx-description   = xsdbool(
      is\_travel-%control-description   = cl\_abap\_behv=>flag\_changed ).
    rs\_travelx-status        = xsdbool(
      is\_travel-%control-status        = cl\_abap\_behv=>flag\_changed ).
ENDMETHOD.
  METHOD map\_travel\_message.
    DATA(lo) = new\_message(
      id       = is\_message-msgid
      number   = is\_message-msgno
      severity = if\_abap\_behv\_message=>severity-error
      v1       = is\_message-msgv1
      v2       = is\_message-msgv2
      v3       = is\_message-msgv3
      v4       = is\_message-msgv4 ).
    rs\_report-%cid      = iv\_cid.
    rs\_report-travel\_id = iv\_travel\_id.
    rs\_report-%msg      = lo.
  ENDMETHOD.
  METHOD new\_message.
    obj = NEW lcl\_abap\_behv\_msg(
      textid = VALUE #(
        msgid = id
        msgno = number
        attr1 = COND #( WHEN v1 IS NOT INITIAL
                        THEN 'IF\_T100\_DYN\_MSG~MSGV1' )
        attr2 = COND #( WHEN v2 IS NOT INITIAL
                        THEN 'IF\_T100\_DYN\_MSG~MSGV2' )
        attr3 = COND #( WHEN v3 IS NOT INITIAL
                        THEN 'IF\_T100\_DYN\_MSG~MSGV3' )
        attr4 = COND #( WHEN v4 IS NOT INITIAL
                        THEN 'IF\_T100\_DYN\_MSG~MSGV4' ))
      msgty = SWITCH #( severity
        WHEN if\_abap\_behv\_message=>severity-error       THEN 'E'
        WHEN if\_abap\_behv\_message=>severity-warning     THEN 'W'
        WHEN if\_abap\_behv\_message=>severity-information THEN 'I'
        WHEN if\_abap\_behv\_message=>severity-success     THEN 'S' )
      msgv1 = |{ v1 }|
      msgv2 = |{ v2 }|
      msgv3 = |{ v3 }|
      msgv4 = |{ v4 }| ).
    obj->m\_severity = severity.
  ENDMETHOD.
ENDCLASS.


---


## ABAP Keyword Documentation / ABAP − Reference / ABAP RESTful Programming Model / Behavior Implementations / Saver Class

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / ABAP RESTful Programming Model / Behavior Implementations / Saver Class

Included pages: 6


### abenrpm_saver_class.htm

---
title: "Saver Class"
description: |
  Syntax CLASS lcl_saver_name DEFINITION INHERITING FROM cl_abap_behavior_saver ABSTRACT FINAL. PROTECTED SECTION. METHODS finalize          REDEFINITION. METHODS check_before_save REDEFINITION. METHODS adjust_numbers    REDEFINITION. METHODS save              REDEFINITION. MET
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm"
abapFile: "abenrpm_saver_class.htm"
keywords: ["delete", "do", "if", "try", "method", "class", "data", "types", "abenrpm", "saver"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP RESTful Programming Model](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrestful_abap_programming.htm) →  [Behavior Implementations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_behavior_implementations.htm) → 

Saver Class

Syntax

CLASS lcl\_saver\_name DEFINITION
      INHERITING FROM cl\_abap\_behavior\_saver
        *\[*ABSTRACT*\]* *\[*FINAL*\]*.
  PROTECTED SECTION.
    METHODS finalize          REDEFINITION.
    METHODS check\_before\_save REDEFINITION.
    METHODS adjust\_numbers    REDEFINITION.
    METHODS save              REDEFINITION.
    METHODS cleanup           REDEFINITION.
ENDCLASS.
CLASS lcl\_saver\_name IMPLEMENTATION.
  METHOD finalize.
    ...
  ENDMETHOD.
  METHOD check\_before\_save.
    ...
  ENDMETHOD.
  METHOD adjust\_numbers.
    ...
  ENDMETHOD.
  METHOD save.
    ...
  ENDMETHOD.
  METHOD cleanup.
    ...
  ENDMETHOD.
ENDCLASS.

Effect

Within the [behavior pool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbehavior_pool_glosry.htm "Glossary Entry"), a local saver class is defined to implement the save phase of the [business object behavior](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbehavior_glosry.htm "Glossary Entry"). The save phase consists of a sequence of calls used to synchronize the business objects in question. Only the final call in this sequence is the actual save method, in which changes can and must be written to the database.

The saver class lcl\_saver is defined implicitly as ABSTRACT and FINAL and derived from the class CL\_ABAP\_BEHAVIOR\_SAVER. There are no special rules for the name of the saver class.

The transactional methods [finalize](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_finalize.htm), [check\_before\_save](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_check_before_save.htm), [adjust\_numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_adjust_numbers.htm), [save](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_method_save.htm), and [cleanup](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_method_cleanup.htm) can be implemented in a saver class:

-   finalize
    Finalizes any changes to data before it can be saved to the database.

-   check\_before\_save
    Checks the consistency of the application buffer.

-   adjust\_numbers
    Implements [late numbering](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlate_numbering_glosry.htm "Glossary Entry").

-   save
    Saves the data from the transactional buffer to the database.

-   cleanup
    Discards all data changes and cleans up the transactional buffer.

The methods that correspond to the saver protocol (finalize, check\_before\_save, adjust\_numbers, save, and cleanup) are all defined already in the basis class CL\_ABAP\_BEHAVIOR\_SAVER and do not have individual signatures. The derived concrete saver class must implement these methods using REDEFINITION. In the redefinition, the types of the parameters defined in the basis class (failed, mapped, and reported are replaced by concrete [derived types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_derived_types.htm). In the basis class, these parameters are defined generically as [CHANGING parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenchanging_type_data.htm).

The implementation of the methods finalize, check\_before\_save, and cleanup is not mandatory. The only mandatory redefinition is the method save. If the behavior definition specifies late numbering, the method adjust\_numbers must also be implemented. The structure [mapped](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenchanging_type_data.htm) is filled here.

Unlike in the [interaction phase](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_handler_class.htm), no instance phase is passed in the saver phase. The saver itself must know where the data is to which it needs to apply the method finalize (by cooperating with the handler or the underlying legacy functions), namely in the transactional buffer administered by the application.

The saver sequence finalize, check\_before\_save, adjust\_numbers, save, and cleanup is called in this order for every business object, after at least one successful change is made in the current [LUW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenluw_glosry.htm "Glossary Entry") using the business object provider. A successful saver sequence is as follows:

-   The saver sequence starts with the method finalize, which finalizes the calculations and data changes before data can be saved to the database.

-   If the method finalize does not report any errors, the follow-on method check\_before\_save is called.

-   If the method check\_before\_save does not return an error, the point has been reached from which a successful save is guaranteed for all business objects in question. After this point, the method adjust\_numbers is called to respect late numbering.

-   Finally, the method save is called to save all data of the business object instance from the transactional buffer to the database.

-   At the end, the method cleanup is called to delete the transaction buffer.

If the method finalize or check\_before\_save reports an error, the method cleanup is called to discard all changes made to the data in the current LUW and to clean up the transactional buffer.

The methods finalize and check\_before\_save can still fail, but this is not possible in the following methods. This means that, from the method adjust\_numbers, the parameters failed and reported no longer exist.

Example

In the following example, the data from the ABAP flight data reference scenario (or flight data scenario for short) is used. It represents a legacy business logic that can be used to create and edit flight bookings. The root entity Travel represents the business object for managing flight trips. The underlying data model and the behavior of the root entity Travel are described in [ABAP BDL - Example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_example.htm).

CLASS lcl\_travel\_saver DEFINITION
      INHERITING FROM cl\_abap\_behavior\_saver.
  PROTECTED SECTION.
    METHODS finalize          REDEFINITION.
    METHODS check\_before\_save REDEFINITION.
    METHODS save              REDEFINITION.
    METHODS cleanup           REDEFINITION.
ENDCLASS.

CLASS lcl\_saver IMPLEMENTATION.
  METHOD finalize.
    ...
  ENDMETHOD.
  METHOD check\_before\_save.
    ...
  ENDMETHOD.
  METHOD adjust\_numbers.
    ...
  ENDMETHOD.
  METHOD save.
    ...
  ENDMETHOD.
  METHOD cleanup.
    ...
  ENDMETHOD.
ENDCLASS.

Continue
[Method FINALIZE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_finalize.htm)
[Method CHECK\_BEFORE\_SAVE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_check_before_save.htm)
[Method ADJUST\_NUMBERS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_adjust_numbers.htm)
[Method SAVE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_method_save.htm)
[CLEANUP method](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_method_cleanup.htm)


### abensaver_finalize.htm

---
title: "Method FINALIZE"
description: |
  The method finalize of the local saver class(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm) is the first method of the saver sequence of the behavior implementation of a business object. The method is used to make any final calculations and data modifications b
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_finalize.htm"
abapFile: "abensaver_finalize.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abensaver", "finalize"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP RESTful Programming Model](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrestful_abap_programming.htm) →  [Behavior Implementations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_behavior_implementations.htm) →  [Saver Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm) → 

Method FINALIZE

The method finalize of the local [saver class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm) is the first method of the saver sequence of the behavior implementation of a business object. The method is used to make any final calculations and data modifications before the method [save](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_method_save.htm) saves data in the database.

The method finalize can return failed keys and messages. For this pupose, there are the [output parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_export_parameters.htm) failed and reported.

If the finalize method returns an error in the output parameter failed, the saver sequence is terminated. The cleanup method is called to discard all changes made to the data in the current [LUW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenluw_glosry.htm "Glossary Entry") and to clean up the transactional buffer.

If the finalize method does not report an error, the subsequent method [check\_before\_save](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_check_before_save.htm) is called.

Remarks

-   The parameter mapped is part of the signature of the method finalize. It is not, however, used.

-   The implementation of the method finalize is not mandatory.


### abensaver_check_before_save.htm

---
title: "Remarks"
description: |
  -   The parameter mapped is part of the signature of the method check_before_save. It is not, however, used. -   The implementation of the method check_before_save is not mandatory.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_check_before_save.htm"
abapFile: "abensaver_check_before_save.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abensaver", "check", "before", "save"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP RESTful Programming Model](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrestful_abap_programming.htm) →  [Behavior Implementations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_behavior_implementations.htm) →  [Saver Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm) → 

Method CHECK\_BEFORE\_SAVE

The method check\_before\_save of the local [saver class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm) is the second method of the saver sequence of the behavior implementation of a business object. The method check\_before\_save is used to check the application buffer for consistency before the method [save](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_method_save.htm) saves data in the database.

The method check\_before\_save can return failed keys and messages. For this pupose, there are the [output parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_export_parameters.htm) failed and reported.

If the check\_before\_save method returns an error in the output parameter failed, the saver sequence is terminated. The [cleanup](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_method_cleanup.htm) method is called to discard all changes made to the data in the current [LUW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenluw_glosry.htm "Glossary Entry") and to clean up the transactional buffer.

If the method check\_before\_save does not return an error, the point has been reached after which a successful save is guaranteed for all involved business objects. The subsequent method [adjust\_numbers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_adjust_numbers.htm) is called.

Remarks

-   The parameter mapped is part of the signature of the method check\_before\_save. It is not, however, used.

-   The implementation of the method check\_before\_save is not mandatory.


### abensaver_adjust_numbers.htm

---
title: "Tip"
description: |
  Ideally, the late numbering is implemented separately from the save. In many legacy applications, however, the final numbers are determined during the save. In this case, we recommend implementing the save logic in the method adjust_numbers and leaving the method save empty.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_adjust_numbers.htm"
abapFile: "abensaver_adjust_numbers.htm"
keywords: ["do", "if", "case", "try", "method", "class", "types", "abensaver", "adjust", "numbers"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP RESTful Programming Model](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrestful_abap_programming.htm) →  [Behavior Implementations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_behavior_implementations.htm) →  [Saver Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm) → 

Method ADJUST\_NUMBERS

The method adjust\_numbers of the local [saver class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm) is the third method of the saver sequence of the behavior implementation of a business object. If the second method of the saver sequence [check\_before\_save](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_check_before_save.htm) does not return an error, the point has been reached after which a successful save is guaranteed for all involved business objects. After this point, the method adjust\_numbers is called. This method implements the [late numbering](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlate_numbering_glosry.htm "Glossary Entry") that is specified in the behavior definition of the business object.

The implementation of the method adjust\_numbers assigns the final keys for the content IDs ([%CID](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencomponents_derived_types.htm)). The output of the method is a table that links the [%PID](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencomponents_derived_types.htm) with the respective final IDs. These final IDs are provided using the [output parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_export_parameters.htm) mapped so that temporary IDs can be exchanged.

The structure of the parameter mapped of the method adjust\_numbers is different from the structure of the parameter mapped of the method FOR MODIFY .... FOR CREATE. The following two structures exist for the parameter mapped of the method adjust\_numbers:

-   %TMP
    Contains the temporary keys that are specified in the output parameter mapped of the operation FOR MODIFY ... FOR CREATE.

-   ID
    Contains the final keys.

The method adjust\_numbers does not return any failed keys or messages because the exchange of temporary IDs happens after the point at which a successful save is guaranteed for all involved business objects.

Tip

Ideally, the late numbering is implemented separately from the save. In many legacy applications, however, the final numbers are determined during the save. In this case, we recommend implementing the save logic in the method adjust\_numbers and leaving the method save empty.


### abensaver_method_save.htm

---
title: "Method SAVE"
description: |
  The method save of the local saver class(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm) is the fourth method of the saver sequence of the behavior implementation of a business object. It is called to save all data of the business object instance from the transa
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_method_save.htm"
abapFile: "abensaver_method_save.htm"
keywords: ["delete", "do", "try", "method", "class", "data", "abensaver", "save"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP RESTful Programming Model](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrestful_abap_programming.htm) →  [Behavior Implementations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_behavior_implementations.htm) →  [Saver Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm) → 

Method SAVE

The method save of the local [saver class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm) is the fourth method of the saver sequence of the behavior implementation of a business object. It is called to save all data of the business object instance from the transactional buffer to the database.

The method save does not have any output parameters and does not return any failed keys or messages.

The implementation of the method save is mandatory.

Once the data is saved to the database, the transactional buffer is deleted. This is because the same ABAP session is potentially used for more than one [LUW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenluw_glosry.htm "Glossary Entry") and any remaining changes in the transactional buffer can cause inconsistencies.

Example

In the following example, the data from the ABAP flight data reference scenario (or flight data scenario for short) is used. It represents a legacy business logic that can be used to create and edit flight bookings. The root entity Travel represents the business object for managing flight trips. The underlying data model and the behavior of the root entity Travel are described in [ABAP BDL - Example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_example.htm).

In the method save, the function module of the legacy business logic /DMO/FLIGHT\_TRAVEL\_SAVE is called.

CLASS lcl\_travel\_saver DEFINITION
    INHERITING FROM cl\_abap\_behavior\_saver.
  PROTECTED SECTION.
    METHODS save REDEFINITION.
ENDCLASS.

CLASS lcl\_travel\_saver IMPLEMENTATION.
  METHOD save.
    CALL FUNCTION '/DMO/FLIGHT\_TRAVEL\_SAVE'.
  ENDMETHOD.
ENDCLASS.

FUNCTION /dmo/flight\_travel\_save.
  /dmo/cl\_flight\_legacy=>get\_instance( )->save( ).
ENDFUNCTION.


### abensaver_method_cleanup.htm

---
title: "CLEANUP method"
description: |
  The cleanup method is called when an error has occurred during the execution of the methods finalize(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_finalize.htm) and check_before_save(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_check_before_save.h
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_method_cleanup.htm"
abapFile: "abensaver_method_cleanup.htm"
keywords: ["delete", "do", "if", "try", "method", "class", "data", "abensaver", "cleanup"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [ABAP RESTful Programming Model](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrestful_abap_programming.htm) →  [Behavior Implementations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_behavior_implementations.htm) →  [Saver Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrpm_saver_class.htm) → 

CLEANUP method

The cleanup method is called when an error has occurred during the execution of the methods [finalize](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_finalize.htm) and [check\_before\_save](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensaver_check_before_save.htm). During the cleanup process, all calculations and data modifications are discarded and the transactional buffer is deleted.

The cleanup method is also called at the end of a successful saver sequence to delete the transactional buffer. Since the same ABAP session is likely to be used for more than one [LUW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenluw_glosry.htm "Glossary Entry"), remaining changes in the transactional buffer can lead to inconsistencies.

The cleanup method does not have any parameters and does not return errors or messages.

Example

In the following example, the data from the ABAP flight data reference scenario (or flight data scenario for short) is used. It represents a legacy business logic that can be used to create and edit flight bookings. The root entity Travel represents the business object for managing flight trips. The underlying data model and the behavior of the root entity Travel are described in [ABAP BDL - Example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbdl_example.htm).

In the method cleanup, the function module of the legacy business logic /DMO/FLIGHT\_TRAVEL\_SAVE is called.

CLASS lcl\_travel\_saver DEFINITION
    INHERITING FROM cl\_abap\_behavior\_saver.
  PROTECTED SECTION.
    METHODS cleanup REDEFINITION.
ENDCLASS.

CLASS lcl\_travel\_saver IMPLEMENTATION.
  METHOD cleanup.
    CALL FUNCTION '/DMO/FLIGHT\_TRAVEL\_INITIALIZE'.
  ENDMETHOD.
ENDCLASS.

FUNCTION flight\_travel\_initialize.
  /dmo/cl\_flight\_legacy=>get\_instance( )->initialize( ).
ENDFUNCTION.


---


## ABAP Keyword Documentation / ABAP − Reference / Text Repositories / Messages / System Interfaces for Messages / System Interface IF_T100_MESSAGE for Messages

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Text Repositories / Messages / System Interfaces for Messages / System Interface IF_T100_DYN_MSG for Messages

Included pages: 5


### abenif_t100_dyn_msg.htm

---
title: "Notes"
description: |
  -   The interface IF_T100_DYN_MSG is designed specifically for raising class-based exceptions with the addition MESSAGE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) of the statement RAISE EXCEPTION(https://help.sap.com/doc/abapdocu_754_index_htm/
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm"
abapFile: "abenif_t100_dyn_msg.htm"
keywords: ["do", "if", "class", "data", "abenif", "t100", "dyn", "msg"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Text Repositories](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_texts.htm) →  [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messages.htm) →  [System Interfaces for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interfaces.htm) → 

System Interface IF\_T100\_DYN\_MSG for Messages

The interface IF\_T100\_DYN\_MSG contains the interface [IF\_T100\_MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_message.htm) as a component interface and adds the following to it:

-   The attribute MSGTY for the message type

-   The attributes MSGV1 to MSGV4 for the placeholders of the message

Like IF\_T100\_MESSAGE, the interface IF\_T100\_DYN\_MSG associates classes with messages, with the attributes for the message type and placeholders of the message being predefined.

Notes

-   The interface IF\_T100\_DYN\_MSG is designed specifically for raising class-based exceptions with the addition [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) of the statement [RAISE EXCEPTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_class.htm) or the addition [THROW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expression_result.htm) in [conditional expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expressions.htm). The properties of the message specified after MESSAGE are assigned automatically to the associated attributes in [exception classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_classes.htm) that include IF\_T100\_DYN\_MSG.

-   The addition [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) to RAISE EXCEPTION and/or THROW has a short form USING MESSAGE. This can be used for exception classes with the interface IF\_T100\_DYN\_MSG and enables determining the message from the current content of system fields sy-msg.... The short form can be used for transforming classical exceptions in class-based exceptions.

-   If the object reference variable oref points to an object that includes the system interface IF\_T100\_DYN\_MSG in the variant [MESSAGE oref](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_msg.htm) of the statement [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage.htm), the addition TYPE can be omitted and the message type from the interface attribute MSGTY of the object is used implicitly.

Example

Uses [THROW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expression_result.htm) to raise an exception of the class CX\_DEMO\_DYN\_T100, which binds the interface IF\_T100\_DYN\_MSG.

DATA col TYPE c LENGTH 1.
...
DATA(color) = COND string(
                WHEN col = 'R' THEN 'red'
                WHEN col = 'B' THEN 'blue'
                WHEN col = 'G' THEN 'green'
                ELSE THROW cx\_demo\_dyn\_t100(
                     MESSAGE e888(sabapdemos)
                       WITH 'Illegal value:' col ) ).

Executable Examples

-   [System Interface IF\_T100\_DYN\_MSG in a Regular Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg_abexa.htm)

-   [System Interface IF\_T100\_DYN\_MSG in a Local Exception Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_abexa.htm)

-   [System Interface IF\_T100\_DYN\_MSG in a Global Exception Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_global_abexa.htm)

-   [System Interface IF\_T100\_DYN\_MSG for Exception error\_message](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_error_message_abexa.htm)

Continue
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Regular Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg_abexa.htm)
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Local Exception Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_abexa.htm)
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Global Exception Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_global_abexa.htm)
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG for Exception error\_message](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_error_message_abexa.htm)


### abenif_t100_dyn_msg_abexa.htm

---
title: "This example demonstrates how a regular class is associated with a message"
description: |
  Source Code REPORT demo_if_t100_dyn_msg. CLASS msg DEFINITION. PUBLIC SECTION. INTERFACES if_t100_dyn_msg. ALIASES: msgty FOR if_t100_dyn_msg~msgty, get_text FOR if_message~get_text, get_longtext FOR if_message~get_longtext. METHODS constructor IMPORTING id TYPE symsgid no TYPE symsg
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg_abexa.htm"
abapFile: "abenif_t100_dyn_msg_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenif", "t100", "dyn", "msg", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Text Repositories](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_texts.htm) →  [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messages.htm) →  [System Interfaces for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interfaces.htm) →  [System Interface IF\_T100\_DYN\_MSG for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm) → 

IF\_T100\_DYN\_MSG in a Regular Class

This example demonstrates how a regular class is associated with a message

Source Code

REPORT demo\_if\_t100\_dyn\_msg.
CLASS msg DEFINITION.
  PUBLIC SECTION.
    INTERFACES if\_t100\_dyn\_msg.
    ALIASES: msgty FOR if\_t100\_dyn\_msg~msgty,
             get\_text FOR if\_message~get\_text,
             get\_longtext FOR if\_message~get\_longtext.
    METHODS constructor IMPORTING id TYPE symsgid
                                  no TYPE symsgno
                                  ty TYPE symsgty
                                  v1 TYPE string OPTIONAL
                                  v2 TYPE string OPTIONAL
                                  v3 TYPE string OPTIONAL
                                  v4 TYPE string OPTIONAL.
ENDCLASS.
CLASS msg IMPLEMENTATION.
  METHOD constructor.
    if\_t100\_message~t100key-msgid = id.
    if\_t100\_message~t100key-msgno = no.
    if\_t100\_dyn\_msg~msgty = ty.
    if\_t100\_message~t100key-attr1 = 'IF\_T100\_DYN\_MSG~MSGV1'.
    if\_t100\_message~t100key-attr2 = 'IF\_T100\_DYN\_MSG~MSGV2'.
    if\_t100\_message~t100key-attr3 = 'IF\_T100\_DYN\_MSG~MSGV3'.
    if\_t100\_message~t100key-attr4 = 'IF\_T100\_DYN\_MSG~MSGV4'.
    if\_t100\_dyn\_msg~msgv1 = v1.
    if\_t100\_dyn\_msg~msgv2 = v2.
    if\_t100\_dyn\_msg~msgv3 = v3.
    if\_t100\_dyn\_msg~msgv4 = v4.
  ENDMETHOD.
  METHOD if\_message~get\_text.
    result = cl\_message\_helper=>get\_text\_for\_message( me ).
  ENDMETHOD.
  METHOD if\_message~get\_longtext.
    result = cl\_message\_helper=>get\_longtext\_for\_message( me ).
  ENDMETHOD.
ENDCLASS.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    DATA(id) = \`SABAPDEMOS\`.
    DATA(no) = \`888\`.
    DATA(ty) = \`I\`.
    DATA(v1) = \`Hello,\`.
    DATA(v2) = \`I am\`.
    DATA(v3) = \`a\`.
    DATA(v4) = \`Message!\`.
    cl\_demo\_input=>new(
      )->add\_field( CHANGING field = id
      )->add\_field( CHANGING field = no
      )->add\_field( CHANGING field = ty
      )->add\_field( CHANGING field = v1
      )->add\_field( CHANGING field = v2
      )->add\_field( CHANGING field = v3
      )->add\_field( CHANGING field = v4
      )->request( ).
    IF strlen( ty ) > 1 OR 'AEISX' NS ty.
      cl\_demo\_output=>display(
        |Invalid message type: { ty }|  ).
      RETURN.
    ENDIF.
    DATA(mref) = NEW msg( id = CONV #( id )
                          no = CONV #( no )
                          ty = CONV #( ty )
                          v1 = v1
                          v2 = v2
                          v3 = v3
                          v4 = v4 ).
    cl\_demo\_output=>display(
      |{ mref->get\_text( ) }, Type: { mref->msgty }| ).
    MESSAGE mref TYPE 'I' DISPLAY LIKE mref->msgty.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

This example applies the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_message_abexa.htm) for the interface IF\_T100\_MESSAGE to the interface IF\_T100\_DYN\_MSG directly. If IF\_T100\_DYN\_MSG is used, it is no longer necessary to create separate attributes for the placeholders of the message. The attributes of the interface are used instead. Furthermore, a message type can be saved and evaluated in the interface attribute msgty. If IF\_T100\_MESSAGE is used, a separate attribute must be declared here.


### abenraise_message_abexa.htm

---
title: "This example demonstrates how a local exception class is associated with a message"
description: |
  Source Code REPORT demo_raise_message. CLASS cx_dyn_t100 DEFINITION INHERITING FROM cx_dynamic_check. PUBLIC SECTION. INTERFACES if_t100_dyn_msg. ALIASES msgty FOR if_t100_dyn_msg~msgty. ENDCLASS. CLASS msg_demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METH
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_abexa.htm"
abapFile: "abenraise_message_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenraise", "message", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Text Repositories](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_texts.htm) →  [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messages.htm) →  [System Interfaces for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interfaces.htm) →  [System Interface IF\_T100\_DYN\_MSG for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm) → 

IF\_T100\_DYN\_MSG in a Local Exception Class

This example demonstrates how a local exception class is associated with a message

Source Code

REPORT demo\_raise\_message.
CLASS cx\_dyn\_t100 DEFINITION INHERITING FROM cx\_dynamic\_check.
  PUBLIC SECTION.
    INTERFACES if\_t100\_dyn\_msg.
    ALIASES msgty FOR if\_t100\_dyn\_msg~msgty.
ENDCLASS.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS meth
      RAISING cx\_dyn\_t100.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    TRY.
        meth( ).
      CATCH cx\_dyn\_t100 INTO DATA(oref).
        cl\_demo\_output=>display(
          |Caught exception:\\n\\n| &&
          |"{ oref->get\_text( ) }", Type { oref->msgty } | ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE oref->msgty.
    ENDTRY.
  ENDMETHOD.
  METHOD meth.
    RAISE EXCEPTION TYPE cx\_dyn\_t100
          MESSAGE e888(sabapdemos) WITH 'I' 'am' 'an' 'Exception!'.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

This example applies the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interface_abexa.htm) for the interface IF\_T100\_MESSAGE to the interface IF\_T100\_DYN\_MSG directly. The local class cx\_dyn\_t100 includes the interface [IF\_T100\_DYN\_MSG](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm) and the addition [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) of the statement [RAISE EXCEPTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_class.htm) is used to raise the exception in the method meth.

Unlike when using [IF\_T100\_MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_message.htm), no separate attributes for the placeholders of the message and no implementation of the instance constructor are required in cx\_dyn\_t100. Furthermore, the message type is passed in an attribute of the exception object when IF\_T100\_DYN\_MSG is used. An alias name is used here.


### abenraise_message_global_abexa.htm

---
title: "This example demonstrates how a global exception class is associated with a message"
description: |
  Source Code REPORT demo_raise_message_global. CLASS msg_demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS meth EXCEPTIONS exception. ENDCLASS. CLASS msg_demo IMPLEMENTATION. METHOD main. TRY. meth( EXCEPTIONS exception = 4 ). IF sy-subrc <> 0. RAISE EXCEPTION T
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_global_abexa.htm"
abapFile: "abenraise_message_global_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "catch", "method", "class", "data", "abenraise", "message", "global", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Text Repositories](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_texts.htm) →  [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messages.htm) →  [System Interfaces for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interfaces.htm) →  [System Interface IF\_T100\_DYN\_MSG for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm) → 

IF\_T100\_DYN\_MSG in a Global Exception Class

This example demonstrates how a global exception class is associated with a message

Source Code

REPORT demo\_raise\_message\_global.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS meth EXCEPTIONS exception.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    TRY.
        meth( EXCEPTIONS exception = 4 ).
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE cx\_demo\_dyn\_t100
            MESSAGE ID sy-msgid
                    TYPE sy-msgty
                    NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      CATCH cx\_demo\_dyn\_t100 INTO DATA(oref).
        cl\_demo\_output=>display(
          |Caught exception:\\n\\n| &&
          |"{ oref->get\_text( ) }", Type { oref->msgty } | ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE oref->msgty.
    ENDTRY.
  ENDMETHOD.
  METHOD meth.
    MESSAGE e888(sabapdemos) WITH 'I' 'am' 'an' 'Exception!'
                             RAISING exception.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

This example demonstrates the transformation of a non-class-based exception raised in a method using [MESSAGE RAISING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_raising.htm) and, when the method is called, handled using the addition [EXCEPTIONS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_parameters.htm) to a class-based exception. This example works in the same way as the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interface_reuse_abexa.htm) for the system interface [IF\_T100\_MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_message.htm), but uses the class CX\_DEMO\_DYN\_T100, which includes the system interface [IF\_T100\_DYN\_MSG](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm).

-   In both cases, sy-msgid and sy-msgno can be used after the addition [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) of the statement [RAISE EXCEPTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_class.htm) to associate the exception object with the message.

-   sy-msgv1 to sy-msgv4 can be specified after [WITH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) and are assigned here to the interface attributes MSGV1 to MSGV4 automatically.

-   sy-msgty can also be passed further here using [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm).

Note

See also the executable [example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_glbl_shrt_abexa.htm) for using a short form of statement [RAISE EXCEPTION MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm).


### abenraise_error_message_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_raise_error_message. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. TRY. CALL FUNCTION 'DEMO_FUNCTION_MESSAGE' EXPORTING message_type  = 'A' message_place = 'in Function Module' message_event = 'START-OF-SELECTION' EXC
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_error_message_abexa.htm"
abapFile: "abenraise_error_message_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenraise", "error", "message", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Text Repositories](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_texts.htm) →  [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messages.htm) →  [System Interfaces for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interfaces.htm) →  [System Interface IF\_T100\_DYN\_MSG for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm) → 

IF\_T100\_DYN\_MSG for Exception error\_message

This example demonstrates how a caught message of a function module is forwarded.

Source Code

REPORT demo\_raise\_error\_message.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TRY.
        CALL FUNCTION 'DEMO\_FUNCTION\_MESSAGE'
          EXPORTING
            message\_type  = 'A'
            message\_place = 'in Function Module'
            message\_event = 'START-OF-SELECTION'
          EXCEPTIONS
            error\_message = 4.
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE cx\_demo\_dyn\_t100
            MESSAGE ID sy-msgid
            TYPE sy-msgty
            NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      CATCH cx\_demo\_dyn\_t100 INTO DATA(oref).
        cl\_demo\_output=>display(
          |Caught exception:\\n\\n| &&
          |"{ oref->get\_text( ) }", Type { oref->msgty } | ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE oref->msgty.
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example works in basically the same way as the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_global_abexa.htm) when transforming a classic exception raised using MESSAGE RAISING to a class-based exception. Here, however, a message of type A caught using [error\_message](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_parameter.htm) is transformed.

Note

See also the executable [example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_error_message_shrt_abexa.htm) for using a short form of statement [RAISE EXCEPTION MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm).


---


## ABAP Keyword Documentation / ABAP − Reference / Text Repositories / Messages / System Interfaces for Messages / System Interface IF_T100_DYN_MSG for Messages

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Text Repositories / Messages / System Interfaces for Messages / System Interface IF_T100_DYN_MSG for Messages

Included pages: 5


### abenif_t100_dyn_msg.htm

---
title: "Notes"
description: |
  -   The interface IF_T100_DYN_MSG is designed specifically for raising class-based exceptions with the addition MESSAGE(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) of the statement RAISE EXCEPTION(https://help.sap.com/doc/abapdocu_754_index_htm/
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm"
abapFile: "abenif_t100_dyn_msg.htm"
keywords: ["do", "if", "class", "data", "abenif", "t100", "dyn", "msg"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Text Repositories](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_texts.htm) →  [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messages.htm) →  [System Interfaces for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interfaces.htm) → 

System Interface IF\_T100\_DYN\_MSG for Messages

The interface IF\_T100\_DYN\_MSG contains the interface [IF\_T100\_MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_message.htm) as a component interface and adds the following to it:

-   The attribute MSGTY for the message type

-   The attributes MSGV1 to MSGV4 for the placeholders of the message

Like IF\_T100\_MESSAGE, the interface IF\_T100\_DYN\_MSG associates classes with messages, with the attributes for the message type and placeholders of the message being predefined.

Notes

-   The interface IF\_T100\_DYN\_MSG is designed specifically for raising class-based exceptions with the addition [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) of the statement [RAISE EXCEPTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_class.htm) or the addition [THROW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expression_result.htm) in [conditional expressions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expressions.htm). The properties of the message specified after MESSAGE are assigned automatically to the associated attributes in [exception classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexceptions_classes.htm) that include IF\_T100\_DYN\_MSG.

-   The addition [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) to RAISE EXCEPTION and/or THROW has a short form USING MESSAGE. This can be used for exception classes with the interface IF\_T100\_DYN\_MSG and enables determining the message from the current content of system fields sy-msg.... The short form can be used for transforming classical exceptions in class-based exceptions.

-   If the object reference variable oref points to an object that includes the system interface IF\_T100\_DYN\_MSG in the variant [MESSAGE oref](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_msg.htm) of the statement [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage.htm), the addition TYPE can be omitted and the message type from the interface attribute MSGTY of the object is used implicitly.

Example

Uses [THROW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenconditional_expression_result.htm) to raise an exception of the class CX\_DEMO\_DYN\_T100, which binds the interface IF\_T100\_DYN\_MSG.

DATA col TYPE c LENGTH 1.
...
DATA(color) = COND string(
                WHEN col = 'R' THEN 'red'
                WHEN col = 'B' THEN 'blue'
                WHEN col = 'G' THEN 'green'
                ELSE THROW cx\_demo\_dyn\_t100(
                     MESSAGE e888(sabapdemos)
                       WITH 'Illegal value:' col ) ).

Executable Examples

-   [System Interface IF\_T100\_DYN\_MSG in a Regular Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg_abexa.htm)

-   [System Interface IF\_T100\_DYN\_MSG in a Local Exception Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_abexa.htm)

-   [System Interface IF\_T100\_DYN\_MSG in a Global Exception Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_global_abexa.htm)

-   [System Interface IF\_T100\_DYN\_MSG for Exception error\_message](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_error_message_abexa.htm)

Continue
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Regular Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg_abexa.htm)
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Local Exception Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_abexa.htm)
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG in a Global Exception Class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_global_abexa.htm)
![Example](exa.gif "Example") [IF\_T100\_DYN\_MSG for Exception error\_message](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_error_message_abexa.htm)


### abenif_t100_dyn_msg_abexa.htm

---
title: "This example demonstrates how a regular class is associated with a message"
description: |
  Source Code REPORT demo_if_t100_dyn_msg. CLASS msg DEFINITION. PUBLIC SECTION. INTERFACES if_t100_dyn_msg. ALIASES: msgty FOR if_t100_dyn_msg~msgty, get_text FOR if_message~get_text, get_longtext FOR if_message~get_longtext. METHODS constructor IMPORTING id TYPE symsgid no TYPE symsg
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg_abexa.htm"
abapFile: "abenif_t100_dyn_msg_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenif", "t100", "dyn", "msg", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Text Repositories](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_texts.htm) →  [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messages.htm) →  [System Interfaces for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interfaces.htm) →  [System Interface IF\_T100\_DYN\_MSG for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm) → 

IF\_T100\_DYN\_MSG in a Regular Class

This example demonstrates how a regular class is associated with a message

Source Code

REPORT demo\_if\_t100\_dyn\_msg.
CLASS msg DEFINITION.
  PUBLIC SECTION.
    INTERFACES if\_t100\_dyn\_msg.
    ALIASES: msgty FOR if\_t100\_dyn\_msg~msgty,
             get\_text FOR if\_message~get\_text,
             get\_longtext FOR if\_message~get\_longtext.
    METHODS constructor IMPORTING id TYPE symsgid
                                  no TYPE symsgno
                                  ty TYPE symsgty
                                  v1 TYPE string OPTIONAL
                                  v2 TYPE string OPTIONAL
                                  v3 TYPE string OPTIONAL
                                  v4 TYPE string OPTIONAL.
ENDCLASS.
CLASS msg IMPLEMENTATION.
  METHOD constructor.
    if\_t100\_message~t100key-msgid = id.
    if\_t100\_message~t100key-msgno = no.
    if\_t100\_dyn\_msg~msgty = ty.
    if\_t100\_message~t100key-attr1 = 'IF\_T100\_DYN\_MSG~MSGV1'.
    if\_t100\_message~t100key-attr2 = 'IF\_T100\_DYN\_MSG~MSGV2'.
    if\_t100\_message~t100key-attr3 = 'IF\_T100\_DYN\_MSG~MSGV3'.
    if\_t100\_message~t100key-attr4 = 'IF\_T100\_DYN\_MSG~MSGV4'.
    if\_t100\_dyn\_msg~msgv1 = v1.
    if\_t100\_dyn\_msg~msgv2 = v2.
    if\_t100\_dyn\_msg~msgv3 = v3.
    if\_t100\_dyn\_msg~msgv4 = v4.
  ENDMETHOD.
  METHOD if\_message~get\_text.
    result = cl\_message\_helper=>get\_text\_for\_message( me ).
  ENDMETHOD.
  METHOD if\_message~get\_longtext.
    result = cl\_message\_helper=>get\_longtext\_for\_message( me ).
  ENDMETHOD.
ENDCLASS.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    DATA(id) = \`SABAPDEMOS\`.
    DATA(no) = \`888\`.
    DATA(ty) = \`I\`.
    DATA(v1) = \`Hello,\`.
    DATA(v2) = \`I am\`.
    DATA(v3) = \`a\`.
    DATA(v4) = \`Message!\`.
    cl\_demo\_input=>new(
      )->add\_field( CHANGING field = id
      )->add\_field( CHANGING field = no
      )->add\_field( CHANGING field = ty
      )->add\_field( CHANGING field = v1
      )->add\_field( CHANGING field = v2
      )->add\_field( CHANGING field = v3
      )->add\_field( CHANGING field = v4
      )->request( ).
    IF strlen( ty ) > 1 OR 'AEISX' NS ty.
      cl\_demo\_output=>display(
        |Invalid message type: { ty }|  ).
      RETURN.
    ENDIF.
    DATA(mref) = NEW msg( id = CONV #( id )
                          no = CONV #( no )
                          ty = CONV #( ty )
                          v1 = v1
                          v2 = v2
                          v3 = v3
                          v4 = v4 ).
    cl\_demo\_output=>display(
      |{ mref->get\_text( ) }, Type: { mref->msgty }| ).
    MESSAGE mref TYPE 'I' DISPLAY LIKE mref->msgty.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

This example applies the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_message_abexa.htm) for the interface IF\_T100\_MESSAGE to the interface IF\_T100\_DYN\_MSG directly. If IF\_T100\_DYN\_MSG is used, it is no longer necessary to create separate attributes for the placeholders of the message. The attributes of the interface are used instead. Furthermore, a message type can be saved and evaluated in the interface attribute msgty. If IF\_T100\_MESSAGE is used, a separate attribute must be declared here.


### abenraise_message_abexa.htm

---
title: "This example demonstrates how a local exception class is associated with a message"
description: |
  Source Code REPORT demo_raise_message. CLASS cx_dyn_t100 DEFINITION INHERITING FROM cx_dynamic_check. PUBLIC SECTION. INTERFACES if_t100_dyn_msg. ALIASES msgty FOR if_t100_dyn_msg~msgty. ENDCLASS. CLASS msg_demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METH
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_abexa.htm"
abapFile: "abenraise_message_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenraise", "message", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Text Repositories](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_texts.htm) →  [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messages.htm) →  [System Interfaces for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interfaces.htm) →  [System Interface IF\_T100\_DYN\_MSG for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm) → 

IF\_T100\_DYN\_MSG in a Local Exception Class

This example demonstrates how a local exception class is associated with a message

Source Code

REPORT demo\_raise\_message.
CLASS cx\_dyn\_t100 DEFINITION INHERITING FROM cx\_dynamic\_check.
  PUBLIC SECTION.
    INTERFACES if\_t100\_dyn\_msg.
    ALIASES msgty FOR if\_t100\_dyn\_msg~msgty.
ENDCLASS.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS meth
      RAISING cx\_dyn\_t100.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    TRY.
        meth( ).
      CATCH cx\_dyn\_t100 INTO DATA(oref).
        cl\_demo\_output=>display(
          |Caught exception:\\n\\n| &&
          |"{ oref->get\_text( ) }", Type { oref->msgty } | ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE oref->msgty.
    ENDTRY.
  ENDMETHOD.
  METHOD meth.
    RAISE EXCEPTION TYPE cx\_dyn\_t100
          MESSAGE e888(sabapdemos) WITH 'I' 'am' 'an' 'Exception!'.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

This example applies the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interface_abexa.htm) for the interface IF\_T100\_MESSAGE to the interface IF\_T100\_DYN\_MSG directly. The local class cx\_dyn\_t100 includes the interface [IF\_T100\_DYN\_MSG](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm) and the addition [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) of the statement [RAISE EXCEPTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_class.htm) is used to raise the exception in the method meth.

Unlike when using [IF\_T100\_MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_message.htm), no separate attributes for the placeholders of the message and no implementation of the instance constructor are required in cx\_dyn\_t100. Furthermore, the message type is passed in an attribute of the exception object when IF\_T100\_DYN\_MSG is used. An alias name is used here.


### abenraise_message_global_abexa.htm

---
title: "This example demonstrates how a global exception class is associated with a message"
description: |
  Source Code REPORT demo_raise_message_global. CLASS msg_demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS meth EXCEPTIONS exception. ENDCLASS. CLASS msg_demo IMPLEMENTATION. METHOD main. TRY. meth( EXCEPTIONS exception = 4 ). IF sy-subrc <> 0. RAISE EXCEPTION T
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_global_abexa.htm"
abapFile: "abenraise_message_global_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "catch", "method", "class", "data", "abenraise", "message", "global", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Text Repositories](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_texts.htm) →  [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messages.htm) →  [System Interfaces for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interfaces.htm) →  [System Interface IF\_T100\_DYN\_MSG for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm) → 

IF\_T100\_DYN\_MSG in a Global Exception Class

This example demonstrates how a global exception class is associated with a message

Source Code

REPORT demo\_raise\_message\_global.
CLASS msg\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS meth EXCEPTIONS exception.
ENDCLASS.
CLASS msg\_demo IMPLEMENTATION.
  METHOD main.
    TRY.
        meth( EXCEPTIONS exception = 4 ).
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE cx\_demo\_dyn\_t100
            MESSAGE ID sy-msgid
                    TYPE sy-msgty
                    NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      CATCH cx\_demo\_dyn\_t100 INTO DATA(oref).
        cl\_demo\_output=>display(
          |Caught exception:\\n\\n| &&
          |"{ oref->get\_text( ) }", Type { oref->msgty } | ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE oref->msgty.
    ENDTRY.
  ENDMETHOD.
  METHOD meth.
    MESSAGE e888(sabapdemos) WITH 'I' 'am' 'an' 'Exception!'
                             RAISING exception.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  msg\_demo=>main( ).

Description

This example demonstrates the transformation of a non-class-based exception raised in a method using [MESSAGE RAISING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage_raising.htm) and, when the method is called, handled using the addition [EXCEPTIONS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_parameters.htm) to a class-based exception. This example works in the same way as the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interface_reuse_abexa.htm) for the system interface [IF\_T100\_MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_message.htm), but uses the class CX\_DEMO\_DYN\_T100, which includes the system interface [IF\_T100\_DYN\_MSG](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm).

-   In both cases, sy-msgid and sy-msgno can be used after the addition [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) of the statement [RAISE EXCEPTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_class.htm) to associate the exception object with the message.

-   sy-msgv1 to sy-msgv4 can be specified after [WITH](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm) and are assigned here to the interface attributes MSGV1 to MSGV4 automatically.

-   sy-msgty can also be passed further here using [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm).

Note

See also the executable [example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_glbl_shrt_abexa.htm) for using a short form of statement [RAISE EXCEPTION MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm).


### abenraise_error_message_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_raise_error_message. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. TRY. CALL FUNCTION 'DEMO_FUNCTION_MESSAGE' EXPORTING message_type  = 'A' message_place = 'in Function Module' message_event = 'START-OF-SELECTION' EXC
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_error_message_abexa.htm"
abapFile: "abenraise_error_message_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenraise", "error", "message", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Text Repositories](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_texts.htm) →  [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messages.htm) →  [System Interfaces for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_interfaces.htm) →  [System Interface IF\_T100\_DYN\_MSG for Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenif_t100_dyn_msg.htm) → 

IF\_T100\_DYN\_MSG for Exception error\_message

This example demonstrates how a caught message of a function module is forwarded.

Source Code

REPORT demo\_raise\_error\_message.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TRY.
        CALL FUNCTION 'DEMO\_FUNCTION\_MESSAGE'
          EXPORTING
            message\_type  = 'A'
            message\_place = 'in Function Module'
            message\_event = 'START-OF-SELECTION'
          EXCEPTIONS
            error\_message = 4.
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE cx\_demo\_dyn\_t100
            MESSAGE ID sy-msgid
            TYPE sy-msgty
            NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      CATCH cx\_demo\_dyn\_t100 INTO DATA(oref).
        cl\_demo\_output=>display(
          |Caught exception:\\n\\n| &&
          |"{ oref->get\_text( ) }", Type { oref->msgty } | ).
        MESSAGE oref TYPE 'I' DISPLAY LIKE oref->msgty.
    ENDTRY.  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example works in basically the same way as the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_message_global_abexa.htm) when transforming a classic exception raised using MESSAGE RAISING to a class-based exception. Here, however, a message of type A caught using [error\_message](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_parameter.htm) is transformed.

Note

See also the executable [example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenraise_error_message_shrt_abexa.htm) for using a short form of statement [RAISE EXCEPTION MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapraise_exception_message.htm).


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / RFC Overview

**Files**: 13 | **Difficulty**: beginner

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

Included pages: 6


### abenrfc_abexas.htm

---
title: "Examples for Remote Function Call"
description: |
  !Example(exa.gif 'Example') Parameter Passing in sRFC and aRFC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm) !Example(exa.gif 'Example') Exception Handling in RFC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.ht
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm"
abapFile: "abenrfc_abexas.htm"
keywords: ["do", "if", "data", "exception-handling", "abenrfc", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) → 

Examples for Remote Function Call

Continue
![Example](exa.gif "Example") [Parameter Passing in sRFC and aRFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm)
![Example](exa.gif "Example") [Exception Handling in RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.htm)
![Example](exa.gif "Example") [Parallel Asynchronous RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenparallel_rfc_abexa.htm)
![Example](exa.gif "Example") [Dynamic RFC Destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_dynamic_dest_abexa.htm)
![Example](exa.gif "Example") [Implicit Logon Data in RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_logon_data_abexa.htm)


### abenrfc_parameters_abexa.htm

---
title: "Parameter Passing in sRFC and aRFC"
description: |
  This example demonstrates parameter passing in two RFC variants. Source Code REPORT demo_rfc_parameters. CLASS demo_rfc DEFINITION. PUBLIC SECTION. CLASS-METHODS: main, callback IMPORTING p_task TYPE clike. PRIVATE SECTION. CLASS-DATA: val_in     TYPE string, val_out    TYPE string, val_in_o
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm"
abapFile: "abenrfc_parameters_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenrfc", "parameters", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Parameter Passing in sRFC and aRFC

This example demonstrates parameter passing in two RFC variants.

Source Code

REPORT demo\_rfc\_parameters.
CLASS demo\_rfc DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main,
      callback IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    CLASS-DATA:
      val\_in     TYPE string,
      val\_out    TYPE string,
      val\_in\_out TYPE string,
      msg        TYPE c LENGTH 80,
      out        TYPE REF TO if\_demo\_output.
ENDCLASS.
CLASS demo\_rfc IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    "Synchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    out->next\_section( 'sRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    "Asynchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      STARTING NEW TASK 'DEMO'
      CALLING demo\_rfc=>callback ON END OF TASK
      EXPORTING
        p\_in                  = val\_in
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling aRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    WAIT FOR ASYNCHRONOUS TASKS UNTIL val\_out IS NOT INITIAL
                                UP TO 10 SECONDS.
    out->next\_section( 'aRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    out->display( ).
  ENDMETHOD.
  METHOD callback.
    val\_out    = \`\`.
    val\_in\_out = \`\`.
    RECEIVE RESULTS FROM FUNCTION 'DEMO\_RFM\_PARAMETERS'
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( '|Error when receiving aRFC.\\n{ msg }|' ).
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_rfc=>main( ).

Description

The function module DEMO\_RFM\_PARAMETERS is called using [synchronous](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_destination.htm) and [asynchronous](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_starting.htm) RFC.

-   In synchronous calls, parameters are passed and applied directly in the statement CALL FUNCTION.

-   In asynchronous calls, parameters can only be passed in the statement CALL FUNCTION. Parameters are applied using the statement [RECEIVE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapreceive.htm) in a callback routine. The statement [WAIT FOR ASYNCHRONOUS TASKS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_until.htm) is used to wait for this routine.


### abenrfc_exceptions_abexa.htm

---
title: "Exception Handling in RFC"
description: |
  This example demonstrates exception handling in RFC. Source Code REPORT demo_rfc_exceptions. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA msg TYPE c LENGTH 255. DATA(out) = cl_demo_output=>new( ). 'Classical exception handling
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.htm"
abapFile: "abenrfc_exceptions_abexa.htm"
keywords: ["select", "do", "if", "case", "method", "class", "data", "exception-handling", "abenrfc", "exceptions", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Exception Handling in RFC

This example demonstrates exception handling in RFC.

Source Code

REPORT demo\_rfc\_exceptions.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA msg TYPE c LENGTH 255.
    DATA(out) = cl\_demo\_output=>new( ).
    "Classical exception handling
    CALL FUNCTION 'DEMO\_RFM\_CLASSIC\_EXCEPTION'
      DESTINATION 'NONE'
      EXCEPTIONS
        system\_failure        = 1  MESSAGE msg
        communication\_failure = 2  MESSAGE msg
        OTHERS                = 3.
    CASE sy-subrc.
      WHEN 1.
        out->write( \`EXCEPTION SYSTEM\_FAILURE \` && msg ).
      WHEN 2.
        out->write( \`EXCEPTION COMMUNICATION\_FAILURE \` && msg ).
      WHEN 3.
        out->write( \`EXCEPTION OTHERS\` ).
    ENDCASE.
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The DEMO\_RFM\_CLASSIC\_EXCEPTION function module triggers the non-class-based exception CLASSIC\_EXCEPTION.

When DEMO\_RFM\_CLASSIC\_EXCEPTION is called, EXCEPTIONS is specified and values for sy-subrc are assigned to the possible classic exceptions. If none of the predefined RFC interface exceptions are raised, sy-subrc is set to 3.


### abenparallel_rfc_abexa.htm

---
title: "Parallel Asynchronous RFC"
description: |
  This example demonstrates parallel asynchronous RFC processing. Source Code REPORT demo_parallel_rfc. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS: main, callbback_meth IMPORTING p_task TYPE clike. PRIVATE SECTION. TYPES: BEGIN OF task_type, name TYPE string, dest TYPE string, END OF ta
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenparallel_rfc_abexa.htm"
abapFile: "abenparallel_rfc_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "types", "internal-table", "abenparallel", "rfc", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Parallel Asynchronous RFC

This example demonstrates parallel asynchronous RFC processing.

Source Code

REPORT demo\_parallel\_rfc.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: main,
                   callbback\_meth IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    TYPES: BEGIN OF task\_type,
           name TYPE string,
           dest TYPE string,
         END OF task\_type.
    CLASS-DATA: task\_list TYPE STANDARD TABLE OF task\_type,
                task\_wa   TYPE task\_type,
                rcv\_jobs  TYPE i,
                mess      TYPE c LENGTH 80.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: snd\_jobs  TYPE i,
          exc\_flag  TYPE i,
          indx      TYPE c LENGTH 4,
          name      TYPE c LENGTH 8.
    DATA(out) = cl\_demo\_output=>new( ).
    DO 10 TIMES.
      indx = sy-index.
      name = 'Task' && indx.
      CALL FUNCTION 'RFC\_SYSTEM\_INFO'
        STARTING NEW TASK name
        DESTINATION IN GROUP DEFAULT
        CALLING callbback\_meth ON END OF TASK
        EXCEPTIONS
          system\_failure        = 1 MESSAGE mess
          communication\_failure = 2 MESSAGE mess
          resource\_failure      = 3.
      CASE sy-subrc.
        WHEN 0.
          snd\_jobs += 1.
        WHEN 1 OR 2.
          out->write\_text( mess ).
        WHEN 3.
          IF snd\_jobs >= 1 AND
             exc\_flag = 0.
             exc\_flag = 1.
            WAIT UNTIL rcv\_jobs >= snd\_jobs
                 UP TO 5 SECONDS.
          ENDIF.
          IF sy-subrc = 0.
            exc\_flag = 0.
          ELSE.
            out->display( 'Resource failure' ).
          ENDIF.
        WHEN OTHERS.
          out->display( 'Other error' ).
      ENDCASE.
    ENDDO.
    WAIT UNTIL rcv\_jobs >= snd\_jobs.
    out->display( task\_list ).  ENDMETHOD.
  METHOD callbback\_meth.
    DATA info TYPE rfcsi.
    task\_wa-name = p\_task.
    rcv\_jobs += 1.
    RECEIVE RESULTS FROM FUNCTION 'RFC\_SYSTEM\_INFO'
      IMPORTING
        rfcsi\_export = info
      EXCEPTIONS
        system\_failure        = 1 MESSAGE mess
        communication\_failure = 2 MESSAGE mess.
    IF sy-subrc = 0.
      task\_wa-dest = info-rfcdest.
    ELSE.
      task\_wa-dest = mess.
    ENDIF.
    APPEND task\_wa TO task\_list.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Parallel asynchronous processing of the function module RFC\_SYSTEM\_INFO using [asynchronous remote function calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasynchronous_rfc_glosry.htm "Glossary Entry"). Ten calls with different task IDs name are made, which each run in a separate [work process](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwork_process_glosry.htm "Glossary Entry"). The callback routine callbback\_meth counts the completed function modules and receives information about the target system.

The addition GROUP DEFAULT is used to distribute the execution across all [AS Instances](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry")s of the current AS ABAP. If no more free work processes are available after at least one successful call, the execution of the program is stopped until all function modules started up to that point have been completed. This stoppage is limited to a maximum of 5 seconds.

After all function modules have been started, the system waits until all callback routines have been executed. After that, the internal table task\_list filled there is produced. The output shows the order in which the individual tasks were completed and on which AS Instance.


### abenrfc_dynamic_dest_abexa.htm

---
title: "Dynamic RFC Destination"
description: |
  This example demonstrates how dynamic destinations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm) are created. Source Code REPORT demo_rfc_dynamic_dest. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS: main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD m
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_dynamic_dest_abexa.htm"
abapFile: "abenrfc_dynamic_dest_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenrfc", "dynamic", "dest", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Dynamic RFC Destination

This example demonstrates how [dynamic destinations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm) are created.

Source Code

REPORT demo\_rfc\_dynamic\_dest.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      val\_in     TYPE string VALUE \`val\_in\`,
      val\_in\_out TYPE string VALUE \`val\_in\_out\`,
      val\_out    TYPE string,
      msg        TYPE c LENGTH 80.
    IF sy-uname IS INITIAL.
      cl\_demo\_output=>display(
        \`Example not possible for anonymous user\` ).
      RETURN.
    ENDIF.
    DATA(in) = cl\_demo\_input=>new( ).
    DATA(client) = sy-mandt.
    in->add\_field( CHANGING field = client ).
    DATA(uname) = sy-uname.
    in->add\_field( CHANGING field = uname ).
    DATA(langu) = sy-langu.
    in->add\_field( CHANGING field = langu ).
    DATA(sysid) = sy-sysid.
    in->add\_field( CHANGING field = sysid ).
    DATA(host) = CONV rfchost( sy-host ).
    in->add\_field( CHANGING field = host ).
    DATA(group) = CONV rfcload( 'PUBLIC' ).
    in->add\_field( CHANGING field = group ).
    in->request( ).
    DATA(dest) = cl\_dynamic\_destination=>create\_rfc\_destination(
                   logon\_client   = client
                   logon\_user     = uname
                   logon\_language = langu
                   sid            = sysid
                   server         = host
                   group          = group ).
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION dest
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    cl\_demo\_output=>display( |{ val\_out }\\n{ val\_in\_out }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The method CREATE\_RFC\_DESTINATION of class CL\_DYNAMIC\_DESTINATION is used to create a [dynamic destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm). Input values, whose default values are determined from system fields for the current AS ABAP, are passed as parameters. A remote-enabled function module is called using the dynamic destination. The call is only successful if the destination is created correctly.


### abenrfc_logon_data_abexa.htm

---
title: "Implicit Logon Data in RFC"
description: |
  This example demonstrates how the logon data of an RFC session is set implicitly. Source Code REPORT demo_rfc_implicit_logon_data. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: BEGIN OF logon_data, uname       TYPE sy-uname, m
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_logon_data_abexa.htm"
abapFile: "abenrfc_logon_data_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "abenrfc", "logon", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Implicit Logon Data in RFC

This example demonstrates how the logon data of an RFC session is set implicitly.

Source Code

REPORT demo\_rfc\_implicit\_logon\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      BEGIN OF logon\_data,
        uname       TYPE sy-uname,
        mandt       TYPE sy-mandt,
        logon\_langu TYPE sy-langu,
        langu       TYPE sy-langu,
      END OF logon\_data.
    IF cl\_abap\_syst=>get\_logon\_language( ) <> 'E'.
      SET LOCALE LANGUAGE 'E'.
    ELSE.
      SET LOCALE LANGUAGE 'D'.
    ENDIF.
    logon\_data = VALUE #(
        uname       = sy-uname
        mandt       = sy-mandt
        logon\_langu = cl\_abap\_syst=>get\_logon\_language( )
        langu       = cl\_abap\_syst=>get\_language( ) ).
    ASSERT logon\_data-langu = sy-langu.
    DATA(out) = cl\_demo\_output=>new(
      )->next\_section( 'Parameters of Caller'
      )->write( logon\_data ).
    CALL FUNCTION 'DEMO\_RFM\_LOGON\_DATA' DESTINATION 'NONE'
      IMPORTING
        uname       = logon\_data-uname
        mandt       = logon\_data-mandt
        logon\_langu = logon\_data-logon\_langu
        langu       = logon\_data-langu.
    out->next\_section( 'Parameters of Callee'
      )->write( logon\_data )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

A remote-enabled function module DEMO\_RFM\_LOGON\_DATA is called with the destination "NONE" using the RFC interface. The logon data user name, client, and logon language of the corresponding [RFC session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_context.htm) are provided implicitly. To demonstrate that the [logon language](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogon_language_glosry.htm "Glossary Entry") of the RFC session is set by the language of the [text environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_environment_glosry.htm "Glossary Entry") of the caller, this is set before the call with the statement [SET LOCALE LANGUAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_locale.htm) to a language different from the logon language of the caller. In the called RFM the language of the text environment of the RFC session is also changed and is then different to the logon language there as well.

If the function module DEMO\_RFM\_LOGON\_DATA is called remotely again, the RFC session is reused with the existing logon data. Changing the language of the text environment again in the caller would have no effect.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / CALL FUNCTION - RFC / CALL FUNCTION - DESTINATION

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

Included pages: 6


### abenrfc_abexas.htm

---
title: "Examples for Remote Function Call"
description: |
  !Example(exa.gif 'Example') Parameter Passing in sRFC and aRFC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm) !Example(exa.gif 'Example') Exception Handling in RFC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.ht
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm"
abapFile: "abenrfc_abexas.htm"
keywords: ["do", "if", "data", "exception-handling", "abenrfc", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) → 

Examples for Remote Function Call

Continue
![Example](exa.gif "Example") [Parameter Passing in sRFC and aRFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm)
![Example](exa.gif "Example") [Exception Handling in RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.htm)
![Example](exa.gif "Example") [Parallel Asynchronous RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenparallel_rfc_abexa.htm)
![Example](exa.gif "Example") [Dynamic RFC Destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_dynamic_dest_abexa.htm)
![Example](exa.gif "Example") [Implicit Logon Data in RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_logon_data_abexa.htm)


### abenrfc_parameters_abexa.htm

---
title: "Parameter Passing in sRFC and aRFC"
description: |
  This example demonstrates parameter passing in two RFC variants. Source Code REPORT demo_rfc_parameters. CLASS demo_rfc DEFINITION. PUBLIC SECTION. CLASS-METHODS: main, callback IMPORTING p_task TYPE clike. PRIVATE SECTION. CLASS-DATA: val_in     TYPE string, val_out    TYPE string, val_in_o
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm"
abapFile: "abenrfc_parameters_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenrfc", "parameters", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Parameter Passing in sRFC and aRFC

This example demonstrates parameter passing in two RFC variants.

Source Code

REPORT demo\_rfc\_parameters.
CLASS demo\_rfc DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main,
      callback IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    CLASS-DATA:
      val\_in     TYPE string,
      val\_out    TYPE string,
      val\_in\_out TYPE string,
      msg        TYPE c LENGTH 80,
      out        TYPE REF TO if\_demo\_output.
ENDCLASS.
CLASS demo\_rfc IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    "Synchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    out->next\_section( 'sRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    "Asynchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      STARTING NEW TASK 'DEMO'
      CALLING demo\_rfc=>callback ON END OF TASK
      EXPORTING
        p\_in                  = val\_in
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling aRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    WAIT FOR ASYNCHRONOUS TASKS UNTIL val\_out IS NOT INITIAL
                                UP TO 10 SECONDS.
    out->next\_section( 'aRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    out->display( ).
  ENDMETHOD.
  METHOD callback.
    val\_out    = \`\`.
    val\_in\_out = \`\`.
    RECEIVE RESULTS FROM FUNCTION 'DEMO\_RFM\_PARAMETERS'
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( '|Error when receiving aRFC.\\n{ msg }|' ).
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_rfc=>main( ).

Description

The function module DEMO\_RFM\_PARAMETERS is called using [synchronous](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_destination.htm) and [asynchronous](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_starting.htm) RFC.

-   In synchronous calls, parameters are passed and applied directly in the statement CALL FUNCTION.

-   In asynchronous calls, parameters can only be passed in the statement CALL FUNCTION. Parameters are applied using the statement [RECEIVE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapreceive.htm) in a callback routine. The statement [WAIT FOR ASYNCHRONOUS TASKS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_until.htm) is used to wait for this routine.


### abenrfc_exceptions_abexa.htm

---
title: "Exception Handling in RFC"
description: |
  This example demonstrates exception handling in RFC. Source Code REPORT demo_rfc_exceptions. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA msg TYPE c LENGTH 255. DATA(out) = cl_demo_output=>new( ). 'Classical exception handling
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.htm"
abapFile: "abenrfc_exceptions_abexa.htm"
keywords: ["select", "do", "if", "case", "method", "class", "data", "exception-handling", "abenrfc", "exceptions", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Exception Handling in RFC

This example demonstrates exception handling in RFC.

Source Code

REPORT demo\_rfc\_exceptions.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA msg TYPE c LENGTH 255.
    DATA(out) = cl\_demo\_output=>new( ).
    "Classical exception handling
    CALL FUNCTION 'DEMO\_RFM\_CLASSIC\_EXCEPTION'
      DESTINATION 'NONE'
      EXCEPTIONS
        system\_failure        = 1  MESSAGE msg
        communication\_failure = 2  MESSAGE msg
        OTHERS                = 3.
    CASE sy-subrc.
      WHEN 1.
        out->write( \`EXCEPTION SYSTEM\_FAILURE \` && msg ).
      WHEN 2.
        out->write( \`EXCEPTION COMMUNICATION\_FAILURE \` && msg ).
      WHEN 3.
        out->write( \`EXCEPTION OTHERS\` ).
    ENDCASE.
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The DEMO\_RFM\_CLASSIC\_EXCEPTION function module triggers the non-class-based exception CLASSIC\_EXCEPTION.

When DEMO\_RFM\_CLASSIC\_EXCEPTION is called, EXCEPTIONS is specified and values for sy-subrc are assigned to the possible classic exceptions. If none of the predefined RFC interface exceptions are raised, sy-subrc is set to 3.


### abenparallel_rfc_abexa.htm

---
title: "Parallel Asynchronous RFC"
description: |
  This example demonstrates parallel asynchronous RFC processing. Source Code REPORT demo_parallel_rfc. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS: main, callbback_meth IMPORTING p_task TYPE clike. PRIVATE SECTION. TYPES: BEGIN OF task_type, name TYPE string, dest TYPE string, END OF ta
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenparallel_rfc_abexa.htm"
abapFile: "abenparallel_rfc_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "types", "internal-table", "abenparallel", "rfc", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Parallel Asynchronous RFC

This example demonstrates parallel asynchronous RFC processing.

Source Code

REPORT demo\_parallel\_rfc.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: main,
                   callbback\_meth IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    TYPES: BEGIN OF task\_type,
           name TYPE string,
           dest TYPE string,
         END OF task\_type.
    CLASS-DATA: task\_list TYPE STANDARD TABLE OF task\_type,
                task\_wa   TYPE task\_type,
                rcv\_jobs  TYPE i,
                mess      TYPE c LENGTH 80.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: snd\_jobs  TYPE i,
          exc\_flag  TYPE i,
          indx      TYPE c LENGTH 4,
          name      TYPE c LENGTH 8.
    DATA(out) = cl\_demo\_output=>new( ).
    DO 10 TIMES.
      indx = sy-index.
      name = 'Task' && indx.
      CALL FUNCTION 'RFC\_SYSTEM\_INFO'
        STARTING NEW TASK name
        DESTINATION IN GROUP DEFAULT
        CALLING callbback\_meth ON END OF TASK
        EXCEPTIONS
          system\_failure        = 1 MESSAGE mess
          communication\_failure = 2 MESSAGE mess
          resource\_failure      = 3.
      CASE sy-subrc.
        WHEN 0.
          snd\_jobs += 1.
        WHEN 1 OR 2.
          out->write\_text( mess ).
        WHEN 3.
          IF snd\_jobs >= 1 AND
             exc\_flag = 0.
             exc\_flag = 1.
            WAIT UNTIL rcv\_jobs >= snd\_jobs
                 UP TO 5 SECONDS.
          ENDIF.
          IF sy-subrc = 0.
            exc\_flag = 0.
          ELSE.
            out->display( 'Resource failure' ).
          ENDIF.
        WHEN OTHERS.
          out->display( 'Other error' ).
      ENDCASE.
    ENDDO.
    WAIT UNTIL rcv\_jobs >= snd\_jobs.
    out->display( task\_list ).  ENDMETHOD.
  METHOD callbback\_meth.
    DATA info TYPE rfcsi.
    task\_wa-name = p\_task.
    rcv\_jobs += 1.
    RECEIVE RESULTS FROM FUNCTION 'RFC\_SYSTEM\_INFO'
      IMPORTING
        rfcsi\_export = info
      EXCEPTIONS
        system\_failure        = 1 MESSAGE mess
        communication\_failure = 2 MESSAGE mess.
    IF sy-subrc = 0.
      task\_wa-dest = info-rfcdest.
    ELSE.
      task\_wa-dest = mess.
    ENDIF.
    APPEND task\_wa TO task\_list.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Parallel asynchronous processing of the function module RFC\_SYSTEM\_INFO using [asynchronous remote function calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasynchronous_rfc_glosry.htm "Glossary Entry"). Ten calls with different task IDs name are made, which each run in a separate [work process](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwork_process_glosry.htm "Glossary Entry"). The callback routine callbback\_meth counts the completed function modules and receives information about the target system.

The addition GROUP DEFAULT is used to distribute the execution across all [AS Instances](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry")s of the current AS ABAP. If no more free work processes are available after at least one successful call, the execution of the program is stopped until all function modules started up to that point have been completed. This stoppage is limited to a maximum of 5 seconds.

After all function modules have been started, the system waits until all callback routines have been executed. After that, the internal table task\_list filled there is produced. The output shows the order in which the individual tasks were completed and on which AS Instance.


### abenrfc_dynamic_dest_abexa.htm

---
title: "Dynamic RFC Destination"
description: |
  This example demonstrates how dynamic destinations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm) are created. Source Code REPORT demo_rfc_dynamic_dest. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS: main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD m
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_dynamic_dest_abexa.htm"
abapFile: "abenrfc_dynamic_dest_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenrfc", "dynamic", "dest", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Dynamic RFC Destination

This example demonstrates how [dynamic destinations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm) are created.

Source Code

REPORT demo\_rfc\_dynamic\_dest.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      val\_in     TYPE string VALUE \`val\_in\`,
      val\_in\_out TYPE string VALUE \`val\_in\_out\`,
      val\_out    TYPE string,
      msg        TYPE c LENGTH 80.
    IF sy-uname IS INITIAL.
      cl\_demo\_output=>display(
        \`Example not possible for anonymous user\` ).
      RETURN.
    ENDIF.
    DATA(in) = cl\_demo\_input=>new( ).
    DATA(client) = sy-mandt.
    in->add\_field( CHANGING field = client ).
    DATA(uname) = sy-uname.
    in->add\_field( CHANGING field = uname ).
    DATA(langu) = sy-langu.
    in->add\_field( CHANGING field = langu ).
    DATA(sysid) = sy-sysid.
    in->add\_field( CHANGING field = sysid ).
    DATA(host) = CONV rfchost( sy-host ).
    in->add\_field( CHANGING field = host ).
    DATA(group) = CONV rfcload( 'PUBLIC' ).
    in->add\_field( CHANGING field = group ).
    in->request( ).
    DATA(dest) = cl\_dynamic\_destination=>create\_rfc\_destination(
                   logon\_client   = client
                   logon\_user     = uname
                   logon\_language = langu
                   sid            = sysid
                   server         = host
                   group          = group ).
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION dest
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    cl\_demo\_output=>display( |{ val\_out }\\n{ val\_in\_out }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The method CREATE\_RFC\_DESTINATION of class CL\_DYNAMIC\_DESTINATION is used to create a [dynamic destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm). Input values, whose default values are determined from system fields for the current AS ABAP, are passed as parameters. A remote-enabled function module is called using the dynamic destination. The call is only successful if the destination is created correctly.


### abenrfc_logon_data_abexa.htm

---
title: "Implicit Logon Data in RFC"
description: |
  This example demonstrates how the logon data of an RFC session is set implicitly. Source Code REPORT demo_rfc_implicit_logon_data. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: BEGIN OF logon_data, uname       TYPE sy-uname, m
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_logon_data_abexa.htm"
abapFile: "abenrfc_logon_data_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "abenrfc", "logon", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Implicit Logon Data in RFC

This example demonstrates how the logon data of an RFC session is set implicitly.

Source Code

REPORT demo\_rfc\_implicit\_logon\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      BEGIN OF logon\_data,
        uname       TYPE sy-uname,
        mandt       TYPE sy-mandt,
        logon\_langu TYPE sy-langu,
        langu       TYPE sy-langu,
      END OF logon\_data.
    IF cl\_abap\_syst=>get\_logon\_language( ) <> 'E'.
      SET LOCALE LANGUAGE 'E'.
    ELSE.
      SET LOCALE LANGUAGE 'D'.
    ENDIF.
    logon\_data = VALUE #(
        uname       = sy-uname
        mandt       = sy-mandt
        logon\_langu = cl\_abap\_syst=>get\_logon\_language( )
        langu       = cl\_abap\_syst=>get\_language( ) ).
    ASSERT logon\_data-langu = sy-langu.
    DATA(out) = cl\_demo\_output=>new(
      )->next\_section( 'Parameters of Caller'
      )->write( logon\_data ).
    CALL FUNCTION 'DEMO\_RFM\_LOGON\_DATA' DESTINATION 'NONE'
      IMPORTING
        uname       = logon\_data-uname
        mandt       = logon\_data-mandt
        logon\_langu = logon\_data-logon\_langu
        langu       = logon\_data-langu.
    out->next\_section( 'Parameters of Callee'
      )->write( logon\_data )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

A remote-enabled function module DEMO\_RFM\_LOGON\_DATA is called with the destination "NONE" using the RFC interface. The logon data user name, client, and logon language of the corresponding [RFC session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_context.htm) are provided implicitly. To demonstrate that the [logon language](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogon_language_glosry.htm "Glossary Entry") of the RFC session is set by the language of the [text environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_environment_glosry.htm "Glossary Entry") of the caller, this is set before the call with the statement [SET LOCALE LANGUAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_locale.htm) to a language different from the logon language of the caller. In the called RFM the language of the text environment of the RFC session is also changed and is then different to the logon language there as well.

If the function module DEMO\_RFM\_LOGON\_DATA is called remotely again, the RFC session is reused with the existing logon data. Changing the language of the text environment again in the caller would have no effect.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / CALL FUNCTION - RFC / CALL FUNCTION - STARTING NEW TASK

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

Included pages: 6


### abenrfc_abexas.htm

---
title: "Examples for Remote Function Call"
description: |
  !Example(exa.gif 'Example') Parameter Passing in sRFC and aRFC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm) !Example(exa.gif 'Example') Exception Handling in RFC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.ht
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm"
abapFile: "abenrfc_abexas.htm"
keywords: ["do", "if", "data", "exception-handling", "abenrfc", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) → 

Examples for Remote Function Call

Continue
![Example](exa.gif "Example") [Parameter Passing in sRFC and aRFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm)
![Example](exa.gif "Example") [Exception Handling in RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.htm)
![Example](exa.gif "Example") [Parallel Asynchronous RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenparallel_rfc_abexa.htm)
![Example](exa.gif "Example") [Dynamic RFC Destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_dynamic_dest_abexa.htm)
![Example](exa.gif "Example") [Implicit Logon Data in RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_logon_data_abexa.htm)


### abenrfc_parameters_abexa.htm

---
title: "Parameter Passing in sRFC and aRFC"
description: |
  This example demonstrates parameter passing in two RFC variants. Source Code REPORT demo_rfc_parameters. CLASS demo_rfc DEFINITION. PUBLIC SECTION. CLASS-METHODS: main, callback IMPORTING p_task TYPE clike. PRIVATE SECTION. CLASS-DATA: val_in     TYPE string, val_out    TYPE string, val_in_o
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm"
abapFile: "abenrfc_parameters_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenrfc", "parameters", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Parameter Passing in sRFC and aRFC

This example demonstrates parameter passing in two RFC variants.

Source Code

REPORT demo\_rfc\_parameters.
CLASS demo\_rfc DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main,
      callback IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    CLASS-DATA:
      val\_in     TYPE string,
      val\_out    TYPE string,
      val\_in\_out TYPE string,
      msg        TYPE c LENGTH 80,
      out        TYPE REF TO if\_demo\_output.
ENDCLASS.
CLASS demo\_rfc IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    "Synchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    out->next\_section( 'sRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    "Asynchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      STARTING NEW TASK 'DEMO'
      CALLING demo\_rfc=>callback ON END OF TASK
      EXPORTING
        p\_in                  = val\_in
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling aRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    WAIT FOR ASYNCHRONOUS TASKS UNTIL val\_out IS NOT INITIAL
                                UP TO 10 SECONDS.
    out->next\_section( 'aRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    out->display( ).
  ENDMETHOD.
  METHOD callback.
    val\_out    = \`\`.
    val\_in\_out = \`\`.
    RECEIVE RESULTS FROM FUNCTION 'DEMO\_RFM\_PARAMETERS'
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( '|Error when receiving aRFC.\\n{ msg }|' ).
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_rfc=>main( ).

Description

The function module DEMO\_RFM\_PARAMETERS is called using [synchronous](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_destination.htm) and [asynchronous](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_starting.htm) RFC.

-   In synchronous calls, parameters are passed and applied directly in the statement CALL FUNCTION.

-   In asynchronous calls, parameters can only be passed in the statement CALL FUNCTION. Parameters are applied using the statement [RECEIVE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapreceive.htm) in a callback routine. The statement [WAIT FOR ASYNCHRONOUS TASKS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_until.htm) is used to wait for this routine.


### abenrfc_exceptions_abexa.htm

---
title: "Exception Handling in RFC"
description: |
  This example demonstrates exception handling in RFC. Source Code REPORT demo_rfc_exceptions. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA msg TYPE c LENGTH 255. DATA(out) = cl_demo_output=>new( ). 'Classical exception handling
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.htm"
abapFile: "abenrfc_exceptions_abexa.htm"
keywords: ["select", "do", "if", "case", "method", "class", "data", "exception-handling", "abenrfc", "exceptions", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Exception Handling in RFC

This example demonstrates exception handling in RFC.

Source Code

REPORT demo\_rfc\_exceptions.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA msg TYPE c LENGTH 255.
    DATA(out) = cl\_demo\_output=>new( ).
    "Classical exception handling
    CALL FUNCTION 'DEMO\_RFM\_CLASSIC\_EXCEPTION'
      DESTINATION 'NONE'
      EXCEPTIONS
        system\_failure        = 1  MESSAGE msg
        communication\_failure = 2  MESSAGE msg
        OTHERS                = 3.
    CASE sy-subrc.
      WHEN 1.
        out->write( \`EXCEPTION SYSTEM\_FAILURE \` && msg ).
      WHEN 2.
        out->write( \`EXCEPTION COMMUNICATION\_FAILURE \` && msg ).
      WHEN 3.
        out->write( \`EXCEPTION OTHERS\` ).
    ENDCASE.
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The DEMO\_RFM\_CLASSIC\_EXCEPTION function module triggers the non-class-based exception CLASSIC\_EXCEPTION.

When DEMO\_RFM\_CLASSIC\_EXCEPTION is called, EXCEPTIONS is specified and values for sy-subrc are assigned to the possible classic exceptions. If none of the predefined RFC interface exceptions are raised, sy-subrc is set to 3.


### abenparallel_rfc_abexa.htm

---
title: "Parallel Asynchronous RFC"
description: |
  This example demonstrates parallel asynchronous RFC processing. Source Code REPORT demo_parallel_rfc. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS: main, callbback_meth IMPORTING p_task TYPE clike. PRIVATE SECTION. TYPES: BEGIN OF task_type, name TYPE string, dest TYPE string, END OF ta
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenparallel_rfc_abexa.htm"
abapFile: "abenparallel_rfc_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "types", "internal-table", "abenparallel", "rfc", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Parallel Asynchronous RFC

This example demonstrates parallel asynchronous RFC processing.

Source Code

REPORT demo\_parallel\_rfc.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: main,
                   callbback\_meth IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    TYPES: BEGIN OF task\_type,
           name TYPE string,
           dest TYPE string,
         END OF task\_type.
    CLASS-DATA: task\_list TYPE STANDARD TABLE OF task\_type,
                task\_wa   TYPE task\_type,
                rcv\_jobs  TYPE i,
                mess      TYPE c LENGTH 80.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: snd\_jobs  TYPE i,
          exc\_flag  TYPE i,
          indx      TYPE c LENGTH 4,
          name      TYPE c LENGTH 8.
    DATA(out) = cl\_demo\_output=>new( ).
    DO 10 TIMES.
      indx = sy-index.
      name = 'Task' && indx.
      CALL FUNCTION 'RFC\_SYSTEM\_INFO'
        STARTING NEW TASK name
        DESTINATION IN GROUP DEFAULT
        CALLING callbback\_meth ON END OF TASK
        EXCEPTIONS
          system\_failure        = 1 MESSAGE mess
          communication\_failure = 2 MESSAGE mess
          resource\_failure      = 3.
      CASE sy-subrc.
        WHEN 0.
          snd\_jobs += 1.
        WHEN 1 OR 2.
          out->write\_text( mess ).
        WHEN 3.
          IF snd\_jobs >= 1 AND
             exc\_flag = 0.
             exc\_flag = 1.
            WAIT UNTIL rcv\_jobs >= snd\_jobs
                 UP TO 5 SECONDS.
          ENDIF.
          IF sy-subrc = 0.
            exc\_flag = 0.
          ELSE.
            out->display( 'Resource failure' ).
          ENDIF.
        WHEN OTHERS.
          out->display( 'Other error' ).
      ENDCASE.
    ENDDO.
    WAIT UNTIL rcv\_jobs >= snd\_jobs.
    out->display( task\_list ).  ENDMETHOD.
  METHOD callbback\_meth.
    DATA info TYPE rfcsi.
    task\_wa-name = p\_task.
    rcv\_jobs += 1.
    RECEIVE RESULTS FROM FUNCTION 'RFC\_SYSTEM\_INFO'
      IMPORTING
        rfcsi\_export = info
      EXCEPTIONS
        system\_failure        = 1 MESSAGE mess
        communication\_failure = 2 MESSAGE mess.
    IF sy-subrc = 0.
      task\_wa-dest = info-rfcdest.
    ELSE.
      task\_wa-dest = mess.
    ENDIF.
    APPEND task\_wa TO task\_list.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Parallel asynchronous processing of the function module RFC\_SYSTEM\_INFO using [asynchronous remote function calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasynchronous_rfc_glosry.htm "Glossary Entry"). Ten calls with different task IDs name are made, which each run in a separate [work process](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwork_process_glosry.htm "Glossary Entry"). The callback routine callbback\_meth counts the completed function modules and receives information about the target system.

The addition GROUP DEFAULT is used to distribute the execution across all [AS Instances](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry")s of the current AS ABAP. If no more free work processes are available after at least one successful call, the execution of the program is stopped until all function modules started up to that point have been completed. This stoppage is limited to a maximum of 5 seconds.

After all function modules have been started, the system waits until all callback routines have been executed. After that, the internal table task\_list filled there is produced. The output shows the order in which the individual tasks were completed and on which AS Instance.


### abenrfc_dynamic_dest_abexa.htm

---
title: "Dynamic RFC Destination"
description: |
  This example demonstrates how dynamic destinations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm) are created. Source Code REPORT demo_rfc_dynamic_dest. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS: main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD m
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_dynamic_dest_abexa.htm"
abapFile: "abenrfc_dynamic_dest_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenrfc", "dynamic", "dest", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Dynamic RFC Destination

This example demonstrates how [dynamic destinations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm) are created.

Source Code

REPORT demo\_rfc\_dynamic\_dest.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      val\_in     TYPE string VALUE \`val\_in\`,
      val\_in\_out TYPE string VALUE \`val\_in\_out\`,
      val\_out    TYPE string,
      msg        TYPE c LENGTH 80.
    IF sy-uname IS INITIAL.
      cl\_demo\_output=>display(
        \`Example not possible for anonymous user\` ).
      RETURN.
    ENDIF.
    DATA(in) = cl\_demo\_input=>new( ).
    DATA(client) = sy-mandt.
    in->add\_field( CHANGING field = client ).
    DATA(uname) = sy-uname.
    in->add\_field( CHANGING field = uname ).
    DATA(langu) = sy-langu.
    in->add\_field( CHANGING field = langu ).
    DATA(sysid) = sy-sysid.
    in->add\_field( CHANGING field = sysid ).
    DATA(host) = CONV rfchost( sy-host ).
    in->add\_field( CHANGING field = host ).
    DATA(group) = CONV rfcload( 'PUBLIC' ).
    in->add\_field( CHANGING field = group ).
    in->request( ).
    DATA(dest) = cl\_dynamic\_destination=>create\_rfc\_destination(
                   logon\_client   = client
                   logon\_user     = uname
                   logon\_language = langu
                   sid            = sysid
                   server         = host
                   group          = group ).
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION dest
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    cl\_demo\_output=>display( |{ val\_out }\\n{ val\_in\_out }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The method CREATE\_RFC\_DESTINATION of class CL\_DYNAMIC\_DESTINATION is used to create a [dynamic destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm). Input values, whose default values are determined from system fields for the current AS ABAP, are passed as parameters. A remote-enabled function module is called using the dynamic destination. The call is only successful if the destination is created correctly.


### abenrfc_logon_data_abexa.htm

---
title: "Implicit Logon Data in RFC"
description: |
  This example demonstrates how the logon data of an RFC session is set implicitly. Source Code REPORT demo_rfc_implicit_logon_data. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: BEGIN OF logon_data, uname       TYPE sy-uname, m
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_logon_data_abexa.htm"
abapFile: "abenrfc_logon_data_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "abenrfc", "logon", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Implicit Logon Data in RFC

This example demonstrates how the logon data of an RFC session is set implicitly.

Source Code

REPORT demo\_rfc\_implicit\_logon\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      BEGIN OF logon\_data,
        uname       TYPE sy-uname,
        mandt       TYPE sy-mandt,
        logon\_langu TYPE sy-langu,
        langu       TYPE sy-langu,
      END OF logon\_data.
    IF cl\_abap\_syst=>get\_logon\_language( ) <> 'E'.
      SET LOCALE LANGUAGE 'E'.
    ELSE.
      SET LOCALE LANGUAGE 'D'.
    ENDIF.
    logon\_data = VALUE #(
        uname       = sy-uname
        mandt       = sy-mandt
        logon\_langu = cl\_abap\_syst=>get\_logon\_language( )
        langu       = cl\_abap\_syst=>get\_language( ) ).
    ASSERT logon\_data-langu = sy-langu.
    DATA(out) = cl\_demo\_output=>new(
      )->next\_section( 'Parameters of Caller'
      )->write( logon\_data ).
    CALL FUNCTION 'DEMO\_RFM\_LOGON\_DATA' DESTINATION 'NONE'
      IMPORTING
        uname       = logon\_data-uname
        mandt       = logon\_data-mandt
        logon\_langu = logon\_data-logon\_langu
        langu       = logon\_data-langu.
    out->next\_section( 'Parameters of Callee'
      )->write( logon\_data )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

A remote-enabled function module DEMO\_RFM\_LOGON\_DATA is called with the destination "NONE" using the RFC interface. The logon data user name, client, and logon language of the corresponding [RFC session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_context.htm) are provided implicitly. To demonstrate that the [logon language](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogon_language_glosry.htm "Glossary Entry") of the RFC session is set by the language of the [text environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_environment_glosry.htm "Glossary Entry") of the caller, this is set before the call with the statement [SET LOCALE LANGUAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_locale.htm) to a language different from the logon language of the caller. In the called RFM the language of the text environment of the RFC session is also changed and is then different to the logon language there as well.

If the function module DEMO\_RFM\_LOGON\_DATA is called remotely again, the RFC session is reused with the existing logon data. Changing the language of the text environment again in the caller would have no effect.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / CALL FUNCTION - RFC / CALL FUNCTION - IN BACKGROUND UNIT

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

Included pages: 6


### abenrfc_abexas.htm

---
title: "Examples for Remote Function Call"
description: |
  !Example(exa.gif 'Example') Parameter Passing in sRFC and aRFC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm) !Example(exa.gif 'Example') Exception Handling in RFC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.ht
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm"
abapFile: "abenrfc_abexas.htm"
keywords: ["do", "if", "data", "exception-handling", "abenrfc", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) → 

Examples for Remote Function Call

Continue
![Example](exa.gif "Example") [Parameter Passing in sRFC and aRFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm)
![Example](exa.gif "Example") [Exception Handling in RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.htm)
![Example](exa.gif "Example") [Parallel Asynchronous RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenparallel_rfc_abexa.htm)
![Example](exa.gif "Example") [Dynamic RFC Destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_dynamic_dest_abexa.htm)
![Example](exa.gif "Example") [Implicit Logon Data in RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_logon_data_abexa.htm)


### abenrfc_parameters_abexa.htm

---
title: "Parameter Passing in sRFC and aRFC"
description: |
  This example demonstrates parameter passing in two RFC variants. Source Code REPORT demo_rfc_parameters. CLASS demo_rfc DEFINITION. PUBLIC SECTION. CLASS-METHODS: main, callback IMPORTING p_task TYPE clike. PRIVATE SECTION. CLASS-DATA: val_in     TYPE string, val_out    TYPE string, val_in_o
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm"
abapFile: "abenrfc_parameters_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenrfc", "parameters", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Parameter Passing in sRFC and aRFC

This example demonstrates parameter passing in two RFC variants.

Source Code

REPORT demo\_rfc\_parameters.
CLASS demo\_rfc DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main,
      callback IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    CLASS-DATA:
      val\_in     TYPE string,
      val\_out    TYPE string,
      val\_in\_out TYPE string,
      msg        TYPE c LENGTH 80,
      out        TYPE REF TO if\_demo\_output.
ENDCLASS.
CLASS demo\_rfc IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    "Synchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    out->next\_section( 'sRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    "Asynchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      STARTING NEW TASK 'DEMO'
      CALLING demo\_rfc=>callback ON END OF TASK
      EXPORTING
        p\_in                  = val\_in
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling aRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    WAIT FOR ASYNCHRONOUS TASKS UNTIL val\_out IS NOT INITIAL
                                UP TO 10 SECONDS.
    out->next\_section( 'aRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    out->display( ).
  ENDMETHOD.
  METHOD callback.
    val\_out    = \`\`.
    val\_in\_out = \`\`.
    RECEIVE RESULTS FROM FUNCTION 'DEMO\_RFM\_PARAMETERS'
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( '|Error when receiving aRFC.\\n{ msg }|' ).
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_rfc=>main( ).

Description

The function module DEMO\_RFM\_PARAMETERS is called using [synchronous](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_destination.htm) and [asynchronous](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_starting.htm) RFC.

-   In synchronous calls, parameters are passed and applied directly in the statement CALL FUNCTION.

-   In asynchronous calls, parameters can only be passed in the statement CALL FUNCTION. Parameters are applied using the statement [RECEIVE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapreceive.htm) in a callback routine. The statement [WAIT FOR ASYNCHRONOUS TASKS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_until.htm) is used to wait for this routine.


### abenrfc_exceptions_abexa.htm

---
title: "Exception Handling in RFC"
description: |
  This example demonstrates exception handling in RFC. Source Code REPORT demo_rfc_exceptions. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA msg TYPE c LENGTH 255. DATA(out) = cl_demo_output=>new( ). 'Classical exception handling
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.htm"
abapFile: "abenrfc_exceptions_abexa.htm"
keywords: ["select", "do", "if", "case", "method", "class", "data", "exception-handling", "abenrfc", "exceptions", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Exception Handling in RFC

This example demonstrates exception handling in RFC.

Source Code

REPORT demo\_rfc\_exceptions.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA msg TYPE c LENGTH 255.
    DATA(out) = cl\_demo\_output=>new( ).
    "Classical exception handling
    CALL FUNCTION 'DEMO\_RFM\_CLASSIC\_EXCEPTION'
      DESTINATION 'NONE'
      EXCEPTIONS
        system\_failure        = 1  MESSAGE msg
        communication\_failure = 2  MESSAGE msg
        OTHERS                = 3.
    CASE sy-subrc.
      WHEN 1.
        out->write( \`EXCEPTION SYSTEM\_FAILURE \` && msg ).
      WHEN 2.
        out->write( \`EXCEPTION COMMUNICATION\_FAILURE \` && msg ).
      WHEN 3.
        out->write( \`EXCEPTION OTHERS\` ).
    ENDCASE.
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The DEMO\_RFM\_CLASSIC\_EXCEPTION function module triggers the non-class-based exception CLASSIC\_EXCEPTION.

When DEMO\_RFM\_CLASSIC\_EXCEPTION is called, EXCEPTIONS is specified and values for sy-subrc are assigned to the possible classic exceptions. If none of the predefined RFC interface exceptions are raised, sy-subrc is set to 3.


### abenparallel_rfc_abexa.htm

---
title: "Parallel Asynchronous RFC"
description: |
  This example demonstrates parallel asynchronous RFC processing. Source Code REPORT demo_parallel_rfc. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS: main, callbback_meth IMPORTING p_task TYPE clike. PRIVATE SECTION. TYPES: BEGIN OF task_type, name TYPE string, dest TYPE string, END OF ta
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenparallel_rfc_abexa.htm"
abapFile: "abenparallel_rfc_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "types", "internal-table", "abenparallel", "rfc", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Parallel Asynchronous RFC

This example demonstrates parallel asynchronous RFC processing.

Source Code

REPORT demo\_parallel\_rfc.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: main,
                   callbback\_meth IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    TYPES: BEGIN OF task\_type,
           name TYPE string,
           dest TYPE string,
         END OF task\_type.
    CLASS-DATA: task\_list TYPE STANDARD TABLE OF task\_type,
                task\_wa   TYPE task\_type,
                rcv\_jobs  TYPE i,
                mess      TYPE c LENGTH 80.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: snd\_jobs  TYPE i,
          exc\_flag  TYPE i,
          indx      TYPE c LENGTH 4,
          name      TYPE c LENGTH 8.
    DATA(out) = cl\_demo\_output=>new( ).
    DO 10 TIMES.
      indx = sy-index.
      name = 'Task' && indx.
      CALL FUNCTION 'RFC\_SYSTEM\_INFO'
        STARTING NEW TASK name
        DESTINATION IN GROUP DEFAULT
        CALLING callbback\_meth ON END OF TASK
        EXCEPTIONS
          system\_failure        = 1 MESSAGE mess
          communication\_failure = 2 MESSAGE mess
          resource\_failure      = 3.
      CASE sy-subrc.
        WHEN 0.
          snd\_jobs += 1.
        WHEN 1 OR 2.
          out->write\_text( mess ).
        WHEN 3.
          IF snd\_jobs >= 1 AND
             exc\_flag = 0.
             exc\_flag = 1.
            WAIT UNTIL rcv\_jobs >= snd\_jobs
                 UP TO 5 SECONDS.
          ENDIF.
          IF sy-subrc = 0.
            exc\_flag = 0.
          ELSE.
            out->display( 'Resource failure' ).
          ENDIF.
        WHEN OTHERS.
          out->display( 'Other error' ).
      ENDCASE.
    ENDDO.
    WAIT UNTIL rcv\_jobs >= snd\_jobs.
    out->display( task\_list ).  ENDMETHOD.
  METHOD callbback\_meth.
    DATA info TYPE rfcsi.
    task\_wa-name = p\_task.
    rcv\_jobs += 1.
    RECEIVE RESULTS FROM FUNCTION 'RFC\_SYSTEM\_INFO'
      IMPORTING
        rfcsi\_export = info
      EXCEPTIONS
        system\_failure        = 1 MESSAGE mess
        communication\_failure = 2 MESSAGE mess.
    IF sy-subrc = 0.
      task\_wa-dest = info-rfcdest.
    ELSE.
      task\_wa-dest = mess.
    ENDIF.
    APPEND task\_wa TO task\_list.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Parallel asynchronous processing of the function module RFC\_SYSTEM\_INFO using [asynchronous remote function calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasynchronous_rfc_glosry.htm "Glossary Entry"). Ten calls with different task IDs name are made, which each run in a separate [work process](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwork_process_glosry.htm "Glossary Entry"). The callback routine callbback\_meth counts the completed function modules and receives information about the target system.

The addition GROUP DEFAULT is used to distribute the execution across all [AS Instances](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry")s of the current AS ABAP. If no more free work processes are available after at least one successful call, the execution of the program is stopped until all function modules started up to that point have been completed. This stoppage is limited to a maximum of 5 seconds.

After all function modules have been started, the system waits until all callback routines have been executed. After that, the internal table task\_list filled there is produced. The output shows the order in which the individual tasks were completed and on which AS Instance.


### abenrfc_dynamic_dest_abexa.htm

---
title: "Dynamic RFC Destination"
description: |
  This example demonstrates how dynamic destinations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm) are created. Source Code REPORT demo_rfc_dynamic_dest. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS: main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD m
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_dynamic_dest_abexa.htm"
abapFile: "abenrfc_dynamic_dest_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenrfc", "dynamic", "dest", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Dynamic RFC Destination

This example demonstrates how [dynamic destinations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm) are created.

Source Code

REPORT demo\_rfc\_dynamic\_dest.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      val\_in     TYPE string VALUE \`val\_in\`,
      val\_in\_out TYPE string VALUE \`val\_in\_out\`,
      val\_out    TYPE string,
      msg        TYPE c LENGTH 80.
    IF sy-uname IS INITIAL.
      cl\_demo\_output=>display(
        \`Example not possible for anonymous user\` ).
      RETURN.
    ENDIF.
    DATA(in) = cl\_demo\_input=>new( ).
    DATA(client) = sy-mandt.
    in->add\_field( CHANGING field = client ).
    DATA(uname) = sy-uname.
    in->add\_field( CHANGING field = uname ).
    DATA(langu) = sy-langu.
    in->add\_field( CHANGING field = langu ).
    DATA(sysid) = sy-sysid.
    in->add\_field( CHANGING field = sysid ).
    DATA(host) = CONV rfchost( sy-host ).
    in->add\_field( CHANGING field = host ).
    DATA(group) = CONV rfcload( 'PUBLIC' ).
    in->add\_field( CHANGING field = group ).
    in->request( ).
    DATA(dest) = cl\_dynamic\_destination=>create\_rfc\_destination(
                   logon\_client   = client
                   logon\_user     = uname
                   logon\_language = langu
                   sid            = sysid
                   server         = host
                   group          = group ).
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION dest
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    cl\_demo\_output=>display( |{ val\_out }\\n{ val\_in\_out }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The method CREATE\_RFC\_DESTINATION of class CL\_DYNAMIC\_DESTINATION is used to create a [dynamic destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm). Input values, whose default values are determined from system fields for the current AS ABAP, are passed as parameters. A remote-enabled function module is called using the dynamic destination. The call is only successful if the destination is created correctly.


### abenrfc_logon_data_abexa.htm

---
title: "Implicit Logon Data in RFC"
description: |
  This example demonstrates how the logon data of an RFC session is set implicitly. Source Code REPORT demo_rfc_implicit_logon_data. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: BEGIN OF logon_data, uname       TYPE sy-uname, m
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_logon_data_abexa.htm"
abapFile: "abenrfc_logon_data_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "abenrfc", "logon", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Implicit Logon Data in RFC

This example demonstrates how the logon data of an RFC session is set implicitly.

Source Code

REPORT demo\_rfc\_implicit\_logon\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      BEGIN OF logon\_data,
        uname       TYPE sy-uname,
        mandt       TYPE sy-mandt,
        logon\_langu TYPE sy-langu,
        langu       TYPE sy-langu,
      END OF logon\_data.
    IF cl\_abap\_syst=>get\_logon\_language( ) <> 'E'.
      SET LOCALE LANGUAGE 'E'.
    ELSE.
      SET LOCALE LANGUAGE 'D'.
    ENDIF.
    logon\_data = VALUE #(
        uname       = sy-uname
        mandt       = sy-mandt
        logon\_langu = cl\_abap\_syst=>get\_logon\_language( )
        langu       = cl\_abap\_syst=>get\_language( ) ).
    ASSERT logon\_data-langu = sy-langu.
    DATA(out) = cl\_demo\_output=>new(
      )->next\_section( 'Parameters of Caller'
      )->write( logon\_data ).
    CALL FUNCTION 'DEMO\_RFM\_LOGON\_DATA' DESTINATION 'NONE'
      IMPORTING
        uname       = logon\_data-uname
        mandt       = logon\_data-mandt
        logon\_langu = logon\_data-logon\_langu
        langu       = logon\_data-langu.
    out->next\_section( 'Parameters of Callee'
      )->write( logon\_data )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

A remote-enabled function module DEMO\_RFM\_LOGON\_DATA is called with the destination "NONE" using the RFC interface. The logon data user name, client, and logon language of the corresponding [RFC session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_context.htm) are provided implicitly. To demonstrate that the [logon language](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogon_language_glosry.htm "Glossary Entry") of the RFC session is set by the language of the [text environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_environment_glosry.htm "Glossary Entry") of the caller, this is set before the call with the statement [SET LOCALE LANGUAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_locale.htm) to a language different from the logon language of the caller. In the called RFM the language of the text environment of the RFC session is also changed and is then different to the logon language there as well.

If the function module DEMO\_RFM\_LOGON\_DATA is called remotely again, the RFC session is reused with the existing logon data. Changing the language of the text environment again in the caller would have no effect.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / RFC - Remote Function Call / Examples for Remote Function Call

Included pages: 6


### abenrfc_abexas.htm

---
title: "Examples for Remote Function Call"
description: |
  !Example(exa.gif 'Example') Parameter Passing in sRFC and aRFC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm) !Example(exa.gif 'Example') Exception Handling in RFC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.ht
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm"
abapFile: "abenrfc_abexas.htm"
keywords: ["do", "if", "data", "exception-handling", "abenrfc", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) → 

Examples for Remote Function Call

Continue
![Example](exa.gif "Example") [Parameter Passing in sRFC and aRFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm)
![Example](exa.gif "Example") [Exception Handling in RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.htm)
![Example](exa.gif "Example") [Parallel Asynchronous RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenparallel_rfc_abexa.htm)
![Example](exa.gif "Example") [Dynamic RFC Destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_dynamic_dest_abexa.htm)
![Example](exa.gif "Example") [Implicit Logon Data in RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_logon_data_abexa.htm)


### abenrfc_parameters_abexa.htm

---
title: "Parameter Passing in sRFC and aRFC"
description: |
  This example demonstrates parameter passing in two RFC variants. Source Code REPORT demo_rfc_parameters. CLASS demo_rfc DEFINITION. PUBLIC SECTION. CLASS-METHODS: main, callback IMPORTING p_task TYPE clike. PRIVATE SECTION. CLASS-DATA: val_in     TYPE string, val_out    TYPE string, val_in_o
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_parameters_abexa.htm"
abapFile: "abenrfc_parameters_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenrfc", "parameters", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Parameter Passing in sRFC and aRFC

This example demonstrates parameter passing in two RFC variants.

Source Code

REPORT demo\_rfc\_parameters.
CLASS demo\_rfc DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main,
      callback IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    CLASS-DATA:
      val\_in     TYPE string,
      val\_out    TYPE string,
      val\_in\_out TYPE string,
      msg        TYPE c LENGTH 80,
      out        TYPE REF TO if\_demo\_output.
ENDCLASS.
CLASS demo\_rfc IMPLEMENTATION.
  METHOD main.
    out = cl\_demo\_output=>new( ).
    "Synchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    out->next\_section( 'sRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    "Asynchronous RFC
    val\_in     = \`val\_in\`.
    val\_out    = \`\`.
    val\_in\_out = \`val\_in\_out\`.
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION 'NONE'
      STARTING NEW TASK 'DEMO'
      CALLING demo\_rfc=>callback ON END OF TASK
      EXPORTING
        p\_in                  = val\_in
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( |Error when calling aRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    WAIT FOR ASYNCHRONOUS TASKS UNTIL val\_out IS NOT INITIAL
                                UP TO 10 SECONDS.
    out->next\_section( 'aRFC'
      )->write( |{ val\_out }\\n{ val\_in\_out }| ).
    out->display( ).
  ENDMETHOD.
  METHOD callback.
    val\_out    = \`\`.
    val\_in\_out = \`\`.
    RECEIVE RESULTS FROM FUNCTION 'DEMO\_RFM\_PARAMETERS'
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      out->display( '|Error when receiving aRFC.\\n{ msg }|' ).
      RETURN.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo\_rfc=>main( ).

Description

The function module DEMO\_RFM\_PARAMETERS is called using [synchronous](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_destination.htm) and [asynchronous](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_starting.htm) RFC.

-   In synchronous calls, parameters are passed and applied directly in the statement CALL FUNCTION.

-   In asynchronous calls, parameters can only be passed in the statement CALL FUNCTION. Parameters are applied using the statement [RECEIVE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapreceive.htm) in a callback routine. The statement [WAIT FOR ASYNCHRONOUS TASKS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_until.htm) is used to wait for this routine.


### abenrfc_exceptions_abexa.htm

---
title: "Exception Handling in RFC"
description: |
  This example demonstrates exception handling in RFC. Source Code REPORT demo_rfc_exceptions. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA msg TYPE c LENGTH 255. DATA(out) = cl_demo_output=>new( ). 'Classical exception handling
version: "7.54"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_exceptions_abexa.htm"
abapFile: "abenrfc_exceptions_abexa.htm"
keywords: ["select", "do", "if", "case", "method", "class", "data", "exception-handling", "abenrfc", "exceptions", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Exception Handling in RFC

This example demonstrates exception handling in RFC.

Source Code

REPORT demo\_rfc\_exceptions.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA msg TYPE c LENGTH 255.
    DATA(out) = cl\_demo\_output=>new( ).
    "Classical exception handling
    CALL FUNCTION 'DEMO\_RFM\_CLASSIC\_EXCEPTION'
      DESTINATION 'NONE'
      EXCEPTIONS
        system\_failure        = 1  MESSAGE msg
        communication\_failure = 2  MESSAGE msg
        OTHERS                = 3.
    CASE sy-subrc.
      WHEN 1.
        out->write( \`EXCEPTION SYSTEM\_FAILURE \` && msg ).
      WHEN 2.
        out->write( \`EXCEPTION COMMUNICATION\_FAILURE \` && msg ).
      WHEN 3.
        out->write( \`EXCEPTION OTHERS\` ).
    ENDCASE.
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The DEMO\_RFM\_CLASSIC\_EXCEPTION function module triggers the non-class-based exception CLASSIC\_EXCEPTION.

When DEMO\_RFM\_CLASSIC\_EXCEPTION is called, EXCEPTIONS is specified and values for sy-subrc are assigned to the possible classic exceptions. If none of the predefined RFC interface exceptions are raised, sy-subrc is set to 3.


### abenparallel_rfc_abexa.htm

---
title: "Parallel Asynchronous RFC"
description: |
  This example demonstrates parallel asynchronous RFC processing. Source Code REPORT demo_parallel_rfc. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS: main, callbback_meth IMPORTING p_task TYPE clike. PRIVATE SECTION. TYPES: BEGIN OF task_type, name TYPE string, dest TYPE string, END OF ta
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenparallel_rfc_abexa.htm"
abapFile: "abenparallel_rfc_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "types", "internal-table", "abenparallel", "rfc", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Parallel Asynchronous RFC

This example demonstrates parallel asynchronous RFC processing.

Source Code

REPORT demo\_parallel\_rfc.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: main,
                   callbback\_meth IMPORTING p\_task TYPE clike.
  PRIVATE SECTION.
    TYPES: BEGIN OF task\_type,
           name TYPE string,
           dest TYPE string,
         END OF task\_type.
    CLASS-DATA: task\_list TYPE STANDARD TABLE OF task\_type,
                task\_wa   TYPE task\_type,
                rcv\_jobs  TYPE i,
                mess      TYPE c LENGTH 80.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: snd\_jobs  TYPE i,
          exc\_flag  TYPE i,
          indx      TYPE c LENGTH 4,
          name      TYPE c LENGTH 8.
    DATA(out) = cl\_demo\_output=>new( ).
    DO 10 TIMES.
      indx = sy-index.
      name = 'Task' && indx.
      CALL FUNCTION 'RFC\_SYSTEM\_INFO'
        STARTING NEW TASK name
        DESTINATION IN GROUP DEFAULT
        CALLING callbback\_meth ON END OF TASK
        EXCEPTIONS
          system\_failure        = 1 MESSAGE mess
          communication\_failure = 2 MESSAGE mess
          resource\_failure      = 3.
      CASE sy-subrc.
        WHEN 0.
          snd\_jobs += 1.
        WHEN 1 OR 2.
          out->write\_text( mess ).
        WHEN 3.
          IF snd\_jobs >= 1 AND
             exc\_flag = 0.
             exc\_flag = 1.
            WAIT UNTIL rcv\_jobs >= snd\_jobs
                 UP TO 5 SECONDS.
          ENDIF.
          IF sy-subrc = 0.
            exc\_flag = 0.
          ELSE.
            out->display( 'Resource failure' ).
          ENDIF.
        WHEN OTHERS.
          out->display( 'Other error' ).
      ENDCASE.
    ENDDO.
    WAIT UNTIL rcv\_jobs >= snd\_jobs.
    out->display( task\_list ).  ENDMETHOD.
  METHOD callbback\_meth.
    DATA info TYPE rfcsi.
    task\_wa-name = p\_task.
    rcv\_jobs += 1.
    RECEIVE RESULTS FROM FUNCTION 'RFC\_SYSTEM\_INFO'
      IMPORTING
        rfcsi\_export = info
      EXCEPTIONS
        system\_failure        = 1 MESSAGE mess
        communication\_failure = 2 MESSAGE mess.
    IF sy-subrc = 0.
      task\_wa-dest = info-rfcdest.
    ELSE.
      task\_wa-dest = mess.
    ENDIF.
    APPEND task\_wa TO task\_list.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Parallel asynchronous processing of the function module RFC\_SYSTEM\_INFO using [asynchronous remote function calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasynchronous_rfc_glosry.htm "Glossary Entry"). Ten calls with different task IDs name are made, which each run in a separate [work process](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwork_process_glosry.htm "Glossary Entry"). The callback routine callbback\_meth counts the completed function modules and receives information about the target system.

The addition GROUP DEFAULT is used to distribute the execution across all [AS Instances](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry")s of the current AS ABAP. If no more free work processes are available after at least one successful call, the execution of the program is stopped until all function modules started up to that point have been completed. This stoppage is limited to a maximum of 5 seconds.

After all function modules have been started, the system waits until all callback routines have been executed. After that, the internal table task\_list filled there is produced. The output shows the order in which the individual tasks were completed and on which AS Instance.


### abenrfc_dynamic_dest_abexa.htm

---
title: "Dynamic RFC Destination"
description: |
  This example demonstrates how dynamic destinations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm) are created. Source Code REPORT demo_rfc_dynamic_dest. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS: main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD m
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_dynamic_dest_abexa.htm"
abapFile: "abenrfc_dynamic_dest_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenrfc", "dynamic", "dest", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Dynamic RFC Destination

This example demonstrates how [dynamic destinations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm) are created.

Source Code

REPORT demo\_rfc\_dynamic\_dest.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      val\_in     TYPE string VALUE \`val\_in\`,
      val\_in\_out TYPE string VALUE \`val\_in\_out\`,
      val\_out    TYPE string,
      msg        TYPE c LENGTH 80.
    IF sy-uname IS INITIAL.
      cl\_demo\_output=>display(
        \`Example not possible for anonymous user\` ).
      RETURN.
    ENDIF.
    DATA(in) = cl\_demo\_input=>new( ).
    DATA(client) = sy-mandt.
    in->add\_field( CHANGING field = client ).
    DATA(uname) = sy-uname.
    in->add\_field( CHANGING field = uname ).
    DATA(langu) = sy-langu.
    in->add\_field( CHANGING field = langu ).
    DATA(sysid) = sy-sysid.
    in->add\_field( CHANGING field = sysid ).
    DATA(host) = CONV rfchost( sy-host ).
    in->add\_field( CHANGING field = host ).
    DATA(group) = CONV rfcload( 'PUBLIC' ).
    in->add\_field( CHANGING field = group ).
    in->request( ).
    DATA(dest) = cl\_dynamic\_destination=>create\_rfc\_destination(
                   logon\_client   = client
                   logon\_user     = uname
                   logon\_language = langu
                   sid            = sysid
                   server         = host
                   group          = group ).
    CALL FUNCTION 'DEMO\_RFM\_PARAMETERS'
      DESTINATION dest
      EXPORTING
        p\_in                  = val\_in
      IMPORTING
        p\_out                 = val\_out
      CHANGING
        p\_in\_out              = val\_in\_out
      EXCEPTIONS
        system\_failure        = 2 MESSAGE msg
        communication\_failure = 4 MESSAGE msg.
    IF sy-subrc <> 0.
      cl\_demo\_output=>display( |Error when calling sRFC.\\n{ msg }| ).
      RETURN.
    ENDIF.
    cl\_demo\_output=>display( |{ val\_out }\\n{ val\_in\_out }| ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The method CREATE\_RFC\_DESTINATION of class CL\_DYNAMIC\_DESTINATION is used to create a [dynamic destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm). Input values, whose default values are determined from system fields for the current AS ABAP, are passed as parameters. A remote-enabled function module is called using the dynamic destination. The call is only successful if the destination is created correctly.


### abenrfc_logon_data_abexa.htm

---
title: "Implicit Logon Data in RFC"
description: |
  This example demonstrates how the logon data of an RFC session is set implicitly. Source Code REPORT demo_rfc_implicit_logon_data. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA: BEGIN OF logon_data, uname       TYPE sy-uname, m
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_logon_data_abexa.htm"
abapFile: "abenrfc_logon_data_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "abenrfc", "logon", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [RFC - Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc.htm) →  [Examples for Remote Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_abexas.htm) → 

Implicit Logon Data in RFC

This example demonstrates how the logon data of an RFC session is set implicitly.

Source Code

REPORT demo\_rfc\_implicit\_logon\_data.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA:
      BEGIN OF logon\_data,
        uname       TYPE sy-uname,
        mandt       TYPE sy-mandt,
        logon\_langu TYPE sy-langu,
        langu       TYPE sy-langu,
      END OF logon\_data.
    IF cl\_abap\_syst=>get\_logon\_language( ) <> 'E'.
      SET LOCALE LANGUAGE 'E'.
    ELSE.
      SET LOCALE LANGUAGE 'D'.
    ENDIF.
    logon\_data = VALUE #(
        uname       = sy-uname
        mandt       = sy-mandt
        logon\_langu = cl\_abap\_syst=>get\_logon\_language( )
        langu       = cl\_abap\_syst=>get\_language( ) ).
    ASSERT logon\_data-langu = sy-langu.
    DATA(out) = cl\_demo\_output=>new(
      )->next\_section( 'Parameters of Caller'
      )->write( logon\_data ).
    CALL FUNCTION 'DEMO\_RFM\_LOGON\_DATA' DESTINATION 'NONE'
      IMPORTING
        uname       = logon\_data-uname
        mandt       = logon\_data-mandt
        logon\_langu = logon\_data-logon\_langu
        langu       = logon\_data-langu.
    out->next\_section( 'Parameters of Callee'
      )->write( logon\_data )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

A remote-enabled function module DEMO\_RFM\_LOGON\_DATA is called with the destination "NONE" using the RFC interface. The logon data user name, client, and logon language of the corresponding [RFC session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_context.htm) are provided implicitly. To demonstrate that the [logon language](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogon_language_glosry.htm "Glossary Entry") of the RFC session is set by the language of the [text environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_environment_glosry.htm "Glossary Entry") of the caller, this is set before the call with the statement [SET LOCALE LANGUAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_locale.htm) to a language different from the logon language of the caller. In the called RFM the language of the text environment of the RFC session is also changed and is then different to the logon language there as well.

If the function module DEMO\_RFM\_LOGON\_DATA is called remotely again, the RFC session is reused with the existing logon data. Changing the language of the text environment again in the caller would have no effect.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ICF - Internet Communication Framework

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ICF - Internet Communication Framework

Included pages: 8


### abenicf.htm

---
title: "ICF - Internet Communication Framework"
description: |
  Internet Communication Framework (ICF) is a programming interface (API), based on interfaces and classes, used by ABAP programs to communicate with the Internet. ICF supports the Internet protocols HTTP, HTTPS, and SMTP. All communication between ABAP and the Internet based on these protocols takes
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf.htm"
abapFile: "abenicf.htm"
keywords: ["select", "update", "do", "if", "try", "method", "class", "data", "abenicf"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) → 

ICF - Internet Communication Framework

Internet Communication Framework (ICF) is a programming interface (API), based on interfaces and classes, used by ABAP programs to communicate with the Internet. ICF supports the Internet protocols HTTP, HTTPS, and SMTP. All communication between ABAP and the Internet based on these protocols takes place using ICF. ICF is a simplified technical foundation that can be used by more advanced programming interfaces. This means that ABAP programs do not usually access ICF directly and wrappers are used instead, such as [Business Server Pages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbusiness_server_pages_glosry.htm "Glossary Entry"), [Web Dynpro ABAP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenweb_dynpro_glosry.htm "Glossary Entry"), Web Services ABAP, or on OData-based services like [SAPUI5](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensapui5_glosry.htm "Glossary Entry"). Wrappers like these ensure that the conventions required for external communication are met, such as the model view controller approach (MVC) in Web Dynpro and SAPUI5 or Simple Object Access Protocol (SOAP) in Web services.

To communicate with the Internet using REST principles (Representational State Transfer), the interfaces and classes in the ABAP REST Library in the package SREST should be used, since they adapt ICF accordingly.

-   [ICF Overview](#abenicf-1--------as-abap-as-an-icf-server---@ITOC@@ABENICF_2)

-   [AS ABAP as an ICF Client](#abenicf-3--------icf-security---@ITOC@@ABENICF_4)

-   [More Information](#abenicf-5---note--information-about-communications-using-the-websocket-protocol-or-tcp-can-be-found-under--abap-push-channels--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenapc-htm----icf-overview--the-following-figure-is-a--highly-simplified--schematic-overview-of-communications-between-abap-and-the-internet-using-icf--it-uses-http-communication-as-an-example-----figure--abdoc-icf-gif---the-actual-communication-of-the--as-abap--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abensap-nw-abap-glosry-htm--glossary-entry---with-the-internet-takes-places-through-its--internet-communication-manager--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abeninternet-con-man-glosry-htm--glossary-entry----icm---the-manager-itself-communicates-with-an--as-abap--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abensap-nw-abap-glosry-htm--glossary-entry---work-process--whose-task-handler-controls-icf---communication-can-run-in-either-direction--meaning-that-as-abap-can-be-a-server-or-a-client--within-icf--this-aspect-is-implemented-using-different-branches-with-their-own-interfaces-and-classes--abap-programs-can-both-respond-to-requests-from-the-internet-and-provide-a-service-with-data-for-further-handling-and-itself-query-data-from-internet--this-is-done-by-implementing-the-appropriate-interfaces---notes------before-each-response-is-sent-in-an-as-abap-as-icf-server-or-icf-client--a--database-commit--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abendatabase-commit-glosry-htm--glossary-entry---is-executed--except-in--updates--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenupdate-glosry-htm--glossary-entry----------requests-sent-from-icm-to-an-as-abap-open-a-separate--icf--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-session-glosry-htm--glossary-entry---session-here--where-as-abap-can-process-the-request-as-an-icf-server-------http-https-communication-is-not-bidirectional--which-means-that-one-partner-is-always-the-client-and-one-partner-is-always-the-server--bidirectional-communication-is-possible-using-the-websocket-protocol-or-tcp-with--abap-push-channels--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenapc-htm----as-abap-as-an-icf-server--each-service-that-is-reachable-from-the-internet-and-for-which-as-abap-is-used-as-an-icf-server-must-be-created-as-a-node-in-the-service-tree-in-the-service-editor--transaction-sicf---a-service-of-this-type-is-a-transportable-repository-object-that-determines-the-properties-of-the-service---the-initial-node-of-the-service-tree-stands-for-the-as-abap-web-address-consisting-of-the-host-and-the-port--the-position-of-the-node-in-the-tree-determines-the-further-url-path-required-to-call-a-specific-service--a-url-can-contain-form-fields-after-the-actual-address-part--which-are-read-by-icf---before-a-response-can-be-made-to-a-http-request-sent-to-a-service-in-the-service-tree-in-transaction-sicf--at-least-one-global-class-must-be-assigned-to-this-service--this-class-must-implement-the-interface-if--http--extension-and-have-access-to-the-icf-infrastructure--when-a-request-is-sent-to-the-service--icf-creates-a-http-request-handler-as-an-instance-of-this-class--the-implemented-interface-has-only-one-method--handle--request--whose-input-parameter-server-is-a-reference-to-the-server-object-represented-by-if--http--server--the-attributes-and-methods-of-the-server-object-make-it-possible-to-query-properties-of-the-request--such-as-the-content-of-the-form-fields-in-the-url-and-to-pass-data-to-the-server-in-a-suitable-format--such-as-html-or-xml--the-most-important-are-the-attributes-request-and-response--which-refer-to-objects-that-implement-the-interfaces-if--http--request-or-if--http--response---an-http-https-request-in-an-http-request-handler-is-handled-as--icf-processing--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-processing-glosry-htm--glossary-entry---in-a-separate--icf-session--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-session-glosry-htm--glossary-entry----here--certain-statements--like--message--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abapmessage-htm--or--break-point--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abapbreak-point-htm---are-handled-differently-than--for-example--in-dialog-processing--external-breakpoints-can-be-set-to-debug-programs-during-icf-processing---notes------special-url-form-fields--such-as-sap-user--sap-client--or-sap-language--all-start-with-the-prefix-sap--and-are-evaluated-accordingly-when-logons-are-made-to-an-icf-session-------a-special-handler-class-can-be-used-to-access-objects-from-the-mime-repository-directly-using-icf-services--see-the--executable-example--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-mime-pictures-abexa-htm---------alongside-the-nodes-that-represent-http-services--the-nodes-for--abap-push-channels--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenapc-htm--addressed-using-the-websocket-protocol-or-tcp-are-defined-in-the-service-tree-in-icf---executable-examples-------calling-an-http-service--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-service-abexa-htm-------one-production-example-of-a-self-programmed-http-service-is-the-web-version-of-this-documentation-itself--as-abap-as-an-icf-client--if-the-proxy-setting-for-the-http-client-is-configured-appropriately-in-transaction-sicf--abap-programs-can-send-requests-to-the-internet-using-icf-and-receive-responses--this-is-done-using-client-objects-from-the-class-cl--http--client--which-implements-the-interface-if--http--client--a-client-object-can-be-created-using-a-factory-method-from-this-class--which-associates-it-with-a-web-address--like-a-server-object--the-attributes-request-and-response-reference-objects-that-implement-the-interfaces-if--http--request-or-if--http--response-and-that-can-be-used-to-send-requests-and-receive-responses---executable-example--abap-as--http-client--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-client-abexa-htm---icf-security--the-api-of-icf-enables-virus-scans-to-be-run-using-the-virus-scan-interface--vsi---the-required-virus-scan-profile-for-the-scan-can-be-selected---if-html-pages-can-be-created-on-an-icf-server--it-may-be-possible-to-prevent--cross-side-scripting--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenxss-scrty-htm---this-is-usually-a-task-of-frameworks-based-on-icf-but-it-is-also-important-not-to-forget-this-for-directly-created-html-pages---other-security-gaps-also-need-to-be-blocked--for-example--pages-delivered-from-an-icf-server-should-be-protected-against-clickjacking-attacks--a-clickjacking-attack-integrates-a-page-into-the-framework-of-an-external-web-page-and-tricks-the-reader-into-clicking-on-malicious-links--this-can-be-prevented-in-the-http-request-handler-by-using-a-method-call--server--response--set--header--field--name----x-frame-options--value---------------provided-that-the-values--sameorigin--or--deny--can-be-passed-to-value--server-is-a-reference-variable--which-points-to-the-server-object----more-information------detailed-information-about-icf-and-icm-can-be-found-in-the-internet-communication-framework-documentation-in-sap-help-portal-------this-documentation-also-describes-communication-between-as-abap-and-the-internet--based-on-class-wrappers-or-icf-enhancements-such-as-abap-web-services-or-the-abap-rest-library---continue--icf-examples--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-abexas-htm--------abenicf-abexas-htm------title---icf-examples--description-------example-exa-gif--example---calling-an-http-service-https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-service-abexa-htm---example-exa-gif--example---calling-an-http-service-using-the-post-method-https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-post-service--version---7-54--category---general--type---abap-reference--sourceurl---https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-abexas-htm--abapfile---abenicf-abexas-htm--keywords----do----if----method----data----abenicf----abexas---------------as-abap-release-754---copyright-2019-sap-se--all-rights-reserved----abap-keyword-documentation--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenabap-htm------abap---reference--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenabap-reference-htm------data-interfaces-and-communication-interfaces--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenabap-data-communication-htm------icf---internet-communication-framework--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-htm------icf-examples--continue---example--exa-gif--example----calling-an-http-service--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-service-abexa-htm----example--exa-gif--example----calling-an-http-service-using-the-post-method--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-post-service-abexa-htm----example--exa-gif--example----abap-as-http-client--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-client-abexa-htm----example--exa-gif--example----accessing-the-mime-repository-using-icf--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-mime-pictures-abexa-htm----example--exa-gif--example----accessing-the-mime-repository-from-a-http-service--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenhttp-mime-pictures-abexa-htm--------abenicf-service-abexa-htm------title---calling-an-http-service--description------this-example-demonstrates-how-an-icf-https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-glosry-htm--glossary-entry---http-service-is-called-directly-using-a-web-browser--source-code-report-demo-http-service--class-demo-definition--public-section--class-methods-main--class-methods-version---7-54--category---general--type---abap-reference--sourceurl---https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-service-abexa-htm--abapfile---abenicf-service-abexa-htm--keywords----select----do----if----try----method----class----data----internal-table----abenicf----service----abexa---------------as-abap-release-754---copyright-2019-sap-se--all-rights-reserved----abap-keyword-documentation--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenabap-htm------abap---reference--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenabap-reference-htm------data-interfaces-and-communication-interfaces--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenabap-data-communication-htm------icf---internet-communication-framework--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-htm------icf-examples--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-abexas-htm------calling-an-http-service--this-example-demonstrates-how-an--icf--https---help-sap-com-doc-abapdocu-754-index-htm-7-54-en-us-abenicf-glosry-htm--glossary-entry---http-service-is-called-directly-using-a-web-browser---source-code--report-demo--http--service--class-demo-definition----public-section------class-methods-main------class-methods-class--constructor----private-section------class-data-icf--node-type-string--endclass--class-demo-implementation----method-main------if-icf--node-is-initial--------return------endif------data-carrid-type-spfli-carrid-value--aa-------cl--demo--input--request--changing-field---carrid--------data-url----icf--node-----------------------sap-client-------sy-mandt-----------------------sap-language-------------------------cl--i18n--languages--sap1--to--sap2--sy-langu-------------------------carrid-----------carrid------cl--demo--output--display--html----------html--------------body-------------link-to-http-service--br--br--------------a-href----url----target----blank----url----a---------------body---------------html-------endmethod----method-class--constructor------constants-path-type-string-value----sap-bc-abap-demo--------data-location----------cl--http--server--get--location--application---path--------if-location-is-not-initial--------icf--node---location----path------endif----endmethod--endclass--start-of-selection----demo--main------description--any-http-service-defined-in-the-service-transaction-sicf-can-be-tested-here--if-the-url-of-the-service-is-known--it-can-be-called-from-the-internet--for-example-by-entering-an-address-in-a-browser--in-this-example--a-service-of-this-type-is-called-using-a-generated-webpage--which-contains-a-link-to-the-url-of-the-service--the-url-is-constructed-from-the-host-and-port-of-the-current-as-instance--the-path-in-the-service-tree--and-a-form-field--the-host-and-port-are-filled-using-the-method-cl--http--server--get--location--the-form-field-carrid-is-filled-with-the-content-of-a-field-filled-previously-by-user-input--when-this-link-is-chosen--the-browser-displays-the-html-page-returned-by-the-service--the-content-of-the-form-field-carrid-can-be-modified-in-the-input-field-of-the-browser--to-display-different-data---the-called-http-service-is-defined-as-the-node--sap-bc-abap-demo-in-the-transaction-sicf--the-assigned-http-request-handler-is-the-class-cl--http--ext--service--demo--if-a-form-field------carrid------is-added-to-the-url-of-the-service--the-content-of-this-field-is-used-as-a-key-for-selecting-associated-data-from-the-database-table-spfli--this-is-achieved-by-the-class-cl--http--ext--service--demo-implementing-the-interface-if--http--extension-and-its-method-handle--request--this-method-is-called-by-icf-and-a-reference-is-passed-to-a-server-object-that-implements-the-interface-if--http--server--the-attributes-request-and-response-of-this-interface-refer-to-objects--which-are-implemented-by-the-interfaces-if--http--request-or-if--http--response--the-request-object-is-used-to-read-the-form-field--the-response-object-returns-the-result---method-if--http--extension-handle--request----select-------------from-spfli----------where-carrid---( to\_upper(
           cl\_abap\_dyn\_prg=>escape\_quotes(
             val = escape( val = server->request->get\_form\_field(
                                                    name = \`carrid\` )
                           format = cl\_abap\_format=>e\_xss\_ml ) ) ) )
         INTO TABLE @DATA(connections) ##no\_text.
  "cl\_demo\_output=>get converts ABAP data to HTML and is secure
  server->response->set\_cdata(
    data = cl\_demo\_output=>get( connections ) ).
ENDMETHOD.

The built-in function [escape](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenescape_functions.htm) and the method ESCAPE\_QUOTES of the class CL\_ABAP\_DYN\_PRG are using to prevent [cross site scripting](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenxss_glosry.htm "Glossary Entry") and [SQL injections](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensql_injection_glosry.htm "Glossary Entry"). The content of the internal table connections (filled in accordance with the passed form field) is converted to HTML using the class CL\_DEMO\_OUTPUT before it is passed to the RESPONSE object.

Note

The HTTP service must be activated in transaction SICF before the example can work.


### abenicf_post_service_abexa.htm

---
title: "Calling an HTTP Service Using the POST Method"
description: |
  This example demonstrates calls of an HTTP service in ICF(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_glosry.htm 'Glossary Entry') and a Web browser. The input data is passed using the POST method. Source Code REPORT demo_http_post_service. CLASS demo DEFINITION. PUBLIC S
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_post_service_abexa.htm"
abapFile: "abenicf_post_service_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abenicf", "post", "service", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ICF - Internet Communication Framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf.htm) →  [ICF Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_abexas.htm) → 

Calling an HTTP Service Using the POST Method

This example demonstrates calls of an HTTP service in [ICF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_glosry.htm "Glossary Entry") and a Web browser. The input data is passed using the POST method.

Source Code

REPORT demo\_http\_post\_service.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS class\_constructor.
  PRIVATE SECTION.
    CLASS-DATA icf\_node TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF icf\_node IS INITIAL.
      RETURN.
    ENDIF.
    DATA(url) = icf\_node &&
                \`?sap-client=\` && sy-mandt &&
                \`&sap-language=\`
                  && cl\_i18n\_languages=>sap1\_to\_sap2( sy-langu ).
    cl\_demo\_output=>display\_html(
      |<html>| &&
      |<body>| &&
      |Link to HTTP-Service:<br><br>| &&
      |<a href="{ url }" target="\_blank">{ url }</a>| &&
      |</body>| &&
      |</html>| ).  ENDMETHOD.
  METHOD class\_constructor.
    CONSTANTS path TYPE string VALUE \`/sap/bc/abap/demo\_post\`.
    DATA(location) =
      cl\_http\_server=>get\_location( application = path ).
    IF location IS NOT INITIAL.
      icf\_node = location && path.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example has the same structure as the executable example [Calling an HTTP Service](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_service_abexa.htm). In this case, the method IF\_HTTP\_EXTENSION~HANDLE\_REQUEST of the class CL\_HTTP\_EXT\_SERVICE\_POST\_DEMO is used to demonstrate how user input sent by a HTML page form generated by the handler class is sent using the POST method and read using the method GET\_CDATA.

Note

The HTTP service must be activated in transaction SICF before the example can work.


### abenicf_client_abexa.htm

---
title: "ABAP as HTTP Client"
description: |
  This example demonstrates an ICF(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_glosry.htm 'Glossary Entry') client object. Source Code REPORT demo_http_client. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA q
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_client_abexa.htm"
abapFile: "abenicf_client_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abenicf", "client", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ICF - Internet Communication Framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf.htm) →  [ICF Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_abexas.htm) → 

ABAP as HTTP Client

This example demonstrates an [ICF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_glosry.htm "Glossary Entry") client object.

Source Code

REPORT demo\_http\_client.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA query TYPE string VALUE 'SAP'.
    cl\_demo\_input=>request( CHANGING field = query ).
    cl\_http\_client=>create(
      EXPORTING
        host =    'wikipedia.org'
        service = ''
      IMPORTING
        client = DATA(client)
      EXCEPTIONS
        OTHERS = 4 ).
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    cl\_http\_utility=>set\_request\_uri(
      request = client->request
      uri     = \`/wiki/\` && query ).
    client->send(
      EXCEPTIONS
        OTHERS = 4 ).
    IF sy-subrc <> 0.
      client->get\_last\_error(
        IMPORTING message = DATA(smsg) ).
      cl\_demo\_output=>display( smsg ).
      RETURN.
    ENDIF.
    client->receive(
      EXCEPTIONS
        OTHERS = 4 ).
    IF sy-subrc <> 0.
      client->get\_last\_error(
        IMPORTING message = DATA(rmsg) ).
      cl\_demo\_output=>display( rmsg ).
      RETURN.
    ENDIF.
    DATA(html) = client->response->get\_cdata( ).
    cl\_demo\_output=>display\_html( html ).
    client->close( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The factory method CREATE of the class CL\_HTTP\_CLIENT is used to create a client object for the address wikipedia.org. The reference variable client of the type IF\_HTTP\_CLIENT points to this object. A specific request, which also contains the value of a user input, is added to the URI of the REQUEST object of the client object. The request is sent and the result is passed to the RESPONSE object of the client object. In the case in question, the HTML page produced by the requested is retrieved and displayed.

Note

The proxy setting for the HTTP client must be configured correctly in transaction SICF before this example can work.


### abenicf_mime_pictures_abexa.htm

---
title: "Accessing the MIME Repository Using ICF"
description: |
  This example demonstrates how the MIME repository is accessed using a HTTP service in ICF(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_glosry.htm 'Glossary Entry'). Source Code REPORT demo_picture_from_mime. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. CLASS-
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_mime_pictures_abexa.htm"
abapFile: "abenicf_mime_pictures_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "abenicf", "mime", "pictures", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ICF - Internet Communication Framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf.htm) →  [ICF Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_abexas.htm) → 

Accessing the MIME Repository Using ICF

This example demonstrates how the MIME repository is accessed using a HTTP service in [ICF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_picture\_from\_mime.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS class\_constructor.
  PRIVATE SECTION.
    CLASS-DATA icf\_node TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF icf\_node IS INITIAL.
      RETURN.
    ENDIF.
    cl\_demo\_output=>display\_html(
      \`<html><body><basefont face="arial">\`                &&
      \`Picture from MIME Repository<br><br>\`               &&
       \`<img src="\` && icf\_node
                    && \`/ABAP\_Docu\_Logo.gif?sap-client=\`
                    && sy-mandt
                    && \`">\`                                &&
       \`</body></html>\`  ).  ENDMETHOD.
  METHOD class\_constructor.
    CONSTANTS path TYPE string VALUE \`/sap/public/bc/abap/mime\_demo\`.
    DATA(location) =
      cl\_http\_server=>get\_location( application = path ).
    IF location IS NOT INITIAL.
      icf\_node = location && path.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

If a path to a HTTP service from ICF is constructed in the same way in transaction SICF as the path to a MIME repository node and the handler class CL\_HTTP\_EXT\_WEBDAV\_PUBLIC is assigned to the service, the service can be used to access the MIME objects of this node directly.

The example contains the node /sap/public/bc/abap/mime\_demo in both the transaction SICF and in the MIME repository. The image ABAP\_Docu\_Logo.gif is saved in the MIME repository under this node. The handler class CL\_HTTP\_EXT\_WEBDAV\_PUBLIC is assigned to the ICF node. The name of the image can be added to the URL of the service and used to access the image directly.

See also the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmime_pictures_abexa.htm) for accessing objects from the MIME repository using the associated API.


### abenhttp_mime_pictures_abexa.htm

---
title: "Accessing the MIME Repository from a HTTP Service"
description: |
  This example demonstrates how the MIME repository is accessed using an HTTP service in ICF(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_glosry.htm 'Glossary Entry'). Source Code REPORT demo_http_mime. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. CLASS-METHODS
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhttp_mime_pictures_abexa.htm"
abapFile: "abenhttp_mime_pictures_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "abenhttp", "mime", "pictures", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ICF - Internet Communication Framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf.htm) →  [ICF Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_abexas.htm) → 

Accessing the MIME Repository from a HTTP Service

This example demonstrates how the MIME repository is accessed using an HTTP service in [ICF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_http\_mime.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS class\_constructor.
  PRIVATE SECTION.
    CLASS-DATA icf\_node TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF icf\_node IS INITIAL.
      RETURN.
    ENDIF.
    DATA(url) = icf\_node
                  && \`?sap-client=\`
                  && sy-mandt
                  && \`&sap-language=\`
                  && cl\_i18n\_languages=>sap1\_to\_sap2( sy-langu ).
    DATA(url\_icf) = url && \`&mime\_access=icf\`.
    DATA(url\_api) = url && \`&mime\_access=api\`.
    cl\_demo\_output=>display\_html(
     |<html>| &&
     |<body>| &&
     |Link to HTTP-Service getting picture from ICF:<br><br>| &&
     |<a href="{ url\_icf }" target="\_blank">{ url\_icf }</a><br><br>| &&
     |Link to HTTP-Service getting picture from API:<br><br>| &&
     |<a href="{ url\_api }" target="\_blank">{ url\_api }</a><br><br>| &&
     |</body>| &&
     |</html>| ).  ENDMETHOD.
  METHOD class\_constructor.
    CONSTANTS path TYPE string VALUE \`/sap/bc/abap/demo\_mime\`.
    DATA(location) =
      cl\_http\_server=>get\_location( application = path ).
    IF location IS NOT INITIAL.
      icf\_node = location && path.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The HTTP service /sap/bc/abap/demo\_mime can be called with different contents of the form field mime\_access of the URL:

-   If the form field has the value icf, the handler class CL\_HTTP\_EXT\_MIME\_DEMO creates an HTML file. This file points to an image in the MIME repository (as described in a different executable [example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_mime_pictures_abexa.htm)).

-   If the form field has the value api, the handler class CL\_HTTP\_EXT\_MIME\_DEMO creates the HTML file and also the image that is referenced in the HTML file. The image is loaded and forwarded using MIME-API.


### abenicf_abexas.htm

---
title: "ICF Examples"
description: |
  !Example(exa.gif 'Example') Calling an HTTP Service(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_service_abexa.htm) !Example(exa.gif 'Example') Calling an HTTP Service Using the POST Method(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_post_service_
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_abexas.htm"
abapFile: "abenicf_abexas.htm"
keywords: ["do", "if", "method", "data", "abenicf", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ICF - Internet Communication Framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf.htm) → 

ICF Examples

Continue
![Example](exa.gif "Example") [Calling an HTTP Service](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_service_abexa.htm)
![Example](exa.gif "Example") [Calling an HTTP Service Using the POST Method](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_post_service_abexa.htm)
![Example](exa.gif "Example") [ABAP as HTTP Client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_client_abexa.htm)
![Example](exa.gif "Example") [Accessing the MIME Repository Using ICF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_mime_pictures_abexa.htm)
![Example](exa.gif "Example") [Accessing the MIME Repository from a HTTP Service](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhttp_mime_pictures_abexa.htm)


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP Channels / AMC - ABAP Messaging Channels

**Files**: 7 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP Channels / APC - ABAP Push Channels / Examples of APC

Included pages: 7


### abenapc_abexas.htm

---
title: "Examples of APC"
description: |
  !Example(exa.gif 'Example') APC, AS ABAP as WebSocket Server(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm) !Example(exa.gif 'Example') APC, AS ABAP as WebSocket Client(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_ws_client_abexa.htm) !Ex
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm"
abapFile: "abenapc_abexas.htm"
keywords: ["do", "if", "data", "abenapc", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) → 

Examples of APC

Continue
![Example](exa.gif "Example") [APC, AS ABAP as WebSocket Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm)
![Example](exa.gif "Example") [APC, AS ABAP as WebSocket Client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_ws_client_abexa.htm)
![Example](exa.gif "Example") [APC, AS ABAP as TCP Socket Client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_tcp_client_abexa.htm)
![Example](exa.gif "Example") [APC, Creating a Detached Client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_detached_client_abexa.htm)
![Example](exa.gif "Example") [APC, AS ABAP as Attached Client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_attached_client_abexa.htm)
![Example](exa.gif "Example") [APC, System-Wide Access](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_connect_via_handle_abexa.htm)


### abenapc_abexa.htm

---
title: "APC, AS ABAP as WebSocket Server"
description: |
  This example demonstrates ABAP push channel(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_glosry.htm 'Glossary Entry')s in AS ABAP as a WebSocket server. Source Code REPORT demo_apc_wsp. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. CLASS-METHODS class_construc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm"
abapFile: "abenapc_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "abenapc", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, AS ABAP as WebSocket Server

This example demonstrates [ABAP push channel](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_glosry.htm "Glossary Entry")s in AS ABAP as a WebSocket server.

Source Code

REPORT demo\_apc\_wsp.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS class\_constructor.
  PRIVATE SECTION.
    CLASS-DATA url TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF url IS INITIAL.
      RETURN.
    ENDIF.
    DATA amc TYPE abap\_bool VALUE 'X'.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    cl\_demo\_input=>add\_line( ).
    DATA pcp TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = pcp ).
    DATA pcp\_stateful TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = pcp\_stateful ).
    cl\_demo\_input=>request( ).
    amc = to\_upper( amc ).
    cl\_demo\_output=>display\_html(
      |<html>| &&
      |<body>| &&
      |<a href="{ COND string( WHEN pcp IS INITIAL AND
                                    pcp\_stateful IS INITIAL THEN url
                               ELSE url && \`\_pcp\` )
        }?sap-client={ sy-mandt
        }&sap-language={ cl\_i18n\_languages=>sap1\_to\_sap2( sy-langu )
        }{ COND string( WHEN amc = abap\_true
             THEN \`&amc=x\`
             ELSE \`\` )
        }{ COND string( WHEN pcp\_stateful = abap\_true
             THEN \`&pcp\_stateful=x\`
             ELSE \`\` )
        }" target="\_blank">| &&
        |Open demo web page with standard browser</a><br><br>| &&
      |If your browser does not support WebSocket, | &&
      |copy the URL to another browser.| &&
      |</body>| &&
      |</html>| ).  ENDMETHOD.
  METHOD class\_constructor.
    CONSTANTS path TYPE string VALUE \`/sap/bc/abap/demo\_apc\`.
    DATA(location) =
      cl\_http\_server=>get\_location( application = path ).
    IF location IS NOT INITIAL.
      url = location && path.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example demonstrates bidirectional communication between a browser that supports the WebSocket protocol as an APC client and AS ABAP as an APC server. The example program above has the task of displaying a webpage that communicates with the current AS ABAP. It is possible to specify the following:

-   Is the APC used associated with an [ABAP messaging channel (AMC)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc.htm)?

-   Is an APC used together with the [Push Channel Protocol (PCP)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpush_channel_protocol_glosry.htm "Glossary Entry") or is an APC used without this protocol?

-   Is a stateful service used when the subprotocol PCP is used?

The Web page is provided by an [ICF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf.htm) HTTP service whose URL is constructed in the program for the current AS Instance. If the standard browser called does not support communication using the WebSocket protocol, you must open the URL using a suitable browser instead.

The communication partners are:

-   The Web pages generated in the HTTP request handler CL\_HTTP\_EXT\_APC\_DEMO or CL\_HTTP\_EXT\_APC\_PCP\_DEMO. One Web page makes it possible to open a WebSocket object without Push Channel Protocol (PCP) support and the other Web page makes it possible to open a WebSocket object with the support of this protocol. Both Web pages make it possible to send messages using the object and to close the object. These tasks are performed by a JavaScript function implemented in the Web page. If PCP is used, a JavaScript file sap-pcp-websocket.js is included from the Mime repository in AS ABAP. This file provides the client-side framework for using this protocol. This API is not needed if PCP is not used. If the PCP protocol is used, it is possible to access both a stateless ABAP channel and a stateful channel.

-   The ABAP push channel DEMO\_APC, DEMO\_APC\_PCP, or DEMO\_APC\_PCP\_STATEFUL from the package SABAPDEMOS in the current AS ABAP (with the latter two supporting the Push Channel Protocol (PCP) and the latter being stateful). The URL of the service assigned to the push channel is used in the JavaScript function of the associated Web page to open the WebSocket communication of this Web page. The form field amc is passed further. The APC handler classes CL\_APC\_WS\_EXT\_DEMO\_APC and CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP implement the methods ON\_START and ON\_MESSAGE of the interface IF\_APC\_WSP\_EXTENSION for communication with and without a connection to an [AMC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc.htm). The APC handler class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP\_ST demonstrates a stateful service by simply calling the identically named methods of an object of the class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP. The AMC used here is /demo\_text or /demo\_pcp from the [executable examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc_abexas.htm) for AMC. When a message is received, the method ON\_MESSAGE creates a new message with information about the received message and sends it. If PCP is not used, a text message is sent. In the version for PCP, this protocol is used. CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP demonstrates the stateful service by raising a counter whose value stays the same in stateless services.

If the ABAP push channel is opened using the form field amc=x, communication takes place using AMC. Each Web page bound to the push channel receives every message sent using AMC. In the example, this means that the message sent by ON\_MESSAGE is not just received by the Web page that sent a message. Furthermore, the Web pages bound to the push channel receive messages sent, for example, using the program DEMO\_SEND\_AMC from the executable example [Sending AMC Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc_send_abexa.htm). Conversely, the program DEMO\_RECEIVE\_AMC receives the messages sent from the Web pages from the executable example [Receiving AMC Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc_receive_abexa.htm).

Note

Before this example can work, the protocols WEBSOCKET and WEBSOCKETS must be specified as active services in the Services function in the transaction SMICM.


### abenapc_ws_client_abexa.htm

---
title: "APC, AS ABAP as WebSocket Client"
description: |
  This example demonstrates AS ABAP as a WebSocket client. Source Code REPORT demo_apc_client. CLASS apc_handler DEFINITION FINAL. PUBLIC SECTION. INTERFACES if_apc_wsp_event_handler_pcp. DATA       message TYPE string. ENDCLASS. CLASS apc_handler IMPLEMENTATION. METHOD if_apc_wsp_event_h
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_ws_client_abexa.htm"
abapFile: "abenapc_ws_client_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenapc", "client", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, AS ABAP as WebSocket Client

This example demonstrates AS ABAP as a WebSocket client.

Source Code

REPORT demo\_apc\_client.
CLASS apc\_handler DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler\_pcp.
    DATA       message TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_open.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_message.
    TRY.
        me->message = i\_message->get\_text( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        me->message = apc\_error->get\_text( ).
      CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
        cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_close.
    me->message = 'Connection closed!'.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_error.
    cl\_demo\_output=>display( 'Error!' ).
    LEAVE PROGRAM.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA stateful\_server TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = stateful\_server ).
    DATA messages TYPE i VALUE '5'.
    cl\_demo\_input=>add\_field(  CHANGING field  = messages ).
    DATA wait TYPE i VALUE '10'.
    cl\_demo\_input=>add\_field(  CHANGING field  = wait ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Client
        DATA(client) =
          cl\_apc\_wsp\_client\_manager=>create\_by\_destination(
            i\_destination = 'NONE'
            i\_event\_handler = event\_handler
            i\_protocol =
              if\_apc\_wsp\_event\_handler\_pcp=>co\_event\_handler\_type ).
        "Server
        DATA(request) =
          client->get\_context( )->get\_initial\_request( ).
        request->set\_path\_and\_query(
          i\_relative\_uri =
            \`/sap/bc/apc/sap/demo\_apc\_pcp\` &&
            COND #(
               WHEN stateful\_server = abap\_true THEN \`\_stateful\` ) &&
            COND #(
              WHEN amc = abap\_true THEN \`?amc=x\` ) ).
        client->connect( ).
        "Sending messages
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager\_pcp(
            client->get\_message\_manager( ) ).
        DATA(message) =
          CAST if\_ac\_message\_type\_pcp(
            message\_manager->create\_message( ) ).
        TRY.
            IF amc = abap\_true.
              message->set\_field( i\_name = 'amc' i\_value = 'x' ).
            ENDIF.
            message->set\_text( msg ).
          CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
            cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
            LEAVE PROGRAM.
        ENDTRY.
        DO messages TIMES.
          message\_manager->send( message ).
        ENDDO.
        "Receiving messages
        DO wait TIMES.
          out->line( ).
          CLEAR event\_handler->message.
          WAIT FOR PUSH CHANNELS
               UNTIL event\_handler->message IS NOT INITIAL
               UP TO 1 SECONDS.
          IF sy-subrc = 4.
            out->write\_text(
              'No handler for APC messages registered' ).
          ELSEIF sy-subrc = 8.
            out->write\_text(
              'Timeout occurred!' ).
          ELSE.
            out->write\_text(
             |Received APC message: \\n\\n{
               event\_handler->message } | ).
          ENDIF.
        ENDDO.
        out->line( ).
        "Close connection
        client->close( i\_reason = 'Application closed connection!' ).
        out->display( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create an [APC client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) for the WebSocket protocol.

-   The local class apc\_handler, which implements the interface IF\_APC\_WSP\_EVENT\_HANDLER\_PCP, is used as the handler class. When a message is received, the method on\_message sets its message attribute to the message text.

-   CL\_APC\_WSP\_CLIENT\_MANAGER is used to create a client object for the current AS ABAP as an APC server and opens a connection to one of its ABAP push channels. It is possible to select which of the two ABAP push channels, DEMO\_APC\_PCP or DEMO\_APC\_PCP\_STATEFUL, from the executable example [AS ABAP as WebSocket Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm) is used. The server can also be instructed to send its messages using [ABAP messaging channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc.htm).

-   The message manager of the client object is used to create a message in [PCP format](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp.htm) and send it multiple times.

-   The statement [WAIT FOR PUSH CHANNELS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_apc.htm) is then used to switch the program to a wait state so that messages sent back from the server can be handled. Here, the logical expression checks the attribute message of the handler class apc\_handler. A received text is displayed.

-   Finally, the connection is closed explicitly.

It is possible to select how many messages are sent and how often the wait state occurs.

-   If communication takes place with the stateful server, the counter level of the server is raised, indicating that multiple messages are being sent and received.

-   If the server sends its messages using ABAP messaging channels, other AMC receivers in the same messaging channel can also see the messages of the server. For example, the Web browser from the executable example [AS ABAP as WebSocket Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm) can receive these messages. In the reverse direction, the APC client can then also receive those messages sent by the APC server as a response to messages from the Web browser, if they occur in one of the programmed wait periods.


### abenapc_tcp_client_abexa.htm

---
title: "APC, AS ABAP as TCP Socket Client"
description: |
  This example demonstrates AS ABAP as a TCP socket client. Source Code REPORT demo_apc_tcp_client. CLASS apc_handler DEFINITION FINAL . PUBLIC SECTION. INTERFACES if_apc_wsp_event_handler. DATA       message TYPE string. ENDCLASS. CLASS apc_handler IMPLEMENTATION. METHOD if_apc_wsp_event
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_tcp_client_abexa.htm"
abapFile: "abenapc_tcp_client_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "types", "abenapc", "tcp", "client", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, AS ABAP as TCP Socket Client

This example demonstrates AS ABAP as a TCP socket client.

Source Code

REPORT demo\_apc\_tcp\_client.
CLASS apc\_handler DEFINITION FINAL .
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler.
    DATA       message TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler~on\_open.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_message.
    TRY.
        message = i\_message->get\_text( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        message = apc\_error->get\_text( ).
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_close.
    message = 'Connection closed!'.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_error.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(tcp\_server) = \`C:\\ncat\\ncat.exe\`.
    DATA(ip\_adress)  = cl\_gui\_frontend\_services=>get\_ip\_address( ).
    DATA(port)       = \`12345\`.
    DATA(terminator) = \`0A\`.
    DATA(msg)        = \`Hello TCP, answer me!\`.
    cl\_demo\_input=>new(
      )->add\_text(
         \`For the TCP server, download the freely available NCAT.EXE\`
      )->add\_field( CHANGING field = tcp\_server
      )->add\_field( CHANGING field = ip\_adress
      )->add\_field( CHANGING field = port
      )->add\_field( CHANGING field = terminator
      )->add\_field( CHANGING field = msg
      )->request( ).
    "Server
    IF cl\_gui\_frontend\_services=>file\_exist(
         file = tcp\_server ) IS INITIAL.
      cl\_demo\_output=>display( 'TCP Server not found!' ).
      LEAVE PROGRAM.
    ENDIF.
    cl\_gui\_frontend\_services=>execute(
    EXPORTING
      application = \`cmd.exe\`
      parameter  =  \`/c \` && tcp\_server &&
                   \` -l \` && ip\_adress && \` -p \` && port ).
    WAIT UP TO 1 SECONDS.
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Client
        DATA(client) = cl\_apc\_tcp\_client\_manager=>create(
          i\_host   = ip\_adress
          i\_port  = port
          i\_frame = VALUE apc\_tcp\_frame(
            frame\_type =
              if\_apc\_tcp\_frame\_types=>co\_frame\_type\_terminator
            terminator =
              terminator )
          i\_event\_handler = event\_handler ).
        client->connect( ).
        "Send mesasage from client
        DATA(message\_manager) = CAST if\_apc\_wsp\_message\_manager(
          client->get\_message\_manager( ) ).
        DATA(message) = CAST if\_apc\_wsp\_message(
          message\_manager->create\_message( ) ).
        DATA(binary\_terminator) = CONV xstring( terminator ).
        DATA(binary\_msg) =
          cl\_abap\_conv\_codepage=>create\_out( )->convert( msg ).
        CONCATENATE binary\_msg binary\_terminator
               INTO binary\_msg IN BYTE MODE.
        message->set\_binary( binary\_msg ).
        message\_manager->send( message ).
        "Wait for a message from server
        CLEAR event\_handler->message.
        WAIT FOR PUSH CHANNELS
             UNTIL event\_handler->message IS NOT INITIAL
             UP TO 10 SECONDS.
        IF sy-subrc = 4.
          cl\_demo\_output=>display(
            'No handler for APC messages registered!' ).
        ELSEIF sy-subrc = 8.
          cl\_demo\_output=>display(
            'Timeout occurred!' ).
        ELSE.
          cl\_demo\_output=>display(
            |TCP client received:\\n\\n{ event\_handler->message }| ).
        ENDIF.
        client->close(
          i\_reason = 'Application closed connection!' ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create an [APC client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) for the TCP socket protocol. It is structured in exactly the same way as in the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_ws_client_abexa.htm) for the WebSocket client, but with the connection being made to a TCP socket server. The current front-end computer is used as the TCP socket server here and the available [Ncat](https://nmap.org/ncat/) can be downloaded to this computer.

This program requires the Ncat.exe directory and the address of the current front-end computer (proposals are made for this information). In addition, a terminator character is needed for the TCP framework structure.

When the program is executed, Ncat.exe is started and waits for messages from the APC client. Once a message is sent, this client waits for a message entered in the Ncat window and confirmed using Enter.


### abenapc_detached_client_abexa.htm

---
title: "APC, Creating a Detached Client"
description: |
  This example demonstrates how a detached client is created for the WebSocket protocol. Source Code REPORT demo_apc_detached_client. CLASS apc_handler DEFINITION FINAL. PUBLIC SECTION. INTERFACES if_apc_wsp_event_handler_pcp. DATA: connection_attach_handle TYPE string, message
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_detached_client_abexa.htm"
abapFile: "abenapc_detached_client_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenapc", "detached", "client", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, Creating a Detached Client

This example demonstrates how a detached client is created for the WebSocket protocol.

Source Code

REPORT demo\_apc\_detached\_client.
CLASS apc\_handler DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler\_pcp.
    DATA: connection\_attach\_handle TYPE string,
          message                  TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_open.
    TRY.
        connection\_attach\_handle =
          i\_context->get\_connection\_attach\_handle(
            EXPORTING i\_connection\_security =
              i\_context->co\_con\_security\_by\_user\_id ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        me->message = apc\_error->get\_text( ).
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_message.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_close.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_error.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA stateful\_server TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = stateful\_server ).
    DATA show\_attach\_handle TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = show\_attach\_handle ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Detached client
        DATA(client\_detach) =
          cl\_apc\_wsp\_client\_conn\_manager=>create\_by\_destination(
            i\_destination = 'NONE'
            i\_application\_id = \`DEMO\_APC\_PCP\`
            i\_event\_handler = event\_handler
            i\_protocol =
              if\_apc\_wsp\_event\_handler\_pcp=>co\_event\_handler\_type ).
        "Server
        DATA(request) =
          client\_detach->get\_context( )->get\_initial\_request( ).
        request->set\_path\_and\_query(
          i\_relative\_uri =
            \`/sap/bc/apc/sap/demo\_apc\_pcp\` &&
            COND #(
               WHEN stateful\_server = abap\_true THEN \`\_stateful\` ) &&
            COND #( WHEN amc = abap\_true THEN \`?amc=x\` ) ).
        client\_detach->connect\_and\_detach( ).
        IF event\_handler->message IS NOT INITIAL.
          out->display(
            |Error during ON\_OPEN: { event\_handler->message }| ).
          LEAVE PROGRAM.
        ENDIF.
        IF show\_attach\_handle IS INITIAL.
          "Attached client
          DATA(client\_attach) =
            cl\_apc\_wsp\_client\_conn\_manager=>attach(
              event\_handler->connection\_attach\_handle ).
          DATA(message\_manager) =
            CAST if\_apc\_wsp\_message\_manager\_pcp(
              client\_attach->get\_message\_manager( ) ).
          DATA(message) = CAST if\_ac\_message\_type\_pcp(
            message\_manager->create\_message( ) ).
          TRY.
              IF amc = abap\_true.
                message->set\_field( i\_name = 'amc' i\_value = 'x' ).
              ENDIF.
              message->set\_field(
                i\_name = 'detached\_client' i\_value = 'x' ).
              message->set\_text( msg ).
            CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
              cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
              LEAVE PROGRAM.
          ENDTRY.
          message\_manager->send( message ).
          client\_attach->close(
            i\_reason = 'Application closed connection!' ).
        ELSE.
          out->display(
            |Attach Handle:\\n\\n{
            event\_handler->connection\_attach\_handle
            }\\n\\nUse as input to DEMO\_APC\_ATTACH\_CLIENT.| ).
        ENDIF.
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create a [detached APC client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) for the WebSocket protocol.

-   The local class apc\_handler, which implements the interface IF\_APC\_WSP\_EVENT\_HANDLER\_PCP, is used as the handler class. The method on\_open gets a connection handle for the connection. The other methods are not needed.

-   CL\_APC\_WSP\_CLIENT\_CONN\_MANAGER is used to create a detached client object as an APC server for the current AS ABAP. It is possible to select which of the two ABAP push channels, DEMO\_APC\_PCP or DEMO\_APC\_PCP\_STATEFUL, from the executable example [AS ABAP as WebSocket Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm) is used. The server can also be instructed to send its messages using [ABAP messaging channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc.htm). The method CONNECT\_AND\_DETACH is used to create a detached client for the ABAP push channel.

-   The connection handle obtained by the method on\_open of the handler class can either be displayed or used immediately in the program to create an attached client for the detached client.

-   A displayed connection handle can be used in the program of the executable [attached client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_attached_client_abexa.htm) example.

-   If not, the method ATTACH of the class CL\_APC\_WSP\_CLIENT\_CONN\_MANAGER is used to create an attached client object for the connection handle. Its message manager is then used to create a message in [PCP format](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp.htm) and send it.

A breakpoint in the method ON\_MESSAGE of the APC handler class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP can be used to monitor the arrival and processing of the message (it is not possible to respond to messages from the same class here). If the message is sent using [AMC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc.htm), the response from the server is received by all associated AMC receivers. The attached client cannot itself wait for the response.


### abenapc_attached_client_abexa.htm

---
title: "APC, AS ABAP as Attached Client"
description: |
  This example demonstrates the AS ABAP as an attached client for a detached client. Source Code REPORT demo_apc_attach_client. CLASS apc_demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS apc_demo IMPLEMENTATION. METHOD main. DATA attach_handle TYPE string VALUE ' '. cl_demo
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_attached_client_abexa.htm"
abapFile: "abenapc_attached_client_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenapc", "attached", "client", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, AS ABAP as Attached Client

This example demonstrates the AS ABAP as an attached client for a detached client.

Source Code

REPORT demo\_apc\_attach\_client.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA attach\_handle TYPE string VALUE ' '.
    cl\_demo\_input=>add\_field( CHANGING field  = attach\_handle ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA close TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = close ).
    cl\_demo\_input=>request( ).
    TRY.
        "Attached client
        DATA(client\_attach) =
          cl\_apc\_wsp\_client\_conn\_manager=>attach( attach\_handle ).
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager\_pcp(
            client\_attach->get\_message\_manager( ) ).
        DATA(message) = CAST if\_ac\_message\_type\_pcp(
          message\_manager->create\_message( ) ).
        TRY.
            IF amc = abap\_true.
              message->set\_field( i\_name = 'amc' i\_value = 'x' ).
            ENDIF.
            message->set\_field(
              i\_name = 'detached\_client' i\_value = 'x' ).
            message->set\_text( msg ).
          CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
            cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
            LEAVE PROGRAM.
        ENDTRY.
        message\_manager->send( message ).
        IF close  = abap\_true.
          client\_attach->close(
            i\_reason = 'Application closed connection!' ).
        ENDIF.
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

The program expects a connection handle as input, as provided in the output of the executable [detached client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_detached_client_abexa.htm) example. The connection handle is used to create and employ an attached client object precisely as described in the detached client example. The connection handle can be reused indefinitely until the connection is closed using the method CLOSE. If the connection is not closed by mistake, this can be done later in the transaction SMWS.


### abenapc_connect_via_handle_abexa.htm

---
title: "APC, System-Wide Access"
description: |
  This example demonstrates access to any ABAP channel using a connection handle. Source Code REPORT demo_apc_access_connection. CLASS apc_demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS apc_demo IMPLEMENTATION. METHOD main. DATA attach_handle TYPE string VALUE ' '. cl_demo
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_connect_via_handle_abexa.htm"
abapFile: "abenapc_connect_via_handle_abexa.htm"
keywords: ["select", "do", "while", "if", "try", "catch", "method", "class", "data", "abenapc", "connect", "via", "handle", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, System-Wide Access

This example demonstrates access to any ABAP channel using a connection handle.

Source Code

REPORT demo\_apc\_access\_connection.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA attach\_handle TYPE string VALUE ' '.
    cl\_demo\_input=>add\_field( CHANGING field  = attach\_handle ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(access\_object) =
          cl\_apc\_wsp\_client\_conn\_manager=>attach( attach\_handle ).
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager(
            access\_object->get\_message\_manager( ) ).
        DATA(message) = CAST if\_apc\_wsp\_message(
          message\_manager->create\_message( ) ).
        message->set\_text( msg ).
        message\_manager->send( message ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

The program expects a valid connection handle for a WebSocket connection as its input, creates an access objects for this handle, and uses it to send a simple text message.

An APC connection from the executable example [AS ABAP as WebSocket Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm) publishes its connection handle as follows:

-   Create a WebSocket server without PCP.

-   Open the connection on the Web page.

-   Send the text message "get handle".

This message is identified in the method ON\_MESSAGE of the APC handler class CL\_APC\_WS\_EXT\_DEMO\_APC and the connection handle is fetched and sent. The Web page displays it in a form that can be copied. If the connection handle is passed to the program above while the connection is open, the message sent by the program is received and displayed by the Web page.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP Channels / APC - ABAP Push Channels / Examples of APC

**Files**: 7 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP Channels / APC - ABAP Push Channels / Examples of APC

Included pages: 7


### abenapc_abexas.htm

---
title: "Examples of APC"
description: |
  !Example(exa.gif 'Example') APC, AS ABAP as WebSocket Server(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm) !Example(exa.gif 'Example') APC, AS ABAP as WebSocket Client(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_ws_client_abexa.htm) !Ex
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm"
abapFile: "abenapc_abexas.htm"
keywords: ["do", "if", "data", "abenapc", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) → 

Examples of APC

Continue
![Example](exa.gif "Example") [APC, AS ABAP as WebSocket Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm)
![Example](exa.gif "Example") [APC, AS ABAP as WebSocket Client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_ws_client_abexa.htm)
![Example](exa.gif "Example") [APC, AS ABAP as TCP Socket Client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_tcp_client_abexa.htm)
![Example](exa.gif "Example") [APC, Creating a Detached Client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_detached_client_abexa.htm)
![Example](exa.gif "Example") [APC, AS ABAP as Attached Client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_attached_client_abexa.htm)
![Example](exa.gif "Example") [APC, System-Wide Access](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_connect_via_handle_abexa.htm)


### abenapc_abexa.htm

---
title: "APC, AS ABAP as WebSocket Server"
description: |
  This example demonstrates ABAP push channel(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_glosry.htm 'Glossary Entry')s in AS ABAP as a WebSocket server. Source Code REPORT demo_apc_wsp. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. CLASS-METHODS class_construc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm"
abapFile: "abenapc_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "abenapc", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, AS ABAP as WebSocket Server

This example demonstrates [ABAP push channel](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_glosry.htm "Glossary Entry")s in AS ABAP as a WebSocket server.

Source Code

REPORT demo\_apc\_wsp.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
    CLASS-METHODS class\_constructor.
  PRIVATE SECTION.
    CLASS-DATA url TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF url IS INITIAL.
      RETURN.
    ENDIF.
    DATA amc TYPE abap\_bool VALUE 'X'.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    cl\_demo\_input=>add\_line( ).
    DATA pcp TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = pcp ).
    DATA pcp\_stateful TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = pcp\_stateful ).
    cl\_demo\_input=>request( ).
    amc = to\_upper( amc ).
    cl\_demo\_output=>display\_html(
      |<html>| &&
      |<body>| &&
      |<a href="{ COND string( WHEN pcp IS INITIAL AND
                                    pcp\_stateful IS INITIAL THEN url
                               ELSE url && \`\_pcp\` )
        }?sap-client={ sy-mandt
        }&sap-language={ cl\_i18n\_languages=>sap1\_to\_sap2( sy-langu )
        }{ COND string( WHEN amc = abap\_true
             THEN \`&amc=x\`
             ELSE \`\` )
        }{ COND string( WHEN pcp\_stateful = abap\_true
             THEN \`&pcp\_stateful=x\`
             ELSE \`\` )
        }" target="\_blank">| &&
        |Open demo web page with standard browser</a><br><br>| &&
      |If your browser does not support WebSocket, | &&
      |copy the URL to another browser.| &&
      |</body>| &&
      |</html>| ).  ENDMETHOD.
  METHOD class\_constructor.
    CONSTANTS path TYPE string VALUE \`/sap/bc/abap/demo\_apc\`.
    DATA(location) =
      cl\_http\_server=>get\_location( application = path ).
    IF location IS NOT INITIAL.
      url = location && path.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example demonstrates bidirectional communication between a browser that supports the WebSocket protocol as an APC client and AS ABAP as an APC server. The example program above has the task of displaying a webpage that communicates with the current AS ABAP. It is possible to specify the following:

-   Is the APC used associated with an [ABAP messaging channel (AMC)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc.htm)?

-   Is an APC used together with the [Push Channel Protocol (PCP)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpush_channel_protocol_glosry.htm "Glossary Entry") or is an APC used without this protocol?

-   Is a stateful service used when the subprotocol PCP is used?

The Web page is provided by an [ICF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf.htm) HTTP service whose URL is constructed in the program for the current AS Instance. If the standard browser called does not support communication using the WebSocket protocol, you must open the URL using a suitable browser instead.

The communication partners are:

-   The Web pages generated in the HTTP request handler CL\_HTTP\_EXT\_APC\_DEMO or CL\_HTTP\_EXT\_APC\_PCP\_DEMO. One Web page makes it possible to open a WebSocket object without Push Channel Protocol (PCP) support and the other Web page makes it possible to open a WebSocket object with the support of this protocol. Both Web pages make it possible to send messages using the object and to close the object. These tasks are performed by a JavaScript function implemented in the Web page. If PCP is used, a JavaScript file sap-pcp-websocket.js is included from the Mime repository in AS ABAP. This file provides the client-side framework for using this protocol. This API is not needed if PCP is not used. If the PCP protocol is used, it is possible to access both a stateless ABAP channel and a stateful channel.

-   The ABAP push channel DEMO\_APC, DEMO\_APC\_PCP, or DEMO\_APC\_PCP\_STATEFUL from the package SABAPDEMOS in the current AS ABAP (with the latter two supporting the Push Channel Protocol (PCP) and the latter being stateful). The URL of the service assigned to the push channel is used in the JavaScript function of the associated Web page to open the WebSocket communication of this Web page. The form field amc is passed further. The APC handler classes CL\_APC\_WS\_EXT\_DEMO\_APC and CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP implement the methods ON\_START and ON\_MESSAGE of the interface IF\_APC\_WSP\_EXTENSION for communication with and without a connection to an [AMC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc.htm). The APC handler class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP\_ST demonstrates a stateful service by simply calling the identically named methods of an object of the class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP. The AMC used here is /demo\_text or /demo\_pcp from the [executable examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc_abexas.htm) for AMC. When a message is received, the method ON\_MESSAGE creates a new message with information about the received message and sends it. If PCP is not used, a text message is sent. In the version for PCP, this protocol is used. CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP demonstrates the stateful service by raising a counter whose value stays the same in stateless services.

If the ABAP push channel is opened using the form field amc=x, communication takes place using AMC. Each Web page bound to the push channel receives every message sent using AMC. In the example, this means that the message sent by ON\_MESSAGE is not just received by the Web page that sent a message. Furthermore, the Web pages bound to the push channel receive messages sent, for example, using the program DEMO\_SEND\_AMC from the executable example [Sending AMC Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc_send_abexa.htm). Conversely, the program DEMO\_RECEIVE\_AMC receives the messages sent from the Web pages from the executable example [Receiving AMC Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc_receive_abexa.htm).

Note

Before this example can work, the protocols WEBSOCKET and WEBSOCKETS must be specified as active services in the Services function in the transaction SMICM.


### abenapc_ws_client_abexa.htm

---
title: "APC, AS ABAP as WebSocket Client"
description: |
  This example demonstrates AS ABAP as a WebSocket client. Source Code REPORT demo_apc_client. CLASS apc_handler DEFINITION FINAL. PUBLIC SECTION. INTERFACES if_apc_wsp_event_handler_pcp. DATA       message TYPE string. ENDCLASS. CLASS apc_handler IMPLEMENTATION. METHOD if_apc_wsp_event_h
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_ws_client_abexa.htm"
abapFile: "abenapc_ws_client_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenapc", "client", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, AS ABAP as WebSocket Client

This example demonstrates AS ABAP as a WebSocket client.

Source Code

REPORT demo\_apc\_client.
CLASS apc\_handler DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler\_pcp.
    DATA       message TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_open.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_message.
    TRY.
        me->message = i\_message->get\_text( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        me->message = apc\_error->get\_text( ).
      CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
        cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_close.
    me->message = 'Connection closed!'.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_error.
    cl\_demo\_output=>display( 'Error!' ).
    LEAVE PROGRAM.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA stateful\_server TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = stateful\_server ).
    DATA messages TYPE i VALUE '5'.
    cl\_demo\_input=>add\_field(  CHANGING field  = messages ).
    DATA wait TYPE i VALUE '10'.
    cl\_demo\_input=>add\_field(  CHANGING field  = wait ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Client
        DATA(client) =
          cl\_apc\_wsp\_client\_manager=>create\_by\_destination(
            i\_destination = 'NONE'
            i\_event\_handler = event\_handler
            i\_protocol =
              if\_apc\_wsp\_event\_handler\_pcp=>co\_event\_handler\_type ).
        "Server
        DATA(request) =
          client->get\_context( )->get\_initial\_request( ).
        request->set\_path\_and\_query(
          i\_relative\_uri =
            \`/sap/bc/apc/sap/demo\_apc\_pcp\` &&
            COND #(
               WHEN stateful\_server = abap\_true THEN \`\_stateful\` ) &&
            COND #(
              WHEN amc = abap\_true THEN \`?amc=x\` ) ).
        client->connect( ).
        "Sending messages
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager\_pcp(
            client->get\_message\_manager( ) ).
        DATA(message) =
          CAST if\_ac\_message\_type\_pcp(
            message\_manager->create\_message( ) ).
        TRY.
            IF amc = abap\_true.
              message->set\_field( i\_name = 'amc' i\_value = 'x' ).
            ENDIF.
            message->set\_text( msg ).
          CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
            cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
            LEAVE PROGRAM.
        ENDTRY.
        DO messages TIMES.
          message\_manager->send( message ).
        ENDDO.
        "Receiving messages
        DO wait TIMES.
          out->line( ).
          CLEAR event\_handler->message.
          WAIT FOR PUSH CHANNELS
               UNTIL event\_handler->message IS NOT INITIAL
               UP TO 1 SECONDS.
          IF sy-subrc = 4.
            out->write\_text(
              'No handler for APC messages registered' ).
          ELSEIF sy-subrc = 8.
            out->write\_text(
              'Timeout occurred!' ).
          ELSE.
            out->write\_text(
             |Received APC message: \\n\\n{
               event\_handler->message } | ).
          ENDIF.
        ENDDO.
        out->line( ).
        "Close connection
        client->close( i\_reason = 'Application closed connection!' ).
        out->display( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create an [APC client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) for the WebSocket protocol.

-   The local class apc\_handler, which implements the interface IF\_APC\_WSP\_EVENT\_HANDLER\_PCP, is used as the handler class. When a message is received, the method on\_message sets its message attribute to the message text.

-   CL\_APC\_WSP\_CLIENT\_MANAGER is used to create a client object for the current AS ABAP as an APC server and opens a connection to one of its ABAP push channels. It is possible to select which of the two ABAP push channels, DEMO\_APC\_PCP or DEMO\_APC\_PCP\_STATEFUL, from the executable example [AS ABAP as WebSocket Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm) is used. The server can also be instructed to send its messages using [ABAP messaging channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc.htm).

-   The message manager of the client object is used to create a message in [PCP format](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp.htm) and send it multiple times.

-   The statement [WAIT FOR PUSH CHANNELS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_apc.htm) is then used to switch the program to a wait state so that messages sent back from the server can be handled. Here, the logical expression checks the attribute message of the handler class apc\_handler. A received text is displayed.

-   Finally, the connection is closed explicitly.

It is possible to select how many messages are sent and how often the wait state occurs.

-   If communication takes place with the stateful server, the counter level of the server is raised, indicating that multiple messages are being sent and received.

-   If the server sends its messages using ABAP messaging channels, other AMC receivers in the same messaging channel can also see the messages of the server. For example, the Web browser from the executable example [AS ABAP as WebSocket Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm) can receive these messages. In the reverse direction, the APC client can then also receive those messages sent by the APC server as a response to messages from the Web browser, if they occur in one of the programmed wait periods.


### abenapc_tcp_client_abexa.htm

---
title: "APC, AS ABAP as TCP Socket Client"
description: |
  This example demonstrates AS ABAP as a TCP socket client. Source Code REPORT demo_apc_tcp_client. CLASS apc_handler DEFINITION FINAL . PUBLIC SECTION. INTERFACES if_apc_wsp_event_handler. DATA       message TYPE string. ENDCLASS. CLASS apc_handler IMPLEMENTATION. METHOD if_apc_wsp_event
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_tcp_client_abexa.htm"
abapFile: "abenapc_tcp_client_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "types", "abenapc", "tcp", "client", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, AS ABAP as TCP Socket Client

This example demonstrates AS ABAP as a TCP socket client.

Source Code

REPORT demo\_apc\_tcp\_client.
CLASS apc\_handler DEFINITION FINAL .
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler.
    DATA       message TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler~on\_open.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_message.
    TRY.
        message = i\_message->get\_text( ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        message = apc\_error->get\_text( ).
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_close.
    message = 'Connection closed!'.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler~on\_error.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(tcp\_server) = \`C:\\ncat\\ncat.exe\`.
    DATA(ip\_adress)  = cl\_gui\_frontend\_services=>get\_ip\_address( ).
    DATA(port)       = \`12345\`.
    DATA(terminator) = \`0A\`.
    DATA(msg)        = \`Hello TCP, answer me!\`.
    cl\_demo\_input=>new(
      )->add\_text(
         \`For the TCP server, download the freely available NCAT.EXE\`
      )->add\_field( CHANGING field = tcp\_server
      )->add\_field( CHANGING field = ip\_adress
      )->add\_field( CHANGING field = port
      )->add\_field( CHANGING field = terminator
      )->add\_field( CHANGING field = msg
      )->request( ).
    "Server
    IF cl\_gui\_frontend\_services=>file\_exist(
         file = tcp\_server ) IS INITIAL.
      cl\_demo\_output=>display( 'TCP Server not found!' ).
      LEAVE PROGRAM.
    ENDIF.
    cl\_gui\_frontend\_services=>execute(
    EXPORTING
      application = \`cmd.exe\`
      parameter  =  \`/c \` && tcp\_server &&
                   \` -l \` && ip\_adress && \` -p \` && port ).
    WAIT UP TO 1 SECONDS.
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Client
        DATA(client) = cl\_apc\_tcp\_client\_manager=>create(
          i\_host   = ip\_adress
          i\_port  = port
          i\_frame = VALUE apc\_tcp\_frame(
            frame\_type =
              if\_apc\_tcp\_frame\_types=>co\_frame\_type\_terminator
            terminator =
              terminator )
          i\_event\_handler = event\_handler ).
        client->connect( ).
        "Send mesasage from client
        DATA(message\_manager) = CAST if\_apc\_wsp\_message\_manager(
          client->get\_message\_manager( ) ).
        DATA(message) = CAST if\_apc\_wsp\_message(
          message\_manager->create\_message( ) ).
        DATA(binary\_terminator) = CONV xstring( terminator ).
        DATA(binary\_msg) =
          cl\_abap\_conv\_codepage=>create\_out( )->convert( msg ).
        CONCATENATE binary\_msg binary\_terminator
               INTO binary\_msg IN BYTE MODE.
        message->set\_binary( binary\_msg ).
        message\_manager->send( message ).
        "Wait for a message from server
        CLEAR event\_handler->message.
        WAIT FOR PUSH CHANNELS
             UNTIL event\_handler->message IS NOT INITIAL
             UP TO 10 SECONDS.
        IF sy-subrc = 4.
          cl\_demo\_output=>display(
            'No handler for APC messages registered!' ).
        ELSEIF sy-subrc = 8.
          cl\_demo\_output=>display(
            'Timeout occurred!' ).
        ELSE.
          cl\_demo\_output=>display(
            |TCP client received:\\n\\n{ event\_handler->message }| ).
        ENDIF.
        client->close(
          i\_reason = 'Application closed connection!' ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create an [APC client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) for the TCP socket protocol. It is structured in exactly the same way as in the [executable example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_ws_client_abexa.htm) for the WebSocket client, but with the connection being made to a TCP socket server. The current front-end computer is used as the TCP socket server here and the available [Ncat](https://nmap.org/ncat/) can be downloaded to this computer.

This program requires the Ncat.exe directory and the address of the current front-end computer (proposals are made for this information). In addition, a terminator character is needed for the TCP framework structure.

When the program is executed, Ncat.exe is started and waits for messages from the APC client. Once a message is sent, this client waits for a message entered in the Ncat window and confirmed using Enter.


### abenapc_detached_client_abexa.htm

---
title: "APC, Creating a Detached Client"
description: |
  This example demonstrates how a detached client is created for the WebSocket protocol. Source Code REPORT demo_apc_detached_client. CLASS apc_handler DEFINITION FINAL. PUBLIC SECTION. INTERFACES if_apc_wsp_event_handler_pcp. DATA: connection_attach_handle TYPE string, message
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_detached_client_abexa.htm"
abapFile: "abenapc_detached_client_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenapc", "detached", "client", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, Creating a Detached Client

This example demonstrates how a detached client is created for the WebSocket protocol.

Source Code

REPORT demo\_apc\_detached\_client.
CLASS apc\_handler DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES if\_apc\_wsp\_event\_handler\_pcp.
    DATA: connection\_attach\_handle TYPE string,
          message                  TYPE string.
ENDCLASS.
CLASS apc\_handler IMPLEMENTATION.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_open.
    TRY.
        connection\_attach\_handle =
          i\_context->get\_connection\_attach\_handle(
            EXPORTING i\_connection\_security =
              i\_context->co\_con\_security\_by\_user\_id ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        me->message = apc\_error->get\_text( ).
    ENDTRY.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_message.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_close.
  ENDMETHOD.
  METHOD if\_apc\_wsp\_event\_handler\_pcp~on\_error.
  ENDMETHOD.
ENDCLASS.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA stateful\_server TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = stateful\_server ).
    DATA show\_attach\_handle TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = show\_attach\_handle ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(event\_handler) = NEW apc\_handler( ).
        "Detached client
        DATA(client\_detach) =
          cl\_apc\_wsp\_client\_conn\_manager=>create\_by\_destination(
            i\_destination = 'NONE'
            i\_application\_id = \`DEMO\_APC\_PCP\`
            i\_event\_handler = event\_handler
            i\_protocol =
              if\_apc\_wsp\_event\_handler\_pcp=>co\_event\_handler\_type ).
        "Server
        DATA(request) =
          client\_detach->get\_context( )->get\_initial\_request( ).
        request->set\_path\_and\_query(
          i\_relative\_uri =
            \`/sap/bc/apc/sap/demo\_apc\_pcp\` &&
            COND #(
               WHEN stateful\_server = abap\_true THEN \`\_stateful\` ) &&
            COND #( WHEN amc = abap\_true THEN \`?amc=x\` ) ).
        client\_detach->connect\_and\_detach( ).
        IF event\_handler->message IS NOT INITIAL.
          out->display(
            |Error during ON\_OPEN: { event\_handler->message }| ).
          LEAVE PROGRAM.
        ENDIF.
        IF show\_attach\_handle IS INITIAL.
          "Attached client
          DATA(client\_attach) =
            cl\_apc\_wsp\_client\_conn\_manager=>attach(
              event\_handler->connection\_attach\_handle ).
          DATA(message\_manager) =
            CAST if\_apc\_wsp\_message\_manager\_pcp(
              client\_attach->get\_message\_manager( ) ).
          DATA(message) = CAST if\_ac\_message\_type\_pcp(
            message\_manager->create\_message( ) ).
          TRY.
              IF amc = abap\_true.
                message->set\_field( i\_name = 'amc' i\_value = 'x' ).
              ENDIF.
              message->set\_field(
                i\_name = 'detached\_client' i\_value = 'x' ).
              message->set\_text( msg ).
            CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
              cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
              LEAVE PROGRAM.
          ENDTRY.
          message\_manager->send( message ).
          client\_attach->close(
            i\_reason = 'Application closed connection!' ).
        ELSE.
          out->display(
            |Attach Handle:\\n\\n{
            event\_handler->connection\_attach\_handle
            }\\n\\nUse as input to DEMO\_APC\_ATTACH\_CLIENT.| ).
        ENDIF.
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

This example demonstrates how an ABAP program can create a [detached APC client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) for the WebSocket protocol.

-   The local class apc\_handler, which implements the interface IF\_APC\_WSP\_EVENT\_HANDLER\_PCP, is used as the handler class. The method on\_open gets a connection handle for the connection. The other methods are not needed.

-   CL\_APC\_WSP\_CLIENT\_CONN\_MANAGER is used to create a detached client object as an APC server for the current AS ABAP. It is possible to select which of the two ABAP push channels, DEMO\_APC\_PCP or DEMO\_APC\_PCP\_STATEFUL, from the executable example [AS ABAP as WebSocket Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm) is used. The server can also be instructed to send its messages using [ABAP messaging channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc.htm). The method CONNECT\_AND\_DETACH is used to create a detached client for the ABAP push channel.

-   The connection handle obtained by the method on\_open of the handler class can either be displayed or used immediately in the program to create an attached client for the detached client.

-   A displayed connection handle can be used in the program of the executable [attached client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_attached_client_abexa.htm) example.

-   If not, the method ATTACH of the class CL\_APC\_WSP\_CLIENT\_CONN\_MANAGER is used to create an attached client object for the connection handle. Its message manager is then used to create a message in [PCP format](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp.htm) and send it.

A breakpoint in the method ON\_MESSAGE of the APC handler class CL\_APC\_WSP\_EXT\_DEMO\_APC\_PCP can be used to monitor the arrival and processing of the message (it is not possible to respond to messages from the same class here). If the message is sent using [AMC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc.htm), the response from the server is received by all associated AMC receivers. The attached client cannot itself wait for the response.


### abenapc_attached_client_abexa.htm

---
title: "APC, AS ABAP as Attached Client"
description: |
  This example demonstrates the AS ABAP as an attached client for a detached client. Source Code REPORT demo_apc_attach_client. CLASS apc_demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS apc_demo IMPLEMENTATION. METHOD main. DATA attach_handle TYPE string VALUE ' '. cl_demo
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_attached_client_abexa.htm"
abapFile: "abenapc_attached_client_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenapc", "attached", "client", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, AS ABAP as Attached Client

This example demonstrates the AS ABAP as an attached client for a detached client.

Source Code

REPORT demo\_apc\_attach\_client.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA attach\_handle TYPE string VALUE ' '.
    cl\_demo\_input=>add\_field( CHANGING field  = attach\_handle ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    DATA amc TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = amc ).
    DATA close TYPE abap\_bool VALUE ' '.
    cl\_demo\_input=>add\_field( EXPORTING as\_checkbox = 'X'
                              CHANGING field  = close ).
    cl\_demo\_input=>request( ).
    TRY.
        "Attached client
        DATA(client\_attach) =
          cl\_apc\_wsp\_client\_conn\_manager=>attach( attach\_handle ).
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager\_pcp(
            client\_attach->get\_message\_manager( ) ).
        DATA(message) = CAST if\_ac\_message\_type\_pcp(
          message\_manager->create\_message( ) ).
        TRY.
            IF amc = abap\_true.
              message->set\_field( i\_name = 'amc' i\_value = 'x' ).
            ENDIF.
            message->set\_field(
              i\_name = 'detached\_client' i\_value = 'x' ).
            message->set\_text( msg ).
          CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_error).
            cl\_demo\_output=>display( pcp\_error->get\_text( ) ).
            LEAVE PROGRAM.
        ENDTRY.
        message\_manager->send( message ).
        IF close  = abap\_true.
          client\_attach->close(
            i\_reason = 'Application closed connection!' ).
        ENDIF.
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

The program expects a connection handle as input, as provided in the output of the executable [detached client](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_detached_client_abexa.htm) example. The connection handle is used to create and employ an attached client object precisely as described in the detached client example. The connection handle can be reused indefinitely until the connection is closed using the method CLOSE. If the connection is not closed by mistake, this can be done later in the transaction SMWS.


### abenapc_connect_via_handle_abexa.htm

---
title: "APC, System-Wide Access"
description: |
  This example demonstrates access to any ABAP channel using a connection handle. Source Code REPORT demo_apc_access_connection. CLASS apc_demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS apc_demo IMPLEMENTATION. METHOD main. DATA attach_handle TYPE string VALUE ' '. cl_demo
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_connect_via_handle_abexa.htm"
abapFile: "abenapc_connect_via_handle_abexa.htm"
keywords: ["select", "do", "while", "if", "try", "catch", "method", "class", "data", "abenapc", "connect", "via", "handle", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_channels.htm) →  [APC - ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc.htm) →  [Examples of APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexas.htm) → 

APC, System-Wide Access

This example demonstrates access to any ABAP channel using a connection handle.

Source Code

REPORT demo\_apc\_access\_connection.
CLASS apc\_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS apc\_demo IMPLEMENTATION.
  METHOD main.
    DATA attach\_handle TYPE string VALUE ' '.
    cl\_demo\_input=>add\_field( CHANGING field  = attach\_handle ).
    DATA(msg) = \`Hello APC!\`.
    cl\_demo\_input=>add\_field( CHANGING field = msg ).
    cl\_demo\_input=>request( ).
    TRY.
        DATA(access\_object) =
          cl\_apc\_wsp\_client\_conn\_manager=>attach( attach\_handle ).
        DATA(message\_manager) =
          CAST if\_apc\_wsp\_message\_manager(
            access\_object->get\_message\_manager( ) ).
        DATA(message) = CAST if\_apc\_wsp\_message(
          message\_manager->create\_message( ) ).
        message->set\_text( msg ).
        message\_manager->send( message ).
      CATCH cx\_apc\_error INTO DATA(apc\_error).
        cl\_demo\_output=>display( apc\_error->get\_text( ) ).
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  apc\_demo=>main( ).

Description

The program expects a valid connection handle for a WebSocket connection as its input, creates an access objects for this handle, and uses it to send a simple text message.

An APC connection from the executable example [AS ABAP as WebSocket Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_abexa.htm) publishes its connection handle as follows:

-   Create a WebSocket server without PCP.

-   Open the connection on the Web page.

-   Send the text message "get handle".

This message is identified in the method ON\_MESSAGE of the APC handler class CL\_APC\_WS\_EXT\_DEMO\_APC and the connection handle is fetched and sent. The Web page displays it in a form that can be copied. If the connection handle is passed to the program above while the connection is open, the message sent by the program is received and displayed by the Web page.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ADF - ABAP Daemon Framework / Examples for ABAP Daemons

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ADF - ABAP Daemon Framework / Examples for ABAP Daemons

Included pages: 3


### abenabap_daemon_abexas.htm

---
title: "Examples for ABAP Daemons"
description: |
  !Example(exa.gif 'Example') ADF, Mini ABAP Daemon(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_mini_daemon_abexa.htm) !Example(exa.gif 'Example') ADF, Creating and Using an ABAP Daemon(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_abexa.htm
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_abexas.htm"
abapFile: "abenabap_daemon_abexas.htm"
keywords: ["do", "if", "data", "abenabap", "daemon", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ADF - ABAP Daemon Framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon.htm) → 

Examples for ABAP Daemons

Continue
![Example](exa.gif "Example") [ADF, Mini ABAP Daemon](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_mini_daemon_abexa.htm)
![Example](exa.gif "Example") [ADF, Creating and Using an ABAP Daemon](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_abexa.htm)


### abenabap_mini_daemon_abexa.htm

---
title: "ADF, Mini ABAP Daemon"
description: |
  This example demonstrates a mini ABAP Daemon(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_glosry.htm 'Glossary Entry'). Source Code REPORT demo_abap_mini_daemon. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_mini_daemon_abexa.htm"
abapFile: "abenabap_mini_daemon_abexa.htm"
keywords: ["select", "do", "while", "if", "try", "catch", "method", "class", "data", "abenabap", "mini", "daemon", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ADF - ABAP Daemon Framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon.htm) →  [Examples for ABAP Daemons](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_abexas.htm) → 

ADF, Mini ABAP Daemon

This example demonstrates a mini [ABAP Daemon](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_abap\_mini\_daemon.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    TRY.
        DATA(pcp) = cl\_ac\_message\_type\_pcp=>create( ).
        pcp->set\_text( \`Hello Daemon!\` ).
      CATCH cx\_ac\_message\_type\_pcp\_error INTO DATA(pcp\_exc).
        cl\_demo\_output=>display( pcp\_exc->get\_text( ) ).
        RETURN.
    ENDTRY.
    TRY.
        cl\_abap\_daemon\_client\_manager=>start(
          EXPORTING
            i\_class\_name = 'CL\_DEMO\_ABAP\_MINI\_DAEMON'
            i\_name       = 'DemoMiniDaemon'
         IMPORTING
            e\_instance\_id = DATA(instance\_id) ).
        cl\_abap\_daemon\_client\_manager=>attach(
          i\_instance\_id = instance\_id )->send( pcp ).
        cl\_abap\_daemon\_client\_manager=>stop(
          i\_instance\_id = instance\_id ).
      CATCH cx\_abap\_daemon\_error INTO DATA(daemon\_exc).
        cl\_demo\_output=>display( daemon\_exc->get\_text( ) ).
        RETURN.
    ENDTRY.
    DATA msg TYPE string.
    DATA(subrc) = 4.
    WHILE subrc = 4.
      IMPORT msg = msg FROM SHARED MEMORY demo\_indx\_blob(dm)
                       ID 'DemoMiniDaemon'.
      subrc = sy-subrc.
    ENDWHILE.
    ASSERT msg = \`Hello Daemon!\`.
    cl\_demo\_output=>display( 'Daemon has received the message' ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The class CL\_DEMO\_ABAP\_MINI\_DAEMON used by the program above demonstrates a mini [ABAP Daemon class](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_class_glosry.htm "Glossary Entry"). It implements only the following methods of the interface IF\_ABAP\_DAEMON\_EXTENSION:

-   ON\_ACCEPT

METHOD if\_abap\_daemon\_extension~on\_accept.
  TRY.
      IF i\_context\_base->get\_start\_caller\_info(
           )-program = 'DEMO\_ABAP\_MINI\_DAEMON'.
        e\_setup\_mode = co\_setup\_mode-accept.
      ENDIF.
    CATCH cx\_abap\_daemon\_error.
      RETURN.
  ENDTRY.
ENDMETHOD.

In this method, the return value E\_SETUP\_MODE must be set to ensure that the daemon is created. The method limits the creation of daemons to the program DEMO\_ABAP\_MINI\_DAEMON.

-   ON\_MESSAGE

METHOD IF\_ABAP\_DAEMON\_EXTENSION~ON\_MESSAGE.
  TRY.
      DATA(msg) = i\_message->get\_text( ).
    CATCH cx\_ac\_message\_type\_pcp\_error.
      RETURN.
  ENDTRY.
  EXPORT msg = msg TO SHARED MEMORY demo\_indx\_blob(dm)
                   ID 'DemoMiniDaemon'.
ENDMETHOD.

This method indicates that the daemon is responding to message from a program. To enable this, the message is exported to the [cross-transaction application buffer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencrosstrans_app_buffer_glosry.htm "Glossary Entry") of the shared memory.

The program DEMO\_ABAP\_MINI\_DAEMON uses [ABAP Daemon Manager](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_manager_glosry.htm "Glossary Entry") to do the following:

-   Start a daemon based on the class CL\_DEMO\_ABAP\_MINI\_DAEMON.

-   Send a [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") message using a temporary [ABAP Daemon handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_handle_glosry.htm "Glossary Entry").

-   Stop the daemon immediately (not a typical step).

It then checks whether the daemon wrote the message to the shared memory.


### abenabap_daemon_abexa.htm

---
title: "ADF, Creating and Using an ABAP Daemon"
description: |
  This example demonstrates an ABAP Daemon(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_glosry.htm 'Glossary Entry'). Source Code REPORT demo_abap_daemon. CLASS amc_receiver DEFINITION. PUBLIC SECTION. INTERFACES if_amc_message_receiver_text. DATA msg TYPE string
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_abexa.htm"
abapFile: "abenabap_daemon_abexa.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "catch", "method", "class", "data", "abenabap", "daemon", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ADF - ABAP Daemon Framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon.htm) →  [Examples for ABAP Daemons](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_abexas.htm) → 

ADF, Creating and Using an ABAP Daemon

This example demonstrates an [ABAP Daemon](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_abap\_daemon.
CLASS amc\_receiver DEFINITION.
  PUBLIC SECTION.
    INTERFACES
      if\_amc\_message\_receiver\_text.
    DATA msg TYPE string.
ENDCLASS.
CLASS amc\_receiver IMPLEMENTATION.
  METHOD if\_amc\_message\_receiver\_text~receive.
    msg = i\_message.
  ENDMETHOD.
ENDCLASS.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA:
      start\_daemon       TYPE abap\_bool,
      get\_information    TYPE abap\_bool,
      send\_message       TYPE abap\_bool,
      trigger\_amc        TYPE abap\_bool,
      trigger\_exception  TYPE abap\_bool,
      trigger\_blocking   TYPE abap\_bool,
      trigger\_restart    TYPE abap\_bool,
      trigger\_relocation TYPE abap\_bool,
      trigger\_stop       TYPE abap\_bool,
      stop\_daemon        TYPE abap\_bool.
    CLASS-DATA:
      out TYPE REF TO if\_demo\_output.
    CLASS-METHODS:
      get\_input,
      write\_log IMPORTING msg TYPE string.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DELETE FROM DATABASE demo\_indx\_blob(dm)
                ID cl\_demo\_abap\_daemon\_broker=>daemon\_log.
    COMMIT CONNECTION default.
    get\_input( ).
    out = cl\_demo\_output=>new( ).
    out->next\_section( 'ABAP Program' ).
    TRY.
        IF NOT cl\_demo\_abap\_daemon\_broker=>check\_daemon( ).
          IF start\_daemon = abap\_true.
            DATA(pcp) = cl\_ac\_message\_type\_pcp=>create( ).
            pcp->set\_field( i\_name = \`Version\`
                            i\_value = \`1\` ).
            IF cl\_demo\_abap\_daemon\_broker=>start\_daemon(
                 pcp = pcp ).
              write\_log( \`Daemon start requested\` ).
            ELSE.
              write\_log( \`Daemon not accepted\` ).
            ENDIF.
          ELSE.
            write\_log( \`Daemon not started\` ).
          ENDIF.
        ELSE.
          cl\_demo\_abap\_daemon\_broker=>attach\_daemon( ).
          CASE abap\_true.
            WHEN start\_daemon.
              write\_log( \`Daemon already started\` ).
            WHEN get\_information.
              write\_log( \`Information requested\` ).
              out->write(
                cl\_demo\_abap\_daemon\_broker=>get\_daemon\_info( ) ).
            WHEN send\_message.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`msg\` ).
              pcp->set\_text( \`Hello Daemon!\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Text message sent\` ).
            WHEN trigger\_amc.
              DATA(receiver) = NEW amc\_receiver( ).
              TRY.
                  cl\_amc\_channel\_manager=>create\_message\_consumer(
                    i\_application\_id = 'DEMO\_AMC'
                    i\_channel\_id     = '/demo\_text'
                    )->start\_message\_delivery( i\_receiver = receiver ).
                CATCH cx\_amc\_error INTO DATA(amc\_exc).
                  write\_log( \`Exception, \` && amc\_exc->get\_text( ) ).
              ENDTRY.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`amc\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`AMC message triggered\` ).
              WAIT FOR MESSAGING CHANNELS
                   UNTIL receiver->msg IS NOT INITIAL
                   UP TO 10 SECONDS.
              IF receiver->msg IS NOT INITIAL.
                write\_log( |AMC message "{ receiver->msg }" received| ).
              ELSE.
                write\_log( \`No AMC message received\` ).
              ENDIF.
            WHEN trigger\_exception.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`err\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Exception triggered\` ).
            WHEN trigger\_blocking.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`blk\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Blocking statement triggered\` ).
            WHEN trigger\_restart.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`rst\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Restart triggered\` ).
            WHEN trigger\_relocation.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`rlo\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Relocation triggered\` ).
            WHEN trigger\_stop.
              pcp = cl\_ac\_message\_type\_pcp=>create( ).
              pcp->set\_field( i\_name = \`Type\`
                              i\_value = \`stp\` ).
              cl\_demo\_abap\_daemon\_broker=>send\_message( pcp = pcp ).
              write\_log( \`Stop triggered\` ).
            WHEN stop\_daemon.
              cl\_demo\_abap\_daemon\_broker=>stop\_daemon( ).
              write\_log( \`Daemon stop requested\` ).
          ENDCASE.
        ENDIF.
      CATCH cx\_abap\_daemon\_error
            cx\_ac\_message\_type\_pcp\_error INTO DATA(exc).
        write\_log( \`Exception, \` && exc->get\_text( ) ).
    ENDTRY.
    WAIT UP TO 1 SECONDS.
    out->next\_section( 'ABAP Daemon' ).
    DATA(daemon\_log) = \`\`.
    IMPORT daemon\_log = daemon\_log
           FROM DATABASE demo\_indx\_blob(dm)
           ID cl\_demo\_abap\_daemon\_broker=>daemon\_log.
    IF sy-subrc = 0.
      out->write( daemon\_log ).
    ENDIF.
    out->display( ).  ENDMETHOD.
  METHOD get\_input.
    cl\_demo\_input=>new(
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = start\_daemon
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = get\_information
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = send\_message
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_amc
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_exception
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_blocking
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_restart
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_relocation
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = trigger\_stop
     )->add\_field( EXPORTING as\_checkbox = abap\_true
                   CHANGING  field = stop\_daemon
     )->request( ).
    IF start\_daemon       &&
       get\_information    &&
       send\_message       &&
       trigger\_amc        &&
       trigger\_exception  &&
       trigger\_blocking   &&
       trigger\_restart    &&
       trigger\_relocation &&
       trigger\_stop       &&
       stop\_daemon <> abap\_true.
      cl\_demo\_output=>display( \`Check exactly one box\` ).
      LEAVE PROGRAM.
    ENDIF.
  ENDMETHOD.
  METHOD write\_log.
    DATA(ts) = utclong\_current( ).
    out->write( |{ ts TIMESTAMP = ISO }: { msg }| ).
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

It implements the most important aspects of an ABAP Daemon and contains the program above and two classes.

Program DEMO\_ABAP\_DAEMON

This program makes it possible to start an ABAP Daemon interactively and then perform various actions using the daemon. The checkboxes have the following meanings:

-   START\_DAEMON

Attempts to start an ABAP Daemon. Only one ABAP Daemon of the ABAP Daemon class in question may exist. When the program starts, a version number is passed in [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") format. If an ABAP Daemon already exists, this daemon is used.

-   GET\_INFORMATION

Gets information about the ABAP Daemon and displays it.

-   SEND\_MESSAGE

Sends a text message to the ABAP Daemon in [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") format.

-   TRIGGER\_AMC

Sends a [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") message to the ABAP Daemon instructing the daemon to send an [AMC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc_glosry.htm "Glossary Entry") message. The program waits until the message arrives at a dedicated AMC receiver.

-   TRIGGER\_EXCEPTION

Sends a [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") message to the ABAP Daemon, where an exception is raised. The exception produces a [short dump](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshort_dump_glosry.htm "Glossary Entry") that can be viewed in transaction ST22 and the ABAP Daemon is restarted automatically. This raises the version number by 1.

-   TRIGGER\_BLOCKING

Sends a [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") message to the ABAP Daemon instructing it to create a statement forbidden in [non-blocking mode](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenadf_non_blocking_model.htm). This raises an exception and [short dump](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenshort_dump_glosry.htm "Glossary Entry"), which can be viewed in transaction ST22. The ABAP Daemon is then restarted automatically. This raises the version number by 1.

-   TRIGGER\_RESTART

Sends a [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") message to the ABAP Daemon that restarts the daemon. This raises the version number by 1.

-   TRIGGER\_RELOCATION

Sends a [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") message to the ABAP Daemon instructing the daemon to create a new instance of its class on a different AS Instance and delete the previous instance.

-   TRIGGER\_STOP

Sends a [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") message to the ABAP Daemon instructing it to stop.

-   STOP\_DAEMON

Stops the daemon.

The output of the program displays the individual actions in both the program and in the ABAP Daemon. To do this, the daemon writes entries to the [export/import table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexport_import_table_glosry.htm "Glossary Entry") DEMO\_INDX\_BLOB, which are then read by the ABAP program after a short delay. If the system in question is slow, this delay may not be long enough to display all actions in the daemon. The ABAP Daemon on the current AS Instance can be viewed in parallel to the execution of the program using the transaction SMDAEMON.

Class CL\_ABAP\_DAEMON\_BROKER

The program DEMO\_ABAP\_DAEMON does not work directly with the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER and any reads performed on this class are wrapped in the class CL\_DEMO\_ABAP\_DAEMON\_BROKER. This is because CL\_ABAP\_DAEMON\_CLIENT\_MANAGER can only be used to access an ABAP Daemon in the program where the daemon was started. It must be possible for the daemon itself to create an instance of its class in this example, which means the reads must be moved to a program that can be accessed from both the ABAP program and the ABAP Daemon. To enable this, CL\_DEMO\_ABAP\_DAEMON\_BROKER contains the following methods:

-   CHECK\_DAEMON

METHOD check\_daemon.
  DATA(daemon\_info) =
    cl\_abap\_daemon\_client\_manager=>get\_daemon\_info(
      i\_class\_name = daemon\_class ).
  instance\_id =
     VALUE #( daemon\_info\[ name = daemon\_name \]-instance\_id
              OPTIONAL ).
  success = COND #( WHEN instance\_id IS NOT INITIAL THEN abap\_true ).
ENDMETHOD.

This method determines whether a daemon of the ABAP Daemon class CL\_DEMO\_ABAP\_DAEMON already exists and saves its ID for further use. The program DEMO\_ABAP\_DAEMON starts a daemon of the class CL\_DEMO\_ABAP\_DAEMON only if no daemon exists. The method shown here for creating an ABAP Daemon as a singleton is not, however, 100% reliable. It is possible that further daemons are created in the same class in the time between starting the daemon and its being returned by the method GET\_DAEMON\_INFO. A fully reliable program, however, would be too detailed for this simple example.

-   START\_DAEMON

METHOD start\_daemon.
  DATA stack TYPE abap\_callstack.
  CALL FUNCTION 'SYSTEM\_CALLSTACK'
    IMPORTING
      callstack = stack.
  IF VALUE #( stack\[ 2 \]-mainprogram OPTIONAL )
     <> 'DEMO\_ABAP\_DAEMON' AND
     VALUE #( stack\[ 2 \]-mainprogram OPTIONAL )
     <> 'CL\_DEMO\_ABAP\_DAEMON===========CP'.
    RETURN.
  ENDIF.
  cl\_abap\_daemon\_client\_manager=>start(
    EXPORTING
      i\_class\_name  = daemon\_class
      i\_name        = daemon\_name
      i\_parameter   = pcp
      i\_destination = destination
    IMPORTING
      e\_instance\_id = instance\_id
      e\_setup\_mode  = DATA(setup\_mode) ).
  success =
    COND #( WHEN setup\_mode =
                   if\_abap\_daemon\_extension=>co\_setup\_mode-accept
            THEN abap\_true ).
ENDMETHOD.

This method wraps the method START of the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER and starts an ABAP Daemon of the ABAP Daemon class CL\_DEMO\_ABAP\_DAEMON. Any callers are checked to ensure that the method is only used in the program DEMO\_ABAP\_DAEMON and in the ABAP Daemon class. The ID of the started daemon is saved for further use. If the ABAP Daemon class is accepted when started, the return value is not initial.

-   GET\_DAEMON\_INFO

METHOD get\_daemon\_info.
  daemon\_info =
    cl\_abap\_daemon\_client\_manager=>get\_daemon\_info(
      i\_class\_name = daemon\_class ).
ENDMETHOD.

This method wraps the identically named method of the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER and returns information about the ABAP Daemons of the ABAP Daemon class CL\_DEMO\_ABAP\_DAEMON.

-   ATTACH\_DAEMON

METHOD attach\_daemon.
  daemon\_handle = cl\_abap\_daemon\_client\_manager=>attach(
    i\_instance\_id = instance\_id ).
ENDMETHOD.

This method wraps the method ATTACH of the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER. The returned reference to the [ABAP Daemon handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_handle_glosry.htm "Glossary Entry") is saved in the private attribute DAEMON\_HANDLE.

-   SEND\_MESSAGE

METHOD send\_message.
  IF daemon\_handle IS INITIAL.
    RAISE EXCEPTION TYPE cx\_abap\_daemon\_error
      EXPORTING
        textid = cx\_abap\_daemon\_error=>action\_not\_permitted.
  ENDIF.
  daemon\_handle->send( pcp ).
ENDMETHOD.

This method is used to send [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") messages to the ABAP Daemon. To do this, the method SEND of the [ABAP Daemon handle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_handle_glosry.htm "Glossary Entry") is used, which is referenced in the private attribute DAEMON\_HANDLE.

-   STOP\_DAEMON

METHOD stop\_daemon.
  cl\_abap\_daemon\_client\_manager=>stop(
    i\_instance\_id = instance\_id ).
ENDMETHOD.

This method wraps the method STOP of the class CL\_ABAP\_DAEMON\_CLIENT\_MANAGER and is used to stop the ABAP Daemon.

The name of the ABAP Daemon and the ABAP Daemon class are defined as constants of the class CL\_ABAP\_DAEMON\_BROKER.

Class CL\_ABAP\_DAEMON

The class CL\_DEMO\_ABAP\_DAEMON is a subclass of CL\_ABAP\_DAEMON\_EXT\_BASE and is the ABAP Daemon class for this example. It implements the most important methods of the interface IF\_ABAP\_DAEMON\_EXTENSION and further standalone helper methods. It also implements the interface IF\_ABAP\_TIMER\_HANDLER so that it can be an [ABAP Timer handler](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_timer_handler_glosry.htm "Glossary Entry") for an [ABAP Timer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_timer_glosry.htm "Glossary Entry"). Although daemons should never be stopped in practice, daemons created by this example are deleted automatically after an hour (if not stopped explicitly first).

-   IF\_ABAP\_DAEMON\_EXTENSION~ON\_ACCEPT

METHOD if\_abap\_daemon\_extension~on\_accept.
  TRY.
      DATA(caller) = i\_context\_base->get\_start\_caller\_info( )-program.
      IF caller = 'CL\_DEMO\_ABAP\_DAEMON\_BROKER====CP'.
        e\_setup\_mode = co\_setup\_mode-accept.
      ENDIF.
    CATCH cx\_abap\_daemon\_error.
      RETURN.
  ENDTRY.
ENDMETHOD.

Before the daemon is started, this method checks whether the calling program is the class pool of the class CL\_DEMO\_ABAP\_DAEMON\_BROKER. Only in this case is the output parameter E\_SETUP\_MODE set so that the daemon can be started.

-   IF\_ABAP\_DAEMON\_EXTENSION~ON\_START

METHOD if\_abap\_daemon\_extension~on\_start.
  TRY.
      set\_context( context = i\_context
                   version = i\_context->get\_start\_parameter(
                                          )->get\_field(
                                             i\_name = \`Version\` ) ).
      write\_log( |Daemon started as version {
                    i\_context->get\_application\_parameter(
                       )->get\_field( i\_name = \`Version\` )
                  } on { sy-host }| ).
    CATCH cx\_ac\_message\_type\_pcp\_error
          cx\_abap\_daemon\_error
          cx\_abap\_timer\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

Directly after the daemon is started, this method calls the helper method SET\_CONTEXT, which saves context information and starts a timer. One example of context information here is the version number passed by the caller when the daemon is started.

-   IF\_ABAP\_DAEMON\_EXTENSION~ON\_MESSAGE

METHOD if\_abap\_daemon\_extension~on\_message.
  TRY.
      DATA(type) = i\_message->get\_field( i\_name = \`Type\` ).
      CASE type.
        WHEN \`msg\`.
          write\_log(
            |Message "{ i\_message->get\_text( )
              }" received on { sy-host }| ).
        WHEN \`amc\`.
          write\_log( \`Sending AMC message in daemon\` ).
          send\_amc( \`Hello from daemon\` ).
        WHEN \`err\`.
          write\_log( \`Raising exception in daemon\` ).
          MESSAGE \`Type X message in daemon\` TYPE 'X'.
        WHEN \`blk\`.
          write\_log( \`Executing blocking statement in daemon\` ).
          WAIT UP TO 1 SECONDS.
        WHEN \`rst\`.
          write\_log( \`Restarting from daemon\` ).
          i\_context->restart( ).
        WHEN \`rlo\`.
          write\_log( \`Relocating daemon\` ).
          relocate( ).
        WHEN \`stp\`.
          write\_log( \`Stopping from daemon\` ).
          i\_context->stop( ).
      ENDCASE.
    CATCH cx\_ac\_message\_type\_pcp\_error
          cx\_abap\_daemon\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

This method evaluates the inbound [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") messages and performs the actions in question directly or calls helper methods from the ABAP Daemon class.

-   IF\_ABAP\_DAEMON\_EXTENSION~ON\_ERROR

METHOD if\_abap\_daemon\_extension~on\_error.
  set\_context( i\_context ).
  TRY.
      write\_log(
        \`Daemon restarted after error and version increased to \` &&
         i\_context->get\_application\_parameter(
                      )->get\_field( i\_name = \`Version\` ) ).
    CATCH cx\_ac\_message\_type\_pcp\_error
          cx\_abap\_daemon\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

IF\_ABAP\_DAEMON\_EXTENSION~ON\_RESTART

METHOD if\_abap\_daemon\_extension~on\_restart.
  set\_context( i\_context ).
  TRY.
      write\_log(
        \`Daemon restarted and version increased to \` &&
         i\_context->get\_application\_parameter(
                      )->get\_field( i\_name = \`Version\` ) ).
    CATCH cx\_ac\_message\_type\_pcp\_error
          cx\_abap\_daemon\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

These methods call the helper method SET\_CONTEXT to set the context information again after a restart.

-   IF\_ABAP\_DAEMON\_EXTENSION~ON\_SERVER\_SHUTDOWN

METHOD if\_abap\_daemon\_extension~on\_server\_shutdown.
  relocate( ).
ENDMETHOD.

When the current AS Instance is shut down, this method calls the helper method RELOCATE to move the daemon to a different AS Instance.

-   IF\_ABAP\_TIMER\_HANDLER~ON\_TIMEOUT

METHOD if\_abap\_timer\_handler~on\_timeout.
  TRY.
      write\_log( \`Timeout reached, stopping daemon\` ).
      daemon\_context->stop( ).
    CATCH cx\_abap\_daemon\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

In the case of a timeout event of the [ABAP Timer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_timer_glosry.htm "Glossary Entry") set in SET\_CONTEXT, this method stops the daemon.

-   SET\_CONTEXT

METHOD set\_context.
  daemon\_context = context.
  TRY.
      DATA(pcp) = cl\_ac\_message\_type\_pcp=>create( ).
      pcp->set\_field(
        i\_name = \`Version\`
        i\_value = COND #(
                    WHEN version IS NOT SUPPLIED
                      THEN context->get\_application\_parameter(
                             )->get\_field( i\_name = \`Version\` ) + 1
                      ELSE version ) ).
      context->set\_application\_parameter( i\_parameter = pcp ).
      cl\_abap\_timer\_manager=>get\_timer\_manager(
        )->start\_timer(
          i\_timer\_handler = me
          i\_timeout = 3600 \* 1000 ).
      write\_log( \`Daemon timeout set to one hour\` ).
    CATCH cx\_ac\_message\_type\_pcp\_error
          cx\_abap\_daemon\_error
          cx\_abap\_timer\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

This method sets an attribute of the class to the context object and uses its method SET\_APPLICATION\_PARAMETER to save the current version number in the [ABAP Daemon memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_memory_glosry.htm "Glossary Entry") in [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") format. If SET\_CONTEXT is called after a restart, the previous version number is fetched from the ABAP Daemon memory and raised by 1. Furthermore, SET\_CONTEXT initializes an [ABAP Timer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_timer_glosry.htm "Glossary Entry") responded to by the method IF\_ABAP\_TIMER\_HANDLER~ON\_TIMEOUT of the current daemon.

-   SEND\_AMC

METHOD send\_amc.
  TRY.
      CAST if\_amc\_message\_producer\_text(
             cl\_amc\_channel\_manager=>create\_message\_producer(
               i\_application\_id = 'DEMO\_AMC'
               i\_channel\_id     = '/demo\_text'
               i\_suppress\_echo  = 'X' )
        )->send( i\_message = msg ).
    CATCH cx\_amc\_error INTO DATA(amc\_exc).
      write\_log( \`Exception, \` && amc\_exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

This method sends an [AMC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamc_glosry.htm "Glossary Entry") message.

-   RELOCATE

METHOD relocate.
  DATA list TYPE TABLE OF msxxlist WITH EMPTY KEY.
  CALL FUNCTION 'TH\_SERVER\_LIST'
    TABLES
      list   = list
    EXCEPTIONS
      OTHERS = 4.
  IF sy-subrc <> 0 OR lines( list ) < 2.
    write\_log( \`No other application server available\`).
    RETURN.
  ENDIF.
  DELETE list WHERE host = sy-host.
  DATA(server) = list\[
    cl\_abap\_random\_int=>create(
      seed = CONV #( sy-uzeit )
      min  = 1
      max  = lines( list ) )->get\_next( ) \].
  TRY.
      IF cl\_demo\_abap\_daemon\_broker=>start\_daemon(
            pcp = daemon\_context->get\_application\_parameter( )
            destination = server-name ).
        write\_log( \`Daemon relocated to \` && server-host && \` \`  ).
        daemon\_context->stop( ).
      ELSE.
        write\_log( \`Daemon not accepted on \` && server-host ).
      ENDIF.
    CATCH cx\_abap\_daemon\_error INTO DATA(exc).
      write\_log( \`Exception, \` && exc->get\_text( ) ).
  ENDTRY.
ENDMETHOD.

This method attempts to move the current daemon to a different AS Instance. To do this, an AS Instances is selected at random from a list in the current AS ABAP. This application server is then used as a destination for starting a daemon of the current ABAP Daemon class using CL\_ABAP\_DAEMON\_BROKER. Here, the current context information from the [ABAP Daemon memory](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_daemon_memory_glosry.htm "Glossary Entry") is passed directly as start parameters in [PCP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpcp_glosry.htm "Glossary Entry") format. The current daemon is then stopped.

-   WRITE\_LOG

METHOD write\_log.
  DATA ts TYPE timestampl.
  GET TIME STAMP FIELD ts.
  DATA(daemon\_log) = \`\`.
  IMPORT daemon\_log = daemon\_log
         FROM DATABASE demo\_indx\_blob(dm)
         ID cl\_demo\_abap\_daemon\_broker=>daemon\_log.
  daemon\_log = daemon\_log && |{ ts TIMESTAMP = ISO }: { msg }\\n|.
  EXPORT daemon\_log = daemon\_log
         TO DATABASE demo\_indx\_blob(dm)
         ID cl\_demo\_abap\_daemon\_broker=>daemon\_log.
  COMMIT CONNECTION default.
ENDMETHOD.

This method writes log entries to the [export/import table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexport_import_table_glosry.htm "Glossary Entry") DEMO\_INDX\_BLOB as a string. It is called by the other methods to log the actions of the daemon for the output of the program DEMO\_ABAP\_DAEMON.

In this example, the remaining methods of the interface IF\_ABAP\_DAEMON\_EXTENSION only write log entries.

Note

This simple example does not guarantee that an ABAP Daemon in the ABAP Daemon class CL\_ABAP\_DAEMON is a system-wide singleton. Any parallel reads that cause restarts can be the source of multiple unwanted daemons. This applies in particular when moving daemons to other AS Instances. A great deal more work is required to create a real singleton. See the class CL\_AD\_EXT\_SIMPLE\_DAEMON, which can be used by the program RS\_ABAP\_DAEMON\_TEST.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / iXML Library / iXML Library - Parsing

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / iXML Library / iXML Library - Access to DOM

**Files**: 7 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / iXML Library / iXML Library - Classes and Interfaces

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / sXML Library / sXML Library - Parsing

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / sXML Library / sXML Library - Rendering

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Class Libraries for XML / sXML Library / sXML Library - Classes and Interfaces

**Files**: 10 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / XSL Transformations

**Files**: 4 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Structure of ST Programs

**Files**: 10 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Addressing ABAP Data

**Files**: 9 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Literal Template Content

**Files**: 6 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Transformation of ABAP Values / ST - tt:value, Elementary Data Objects / ST - option, Mapping Rules / ST - option, Mapping Rules for Elementary Types

**Files**: 5 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Transformation of ABAP Values / ST - tt:value, Elementary Data Objects / ST - option, Mapping Rules / ST - option, Mapping Rules for XML Fragments

**Files**: 2 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Value Assignments

**Files**: 4 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Reading and Writing Variables

**Files**: 4 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Flow Control / ST - tt:cond, Conditional Transformations

**Files**: 6 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Serialization and Deserialization / ST - Flow Control / ST - Flow Control with Variables

**Files**: 3 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Modularization with Subtemplates

**Files**: 3 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Reusing ST Programs

**Files**: 3 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Access to ABAP Objects from ST

**Files**: 5 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / ST - Simple Transformations / ST - Examples

**Files**: 4 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / asXML - Canonical XML Representation / asXML - Mapping of ABAP Data Types / asXML - Mapping of Reference Variables and Objects / asXML - Named Reference Variables

**Files**: 2 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / asXML - Canonical XML Representation / asXML - Mapping of ABAP Data Types / asXML - Mapping of Reference Variables and Objects / asXML - Anonymous Data Objects

**Files**: 2 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / asXML - Canonical XML Representation / asXML - Mapping of ABAP Data Types / asXML - Mapping of Reference Variables and Objects / asXML - Instances of Classes

**Files**: 2 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / asXML - Canonical XML Representation / asXML, Examples of Mappings

**Files**: 11 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

**Files**: 7 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and XML / Transformations for XML / CALL TRANSFORMATION / CALL TRANSFORMATION - Examples

Included pages: 7


### abencall_transformation_abexas.htm

---
title: "CALL TRANSFORMATION - Examples"
description: |
  !Example(exa.gif 'Example') XML Sources of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm) !Example(exa.gif 'Example') XML Targets of Transformations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm"
abapFile: "abencall_transformation_abexas.htm"
keywords: ["do", "if", "data", "abencall", "transformation", "abexas"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) → 

CALL TRANSFORMATION - Examples

Continue
![Example](exa.gif "Example") [XML Sources of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm)
![Example](exa.gif "Example") [XML Targets of Transformations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm)
![Example](exa.gif "Example") [Deserializing Missing Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm)
![Example](exa.gif "Example") [Deserializing Empty Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Syntax Characters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm)
![Example](exa.gif "Example") [Transformation of XML Element Names](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm)


### abencall_trafo_sources_abexa.htm

---
title: "XML Sources of Transformations"
description: |
  This example demonstrates the possible XML sources of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_sources. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_sources_abexa.htm"
abapFile: "abencall_trafo_sources_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "abencall", "trafo", "sources", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Sources of Transformations

This example demonstrates the possible XML sources of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_sources.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE xstring.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`XML-Sources for CALL TRANSFORMATION\` ).
    "XML 1.0
    out->begin\_section( \`XML 1.0\` ).
    "XML 1.0 in string
    out->begin\_section( \`XML 1.0 in Text String\` ).
    DATA(xml\_str) = \`<text>Hello XML!</text>\`.
    CALL TRANSFORMATION id SOURCE XML xml\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in text table
    out->next\_section( \`XML 1.0 in Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    xml\_tab =
      VALUE #( LET l1 = strlen( xml\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_str+j(10)
                          ELSE
                            xml\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in xstring
    out->next\_section( \`XML 1.0 in Byte String\` ).
    DATA(xml\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
      )->convert( xml\_str ).
    CALL TRANSFORMATION id SOURCE XML xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in byte table
    out->next\_section( \`XML 1.0 in Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    xml\_xtab =
      VALUE #( LET l1 = xstrlen( xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            xml\_xstr+j(10)
                          ELSE
                            xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML input stream
    out->next\_section( \`XML 1.0 from Input Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    DATA(istream) = ixml->create\_stream\_factory(
                      )->create\_istream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML istream
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in iXML DOM
    out->next\_section( \`XML 1.0 in DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    DATA(parser) = ixml->create\_parser(
                     document = dom
                     stream\_factory = ixml->create\_stream\_factory( )
                     istream = ixml->create\_stream\_factory(
                        )->create\_istream\_xstring( xml\_xstr ) ).
    parser->parse( ).
    CALL TRANSFORMATION id SOURCE XML dom
                           RESULT XML xml.
    out->write\_xml( xml ).
    "XML 1.0 in XML-Reader
    out->next\_section( \`XML 1.0 from XML Reader\` ).
    DATA(xml\_reader) = cl\_sxml\_string\_reader=>create( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "Binary XML
    out->next\_section( \`Binary XML\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello binary XML!</text>\` ) ).
    DATA(binary\_xml\_writer) =
      cl\_sxml\_string\_writer=>create( type = if\_sxml=>co\_xt\_binary ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( binary\_xml\_writer ).
    "Binary XML in xstring
    out->begin\_section( \`Binary XML in Byte String\` ).
    DATA(binary\_xml\_xstr) = binary\_xml\_writer->get\_output( ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in byte table
    out->next\_section( \`Binary XML in Byte Table\` ).
    DATA binary\_xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    binary\_xml\_xtab =
      VALUE #( LET l1 = xstrlen( binary\_xml\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            binary\_xml\_xstr+j(10)
                          ELSE
                            binary\_xml\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "Binary XML in XML-Reader
    out->next\_section( \`Binary XML from XML Reader\` ).
    DATA(binary\_xml\_reader) = cl\_sxml\_string\_reader=>create(
                                binary\_xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML binary\_xml\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "XOP
    out->next\_section( \`XOP\` ).
    xml\_reader = cl\_sxml\_string\_reader=>create(
                   cl\_abap\_conv\_codepage=>create\_out( )->convert(
                     \`<text>Hello XOP!</text>\` ) ).
    DATA(xop\_writer) =
      cl\_sxml\_xop\_writer=>create( ).
    xml\_reader->next\_node( ).
    xml\_reader->skip\_node( xop\_writer ).
    DATA(xop\_package) = xop\_writer->get\_output( ).
    "XOP in XML-Reader
    out->begin\_section( \`XOP from XML Reader\` ).
    DATA(xop\_reader) = cl\_sxml\_xop\_reader=>create( xop\_package ).
    CALL TRANSFORMATION id SOURCE XML xop\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->end\_section( ).
    "JSON
    out->next\_section( \`JSON\` ).
    "JSON in string
    out->begin\_section( \`JSON in Text String\` ).
    DATA(json\_str) = \`{"TEXT":"Hello JSON!"}\`.
    CALL TRANSFORMATION id SOURCE XML json\_str
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in text table
    out->next\_section( \`JSON in Table of Text Fields\` ).
    DATA json\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    json\_tab =
      VALUE #( LET l1 = strlen( json\_str ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_str+j(10)
                          ELSE
                            json\_str+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_tab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in xstring
    out->next\_section( \`JSON in Byte String\` ).
    DATA(json\_xstr) = cl\_abap\_conv\_codepage=>create\_out(
                        )->convert( json\_str ).
    CALL TRANSFORMATION id SOURCE XML json\_xstr
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in byte table
    out->next\_section( \`JSON in Table of Byte Fields\` ).
    DATA json\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    json\_xtab =
      VALUE #( LET l1 = xstrlen( json\_xstr ) l2 = l1 - 10 IN
               FOR j = 0 THEN j + 10  UNTIL j >= l1
                ( COND #( WHEN j <= l2 THEN
                            json\_xstr+j(10)
                          ELSE
                            json\_xstr+j ) ) ).
    CALL TRANSFORMATION id SOURCE XML json\_xtab
                           RESULT XML xml.
    out->write\_xml( xml ).
    "JSON in XML-Reader
    out->next\_section( \`JSON from XML Reader\` ).
    DATA(json\_reader) = cl\_sxml\_string\_reader=>create( json\_xstr ).
    CALL TRANSFORMATION id SOURCE XML json\_reader
                           RESULT XML xml.
    out->write\_xml( xml
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called with all XML sources for which a format is possible, in the order of the formats. The XML target is always a byte string, which is produced after each successful transformation.


### abencall_trafo_results_abexa.htm

---
title: "XML Targets of Transformations"
description: |
  This example demonstrates the possible XML targets of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm). Source Code REPORT demo_call_trafo_xml_results. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_results_abexa.htm"
abapFile: "abencall_trafo_results_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "types", "internal-table", "abencall", "trafo", "results", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

XML Targets of Transformations

This example demonstrates the possible XML targets of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).

Source Code

REPORT demo\_call\_trafo\_xml\_results.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = CL\_DEMO\_OUTPUT=>NEW(
      )->begin\_section(
      \`XML Results for CALL TRANSFORMATION\` ).
    DATA(xml) = cl\_abap\_conv\_codepage=>create\_out( )->convert(
                 \`<object>\` &&
                 \` <str name="TEXT">Hello Writers!</str>\` &&
                 \`</object>\` ).
    "Strings
    out->begin\_section( \`Strings\` ).
    "string
    out->begin\_section( \`Text String\` ).
    DATA(xml\_str) = VALUE string( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_str.
    out->write\_xml( xml\_str ).
    "xstring
    out->next\_section( \`Byte String\` ).
    DATA(xml\_xstr) = VALUE xstring( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_xstr.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "Internal tables
    out->next\_section( \`Internal Tables\` ).
    "Text table
    out->begin\_section( \`Table of Text Fields\` ).
    TYPES c10 TYPE c LENGTH 10.
    DATA xml\_tab TYPE STANDARD TABLE OF c10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_tab.
    out->write\_xml( concat\_lines\_of( xml\_tab ) ).
    "Byte table
    out->next\_section( \`Table of Byte Fields\` ).
    TYPES x10 TYPE x LENGTH 10.
    DATA xml\_xtab TYPE STANDARD TABLE OF x10 WITH DEFAULT KEY.
    CALL TRANSFORMATION id SOURCE XML xml
                        RESULT XML xml\_xtab.
    CONCATENATE LINES OF xml\_xtab INTO xml\_xstr IN BYTE MODE.
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "iXML
    out->next\_section( \`iXML Library\` ).
    "Output stream
    out->begin\_section( \`Output Stream\` ).
    DATA(ixml) = cl\_ixml=>create( ).
    CLEAR xml\_xstr.
    DATA(ostream) = ixml->create\_stream\_factory(
                      )->create\_ostream\_xstring( xml\_xstr ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML ostream.
    out->write\_xml( xml\_xstr ).
    "DOM
    out->next\_section( \`DOM\` ).
    DATA(dom) = ixml->create\_document( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML dom.
    CLEAR xml\_xstr.
    dom->render( ixml->create\_stream\_factory(
                         )->create\_ostream\_xstring( xml\_xstr ) ).
    out->write\_xml( xml\_xstr
      )->end\_section( ).
    "sXML
    out->next\_section( \`sXML Library\` ).
    "XML 1.0 writer
    out->begin\_section( \`XML 1.0 Writer\` ).
    DATA(xml\_writer) = cl\_sxml\_string\_writer=>create(
                         type = if\_sxml=>co\_xt\_xml10 ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xml\_writer.
    out->write\_xml( xml\_writer->get\_output( ) ).
    "Binary XML writer
    out->next\_section( \`Binary XML Writer\` ).
    DATA(binary\_xml\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_binary ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML binary\_xml\_writer.
    out->write\_xml( binary\_xml\_writer->get\_output( ) ).
    "XOP writer
    out->next\_section( \`XOP Writer\` ).
    DATA(xop\_writer) = cl\_sxml\_xop\_writer=>create( ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML xop\_writer.
    DATA(xop\_package) = xop\_writer->get\_output( ).
    out->write\_xml( xop\_package-xop\_document ).
    "JSON writer
    out->next\_section( \`JSON Writer\` ).
    DATA(json\_writer) = cl\_sxml\_string\_writer=>create(
                                type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT XML json\_writer.
    out->write\_json( json\_writer->get\_output( )
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID is called for all possible XML targets and the result is displayed. The XML source is always the same byte string, which contains the XML data in JSON-XML format.


### abenabap_deserl_no_elem_abexa.htm

---
title: "Deserializing Missing Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_no_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA elem
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_no_elem_abexa.htm"
abapFile: "abenabap_deserl_no_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Missing Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_no\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
       )->write\_data( elem
       )->write\_data( struc
       )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    json = \`{ }\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With the asXML and asJSON display formats, all elements or object components are removed.

When a standard deserialization into the original ABAP data objects is performed, the objects retain their original values. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abenabap_deserl_empt_elem_abexa.htm

---
title: "Deserializing Empty Elements"
description: |
  This example demonstrates the deserialization of empty elements. Source Code REPORT demo_asxml_asjson_empty_vals. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( )->begin_section( `asXML` ). DATA e
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_deserl_empt_elem_abexa.htm"
abapFile: "abenabap_deserl_empt_elem_abexa.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "internal-table", "abenabap", "deserl", "empt", "elem", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Deserializing Empty Elements

This example demonstrates the deserialization of empty elements.

Source Code

REPORT demo\_asxml\_asjson\_empty\_vals.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`asXML\` ).
    DATA elem TYPE i VALUE 111.
    DATA: BEGIN OF struc,
           col TYPE i VALUE 111,
          END OF struc.
    DATA itab TYPE TABLE OF i.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asXML\` ).
    DATA xml TYPE string.
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML xml.
    out->write\_xml( xml ).
    out->next\_section( \`Modified asXML\` ).
    REPLACE \`<ELEM>111</ELEM>\` IN xml WITH \`<ELEM />\`.
    REPLACE \`<STRUC><COL>111</COL></STRUC>\` IN xml WITH \`<STRUC />\`.
    REPLACE \`<ITAB><item>111</item></ITAB>\` IN xml WITH \`<ITAB />\`.
    out->write\_xml( xml ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asXML\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML xml
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->end\_section( ).
    out->next\_section( \`asJSON\` ).
    elem = 111.
    struc-col = 111.
    itab = VALUE #( ( 111 ) ).
    out->begin\_section( \`ABAP Data Objects\`
      )->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects serialized to asJSON\` ).
    DATA(writer) = cl\_sxml\_string\_writer=>create(
                     type = if\_sxml=>co\_xt\_json ).
    CALL TRANSFORMATION id SOURCE elem = elem
                                  struc = struc
                                  itab = itab
                           RESULT XML writer.
    DATA(json) = cl\_abap\_conv\_codepage=>create\_in( )->convert(
                   writer->get\_output( ) ).
    out->write\_json( json ).
    out->next\_section( \`Modified asJSON\` ).
    REPLACE \`"ELEM":111\` IN json WITH \`"ELEM":0\`.
    REPLACE \`"COL":111\` IN json WITH \`\`.
    REPLACE \`111\` IN json WITH \`\`.
    out->write\_json( json ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization of asJSON\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab ).
    out->next\_section(
      \`ABAP Data Objects after Deserialization with Clearing\` ).
    CALL TRANSFORMATION id SOURCE XML json
                           RESULT elem = elem
                                  struc = struc
                                  itab = itab
                          OPTIONS clear = 'all'.
    out->write\_data( elem
      )->write\_data( struc
      )->write\_data( itab
      )->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

An elementary data object, a structure and an internal table are transformed using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID into [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") and [asJSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_glosry.htm "Glossary Entry") display formats. With asXML display format, the values of all elements are removed. With asJSON display format, only the components from objects and arrays can be removed.

After deserialization into the original ABAP data objects, the elementary data object and the internal table are initial. However, the empty element in the structure is interpreted as a missing component and the structure component retains its previous value. If the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) is used with the value "all", all ABAP data objects are initialized.

Note

The modification of XML and JSON data using string processing is only shown here to make the example clearer. In production programs, the APIs of [class libraries for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_libs.htm) should be used.


### abencall_trafo_escaping_abexa.htm

---
title: "Transformation of XML Syntax Characters"
description: |
  This example demonstrates the serialization of characters from the XML syntax using various transformations. Source Code REPORT demo_transformation_escaping. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA xml TYPE string. DATA(text
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_escaping_abexa.htm"
abapFile: "abencall_trafo_escaping_abexa.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abencall", "trafo", "escaping", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Syntax Characters

This example demonstrates the serialization of characters from the XML syntax using various transformations.

Source Code

REPORT demo\_transformation\_escaping.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA xml TYPE string.
    DATA(text) = \`<>&"\`.
    DATA(out) = cl\_demo\_output=>new(
      )->begin\_section( \`Text\`
      )->write( text
      )->next\_section( \`XSLT\`
      )->begin\_section( \`<xsl:output method="text" />\` ).
    CALL TRANSFORMATION demo\_escaping\_text SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="xml" />\` ).
    CALL TRANSFORMATION demo\_escaping\_xml SOURCE text = text
                                          RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_html SOURCE text = text
                                           RESULT XML xml.
    out->write( xml
      )->next\_section( \`<xsl:output method="html" />\` ).
    CALL TRANSFORMATION demo\_escaping\_js SOURCE text = text
                                         RESULT XML xml.
    out->write( xml
      )->end\_section(
      )->next\_section( \`ST\` ).
    CALL TRANSFORMATION demo\_escaping\_st SOURCE text = text
                                         RESULT XML xml.
    out->write( xml ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Four XSLT programs with different output methods are called and an ST program for serializing a text string containing the syntax characters <>&". The results are as follows:

-   No replacements are made in the results of the XSL transformation DEMO\_ESCAPING\_TEXT with the output method "text".

-   In the results of the XSL transformation DEMO\_ESCAPING\_XML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_HTML with the output method "xml", the syntax characters <, \> and & are replaced by &lt;, &gt;, and &amp;.

-   In the results of the XSL transformation DEMO\_ESCAPING\_JS with the output method "html", the syntax characters are not replaced because they are part of JavaScript.

The results of the simple transformation DEMO\_ESCAPING\_ST match the XSL transformation with the output method "xml". Also, the text string is displayed here as an attribute in which the syntax character " is replaced by &quot;.


### abencall_trafo_upper_lower_abexa.htm

---
title: "Transformation of XML Element Names"
description: |
  This example demonstrates the transformation of letters in XML element names. Source Code REPORT demo_trafo_upper_lower. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. ENDCLASS. CLASS demo IMPLEMENTATION. METHOD main. DATA(out) = cl_demo_output=>new( ). DATA: BEGIN OF simple_struc,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_trafo_upper_lower_abexa.htm"
abapFile: "abencall_trafo_upper_lower_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "abencall", "trafo", "upper", "lower", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml.htm) →  [Transformations for XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_trafos.htm) →  [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) →  [CALL TRANSFORMATION - Examples](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencall_transformation_abexas.htm) → 

Transformation of XML Element Names

This example demonstrates the transformation of letters in XML element names.

Source Code

REPORT demo\_trafo\_upper\_lower.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA(out) = cl\_demo\_output=>new( ).
    DATA: BEGIN OF simple\_struc,
            int\_col1 TYPE i VALUE 111,
            int\_col2 TYPE i VALUE 222,
          END OF simple\_struc.
    out->begin\_section( \`Serialization\` ).
    CALL TRANSFORMATION id
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(asxml).
    out->begin\_section( \`ID\`
      )->write\_xml( asxml ).
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        PARAMETERS mode = 'LO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_lower).
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER\`
      )->write\_xml( xml\_lower ).
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        PARAMETERS mode = 'TO'
                        SOURCE simple\_struc = simple\_struc
                        RESULT XML DATA(xml\_camel).
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED\`
      )->write\_xml( xml\_camel ).
    out->end\_section(
      )->next\_section( \`Deserialization\` ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->begin\_section( \`ID for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION id
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`ID for XML\_CAMEL\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_upper\_lower
                        SOURCE XML xml\_lower
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_UPPER\_LOWER for XML\_LOWER\`
      )->write( simple\_struc ).
    CLEAR simple\_struc.
    CALL TRANSFORMATION demo\_id\_from\_to\_mixed
                        SOURCE XML xml\_camel
                        RESULT simple\_struc = simple\_struc.
    out->next\_section( \`DEMO\_ID\_FROM\_TO\_MIXED for XML\_CAMEL\`
      )->write( simple\_struc ).
    out->display( ).  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

In deserializations of XML data to ABAP data, the XML elements in question must generally be written in uppercase letters to be identified. This example shows ways of transforming elements written in other ways using self-written XSL transformations.

-   A structure, simple\_struc, is serialized using various XSL transformations.

-   The [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID creates [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry") with XML element names in uppercase letters.

-   The self-written XSL transformation DEMO\_ID\_UPPER\_LOWER transforms the XML element names created by the serialization to lowercase letters, if the correct parameter passing is used.

-   The self-written XSL transformation DEMO\_ID\_FROM\_TO\_MIXED transforms the XML element names created by the serialization to Mixed Case Style (also known as Camel Case Style), if the correct parameter passing is used. To do this, an ABAP method is called from the transformation and this method itself calls the built-in function [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm).

-   Deserializations of the transformed asXML data with the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID do not find the structure or the components.

-   Deserializations of the transformed asXML data with the self-written XSL transformations, on the other hand, are successful.

-   DEMO\_ID\_UPPER\_LOWER also transforms lowercase letters to uppercase letters.

-   DEMO\_ID\_FROM\_TO\_MIXED also calls a method for [to\_mixed](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencase_functions.htm). This simple example transformations is not, however, symmetrical in all cases.

Instead of transformations, parsers and renderers can be used, as demonstrated in the executable example for [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_names_to_upper_abexa.htm). The serial processing used here can be useful when dealing with large volumes of data.

The transformations used are as follows:

DEMO\_ID\_UPPER\_LOWER

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml">
  <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:param name="MODE" select="'UP'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='LO',
         translate(name(),$uppercase, $smallcase ),
         translate(name(),$smallcase, $uppercase ))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>

DEMO\_ID\_FROM\_TO\_MIXED

<xsl:transform version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sap="http://www.sap.com/sapxsl"
  xmlns:asx="http://www.sap.com/abapxml"
  xmlns:f="FCT" exclude-result-prefixes="f">
<sap:external-function name="f:toCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="TO\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<sap:external-function name="f:fromCC" kind="class"
class="CL\_DEMO\_XSLT\_FROM\_TO\_MIXED" method="FROM\_CAMEL\_CASE">
  <sap:argument param="IN"  type="string"/>
  <sap:result   param="OUT" type="string"/>
</sap:external-function>
<xsl:param name="MODE" select="'FROM'"/>
<xsl:template match="\*">
  <xsl:element name="{sap:if($MODE='TO',
                      f:toCC(name()),
                      f:fromCC(name()))}">
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>
<xsl:template match="asx:\*">
  <xsl:copy>
    <xsl:copy-of select="@\*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:copy>
</xsl:template>
<xsl:template match="text() | processing-instruction() | comment()">
  <xsl:copy/>
</xsl:template>
</xsl:transform>


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and JSON / Transformations for JSON / asJSON - Canonical JSON Representation

**Files**: 14 | **Difficulty**: advanced

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and JSON / Transformations for JSON / asJSON - Canonical JSON Representation

Included pages: 14


### abenabap_asjson.htm

---
title: "Notes"
description: |
  -   asJSON only occurs in the identity transformation(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm 'Glossary Entry') ID. In particular, asJSON is not generally needed for self-written transformations for JSON; JSON-XML(https://help.sap.com/doc/abapdocu_754_i
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm"
abapFile: "abenabap_asjson.htm"
keywords: ["do", "while", "try", "data", "types", "abenabap", "asjson"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) → 

asJSON - Canonical JSON Representation

The canonical JSON representation asJSON is the format of [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_glosry.htm "Glossary Entry") data that is produced by a serialization of ABAP data using the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID, or that is required for a deserialization using the identity transformation.

asJSON is based closely on [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml.htm). From a conceptual perspective, a asJSON representation is produced by a restructuring of the asXML representation of this ABAP data to a [JSON-XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_xml_glosry.htm "Glossary Entry") representation, while keeping all value content. This means the same basic rules apply as for asXML. In particular, XML schema data types for the mapping of ABAP data types are also used in asJSON.

Description of the asJSON format:

-   [General asJSON Format](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm)

-   [Mapping of ABAP Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm)

Notes

-   asJSON only occurs in the [identity transformation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") ID. In particular, asJSON is not generally needed for self-written transformations for JSON; [JSON-XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_xml_glosry.htm "Glossary Entry") is used directly instead.

-   A JSON-XML representation of asJSON is known as [asJSON-XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasjson_xml_glosry.htm "Glossary Entry"). asJSON-XML is not used as an intermediate format in transformations, but the asJSON-XML associated with a asJSON representation can be created to analyze it and compare it with asXML.

Continue
[asJSON - General Format](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm)
[asJSON - Mapping of ABAP Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm)
[asJSON - Mapping Additional XML Schema Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_schema.htm)


### abenabap_asjson_general.htm

---
title: "Executable Example"
description: |
  asJSON, General Format(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_hello_json_abexa.htm)
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm"
abapFile: "abenabap_asjson_general.htm"
keywords: ["do", "if", "case", "try", "class", "data", "abenabap", "asjson", "general"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) → 

asJSON - General Format

The following lines show the general format of the [canonical JSON representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencanonical_json_represen_glosry.htm "Glossary Entry"). Any line breaks and indents are included for ease or reading only.

{
  "bn1":...
  "bn2":...
   ...
  "%heap":{...}
}

The top level contains the object { }. The object components with the names bn1, bn2 ... represent the ABAP data objects specified in the addition source of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) as e1 e2 ... or in the addition result as f1 f2 ... The names of the object components bn1, bn2, ... are the names specified there in uppercase.

The values of the object components represent the content of named data object in accordance with the type-dependent mapping described in the following sections. Here, reference variables are always represented as object components whose content is objects that reference the content of referenced anonymous data objects and instances of classes in an optional object component %heap of the top object.

The same rules apply to the names of the object components bn1, bn2 ... as in [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml_general.htm) and replacements can be made as defined the table specified there.

Executable Example

[asJSON, General Format](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_hello_json_abexa.htm)


### abenabap_asjson_abap_types.htm

---
title: "Continue"
description: |
  asJSON - Mapping of Elementary ABAP Types(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_elem.htm) asJSON - Mapping of Structures(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_struc.htm) asJSON - Mapping of Internal
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm"
abapFile: "abenabap_asjson_abap_types.htm"
keywords: ["do", "data", "types", "internal-table", "abenabap", "asjson", "abap"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) → 

asJSON - Mapping of ABAP Data Types

Named data objects other than reference variables are represented in asJSON as the content of the following object components:

[“bn1":...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm)
["bn1":...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm)
[...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm)

An additional object is implemented for the objects referenced by reference variables:

["%heap":...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm)

Depending on the ABAP data type, serializations map the value of named data objects to a particular JSON representation; deserializations operate in the opposite direction:

-   [Mapping of Elementary ABAP Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_elem.htm)

-   [Mapping of Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_struc.htm)

-   [Mapping of Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_table.htm)

-   [Mapping of Enumerated Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_enum.htm)

-   [Mapping of Reference Variables and Referenced Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asxml_references.htm)

Continue
[asJSON - Mapping of Elementary ABAP Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_elem.htm)
[asJSON - Mapping of Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_struc.htm)
[asJSON - Mapping of Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_table.htm)
[asJSON - Mapping of Enumerated Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_enum.htm)
[asJSON - Mapping of Reference Variables and Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asxml_references.htm)


### abenabap_asjson_abap_types_elem.htm

---
title: "Note"
description: |
  An elementary ABAP data object that does not have an associated JSON object component in deserializations retains its previous value. To initialize the data object in this case, the transformation option clear(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_optio
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_elem.htm"
abapFile: "abenabap_asjson_abap_types_elem.htm"
keywords: ["do", "case", "data", "types", "abenabap", "asjson", "abap", "elem"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) →  [asJSON - Mapping of ABAP Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm) → 

asJSON - Mapping of Elementary ABAP Types

The values of elementary ABAP types are represented in asJSON using the [JSON representations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_oview.htm) of character-like values and number values. Representations of Boolean values and zero are not used.

-   The values of all numeric types (i, p, decfloat16, decfloat34, f) are represented directly as JSON number values.

-   The values of all other types (c, string, n, d, t, x, xstring) are represented as character-like values in quotation marks.

The type-dependent format of a value corresponds to the [asXML representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml_named.htm) of elementary types and can be taken from the tables there. The serialization and deserialization behavior noted there applies.

Note

An elementary ABAP data object that does not have an associated JSON object component in deserializations retains its previous value. To initialize the data object in this case, the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) with the value "all" can be used.

Executable Example

[asJSON for Elementary ABAP Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_asjson_elem_abexa.htm)


### abenabap_asjson_abap_types_struc.htm

---
title: "Note"
description: |
  A structure that does not have an associated JSON object component in deserializations retains its previous value. A structure to which an empty object is assigned also remains unchanged, since this has the same effect on the structure components as a missing object component. To initialize the stru
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_struc.htm"
abapFile: "abenabap_asjson_abap_types_struc.htm"
keywords: ["do", "case", "data", "types", "abenabap", "asjson", "abap", "struc"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) →  [asJSON - Mapping of ABAP Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm) → 

asJSON - Mapping of Structures

In asJSON, an ABAP structure is represented as a [JSON object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_oview.htm) whose object components represent the structure components. The content of each object component corresponds to the canonical representation of the component value. The name of each object component is the name of the corresponding structure component. In serializations, the object components are represented in the order of the components in the structure. In deserializations of the asJSON representation of a structure, the order of the object components is not important and redundant object components are ignored. Components of the structure for which there are no object components remain unchanged.

Note

A structure that does not have an associated JSON object component in deserializations retains its previous value. A structure to which an empty object is assigned also remains unchanged, since this has the same effect on the structure components as a missing object component. To initialize the structure in these cases, the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) can be used with the value "all".

Executable Example

[asJSON for Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_asjson_struc_abexa.htm)


### abenabap_asjson_abap_types_table.htm

---
title: "Notes"
description: |
  -   An internal table that does not have an associated JSON object component in deserializations retains its previous value. If an empty array is assigned to an internal table, it is set to its type-dependent initial value (which means it is emptied). To initialize the internal table in either case,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_table.htm"
abapFile: "abenabap_asjson_abap_types_table.htm"
keywords: ["do", "if", "case", "try", "data", "types", "internal-table", "abenabap", "asjson", "abap", "table"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) →  [asJSON - Mapping of ABAP Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm) → 

asJSON - Mapping of Internal Tables

Internal tables are represented in asJSON as [JSON arrays](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_oview.htm). The rows of the internal table are represented in their canonical representation as the components of the array. All table categories are allowed. Serializations do not pass any information about the table category to the JSON data. If the target field of a deserialization is a [sorted table](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensorted_table_glosry.htm "Glossary Entry"), the rows are sorted accordingly.

Notes

-   An internal table that does not have an associated JSON object component in deserializations retains its previous value. If an empty array is assigned to an internal table, it is set to its type-dependent initial value (which means it is emptied). To initialize the internal table in either case, the transformation option [clear](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) with the value "all" can be used.

-   Unlike in the [asXML representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml_table.htm) of internal tables, asJSON does not require a name like item for the table rows.

Executable Example

[asJSON for Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_asjson_table_abexa.htm)


### abenabap_asjson_abap_types_enum.htm

---
title: "Example"
description: |
  Serialization of an internal table with enumerated values by JSON. TYPES: BEGIN OF ENUM color STRUCTURE col, red, blue, green, END OF ENUM color STRUCTURE col. DATA colors TYPE SORTED TABLE OF color WITH UNIQUE KEY table_line. DO. ASSIGN COMPONENT sy-index OF STRUCTURE col TO FIELD-SYMBOL(<fs>). IF
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_enum.htm"
abapFile: "abenabap_asjson_abap_types_enum.htm"
keywords: ["do", "if", "case", "try", "data", "types", "internal-table", "abenabap", "asjson", "abap", "enum"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) →  [asJSON - Mapping of ABAP Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm) → 

asJSON - Mapping of Enumerated Types

The asJSON representation of [enumerated types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_type_glosry.htm "Glossary Entry") corresponds to their [asXML representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml_enum.htm). That is, in asJSON the content of an [enumerated object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_object_glosry.htm "Glossary Entry") is represented by the name (maximum 30 characters) of the [enumerated value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenenumerated_value_glosry.htm "Glossary Entry") in uppercase letters, and this is represented as a character-like [elementary data object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_elem.htm).

Example

Serialization of an internal table with enumerated values by JSON.

TYPES:
  BEGIN OF ENUM color STRUCTURE col,
    red, blue, green,
  END OF ENUM color STRUCTURE col.
DATA colors TYPE SORTED TABLE OF color
            WITH UNIQUE KEY table\_line.
DO.
  ASSIGN COMPONENT sy-index OF STRUCTURE col TO FIELD-SYMBOL(<fs>).
  IF sy-subrc <> 0.
    EXIT.
  ENDIF.
  colors = VALUE #( BASE colors ( <fs> ) ).
ENDDO.
DATA(writer) = cl\_sxml\_string\_writer=>create(
     type = if\_sxml=>co\_xt\_json ).
CALL TRANSFORMATION id SOURCE colors = colors
                       RESULT XML writer.
cl\_demo\_output=>display\_json( writer->get\_output( ) ).

The output is:

{
"COLORS":
\[
  "RED",
  "BLUE",
  "GREEN"
\]
}


### abenabap_asxml_references.htm

---
title: "Note"
description: |
  -   The asJSON representation of reference variables and referenced objects is only of relevance for XSL(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm 'Glossary Entry') transformations and the identity transformation ID. You cannot currently use simple transfor
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asxml_references.htm"
abapFile: "abenabap_asxml_references.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenabap", "asxml", "references"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) →  [asJSON - Mapping of ABAP Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm) → 

asJSON - Mapping of Reference Variables and Objects

A reference mechanism is used (like in [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml_references.htm)) for the asJSON display of anonymous data objects and class instances (objects), which are addressed using references in reference variables. As [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_oview.htm) does not suggest any syntax for references, an SAP-specific reference mechanism based on asXML is used.

-   Named reference variables are displayed as object components, whose content is usually a key for the referenced objects.

-   The referenced objects are stored as object components in the object [%heap](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm). This name corresponds to the key.

In addition to the value, the dynamic type of the reference variables is specified in the object components of %heap when serialization takes place. This ensures that deserialization is unambiguous.

-   [Named Reference Variables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_reference_var.htm)

-   [Anonymous Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_anonym_do.htm)

-   [Class Instances](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_class_instances.htm)

Note

-   The asJSON representation of reference variables and referenced objects is only of relevance for [XSL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") transformations and the identity transformation ID. You cannot currently use simple transformations to transform reference variables.

-   For data references, the value "embedded" can be specified for the transformation option [data\_refs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) to define embedded storage in serializations instead of storage in the %heap object component.

Example

For information about the differences between serializing to %heap and embedded storage, see the executable example [Serializations to Heap or Embedded](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenserialize_ref_heap_embed_abexa.htm).

Continue
[asJSON - Named Reference Variables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_reference_var.htm)
[asJSON - Anonymous Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_anonym_do.htm)
[asXML - Instances of Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_class_instances.htm)


### abenabap_asjson_reference_var.htm

---
title: "Executable Example"
description: |
  Serializing Data References(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenserialize_dref_abexa.htm)
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_reference_var.htm"
abapFile: "abenabap_asjson_reference_var.htm"
keywords: ["do", "case", "data", "types", "abenabap", "asjson", "reference", "var"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) →  [asJSON - Mapping of ABAP Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm) →  [asJSON - Mapping of Reference Variables and Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asxml_references.htm) → 

asJSON - Named Reference Variables

Like a regular data object, a named reference variable is represented as an object component that has special content:

"bni":{ "%ref":"#key" }

The content of the object component of a named reference variable is an object with precisely one object component, called %ref. The content of the object component %ref is a character-like value "#key", where key is the unique key of an object component in the object %heap. The object of an initial reference is empty. The key key of the ABAP runtime environment is set in serializations; in deserializations, any key can be used.

Otherwise the same rules apply to serializations and deserializations of named reference variables as to [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_reference_variable.htm) and the same special cases need to be noted.

Executable Example

[Serializing Data References](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenserialize_dref_abexa.htm)


### abenabap_asjson_anonym_do.htm

---
title: "Executable Example"
description: |
  asJSON for Anonymous Data Objects(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_asjson_dref_abexa.htm).
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_anonym_do.htm"
abapFile: "abenabap_asjson_anonym_do.htm"
keywords: ["do", "if", "data", "types", "abenabap", "asjson", "anonym"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) →  [asJSON - Mapping of ABAP Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm) →  [asJSON - Mapping of Reference Variables and Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asxml_references.htm) → 

asJSON - Anonymous Data Objects

An anonymous data object, that is a data object created using CREATE DATA or the instance operator NEW, is displayed as an object component of %heap in the form:

"key":{ "%type":"...",
        "%maxLength":...,
        "%totalDigits":...,
        "%fractionDigits":...,
        "%val":...
      }

The name key is the key used to reference the anonymous data object. The value of key is itself an object whose object components represent the type and the value of the anonymous data object.

The values of the anonymous data object is specified as content of the component %val in its canonical representation. If the anonymous data object itself is a non-initial reference variable, it references another component of %heap.

The remaining components specify the data type of the anonymous data object.

-   The same rules apply to the content of %type as to the element name type in [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_anonymous_data_object.htm).

-   The components %maxLength, %totalDigits, and %fractionDigits specify the technical attributes of the type (if required). The same rules apply to their content as to the corresponding attributes in [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_anonymous_data_object.htm).

Executable Example

[asJSON for Anonymous Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_asjson_dref_abexa.htm).


### abenabap_asjson_class_instances.htm

---
title: "Executable Example"
description: |
  asJSON for Object References(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_asjson_oref_abexa.htm)
version: "7.54"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_class_instances.htm"
abapFile: "abenabap_asjson_class_instances.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "abenabap", "asjson", "instances"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) →  [asJSON - Mapping of ABAP Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm) →  [asJSON - Mapping of Reference Variables and Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asxml_references.htm) → 

asXML - Instances of Classes

To transform classes to [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_glosry.htm "Glossary Entry") using the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm), or to create classes from JSON data, their classes must implement the interface IF\_SERIALIZABLE\_OBJECT. The instance of a class (object) is displayed as an object component of the object %heap as follows:

"key":{ "%type":"class",
        "%val":{ "part":{ "%classVersion":"...",
                          "name":...
                          ...
                        }
                 ...
               }
      }

The name key is the key used to reference the object. The value of key is itself an object whose object components represent the class and the attributes of the referenced ABAP object.

-   The character-like value class of the component %TYPE specifies the class of the object. The same applies to class as to the element name class in [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_class_instances.htm) representation. In asJSON, the namespace that specifies where the class is defined in asXML is resolved before the class name.

-   The component %VAL represents the attribute values of the object. The value of %VAL is itself an object. The components part are objects that contain the values of the instance attributes of individual object parts. The same applies to the object parts and their names part as to the subelements <part> in [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_class_instances.htm) representation.

-   The components of an object part part represent the values of the instance attributes of the objects in their canonical representation, under their names. The same applies to the names as to the corresponding elements in [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_class_instances.htm) representation. Static attributes are ignored.

-   An optional component, %classVersion, of an object part, part, contains the version of the class of the object part in character-like representation. The same applies to the version of the class as to the attribute classVersion in [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_class_instances.htm) representation.

The [tag interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentag_interface_glosry.htm "Glossary Entry") IF\_SERIALIZABLE\_OBJECT has the same meaning for JSON as for [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_class_instances.htm). This means it defines which attributes of a class are serialized and helper methods can be implement that modify the behavior (see the [example](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenserializable_object_abexa.htm)).

Executable Example

[asJSON for Object References](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_asjson_oref_abexa.htm)


### abenabap_asxml_references.htm

---
title: "Note"
description: |
  -   The asJSON representation of reference variables and referenced objects is only of relevance for XSL(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm 'Glossary Entry') transformations and the identity transformation ID. You cannot currently use simple transfor
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asxml_references.htm"
abapFile: "abenabap_asxml_references.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenabap", "asxml", "references"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) →  [asJSON - Mapping of ABAP Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm) → 

asJSON - Mapping of Reference Variables and Objects

A reference mechanism is used (like in [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml_references.htm)) for the asJSON display of anonymous data objects and class instances (objects), which are addressed using references in reference variables. As [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_oview.htm) does not suggest any syntax for references, an SAP-specific reference mechanism based on asXML is used.

-   Named reference variables are displayed as object components, whose content is usually a key for the referenced objects.

-   The referenced objects are stored as object components in the object [%heap](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm). This name corresponds to the key.

In addition to the value, the dynamic type of the reference variables is specified in the object components of %heap when serialization takes place. This ensures that deserialization is unambiguous.

-   [Named Reference Variables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_reference_var.htm)

-   [Anonymous Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_anonym_do.htm)

-   [Class Instances](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_class_instances.htm)

Note

-   The asJSON representation of reference variables and referenced objects is only of relevance for [XSL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenid_trafo_glosry.htm "Glossary Entry") transformations and the identity transformation ID. You cannot currently use simple transformations to transform reference variables.

-   For data references, the value "embedded" can be specified for the transformation option [data\_refs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_options.htm) to define embedded storage in serializations instead of storage in the %heap object component.

Example

For information about the differences between serializing to %heap and embedded storage, see the executable example [Serializations to Heap or Embedded](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenserialize_ref_heap_embed_abexa.htm).

Continue
[asJSON - Named Reference Variables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_reference_var.htm)
[asJSON - Anonymous Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_anonym_do.htm)
[asXML - Instances of Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_class_instances.htm)


### abenabap_asjson_abap_types.htm

---
title: "Continue"
description: |
  asJSON - Mapping of Elementary ABAP Types(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_elem.htm) asJSON - Mapping of Structures(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_struc.htm) asJSON - Mapping of Internal
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types.htm"
abapFile: "abenabap_asjson_abap_types.htm"
keywords: ["do", "data", "types", "internal-table", "abenabap", "asjson", "abap"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) → 

asJSON - Mapping of ABAP Data Types

Named data objects other than reference variables are represented in asJSON as the content of the following object components:

[“bn1":...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm)
["bn1":...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm)
[...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm)

An additional object is implemented for the objects referenced by reference variables:

["%heap":...](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_general.htm)

Depending on the ABAP data type, serializations map the value of named data objects to a particular JSON representation; deserializations operate in the opposite direction:

-   [Mapping of Elementary ABAP Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_elem.htm)

-   [Mapping of Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_struc.htm)

-   [Mapping of Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_table.htm)

-   [Mapping of Enumerated Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_enum.htm)

-   [Mapping of Reference Variables and Referenced Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asxml_references.htm)

Continue
[asJSON - Mapping of Elementary ABAP Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_elem.htm)
[asJSON - Mapping of Structures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_struc.htm)
[asJSON - Mapping of Internal Tables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_table.htm)
[asJSON - Mapping of Enumerated Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_abap_types_enum.htm)
[asJSON - Mapping of Reference Variables and Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asxml_references.htm)


### abenabap_asjson_schema.htm

---
title: "Note"
description: |
  By specifying format(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenst_option_format.htm) in the attribute option(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenst_option.htm) of the ST command tt:value(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson_schema.htm"
abapFile: "abenabap_asjson_schema.htm"
keywords: ["do", "if", "try", "data", "types", "abenabap", "asjson", "schema"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json.htm) →  [Transformations for JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_trafos.htm) →  [asJSON - Canonical JSON Representation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_asjson.htm) → 

asJSON - Mapping Additional XML Schema Data Types

In [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasxml_glosry.htm "Glossary Entry"), apart from the XML schema data types needed to map elementary ABAP types, additional XML schema data types are supported by special [domains](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml_schema.htm) called XSD....

asJSON, which is based on asXML, also supports these domains (with the exception of XSDQNAME). In serializations and deserializations from or to ABAP data objects typed with these domains, the same applies as to [asXML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xslt_asxml_schema.htm). Here, values from the domain XSDBOOLEAN are represented as real [Boolean JSON values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_oview.htm) in asJSON.

Note

By specifying [format](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenst_option_format.htm) in the attribute [option](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenst_option.htm) of the ST command [tt:value](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenst_tt_value_elementary.htm), formats of this type can also be applied to ABAP data objects that are not typed with a domain of this type. In JSON, furthermore, the option attribute also makes it possible to convert ABAP data fields and time stamps to UNIX time stamps (or ticks) in the JSON format for OData.

Executable Example

[asJSON for Additional XML Schema Data Types](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_json_asjson_xsd_abexa.htm)


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and OLE

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and OLE

Included pages: 6


### abenole2.htm

---
title: "ABAP and OLE"
description: |
  ABAP can be used to edit automation objects whose functions are available in the presentation layer in the form of an OLE Automation server. Only automation objects for Windows are supported. Typical applications that offer an automation interface are Microsoft Office products Excel and Word, for wh
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenole2.htm"
abapFile: "abenole2.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abenole2"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) → 

ABAP and OLE

ABAP can be used to edit automation objects whose functions are available in the presentation layer in the form of an OLE Automation server. Only automation objects for Windows are supported. Typical applications that offer an automation interface are Microsoft Office products Excel and Word, for which the published classes and their attributes and methods are found in the object directory of Visual Basic Editor called using the Macro menu option.

All automation applications that can be used by ABAP are contained in the database table TOLE, which is edited using transaction SOLE. This table contains the names of the classes and components supported by the [ABAP runtime environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_runtime_envir_glosry.htm "Glossary Entry"). It also contains type information for adapting different data formats. The automation command set consists of the following ABAP statements:

-   [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole2.htm)

-   [CALL METHOD](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_ole2.htm)

-   [GET PROPERTY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_property.htm)

-   [SET PROPERTY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_property.htm)

-   [FREE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapfree_object.htm),

where CREATE OBJECT and CALL METHOD should not be confused with the ABAP Objects statements using the same syntax.

The statements of the automation command set are passed from the ABAP runtime environment to the SAP GUI on the current presentation server responsible for the actual communication with the automation server. The statements are not passed directly and are first buffered in an automation queue and passed together to SAP GUI in a flush call. By default, a flush is triggered by the next ABAP statement that does not belong to the automation command set.

Note

For editing some of the automation objects, the more general interfaces SAP Desktop Office Integration (DOI) and Control Framework (CFW) are now available. The statements of the automation command set should be used only to access automation applications for which there is no such wrapping.

Continue
[CREATE OBJECT - OLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole2.htm)
[CALL METHOD - OLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_ole2.htm)
[GET PROPERTY - OLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_property.htm)
[SET PROPERTY - OLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_property.htm)
[FREE OBJECT - OLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapfree_object.htm)


### abapcreate_object_ole2.htm

---
title: "CREATE OBJECT - OLE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole_shortref.htm) Syntax CREATE OBJECT ole class NO FLUSH QUEUE-ONLY. Extras: 1. ... NO FLUSH(#!ABAP_ADDITION_1@1@) 2. ... QUEUE-ONLY(#!ABAP_ADDITION_2@2@) Effect This statement creat
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole2.htm"
abapFile: "abapcreate_object_ole2.htm"
keywords: ["do", "if", "case", "try", "method", "class", "data", "abapcreate", "object", "ole2"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and OLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenole2.htm) → 

CREATE OBJECT - OLE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole_shortref.htm)

Syntax

CREATE OBJECT ole class *\[*NO FLUSH*\]* *\[*QUEUE-ONLY*\]*.

Extras:

[1\. ... NO FLUSH](#!ABAP_ADDITION_1@1@)
[2\. ... QUEUE-ONLY](#!ABAP_ADDITION_2@2@)

Effect

This statement creates the automation object ole of the automation class class. The object ole must be of type ole2\_object, which is defined in ABAP Dictionary in the [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") OLE2. The automation class class expects a character-like data object is expected that contains the name of the class.

The system automatically executes an authorization check if the column AUTH\_CHK in the database table TOLE contains the value "X" for the class. The authorization status can be checked with the function module AUTHORITY\_CHECK\_OLE.

System Fields

sy-subrc

Meaning

0

Automation object created.

1

Error in communication to the SAP GUI

2

Error in function call in the SAP GUI

3

Problems with memory allocation in the presentation layer.

Notes

-   For the declaration of ole, exactly the type ole2\_object must be specified. It is not sufficient to specify another type declared with a reference to ole2\_object.
    
-   An automation object ole created using CREATE OBJECT ole must also be released by using FREE OBJECT ole to avoid memory bottle necks and terminations of the application to be controlled.
    
-   CREATE OBJECT for OLE should not be confused with the statement of the same name in ABAP Objects.
    

Addition 1

... NO FLUSH

Effect

When using the addition NO FLUSH, calls from automation methods are collected in the automation buffer until the function module FLUSH (which is provided for this purpose) is called and the FREE OBJECT statement is passed or, at the most, until a change of [screen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscreen_glosry.htm "Glossary Entry"). They are then passed to the automation server in the current presentation layer for asynchronous execution. Without this addition, the flush is executed and the pass takes place as soon as a statement that does not belong to the automation command set is reached. Note that in the ABAP Debugger, the return values of the individual automation statements are not available until after the pass to the presentation layer.

Addition 2

... QUEUE-ONLY

Effect

The addition QUEUE-ONLY dictates that, in flushes, the new object is not passed to the specified ABAP data object rc as a return code using methods called by CALL METHOD OF. In this case, the automation buffer can only contain the statements CREATE OBJECT, CALL METHOD, and GET PROPERTY using the addition QUEUE-ONLY. When executing the program in the ABAP Debugger, the return values are passed by default.

Example

In this example, the automation object app is created, which has access to all methods and attributes of the class APPLICATION in the MS Excel Library. This class contains methods with which, for example, an Excel document can be opened or copied.

DATA app TYPE ole2\_object.
CREATE OBJECT app 'Excel.Application' NO FLUSH.


### abapcall_method_ole2.htm

---
title: "CALL METHOD - OLE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_of_ole_shortref.htm) Syntax CALL METHOD OF ole meth = rc EXPORTING p1 = f1 p2 = f2 ... NO FLUSH QUEUE-ONLY. Extras: 1.... EXPORTING p1 = f1 p2 = f2 ...(#!ABAP_ADDITION_1@1@
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_ole2.htm"
abapFile: "abapcall_method_ole2.htm"
keywords: ["select", "do", "if", "case", "try", "method", "data", "abapcall", "ole2"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and OLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenole2.htm) → 

CALL METHOD - OLE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_method_of_ole_shortref.htm)

Syntax

CALL METHOD OF ole meth *\[*\= rc*\]*
               *\[*EXPORTING p1 = f1 p2 = f2 ...*\]*
               *\[*NO FLUSH*\]* *\[*QUEUE-ONLY*\]*.

Extras:

[1.... EXPORTING p1 = f1 p2 = f2 ...](#!ABAP_ADDITION_1@1@)
[2.... NO FLUSH](#!ABAP_ADDITION_2@2@)
[3.... QUEUE-ONLY](#!ABAP_ADDITION_3@3@)

Effect

This statement calls the method meth of the automation object ole. The automation object must have been created using the special statement [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole2.htm) for automation objects. The name of the method has to be specified in a character-like data object meth.

The return value of the external method meth can be stored in a data object rc. This data object expects, in accordance with the called method, a character-like data type of length 8 or a data type of type ole2\_object from the [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") OLE2 to be able to accept the addressed object.

Addition 1

... EXPORTING p1 = f1 p2 = f2 ...

Effect

The addition EXPORTING can be used to assign actual parameters f1 f2 ... to the input parameters p1 p2 ... of the automation method. The data type of the data objects f1 f2 ... depends on the requirements of the automation method.

Addition 2

... NO FLUSH

Addition 3

... QUEUE-ONLY

Effect

The additions NO FLUSH and QUEUE-ONLY are described in the statement [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole2.htm).

System Fields

sy-subrc

Meaning

0

Method meth executed successfully.

1

Error in communication with SAP GUI.

2

Error when calling the method meth.

3

Error when setting an attribute.

4

Error when reading an attribute.

Example

Depending on the selection on the [selection screen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselection_screen_glosry.htm "Glossary Entry"), this source code can be used to open the Excel file Table.xls in directory C:\\temp, start the application Word, and then close both applications again. The automation methods used are listed in the following table.

Application

Method

Parameter

Function

Excel

Open

File name and path

Open

Excel

Quit

\-

Exit

Word

AppShow

\-

Start

Word

AppClose

\-

Exit

TABLES sscrfields.
DATA: excel TYPE ole2\_object,
      word  TYPE ole2\_object,
      book  TYPE ole2\_object,
      rc    TYPE c LENGTH 8.
SELECTION-SCREEN:
  BEGIN OF SCREEN 100 AS WINDOW TITLE title,
    BEGIN OF LINE,
      PUSHBUTTON  2(12) button\_1
                  USER-COMMAND word\_start,
      PUSHBUTTON  20(12) button\_2
                  USER-COMMAND excel\_start,
    END OF LINE,
    BEGIN OF LINE,
      PUSHBUTTON  2(12) button\_3
                  USER-COMMAND word\_stop,
      PUSHBUTTON  20(12) button\_4
                  USER-COMMAND excel\_stop,
    END OF LINE,
  END OF SCREEN 100.
START-OF-SELECTION.
  button\_1 = 'Start Word'.
  button\_2 = 'Start Excel'.
  button\_3 = 'Stop  Word'.
  button\_4 = 'Stop  Excel'.
  CALL SELECTION-SCREEN 100 STARTING AT 10 10.
AT SELECTION-SCREEN.
  CASE sscrfields-ucomm.
    WHEN 'WORD\_START'.
      CHECK word-handle <> -1.
      CHECK word-header = space.
      CREATE OBJECT   word  'Word.Basic'.
      CALL METHOD  OF word  'AppShow'.
    WHEN 'EXCEL\_START'.
      CHECK excel-handle = 0.
      CHECK excel-header = space.
      CREATE OBJECT   excel 'Excel.Application'.
      SET PROPERTY OF excel 'Visible' = 1.
      GET PROPERTY OF excel 'Workbooks' = book.
      CALL METHOD  OF book  'Open' = rc
        EXPORTING #1 = 'C:\\temp\\Table.xls'.
    WHEN 'WORD\_STOP'.
      CALL METHOD OF word 'AppClose'.
      FREE OBJECT word.
      CLEAR: word-handle, word-header.
    WHEN 'EXCEL\_STOP'.
      CALL METHOD OF  excel 'Quit'.
      FREE OBJECT excel.
      CLEAR: excel-handle, excel-header.
    WHEN OTHERS.
      LEAVE PROGRAM.
  ENDCASE.


### abapget_property.htm

---
title: "GET PROPERTY - OLE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_property_shortref.htm) Syntax GET PROPERTY OF ole attr = dobj NO FLUSH QUEUE-ONLY EXPORTING p1 = f1 p2 = f2 .... Extras: 1. ... NO FLUSH(#!ABAP_ADDITION_1@1@) 2. ... QUEUE-ONLY(#!ABAP_A
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_property.htm"
abapFile: "abapget_property.htm"
keywords: ["do", "if", "try", "data", "abapget", "property"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and OLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenole2.htm) → 

GET PROPERTY - OLE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_property_shortref.htm)

Syntax

GET PROPERTY OF ole attr = dobj *\[*NO FLUSH*\]* *\[*QUEUE-ONLY*\]*
                                *\[*EXPORTING p1 = f1 p2 = f2 ...*\]*.

Extras:

[1\. ... NO FLUSH](#!ABAP_ADDITION_1@1@)
[2\. ... QUEUE-ONLY](#!ABAP_ADDITION_2@2@)
[3\. ... EXPORTING p1 = f1 p2 = f2 ...](#!ABAP_ADDITION_3@3@)

Effect

Assigns the content of the attribute attr of an automation object ole to the data object dobj. The automation object must have been created using the special statement [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole2.htm) for automation objects. For the [typing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentyping_glosry.htm "Glossary Entry") of ole, the description of the statement CREATE OBJECT applies. The typing of the data object dobj depends on the properties of the automation attribute attr.

System Fields

sy-subrc

Meaning

0

Object attributes passed successfully.

1

Error in communication with SAP GUI.

2

Error in function call in SAP GUI.

3

Error when setting an attribute.

4

Error when reading an attribute.

Addition 1

... NO FLUSH

Addition 2

... QUEUE-ONLY

Effect

For the description of the NO FLUSH and QUEUE-ONLY additions, refer to the description of the statement [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole2.htm).

Addition 3

... EXPORTING p1 = f1 p2 = f2 ...

Effect

The addition EXPORTING can be assigned to the parameters p1 p2 ... of the actual parameters f1 f2 ... of the attribute, where the data type of the data objects f1 f2 ... depends on the requirements of the attribute.

Example

This example reads the attribute "Visible" of an Excel table created at runtime. This attribute specifies whether the table processing is visible or runs in the background. The variable vis is typed as an integer, because Excel passes an integer value.

DATA: vis TYPE i,
      app TYPE ole2\_object.
CREATE OBJECT app 'Excel.Application'.
GET PROPERTY OF app 'Visible' = vis.


### abapset_property.htm

---
title: "SET PROPERTY - OLE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_property_shortref.htm) Syntax SET PROPERTY OF ole attr = dobj NO FLUSH EXPORTING p1 = f1 p2 = f2 .... Extras: 1. ... NO FLUSH(#!ABAP_ADDITION_1@1@) 2. ... EXPORTING p1 = f1 p2 = f2 ...(#!ABAP_A
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_property.htm"
abapFile: "abapset_property.htm"
keywords: ["do", "try", "data", "abapset", "property"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and OLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenole2.htm) → 

SET PROPERTY - OLE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_property_shortref.htm)

Syntax

SET PROPERTY OF ole attr = dobj *\[*NO FLUSH*\]*
                                *\[*EXPORTING p1 = f1 p2 = f2 ...*\]*.

Extras:

[1\. ... NO FLUSH](#!ABAP_ADDITION_1@1@)
[2\. ... EXPORTING p1 = f1 p2 = f2 ...](#!ABAP_ADDITION_2@2@)

Effect

The attribute attr of an automation object ole is set in accordance with the content of the data object dobj. The automation object must have been created using the special statement [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole2.htm) for automation objects. For the [typing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentyping_glosry.htm "Glossary Entry") of ole, the description of the statement CREATE OBJECT applies. The typing of the data object dobj depends on the properties of the automation attribute attr.

System Fields

sy-subrc

Meaning

0

Object attributes passed successfully.

1

Error in communication with SAP GUI.

2

Error in function call in SAP GUI.

3

Error when setting an attribute.

4

Error when reading an attribute.

Addition 1

... NO FLUSH

Effect

The meaning of the addition NO FLUSH is included in the description of the statement [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole2.htm).

Addition 2

... EXPORTING p1 = f1 p2 = f2 ...

Effect

The addition EXPORTING can be assigned to the parameters p1 p2 ... of the actual parameters f1 f2 ... of the attribute, where the data type of the data objects f1 f2 ... depends on the requirements of the attribute.

Example

Calls the Office application Excel and displays an empty Excel table by assigning the value 1 to the attribute "Visible".

DATA app TYPE ole2\_object.
CREATE OBJECT app 'Excel.Application'.
SET PROPERTY OF app 'Visible' = 1.


### abapfree_object.htm

---
title: "FREE OBJECT - OLE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapfree_object_shortref.htm) Syntax FREE OBJECT ole NO FLUSH. Addition: ... NO FLUSH(#!ABAP_ONE_ADD@1@) Effect This statement releases the memory occupied by the object ole on the current AS Instance(https://he
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapfree_object.htm"
abapFile: "abapfree_object.htm"
keywords: ["do", "try", "data", "abapfree", "object"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and OLE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenole2.htm) → 

FREE OBJECT - OLE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapfree_object_shortref.htm)

Syntax

FREE OBJECT ole *\[*NO FLUSH*\]*.

Addition:

[... NO FLUSH](#!ABAP_ONE_ADD@1@)

Effect

This statement releases the memory occupied by the object ole on the current [AS Instance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry"). The automation object must have been created using the special statement [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole2.htm) for automation objects. After the release, the object is still available on the current automation server, but can no longer be processed in the ABAP program. For the [typing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentyping_glosry.htm "Glossary Entry") of ole, the description of the statement CREATE OBJECT applies.

When the statement FREE OBJECT is passed to the presentation layer, the entire automation queue collected using the addition NO FLUSH is passed.

System Fields

sy-subrc

Meaning

0

Memory released successfully.

1

Error in communication with SAP GUI.

2

Error in function call in SAP GUI.

Note

An automation object ole created using CREATE OBJECT must also be released using FREE OBJECT to avoid memory bottlenecks and terminations of the application.

Addition

... NO FLUSH

Effect

The meaning of the addition NO FLUSH is included in the description of the statement [CREATE OBJECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcreate_object_ole2.htm).

Example

Releases an Excel object.

DATA app TYPE ole2\_object.
CREATE OBJECT app 'Excel.Application' NO FLUSH.
...
FREE OBJECT app NO FLUSH.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and Operating System Statements

**Files**: 6 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / ABAP and Operating System Statements

Included pages: 6


### abenabap_system_commands.htm

---
title: "ABAP and Operating System Statements"
description: |
  Operating system statements or system commands execute statements or programs directly on the operating system of the host computer of an AS Instance or of a presentation server. Executing operating system statements from ABAP programs should be the exception not the rule, however it may become nece
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands.htm"
abapFile: "abenabap_system_commands.htm"
keywords: ["do", "data", "abenabap", "system", "commands"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) → 

ABAP and Operating System Statements

Operating system statements or system commands execute statements or programs directly on the operating system of the host computer of an AS Instance or of a presentation server. Executing operating system statements from ABAP programs should be the exception not the rule, however it may become necessary in system or administration programs to call operating system functions that cannot be accessed by ABAP statements. In certain circumstances, input from external sources may need to be passed to the operating system.

-   [Operating System Statements of the Host Computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl.htm)

-   [Operating System Statements of the Presentation Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_pres.htm)

Security Note

Using input from external sources in operating system statements incurs the risk of [system command injections](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensys_comm_injections_scrty.htm).

Continue
[Operating System Statements of the Host Computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl.htm)
[Operating System Statements of the Presentation Server](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_pres.htm)


### abenabap_system_commands_appl.htm

---
title: "Operating System Statements of the Host Computer"
description: |
  There is one recommended framework when executing operating system statements on the host computer(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm 'Glossary Entry') of the current AS Instance(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abena
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl.htm"
abapFile: "abenabap_system_commands_appl.htm"
keywords: ["do", "try", "method", "data", "abenabap", "system", "commands", "appl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands.htm) → 

Operating System Statements of the Host Computer

There is one recommended framework when executing operating system statements on the [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") of the current [AS Instance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry") and two unwanted methods:

-   [SXPG Framework for Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_sxpg.htm)

-   [Unwanted Calls of Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_depr.htm)

Continue
[SXPG Framework for Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_sxpg.htm)
[Unwanted Calls of Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_depr.htm)


### abenabap_system_commands_appl_sxpg.htm

---
title: "SXPG Framework for Operating System Statements"
description: |
  The only recommended method for executing operating system statements from ABAP on the operating system of the host computer(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm 'Glossary Entry') of the current AS Instance or another server is to use the SXPG fra
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_sxpg.htm"
abapFile: "abenabap_system_commands_appl_sxpg.htm"
keywords: ["do", "if", "try", "method", "data", "internal-table", "abenabap", "system", "commands", "appl", "sxpg"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands.htm) →  [Operating System Statements of the Host Computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl.htm) → 

SXPG Framework for Operating System Statements

The only recommended method for executing operating system statements from ABAP on the operating system of the [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") of the current AS Instance or another server is to use the SXPG framework. This framework is based on a list of permitted operating system statements that can be called using function modules in the function group SXPG.

The list of permitted operating system statements is defined by the system administrator in transaction SM69. Here, the platform-dependent physical operating system statements are assigned to a logical command name used to address them in ABAP. When one of these logical command names is passed to one of the function modules listed below, the operating system statement appropriate for the platform in question is executed. Logical command names assigned to an operating system command used by all platforms can be flagged with the operating system ANYOS. Static parameters can be assigned to any operating system statement and further parameters can be specified for when the statement is called. When an operating system statement is called using a logical command name, implicit authorization checks are performed, accompanied by extra self-defined checks. SAP provides a range of predefined logical command names with the type SAP. Logical command names created by customers have the type KUNDE.

If they have the right authorizations, developers can view the list of operating system statements in transaction SM49 and execute them from here. The following function modules can be called from ABAP programs:

-   SXPG\_CALL\_SYSTEM for execution on the host computer of the current AS Instance

-   SXPG\_COMMAND\_EXECUTE for execution on other servers; the result can caught, but this is not mandatory

-   SXPG\_COMMAND\_EXECUTE\_LONG, like SXPG\_COMMAND\_EXECUTE but with a longer list of parameters

These function modules can also be called remotely.

Note

For more information, see the Documentation Programming with External Commands in [SAP Help Portal](http://help.sap.com).

Example

Calls the operating system statement ping for the central database server of the system on the host computer of the current AS Instance using the logical command name PING defined by SAP. The result of the call is passed to the internal table result. The function module SXPG\_CALL\_SYSTEM can raise more specific exceptions than those handled explicitly here.

DATA dbserver TYPE c LENGTH 255.
CALL 'C\_SAPGPARAM' ID 'NAME'  FIELD 'SAPDBHOST'
                   ID 'VALUE' FIELD  dbserver.
DATA parameters TYPE sxpgcolist-parameters.
parameters = |-c1 { dbserver }|.
DATA result TYPE TABLE OF btcxpm WITH EMPTY KEY.
CALL FUNCTION 'SXPG\_CALL\_SYSTEM'
  EXPORTING
    commandname           = 'PING'
    additional\_parameters = parameters
  TABLES
    exec\_protocol         = result
  EXCEPTIONS
    no\_permission         = 1
    command\_not\_found     = 2
    security\_risk         = 3
    OTHERS                = 4.
IF sy-subrc = 0.
  cl\_demo\_output=>display( result ).
ELSE.
  cl\_demo\_output=>display( |Error, return code { sy-subrc }| ).
ENDIF.


### abenabap_system_commands_appl_depr.htm

---
title: "Unwanted Calls of Operating System Statements"
description: |
  Alongside calls of function modules in the SXPG framework(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_sxpg.htm), operating system statements for the host computer(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_depr.htm"
abapFile: "abenabap_system_commands_appl_depr.htm"
keywords: ["do", "if", "try", "data", "types", "internal-table", "abenabap", "system", "commands", "appl", "depr"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands.htm) →  [Operating System Statements of the Host Computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl.htm) → 

Unwanted Calls of Operating System Statements

Alongside calls of function modules in the [SXPG framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_sxpg.htm), operating system statements for the [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") of the current AS Instance can be executed in ABAP programs as follows:

-   The addition [FILTER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_os_addition.htm) of the statement [OPEN DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset.htm) used for executing operating system statements using pipes.

-   The internal statement [CALL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall-.htm) used to call a special system function (SYSTEM), which can be used to execute operating system statements.

Neither of these options should be used for common execution of operating system statements in ABAP programs.

-   The addition [FILTER](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset_os_addition.htm) of [OPEN DATASET](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapopen_dataset.htm) should only be used (if at all) for operating system statements required for data handling.

-   Calls of the system function SYSTEM with the internal statement [CALL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall-.htm) should never be made and can be deactivated using the [profile parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprofile_parameter_glosry.htm "Glossary Entry") rdisp/call\_system. If called, it then raises a non-handleable exception.

Both statements cause the following problems:

-   There are no central authorization checks.

-   The platform dependency of the operating system statements must be handled in the ABAP program itself.

-   Errors and exceptions cannot be handled specifically.

-   If input from external sources is used, it must be checked thoroughly and filtered to prevent [system command injections](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensys_comm_injections_scrty.htm) on any platform.

If possible, the [SXPG framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_sxpg.htm) should be used instead of these two options.

Note

Before the statements CALL 'SYSTEM' is deactivated using the [profile parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprofile_parameter_glosry.htm "Glossary Entry") rdisp/call\_system, it must be ensured that it is no longer used in any programs. Any programs that still use CALL 'SYSTEM' must first be switched to use of the [SXPG frameworks](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_sxpg.htm) before the unwanted statement can be deactivated. The options in the SXPG frameworks generally cover all requirements when calling operating system statements.

Example

Calls the operating system statement ping for the central database server of the system on the [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") of the current AS Instance using the addition FILTER of the statement OPEN DATASET. The output of the operating system statement is written to the opened file and can be read from there.

DATA dbserver TYPE c LENGTH 255.
CALL 'C\_SAPGPARAM' ID 'NAME'  FIELD 'SAPDBHOST'
                   ID 'VALUE' FIELD  dbserver.
DATA(command) = |ping -c1 { dbserver }|.
DATA(fname) = 'result.dat'.
OPEN DATASET fname FOR OUTPUT IN BINARY MODE FILTER command.
CLOSE DATASET fname.
OPEN DATASET fname FOR INPUT IN BINARY MODE.
DATA result TYPE xstring.
READ DATASET fname INTO result.
CLOSE DATASET fname.
cl\_demo\_output=>display(
  cl\_abap\_conv\_codepage=>create\_in( )->convert( result ) ).

Example

Calls the operating system statement ping for the central database server of the system on the [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") of the current AS Instance using the addition SYSTEM. The result of the call is passed to the internal table result. This example can only be executed if the [profile parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprofile_parameter_glosry.htm "Glossary Entry") rdisp/call\_system permits the call.

TYPES char255 TYPE c LENGTH 255.
DATA dbserver TYPE char255.
CALL 'C\_SAPGPARAM' ID 'NAME'  FIELD 'SAPDBHOST'
                   ID 'VALUE' FIELD  dbserver.
DATA command TYPE char255.
command = |ping -c1 { dbserver }|.
DATA result  TYPE TABLE OF char255 WITH EMPTY KEY.
CALL 'SYSTEM' ID 'COMMAND' FIELD command
              ID 'TAB'     FIELD result.
cl\_demo\_output=>display( result ).


### abenabap_system_commands_appl.htm

---
title: "Operating System Statements of the Host Computer"
description: |
  There is one recommended framework when executing operating system statements on the host computer(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm 'Glossary Entry') of the current AS Instance(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abena
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl.htm"
abapFile: "abenabap_system_commands_appl.htm"
keywords: ["do", "try", "method", "data", "abenabap", "system", "commands", "appl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands.htm) → 

Operating System Statements of the Host Computer

There is one recommended framework when executing operating system statements on the [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry") of the current [AS Instance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry") and two unwanted methods:

-   [SXPG Framework for Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_sxpg.htm)

-   [Unwanted Calls of Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_depr.htm)

Continue
[SXPG Framework for Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_sxpg.htm)
[Unwanted Calls of Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_depr.htm)


### abenabap_system_commands_pres.htm

---
title: "Operating System Statements of the Presentation Server"
description: |
  The method EXECUTE of the class CL_GUI_FRONTEND_SERVICES(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfrontend_services.htm) can be used to call operating system statements of the presentation server. To make this possible, however, the current ABAP program must be executed in
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_pres.htm"
abapFile: "abenabap_system_commands_pres.htm"
keywords: ["do", "if", "try", "method", "class", "data", "abenabap", "system", "commands", "pres"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [ABAP and Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands.htm) → 

Operating System Statements of the Presentation Server

The method EXECUTE of the class [CL\_GUI\_FRONTEND\_SERVICES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfrontend_services.htm) can be used to call operating system statements of the presentation server. To make this possible, however, the current ABAP program must be executed in [dialog](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendialog_processing_glosry.htm "Glossary Entry") and from SAP GUI.

Note

The method EXECUTE of the class CL\_GUI\_FRONTEND\_SERVICES replaces the obsolete function module WS\_EXECUTE.

Example

Calls the command line window in MS Windows.

cl\_gui\_frontend\_services=>execute(
   EXPORTING
     application           = 'cmd.exe'
    default\_directory      = 'C:\\'
  EXCEPTIONS
    cntl\_error = 1
    error\_no\_gui           = 2
    bad\_parameter          = 3
    file\_not\_found   = 4
    path\_not\_found         = 5
    file\_extension\_unknown = 6
    error\_execute\_failed   = 7
    synchronous\_failed     = 8
    not\_supported\_by\_gui   = 9
    OTHERS = 10 ).
IF sy-subrc <> 0.
  ...
ENDIF.


---


## ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / Internal Statement for System Function Call

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Data Interfaces and Communication Interfaces / Internal Statement for System Function Call

Included pages: 2


### abendata_communication_internal.htm

---
title: "Internal Statement for System Function Call"
description: |
  This statement is for internal use only. It must not be used in application programs. -   CALL cfunc(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall-.htm) CALL - System Function Call(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall-.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_communication_internal.htm"
abapFile: "abendata_communication_internal.htm"
keywords: ["do", "data", "abendata", "communication", "internal"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) → 

Internal Statement for System Function Call

This statement is for internal use only.
It must not be used in application programs.

-   [CALL cfunc](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall-.htm)

Continue
[CALL - System Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall-.htm)


### abapcall-.htm

---
title: "CALL - System Function Call"
description: |
  This statement is for internal use only. It must not be used in application programs. Syntax CALL cfunc. Addition: ... ID id1 FIELD f1 ... ID idn FIELD fn(#!ABAP_ONE_ADD@1@) Effect Calls the system function cfunc. A flat character-like data object containing the name of the function can be specifi
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall-.htm"
abapFile: "abapcall-.htm"
keywords: ["do", "if", "try", "method", "data", "internal-table", "abapcall"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Data Interfaces and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_data_communication.htm) →  [Internal Statement for System Function Call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_communication_internal.htm) → 

CALL - System Function Call

This statement is for internal use only.
It must not be used in application programs.

Syntax

CALL cfunc.

Addition:

[... ID id1 FIELD f1 ... ID idn FIELD fn](#!ABAP_ONE_ADD@1@)

Effect

Calls the system function cfunc. A flat character-like data object containing the name of the function can be specified for cfunc. The function must be entered in the file sapactab.h. Modifying a function or creating a new function requires the ABAP kernel to be compiled again and linked. This requires the C source code files.

System Fields

The CALL statement itself does not set any system fields. Whether system fields such as sy-subrc are set depends on the system function called.

Notes

-   If possible, use [kernel methods](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenkernel_methods.htm) instead of system functions.
    
-   External programs should be called using the RFC mechanism: [CALL FUNCTION ... DESTINATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_destination.htm).
    
-   With some critical C functions, the system performs an authorization check automatically. If the user does not have the appropriate authorization, a runtime error occurs. The authorization can be checked using the function module AUTHORITY\_CHECK\_C\_FUNCTION.
    
-   The use of the system function SYSTEM, which can be used to execute operating system statements of the current [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry"), is not recommended and can be deactivated using the [profile parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprofile_parameter_glosry.htm "Glossary Entry") rdisp/call\_system. If called, it then raises a non-handleable exception. If absolutely necessary, operating system statements can be called using the function modules in the [SXPG framework](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_sxpg.htm). This addresses specific statements using logical command names created by the system administrator in the transaction SM68. See also [Unwanted Calls of Operating System Statements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_system_commands_appl_depr.htm).
    

Security Note

Calls of system functions whose names or parameters are injected into the program from outside present a serious security risk. The values from outside must be checked thoroughly before being used. See [System Command Injections](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensys_comm_injections_scrty.htm).

Addition

... ID id1 FIELD f1 ... ID idn FIELD fn

Effect

Passes fields to the called program using pass by reference. ID id1 is used to specify the name of a formal parameter and FIELD f1 is used to specify the associated field from the ABAP program. If a formal parameter expects an internal table, the latter is passed in the form FIELD tab\[\].

Example

Query of the current database server.

DATA dbserver TYPE c LENGTH 255.
CALL 'C\_SAPGPARAM' ID 'NAME'  FIELD 'SAPDBHOST'
                   ID 'VALUE' FIELD  dbserver.

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Non-Handleable Exceptions

-   Cause: No authorization to call this C function.
    Runtime error: CALL\_C\_FUNCTION\_NO\_AUTHORITY
    
-   Cause: The system function specified is unknown.
    Runtime error: CALL\_C\_FUNCTION\_NOT\_FOUND
    
-   Cause: The system function SYSTEM is disabled.
    Runtime error: CALL\_SYSTEM\_DISABLED


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / General Dynpros / User Interface

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / General Dynpros / User Interface

Included pages: 2


### abenabap_dynpros_gui.htm

---
title: "User Interface"
description: |
  For the execution of user dialogs, input and output services are required that can be accessed through a user interface (UI). A user interface is used for the interaction between a user and a program. If parts of the user interface are displayed in the GUI window on the screen, this is a graphical u
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpros_gui.htm"
abapFile: "abenabap_dynpros_gui.htm"
keywords: ["do", "if", "try", "abenabap", "dynpros", "gui"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpros.htm) → 

User Interface

For the execution of user dialogs, input and output services are required that can be accessed through a user interface (UI). A user interface is used for the interaction between a user and a program. If parts of the user interface are displayed in the GUI window on the screen, this is a graphical user interface (GUI). The SAP-specific implementation for the execution of dialog-based applications with [dynpros](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_nw_abap_glosry.htm "Glossary Entry") is SAP GUI, which is installed as a component of the [AS ABAP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_nw_abap_glosry.htm "Glossary Entry") [presentation layer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpresentation_layer_glosry.htm "Glossary Entry") on the presentation servers. It contains all the control elements that are required for execution of dialogs between the user and the program. The operating elements of the SAP GUI are represented schematically in the following diagram:

![Figure](abdoc_gui.gif)

On the screen, SAP GUI presents the [screen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscreen_glosry.htm "Glossary Entry") of a dynpro (dynamic program) in a GUI window. The screen can contain screen elements for displaying contents or for receiving user actions. The screen and its screen elements are processed using [Layout Editor](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlayout_editor_glosry.htm "Glossary Entry") in the Screen Painter tool. Each screen element has properties that are statically predefined in [Screen Painter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscreen_painter_glosry.htm "Glossary Entry") and, in part, can be modified dynamically in the ABAP program.

As a further part of the graphical user interface, each standard window contains a menu bar, a standard toolbar, and an application toolbar. GUI windows that are displayed as a modal dialog box contain only an application toolbar. The bars are standalone components of the ABAP program and are grouped together in a GUI status. Also, they are assigned to a dynpro when the GUI status is set. In addition to the graphical elements, the function keys are part of the user interface. They are defined as an independent component of the ABAP program and therefore part of a GUI status. The components of the GUI status and the GUI status itself are processed using the Menu Painter tool. For the most part, the control elements presented by the user interface are linked with the function codes, which can be evaluated in the ABAP program. The description of the current GUI status can be found in the system field sy-pfkey.

A GUI window in SAP GUI is complete when it has a title bar and a status bar. The title bar, which is also edited using Menu Painter, contains the heading of the GUI window. The status bar displays information that can be transmitted, among other things, during the execution of an ABAP program using the [MESSAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmessage.htm) statement. In addition, it contains system information that can be displayed or hidden through an icon on the right-hand side of the bar.

Continue
![Example](exa.gif "Example") [Dynpros, GUI Status, and Function Codes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_gui_status_abexa.htm)


### abendynpro_gui_status_abexa.htm

---
title: "Dynpros, GUI Status, and Function Codes"
description: |
  This example demonstrates how to set the GUI status and evaluate function codes. Source Code PROGRAM demo_dynpro_gui_status. DATA: ok_code TYPE sy-ucomm, save_ok LIKE ok_code, output  LIKE ok_code. CALL SCREEN 100. MODULE init_screen_0100 OUTPUT. SET PF-STATUS 'STATUS_100'. SET TITLEBAR '1
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_gui_status_abexa.htm"
abapFile: "abendynpro_gui_status_abexa.htm"
keywords: ["do", "case", "data", "abendynpro", "gui", "status", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpros.htm) →  [User Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpros_gui.htm) → 

Dynpros, GUI Status, and Function Codes

This example demonstrates how to set the GUI status and evaluate function codes.

Source Code

PROGRAM demo\_dynpro\_gui\_status.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok LIKE ok\_code,
      output  LIKE ok\_code.
CALL SCREEN 100.
MODULE init\_screen\_0100 OUTPUT.
  SET PF-STATUS 'STATUS\_100'.
  SET TITLEBAR '100'.
ENDMODULE.
MODULE user\_command\_0100 INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  CASE save\_ok.
    WHEN 'BACK' OR 'EXIT' OR 'CANCEL'.
      LEAVE PROGRAM.
    WHEN OTHERS.
      output = save\_ok.
  ENDCASE.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The screen field of output is defined as not ready for input in Screen Painter. The module init\_screen\_0100 sets the GUI status status\_0100 and the title 100 in the PBO event. All function codes exist as menu entries, but not all of them are assigned to function keys. The function codes in the standard toolbar activate the icons and are automatically assigned to their function keys. Some of the additional function keys are assigned to the application toolbar. The module user\_command\_0100 first assigns the contents of the field ok\_code to the helper variable save\_ok and initializes ok\_code. This procedure is always recommended since it makes sure that the dynpro field ok\_code is also reinitialized in the PBO event and does not contain any unwanted values. Then the function code chosen is assigned to the field output and displayed in the corresponding screen field, except for BACK, EXIT, and CANCEL. The latter exits the program. The function code SELE can be passed to the ABAP program in the following ways:

-   Choosing Choose in the Edit menu

-   Choosing the Choose pushbutton in the application toolbar

-   Choosing F2 on the keyboard

-   Pressing the right mouse button and choosing Choose

-   Double-clicking the screen field of output

-   Entering SELE in the command field and choosing ENTER

The other function codes are passed in accordance with their definition, but without the double-click function.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / WRITE / WRITE - ext_format_options

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / WRITE / WRITE - list_elements

Included pages: 2


### abapwrite_list_elements.htm

---
title: "Syntax"
description: |
  ... AS CHECKBOX  AS ICON  AS SYMBOL  AS LINE ... Alternatives: 1. ... AS CHECKBOX(#!ABAP_ALTERNATIVE_1@1@) 2. ... AS ICON(#!ABAP_ALTERNATIVE_2@2@) 3. ... AS SYMBOL(#!ABAP_ALTERNATIVE_3@3@) 4. ... AS LINE(#!ABAP_ALTERNATIVE_4@4@) Effect These additions are
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_list_elements.htm"
abapFile: "abapwrite_list_elements.htm"
keywords: ["select", "do", "if", "case", "try", "class", "data", "abapwrite", "list", "elements"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Creating Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists.htm) →  [WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite-.htm) → 

WRITE - list\_elements

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_shortref.htm)

Syntax

... *{*AS CHECKBOX*}*
  *|* *{*AS ICON*}*
  *|* *{*AS SYMBOL*}*
  *|* *{*AS LINE*}* ...

Alternatives:

[1\. ... AS CHECKBOX](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... AS ICON](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... AS SYMBOL](#!ABAP_ALTERNATIVE_3@3@)
[4\. ... AS LINE](#!ABAP_ALTERNATIVE_4@4@)

Effect

These additions are used to represent special list elements.

The data object dobj in the output must have certain properties. The additions cannot be used together. If they are used with the additions for [internal formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_int_options.htm) and [external formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_ext_options.htm), they can only be used to a limited extent.

Alternative 1

... AS CHECKBOX

Effect

The output of this addition is a single-character checkbox that is ready for input. dobj expects a character-like data type of length 1. If the first character in dobj is "X" or "x", the checkbox is shown as selected. If the first character is not "X" or "x", the checkbox is shown as empty. If dobj is an empty data object of the type string, the checkbox is not in the output.

The user can select and deselect the checkbox in the list displayed on the screen. If the user selects the checkbox, the first character of the assigned field in the list is set to "X". If the user deselects it, it is set to blank. The change is stored in the list buffer and can be evaluated during a list event.

If the addition AS CHECKBOX is used, no list output len is allowed after AT. Except for INPUT, NO-GAP, and UNDER, the other additions specified at the same time for [internal formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_int_options.htm) and [external formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_ext_options.htm) are ignored.

The addition AS CHECKBOX has the same effect as specifying the addition INPUT ON simultaneously. The standard settings or a format INPUT OFF set by a FORMAT statement are overridden for the current WRITE statement. To make the checkbox not ready for input, the addition INPUT OFF must be used simultaneously.

Notes

-   If a list line contains only a checkbox with a blank, it is displayed only if the statement SET BLANK LINES ON is executed beforehand.
    
-   By default, addition [HOTSPOT ON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapformat.htm) has no effect on a checkbox. [HOTSPOT ON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapformat.htm) only has an effect, if INPUT OFF is deactivated.
    

Example

Displays two checkbox fields and evaluates the user input in the event AT LINE-SELECTION.

REPORT test NO STANDARD PAGE HEADING.
DATA: check1 TYPE c LENGTH 1 VALUE 'X',
      check2 TYPE c LENGTH 1 VALUE ' '.
START-OF-SELECTION.
  WRITE: / check1 AS CHECKBOX, 'Checkbox 1',
         / check2 AS CHECKBOX, 'Checkbox 2'.
AT LINE-SELECTION.
  READ: LINE 1 FIELD VALUE check1,
        LINE 2 FIELD VALUE check2.

Alternative 2

... AS ICON

Effect

This addition produces icons. Be aware that not all icons are suitable for spool lists. dobj expects data objects of the type c whose initial characters can be interpreted as the internal ID of an icon by the runtime environment.

In the [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") ICON, a constant is declared for each icon that can be displayed. The names of the constants can be taken from the type group or the output of the SHOWICON program. This program also shows the corresponding output length and whether an icon can be spooled or not.

If the content of dobj cannot be interpreted as an icon or the content is changed by concurrent use of other additions for [internal formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_int_options.htm) or [external formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_ext_options.htm), blanks are produced instead of icons.

Notes

-   None of the additions from the [internal formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_int_options.htm) and [external formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_ext_options.htm) are forbidden. When using these additions, care must be taken that the content of dobj can be interpreted as an icon.
    
-   The [output length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwrite_output_length.htm) is determined, as usual, either implicitly using the data type of dobj or by being specified explicitly. Characters in the output area that do not have the icon are set to blanks.
    
-   The program SHOWICON shows two internal IDs for each icon:
    

-   A two-digit hexadecimal number as the key.

-   A six-character string composed of uppercase letters and any underscores as the internal name.

If a character string that is output using WRITE has an internal ID of this type between two "@" characters at the start, this is represented as an icon in the list output, even without the addition AS ICON. This can lead to unwanted of icons and unexpected effects in terms of the output length. By default, the output length is determined by the length of the character string. However, this attribute can also be exploited, for example, to use icons at the start of [text symbols](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_symbol_glosry.htm "Glossary Entry"). IDs that are not at the start are not represented as icons.

Example

Displays a traffic light icon.

WRITE icon\_green\_light AS ICON.

Example

Displaying traffic light icons using their internal IDs (key and internal name). The IDs that are not at the start of the character string are not converted.

WRITE: / 'xxx', '@08@xxx    ', 'xxx@08@xxx'.
WRITE: / 'xxx', '@S\_TL\_G@xxx', 'xxx@S\_TL\_G@xxx'.

Alternative 3

... AS SYMBOL

Effect

This addition produces all the characters of the data object dobj as symbols. The [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") SYM declares constants with a length of 1 for each character that can be displayed as a symbol, and whose name reflects the meaning of the symbol. The names of the constants and the meaning and length of the symbols can be taken from the type group or from the output of the program SHOWSYMB.

Note

The [output length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwrite_output_length.htm) is determined, as usual, either implicitly using the data type of dobj or by being specified explicitly.

Example

Displays a hand symbol.

WRITE sym\_left\_hand AS SYMBOL.

Alternative 4

... AS LINE

Effect

This addition produces [line elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_element_glosry.htm "Glossary Entry") with the output length 1. Line elements are corners, crosses, lines, and T sections. dobj expects data objects of the type c whose content can be interpreted as line elements by the runtime environment. The [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") LINE declares the line element constants displayed in the following table.

Constant

Meaning

line\_space

Blank

line\_top\_left\_corner

Top left corner

line\_bottom\_left\_corner

Bottom left corner

line\_top\_right\_corner

Top right corner

line\_bottom\_right\_corner

Bottom right corner

line\_horizontal\_line

Horizontal line

line\_vertical\_line

Vertical line

line\_left\_middle\_corner

T section turned to the left

line\_right\_middle\_corner

T section turned to the right

line\_bottom\_middle\_corner

Reversed T section

line\_top\_middle\_corner

T section

line\_cross

Cross

If dobj has different content or the content is changed by concurrent use of other additions for [internal formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_int_options.htm), a blank is produced instead of a line element. The addition FRAMES OFF must not be specified simultaneously. The other additions for [external formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_ext_options.htm) and QUICKINFO are ignored in the output of line elements.

Notes

-   The characters "-" and "|" and produced using ULINE are [joined with each other](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwrite_lines.htm) by default, if no other characters exist between them. Here the system replaces the characters by the above line elements. A standalone character "|" is always replaced by a vertical line. The "-" characters from sy-uline are always replaced by a horizontal line. The default behavior can be switched off using the addition [FRAMES OFF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapformat.htm).
    
-   The addition AS LINE produces line elements in the exact way they are defined. Links are produced only where line elements actually meet each other. The system does not, however, create any automatic extensions between the characters "-" or "|" and line elements produced explicitly using AS LINE.
    

Example

Produces four adjoining rectangles.

WRITE: /10 line\_top\_left\_corner      AS LINE NO-GAP,
           line\_top\_middle\_corner    AS LINE NO-GAP,
           line\_top\_right\_corner     AS LINE,
       /10 line\_left\_middle\_corner   AS LINE NO-GAP,
           line\_cross                AS LINE NO-GAP,
           line\_right\_middle\_corner  AS LINE,
       /10 line\_bottom\_left\_corner   AS LINE NO-GAP,
           line\_bottom\_middle\_corner AS LINE NO-GAP,
           line\_bottom\_right\_corner  AS LINE.

Continue
![Example](exa.gif "Example") [Lists, Line Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_line_elements_abexa.htm)


### abenlist_line_elements_abexa.htm

---
title: "Lists, Line Elements"
description: |
  This example demonstrates line elements on lists. Source Code REPORT demo_list_line_elements NO STANDARD PAGE HEADING LINE-SIZE 60. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-DATA: x TYPE i, y TYPE i. CLASS-METHODS pos. ENDCLASS. CLASS demo IMPLEMENTATION. M
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_line_elements_abexa.htm"
abapFile: "abenlist_line_elements_abexa.htm"
keywords: ["select", "do", "while", "method", "class", "data", "abenlist", "line", "elements", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Creating Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists.htm) →  [WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite-.htm) →  [WRITE - list\_elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_list_elements.htm) → 

Lists, Line Elements

This example demonstrates line elements on lists.

Source Code

REPORT demo\_list\_line\_elements NO STANDARD PAGE HEADING LINE-SIZE 60.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA: x TYPE i,
                y TYPE i.
    CLASS-METHODS pos.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: x0 TYPE i VALUE 10,
          y0 TYPE i VALUE 10,
          n  TYPE i VALUE 16,
          i  TYPE i VALUE 0.
    x = x0.
    y = y0.
    pos( ).
    WHILE i LE n.
      WRITE line\_bottom\_left\_corner AS LINE.
      x += 1. pos( ).
      ULINE AT x(i).
      x += i. pos( ).
      WRITE line\_bottom\_right\_corner AS LINE.
      y -= 1. pos( ).
      DO i TIMES.
        WRITE '|'.
        y -= 1. pos( ).
      ENDDO.
      WRITE line\_top\_right\_corner AS LINE.
      i += 1.
      x -= i. pos( ).
      ULINE AT x(i).
      x -= 1. pos( ).
      WRITE line\_top\_left\_corner AS LINE.
      y += 1. pos( ).
      DO i TIMES.
        WRITE '|'.
        y += 1. pos( ).
      ENDDO.
      i += 1.
    ENDWHILE.  ENDMETHOD.
  METHOD pos.
    SKIP TO LINE y.
    POSITION x.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Displays a spiral using line elements and joins these automatically in a list.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / WRITE / WRITE - list_elements

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / WRITE / WRITE - list_elements

Included pages: 2


### abapwrite_list_elements.htm

---
title: "Syntax"
description: |
  ... AS CHECKBOX  AS ICON  AS SYMBOL  AS LINE ... Alternatives: 1. ... AS CHECKBOX(#!ABAP_ALTERNATIVE_1@1@) 2. ... AS ICON(#!ABAP_ALTERNATIVE_2@2@) 3. ... AS SYMBOL(#!ABAP_ALTERNATIVE_3@3@) 4. ... AS LINE(#!ABAP_ALTERNATIVE_4@4@) Effect These additions are
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_list_elements.htm"
abapFile: "abapwrite_list_elements.htm"
keywords: ["select", "do", "if", "case", "try", "class", "data", "abapwrite", "list", "elements"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Creating Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists.htm) →  [WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite-.htm) → 

WRITE - list\_elements

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_shortref.htm)

Syntax

... *{*AS CHECKBOX*}*
  *|* *{*AS ICON*}*
  *|* *{*AS SYMBOL*}*
  *|* *{*AS LINE*}* ...

Alternatives:

[1\. ... AS CHECKBOX](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... AS ICON](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... AS SYMBOL](#!ABAP_ALTERNATIVE_3@3@)
[4\. ... AS LINE](#!ABAP_ALTERNATIVE_4@4@)

Effect

These additions are used to represent special list elements.

The data object dobj in the output must have certain properties. The additions cannot be used together. If they are used with the additions for [internal formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_int_options.htm) and [external formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_ext_options.htm), they can only be used to a limited extent.

Alternative 1

... AS CHECKBOX

Effect

The output of this addition is a single-character checkbox that is ready for input. dobj expects a character-like data type of length 1. If the first character in dobj is "X" or "x", the checkbox is shown as selected. If the first character is not "X" or "x", the checkbox is shown as empty. If dobj is an empty data object of the type string, the checkbox is not in the output.

The user can select and deselect the checkbox in the list displayed on the screen. If the user selects the checkbox, the first character of the assigned field in the list is set to "X". If the user deselects it, it is set to blank. The change is stored in the list buffer and can be evaluated during a list event.

If the addition AS CHECKBOX is used, no list output len is allowed after AT. Except for INPUT, NO-GAP, and UNDER, the other additions specified at the same time for [internal formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_int_options.htm) and [external formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_ext_options.htm) are ignored.

The addition AS CHECKBOX has the same effect as specifying the addition INPUT ON simultaneously. The standard settings or a format INPUT OFF set by a FORMAT statement are overridden for the current WRITE statement. To make the checkbox not ready for input, the addition INPUT OFF must be used simultaneously.

Notes

-   If a list line contains only a checkbox with a blank, it is displayed only if the statement SET BLANK LINES ON is executed beforehand.
    
-   By default, addition [HOTSPOT ON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapformat.htm) has no effect on a checkbox. [HOTSPOT ON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapformat.htm) only has an effect, if INPUT OFF is deactivated.
    

Example

Displays two checkbox fields and evaluates the user input in the event AT LINE-SELECTION.

REPORT test NO STANDARD PAGE HEADING.
DATA: check1 TYPE c LENGTH 1 VALUE 'X',
      check2 TYPE c LENGTH 1 VALUE ' '.
START-OF-SELECTION.
  WRITE: / check1 AS CHECKBOX, 'Checkbox 1',
         / check2 AS CHECKBOX, 'Checkbox 2'.
AT LINE-SELECTION.
  READ: LINE 1 FIELD VALUE check1,
        LINE 2 FIELD VALUE check2.

Alternative 2

... AS ICON

Effect

This addition produces icons. Be aware that not all icons are suitable for spool lists. dobj expects data objects of the type c whose initial characters can be interpreted as the internal ID of an icon by the runtime environment.

In the [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") ICON, a constant is declared for each icon that can be displayed. The names of the constants can be taken from the type group or the output of the SHOWICON program. This program also shows the corresponding output length and whether an icon can be spooled or not.

If the content of dobj cannot be interpreted as an icon or the content is changed by concurrent use of other additions for [internal formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_int_options.htm) or [external formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_ext_options.htm), blanks are produced instead of icons.

Notes

-   None of the additions from the [internal formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_int_options.htm) and [external formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_ext_options.htm) are forbidden. When using these additions, care must be taken that the content of dobj can be interpreted as an icon.
    
-   The [output length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwrite_output_length.htm) is determined, as usual, either implicitly using the data type of dobj or by being specified explicitly. Characters in the output area that do not have the icon are set to blanks.
    
-   The program SHOWICON shows two internal IDs for each icon:
    

-   A two-digit hexadecimal number as the key.

-   A six-character string composed of uppercase letters and any underscores as the internal name.

If a character string that is output using WRITE has an internal ID of this type between two "@" characters at the start, this is represented as an icon in the list output, even without the addition AS ICON. This can lead to unwanted of icons and unexpected effects in terms of the output length. By default, the output length is determined by the length of the character string. However, this attribute can also be exploited, for example, to use icons at the start of [text symbols](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_symbol_glosry.htm "Glossary Entry"). IDs that are not at the start are not represented as icons.

Example

Displays a traffic light icon.

WRITE icon\_green\_light AS ICON.

Example

Displaying traffic light icons using their internal IDs (key and internal name). The IDs that are not at the start of the character string are not converted.

WRITE: / 'xxx', '@08@xxx    ', 'xxx@08@xxx'.
WRITE: / 'xxx', '@S\_TL\_G@xxx', 'xxx@S\_TL\_G@xxx'.

Alternative 3

... AS SYMBOL

Effect

This addition produces all the characters of the data object dobj as symbols. The [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") SYM declares constants with a length of 1 for each character that can be displayed as a symbol, and whose name reflects the meaning of the symbol. The names of the constants and the meaning and length of the symbols can be taken from the type group or from the output of the program SHOWSYMB.

Note

The [output length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwrite_output_length.htm) is determined, as usual, either implicitly using the data type of dobj or by being specified explicitly.

Example

Displays a hand symbol.

WRITE sym\_left\_hand AS SYMBOL.

Alternative 4

... AS LINE

Effect

This addition produces [line elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_element_glosry.htm "Glossary Entry") with the output length 1. Line elements are corners, crosses, lines, and T sections. dobj expects data objects of the type c whose content can be interpreted as line elements by the runtime environment. The [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") LINE declares the line element constants displayed in the following table.

Constant

Meaning

line\_space

Blank

line\_top\_left\_corner

Top left corner

line\_bottom\_left\_corner

Bottom left corner

line\_top\_right\_corner

Top right corner

line\_bottom\_right\_corner

Bottom right corner

line\_horizontal\_line

Horizontal line

line\_vertical\_line

Vertical line

line\_left\_middle\_corner

T section turned to the left

line\_right\_middle\_corner

T section turned to the right

line\_bottom\_middle\_corner

Reversed T section

line\_top\_middle\_corner

T section

line\_cross

Cross

If dobj has different content or the content is changed by concurrent use of other additions for [internal formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_int_options.htm), a blank is produced instead of a line element. The addition FRAMES OFF must not be specified simultaneously. The other additions for [external formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_ext_options.htm) and QUICKINFO are ignored in the output of line elements.

Notes

-   The characters "-" and "|" and produced using ULINE are [joined with each other](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwrite_lines.htm) by default, if no other characters exist between them. Here the system replaces the characters by the above line elements. A standalone character "|" is always replaced by a vertical line. The "-" characters from sy-uline are always replaced by a horizontal line. The default behavior can be switched off using the addition [FRAMES OFF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapformat.htm).
    
-   The addition AS LINE produces line elements in the exact way they are defined. Links are produced only where line elements actually meet each other. The system does not, however, create any automatic extensions between the characters "-" or "|" and line elements produced explicitly using AS LINE.
    

Example

Produces four adjoining rectangles.

WRITE: /10 line\_top\_left\_corner      AS LINE NO-GAP,
           line\_top\_middle\_corner    AS LINE NO-GAP,
           line\_top\_right\_corner     AS LINE,
       /10 line\_left\_middle\_corner   AS LINE NO-GAP,
           line\_cross                AS LINE NO-GAP,
           line\_right\_middle\_corner  AS LINE,
       /10 line\_bottom\_left\_corner   AS LINE NO-GAP,
           line\_bottom\_middle\_corner AS LINE NO-GAP,
           line\_bottom\_right\_corner  AS LINE.

Continue
![Example](exa.gif "Example") [Lists, Line Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_line_elements_abexa.htm)


### abenlist_line_elements_abexa.htm

---
title: "Lists, Line Elements"
description: |
  This example demonstrates line elements on lists. Source Code REPORT demo_list_line_elements NO STANDARD PAGE HEADING LINE-SIZE 60. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-DATA: x TYPE i, y TYPE i. CLASS-METHODS pos. ENDCLASS. CLASS demo IMPLEMENTATION. M
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_line_elements_abexa.htm"
abapFile: "abenlist_line_elements_abexa.htm"
keywords: ["select", "do", "while", "method", "class", "data", "abenlist", "line", "elements", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Creating Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists.htm) →  [WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite-.htm) →  [WRITE - list\_elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_list_elements.htm) → 

Lists, Line Elements

This example demonstrates line elements on lists.

Source Code

REPORT demo\_list\_line\_elements NO STANDARD PAGE HEADING LINE-SIZE 60.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-DATA: x TYPE i,
                y TYPE i.
    CLASS-METHODS pos.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA: x0 TYPE i VALUE 10,
          y0 TYPE i VALUE 10,
          n  TYPE i VALUE 16,
          i  TYPE i VALUE 0.
    x = x0.
    y = y0.
    pos( ).
    WHILE i LE n.
      WRITE line\_bottom\_left\_corner AS LINE.
      x += 1. pos( ).
      ULINE AT x(i).
      x += i. pos( ).
      WRITE line\_bottom\_right\_corner AS LINE.
      y -= 1. pos( ).
      DO i TIMES.
        WRITE '|'.
        y -= 1. pos( ).
      ENDDO.
      WRITE line\_top\_right\_corner AS LINE.
      i += 1.
      x -= i. pos( ).
      ULINE AT x(i).
      x -= 1. pos( ).
      WRITE line\_top\_left\_corner AS LINE.
      y += 1. pos( ).
      DO i TIMES.
        WRITE '|'.
        y += 1. pos( ).
      ENDDO.
      i += 1.
    ENDWHILE.  ENDMETHOD.
  METHOD pos.
    SKIP TO LINE y.
    POSITION x.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

Displays a spiral using line elements and joins these automatically in a list.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / FORMAT

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / FORMAT

Included pages: 2


### abapformat.htm

---
title: "FORMAT"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapformat_shortref.htm) Syntax FORMAT COLOR       =color ONOFF= col INTENSIFIED ONOFF= flag INVERSE     ONOFF= fl
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapformat.htm"
abapFile: "abapformat.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "abapformat"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Creating Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists.htm) → 

FORMAT

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapformat_shortref.htm)

Syntax

FORMAT *\[*COLOR       *{**\[*\=*\]**{*color *\[*ON*\]**}**|*OFF*}**|**{*\= col*}**\]*
       *\[*INTENSIFIED *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]**\]*
       *\[*INVERSE     *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]**\]*
       *\[*HOTSPOT     *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]**\]*
       *\[*INPUT       *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]**\]*
       *\[*FRAMES      *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]**\]*
       *\[*RESET*\]*.

Extras:

[1\. ... COLOR *{**\[*\=*\]**{*color *\[*ON*\]**}**|*OFF*}**|**{*\= col*}*](#!ABAP_ADDITION_1@1@)
[2\. ... INTENSIFIED *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*](#!ABAP_ADDITION_2@2@)
[3\. ... INVERSE *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*](#!ABAP_ADDITION_3@3@)
[4\. ... HOTSPOT *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*](#!ABAP_ADDITION_4@4@)
[5\. ... INPUT *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*](#!ABAP_ADDITION_5@5@)
[6\. ... FRAMES *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*](#!ABAP_ADDITION_6@6@)
[7\. ... RESET](#!ABAP_ADDITION_7@7@)

Effect

The settings defined using FORMAT apply from the current position of the [list cursor](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_cursor_glosry.htm "Glossary Entry") for all of the following output statements ([WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite-.htm) and, with restrictions, [ULINE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapuline.htm)) until they are redefined by a new FORMAT statement. Within a line, the areas between the individual output and between the start of the line and the first output are formatted. Blank lines created using [SKIP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapskip.htm) are not formatted, however.

The individual additions change the associated setting only and leave the others unchanged, with the exception of the addition RESET, which can change all settings.

At the start of the program, standard settings are defined for the settings that can be defined using FORMAT. These are set automatically for each [reporting event](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreporting_event_glosry.htm "Glossary Entry") and [list event](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_event_glosry.htm "Glossary Entry") (with the exception of the attribute set by FRAMES). A table of the standard settings is in the description of the addition RESET.

For each individual WRITE output, the settings can be overridden using the same additions in the addition WRITE. The settings that are defined using FORMAT or the standard settings then apply again.

Note

Alongside the statement FORMAT, [obsolete formats](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenformat_obsolete.htm) also exist that are replaced by FORMAT.

Addition 1

... COLOR *{**\[*\=*\]**{*color *\[*ON*\]**}**|*OFF*}**|**{*\= col*}*

Effect

This addition sets the color of the output. If the attribute INVERSE is set to OFF (default setting), this sets the background color of the output. If the attribute INVERSE is set to ON, this sets the foreground color of the output.

The color can be specified either statically using color, or dynamically using col.

-   color expects syntax taken directly from the following table. ON does not need to be specified. The optional equals sign \= in front of color or OFF can be specified only if the addition ON is not specified.
    
-   A data object of type i, containing one of the values from the following table, can be specified for col. If col contains a different value, this is handled like the value 0. The equals sign \= must be used if the data object col is not specified directly as a number.
    

Syntax of color

Value in col

Color

*{* COL\_BACKGROUND *}*

0

GUI-dependent

*{* 1 *|* COL\_HEADING *}*

1

Gray-blue

*{* 2 *|* COL\_NORMAL *}*

2

Light gray

*{* 3 *|* COL\_TOTAL *}*

3

Yellow

*{* 4 *|* COL\_KEY *}*

4

Blue-green

*{* 5 *|* COL\_POSITIVE *}*

5

Green

*{* 6 *|* COL\_NEGATIVE *}*

6

Red

*{* 7 *|* COL\_GROUP *}*

7

Purple

The addition OFF has the same effect as COL\_BACKGROUND or the value 0 in col and is the default setting. In this setting, the color of the background corresponds to a list line of the background color of the GUI window.

The addition COLOR does not affect lines made of [line elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_element_glosry.htm "Glossary Entry"), or on GUI windows that are ready for input. The latter can be overridden by the other additions.

Addition 2

... INTENSIFIED *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*

Effect

This addition defines the intensity of the background color. flag expects a data object of type i. If ON is specified or if the content of flag is not equal to 0, an intensified background color is used (default setting). If OFF is specified or if the content of flag is equal to 0, a non-intensified background color is used. An exception to this is the background color COL\_BACKGROUND used by INTENSIFIED ON to control the foreground color. If none of ON, OFF, or flag are specified after INTENSIFIED, the addition ON is applied.

At the same time, if the INPUT ON attribute is set, the addition INTENSIFIED OFF changes the foreground color of fields that are ready for input. If the INVERSE ON setting is made at the same time, the INTENSIFIED OFF setting is ignored (with the exception of COL\_BACKGROUND).

Addition 3

... INVERSE *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*

Effect

This addition defines whether the addition COLOR sets the background color or the foreground color. flag expects a data object of type i. If ON is specified or the content of flag is not equal to 0, the foreground (the output) is displayed in the selected color. An exception to this is the COL\_BACKGROUND color, used to display the foreground in white. If OFF is specified or if the content of flag is equal to 0, the background is displayed in the selected color (default setting). If none of ON, OFF, or flag are specified after INVERSE, the addition ON is applied.

At the same time, if the attribute INPUT ON is set, the addition INVERSE ON changes the background and foreground color of fields that are ready for input.

Example

Demonstrates different combinations of the additions COLOR, INTENSIFIED, and INVERSE. The program SHOWCOLO produces a similar result.

DATA col TYPE i VALUE 0.
DO 8 TIMES.
  col = sy-index - 1.
  FORMAT COLOR = col.
  WRITE: /  col              COLOR OFF,
           'INTENSIFIED ON'  INTENSIFIED ON,
           'INTENSIFIED OFF' INTENSIFIED OFF,
           'INVERSE ON'      INVERSE ON.
ENDDO.

Addition 4

... HOTSPOT *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*

Effect

This addition influences the display of the mouse pointer and the function of the mouse in the list displayed on the screen. flag expects a data object of type i. If ON is specified or if the content of flag is not equal to 0, it changes its appearance to a hand when the mouse pointer is positioned on a list area that is formatted accordingly (hotspot) and a single click has the same effect as a double-click (that is, selecting the function key F2). If OFF is specified or if the content of flag is equal to 0, the function of the mouse does not change (default setting). If none of ON, OFF, or flag are specified after HOTSPOT, the addition ON is applied.

If the attribute INPUT ON is set, the addition HOTSPOT ON is ignored and is also ignored by [line elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_element_glosry.htm "Glossary Entry").

Note

By default, INPUT ON is set for a checkbox defined with [AS CHECKBOX](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_list_elements.htm) and the addition HOTSPOT ON is ignored. However, HOTSPOT ON does have an effect on a non-input-ready checkbox.

Example

Demonstration of a Hotspot Clicking the output once creates a details list.

START-OF-SELECTION.
  FORMAT HOTSPOT.
  WRITE 'Click me!' COLOR 5.
  FORMAT HOTSPOT OFF.
AT LINE-SELECTION.
  WRITE 'Yeah!' COLOR 3.

Addition 5

... INPUT *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*

Effect

This addition makes list areas ready for input. flag expects a data object of type i. If ON is specified or the content of flag is not equal to 0, the relevant list area is displayed with a different foreground and background color than the rest of the list, and the user can overwrite the output. The screen cursor is positioned in the first field that is ready for input. If OFF is specified or the content of flag is equal to 0, the output is not made ready for input (default setting). If none of ON, OFF, or flag are specified after INPUT, the addition ON is applied.

Within an area that is ready for input, icons are displayed empty and symbols are displayed as characters according to the [code page](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencodepage_glosry.htm "Glossary Entry"). [Line elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_element_glosry.htm "Glossary Entry") are not made ready for input. In list areas that are ready for input, however, the characters "-" and "|", are not transformed into line elements and are not displayed as being ready for input. In particular, the latter also applies to the statement ULINE.

The width of the list area that is ready for input is defined by the [output length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwrite_output_length.htm). If the display of contents from the list buffer in a list area that is ready for input results in truncation, the indicator is placed outside the area. The number of characters that can be entered is limited by the output length. The content cannot be moved. The number of characters that can be entered depends on the space that the individual characters require.

The entries made by the user are saved in the list buffer and can be evaluated during a list event. If characters were truncated in the list, then they will also be lost in the list buffer.

Note

If a list line contains an input field with only blanks, it is not displayed if the statement SET BLANK LINES ON was not executed beforehand.

Example

Displays a field that is ready for input and evaluates it in the event AT LINE-SELECTION. The evaluation is performed only if the user clicks the hotspot below the line that is ready for input.

DATA: input\_field TYPE c LENGTH 100,
      line\_num TYPE i.
START-OF-SELECTION.
  WRITE 'Input text:'.
  SET BLANK LINES ON.
  FORMAT INPUT.
  WRITE / input\_field.
  FORMAT INPUT OFF.
  WRITE / '>>> OK <<<' COLOR 5 HOTSPOT.
AT LINE-SELECTION.
  IF sy-lisel = '>>> OK <<<'.
    line\_num = sy-lilli - 1.
    READ LINE line\_num FIELD VALUE input\_field.
    WRITE:   'The input was:',
           /  input\_field.
  ENDIF.

Addition 6

... FRAMES *\[**{*ON*|*OFF*}**|**{*\= flag*}**\]*

Effect

This addition defines whether the "-" and "|" characters are transformed to [line elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenline_element_glosry.htm "Glossary Entry"). flag expects a data object of type i. If ON is specified or if the content of flag is not equal to 0, the characters are transformed in the relevant list area (default setting). If OFF is specified or if the content of flag is not equal to 0, the characters are not transformed. If none of ON, OFF, or flag are specified after FRAMES, the addition ON is applied.

In the FRAMES ON setting, the following points apply:

-   If the "-" and "|" characters are displayed directly next to each other or above each other, they are replaced by line elements, producing continuous lines (frames). This applies particularly to the output of lines using ULINE.
    
-   A solitary "|" character is always replaced by a vertical line.
    
-   Line elements that are displayed explicitly by the addition AS LINE are not replaced by other line elements and they do not influence "-" and "|" characters that are next to each other.
    

In the FRAMES OFF setting, the "-" and "|" are not converted into line elements. Line elements can be displayed explicitly using the addition AS LINE.

Note

The addition FRAMES OFF is suitable for preventing unwanted results in spool lists. This applies particularly to lists that are intended for archiving.

Example

Displays a frame with the characters "-" and "|" joined/not joined.

CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS frame.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    FORMAT FRAMES ON.
    frame( ).
    FORMAT FRAMES OFF.
    frame( ).
  ENDMETHOD.
  METHOD frame.
    SKIP.
    WRITE: / '----',
           / '|  |',
           / '----'.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Addition 7

... RESET

Effect

This addition sets all formatting settings for which the corresponding addition is not specified in the same FORMAT statement to the state OFF, apart from the setting of the addition FRAMES, which is set to ON. For settings whose addition is also specified, the addition RESET is ignored.

The following table shows the effect of RESET compared with the default settings (the setting when the program starts and the setting that is made for reporting and list events).

Addition

State After RESET

State After Program Start

State After Reporting Event/List Event

COLOR

OFF

OFF

OFF

INTENSIFIED

OFF

ON

ON

INVERSE

OFF

OFF

OFF

HOTSPOT

OFF

OFF

OFF

INPUT

OFF

OFF

OFF

FRAMES

ON

ON

No change

Example

This FORMAT statement creates the default setting after the program starts.

FORMAT RESET
       INTENSIFIED ON.

Continue
![Example](exa.gif "Example") [Lists, Supported Colors](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_format_color2_abexa.htm)


### abenlist_format_color2_abexa.htm

---
title: "Lists, Supported Colors"
description: |
  This example demonstrates which colors are available for list formatting. Source Code REPORT demo_list_format_color_1 . DATA i TYPE i VALUE 0. DATA col(15) TYPE c. WHILE i < 8. CASE i. WHEN 0. col = 'COL_BACKGROUND '. WHEN 1. col = 'COL_HEADING    '. WHEN 2. col = 'COL_NORMAL     '. WHEN 3. c
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_format_color2_abexa.htm"
abapFile: "abenlist_format_color2_abexa.htm"
keywords: ["do", "while", "if", "case", "class", "data", "abenlist", "format", "color2", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Creating Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists.htm) →  [FORMAT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapformat.htm) → 

Lists, Supported Colors

This example demonstrates which colors are available for list formatting.

Source Code

REPORT demo\_list\_format\_color\_1 .
DATA i TYPE i VALUE 0.
DATA col(15) TYPE c.
WHILE i < 8.
  CASE i.
    WHEN 0. col = 'COL\_BACKGROUND '.
    WHEN 1. col = 'COL\_HEADING    '.
    WHEN 2. col = 'COL\_NORMAL     '.
    WHEN 3. col = 'COL\_TOTAL      '.
    WHEN 4. col = 'COL\_KEY        '.
    WHEN 5. col = 'COL\_POSITIVE   '.
    WHEN 6. col = 'COL\_NEGATIVE   '.
    WHEN 7. col = 'COL\_GROUP      '.
  ENDCASE.
  FORMAT INTENSIFIED COLOR = i.
  WRITE: /(4) i, AT 7            sy-vline,
            col,                 sy-vline,
            col INTENSIFIED OFF, sy-vline,
            col INVERSE.
  i += 1.
ENDWHILE.

Description

In the statement FORMAT, the COLOR option for subsequent WRITE statements is set at runtime. The other options are set individually for each WRITE statement in the program.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / NEW-PAGE

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / NEW-PAGE

Included pages: 3


### abapnew-page.htm

---
title: "NEW-PAGE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_shortref.htm) Syntax NEW-PAGE page_options(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_options.htm)  spool_options(https://help.sap.com/doc/abapdocu_754_index_htm/7
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page.htm"
abapFile: "abapnew-page.htm"
keywords: ["insert", "do", "if", "try", "class", "abapnew", "page"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Creating Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists.htm) → 

NEW-PAGE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_shortref.htm)

Syntax

NEW-PAGE *\[*[page\_options](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_options.htm)*\]* *\[* [spool\_options](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_print.htm)*\]*.

Effect

This statement creates a new page in the current list and writes the subsequent list output into a spool list. The additions [page\_options](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_options.htm) determine general properties of the new page. The additions [spool\_options](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_print.htm) control the spool list output.

The statement NEW-PAGE completes the current page. If output was created by [WRITE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite-.htm) or [ULINE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapuline.htm) on the current page, a new page is created and the value in sy-pagno is increased by 1. An empty line is inserted between the individual pages. The [list cursor](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_cursor_glosry.htm "Glossary Entry") is set to the first position of the first line under the standard page header of the new page.

The new page is created independently of the current list cursor position underneath the last line of the current page in which output was created.

Notes

-   The statement NEW-PAGE cannot be used to create empty pages.
    
-   The statement NEW-PAGE does not raise the list event [END-OF-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapend-of-page.htm). This list event is raised only if the page footer or page end is reached when the list is being written. If NEW-PAGE is executed at precisely this event, it just seems like END-OF-PAGE was reached by this statement, like for any other statement.
    
-   The event [TOP-OF-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page.htm) is triggered before the first output on the new page.
    

Continue
[NEW-PAGE - page\_options](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_options.htm)
[NEW-PAGE - spool\_options](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_print.htm)


### abapnew-page_options.htm

---
title: "Syntax"
description: |
  ... WITH-TITLENO-TITLE WITH-HEADINGNO-HEADING LINE-COUNT page_lines LINE-SIZE width NO-TOPOFPAGE ... Extras: 1. ... WITH-TITLENO-TITLE(#!ABAP_ADDITION_1@1@) 2. ... WITH-HEADINGNO-HEADING(#!ABAP_ADDITION_2@2@) 3. ... LINE-COUNT page_lines
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_options.htm"
abapFile: "abapnew-page_options.htm"
keywords: ["select", "do", "if", "try", "class", "data", "abapnew", "page", "options"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Creating Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists.htm) →  [NEW-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page.htm) → 

NEW-PAGE - page\_options

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_shortref.htm)

Syntax

... *\[*WITH-TITLE*|*NO-TITLE*\]*
    *\[*WITH-HEADING*|*NO-HEADING*\]*
    *\[*LINE-COUNT page\_lines*\]*
    *\[*LINE-SIZE width*\]*
    *\[*NO-TOPOFPAGE*\]* ...

Extras:

[1\. ... WITH-TITLE*|*NO-TITLE](#!ABAP_ADDITION_1@1@)
[2\. ... WITH-HEADING*|*NO-HEADING](#!ABAP_ADDITION_2@2@)
[3\. ... LINE-COUNT page\_lines](#!ABAP_ADDITION_3@3@)
[4\. ... LINE-SIZE width](#!ABAP_ADDITION_4@4@)
[5\. ... NO-TOPOFPAGE](#!ABAP_ADDITION_5@5@)

Effect

These additions set properties of the list for all subsequent pages of the current list level, until they are set again in another NEW-PAGE statement. The additions override additions of the same name in the introductory program statement.

Addition 1

... WITH-TITLE*|*NO-TITLE

Addition 2

... WITH-HEADING*|*NO-HEADING

Effect

These additions specify which components of the standard page header are output for the subsequent pages of the current list level. The standard page header consists of a standard title and column headings.

The additions WITH-TITLE and NO-TITLE switch the output of the standard title on or off for the subsequent pages. The predefined default setting for basic lists is WITH-TITLE, and for details lists is NO-TITLE.

The additions WITH-HEADING and NO-HEADING switch the output of the column headings on or off for all subsequent pages. The predefined default setting for basic lists is WITH-HEADING, and for details lists is NO-HEADING.

Note

For basic lists, these additions override the setting made in the introductory program statement. The addition NO STANDARD PAGE HEADING used there functions in the same way as when NO-TITLE and NO-HEADING are used simultaneously, with the exception that the latter do not have an impact on the system field sy-wtitl.

Addition 3

... LINE-COUNT page\_lines

Effect

This addition sets the page length of the subsequent pages of the current list level to the value in page\_lines and sets sy-linct to this value. page\_lines expects a data object of type i. If the value of page\_lines is less than or equal to 0 or greater than 60000, the page length is set to 60000. For the basic list, the addition overrides the page length specified in the introductory program statement.

The page length determines how many lines including [page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") and [page footer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") can be written to a list page. If output is written to a line outside the current page length or in the area reserved for the page footer of a basic list, a new page is created automatically.

Notes

The lines reserved in the introductory program statement for the page footer of the basic list cannot be changed with the addition LINE-COUNT of the statement NEW-PAGE. For details lists, you cannot create a page footer.

-   The default value should be used for screen lists since, as a rule, page breaks specified using LINE-COUNT are not adjusted to the window size.
    
-   The default value should also be used for spool lists, so that the page size can be selected on a printer-specific basis. A spool list should be created in such a way that it provides satisfactory results for any page size.
    
-   Specifying a fixed line count is only useful for form-like lists with a fixed page layout. Here, however, it is always advisable to check whether these forms can be created by other means. This can be done, for example, by searching [SAP Help Portal](http://help.sap.com) for the term "form".
    

Example

The following code demonstrates automatic page breaks in a basic list. The pages have two-line page headers and page footers defined after [TOP-OF-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page.htm) and [END-OF-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapend-of-page.htm). The page length is specified after NEW-PAGE. The program displays five pages.

REPORT NO STANDARD PAGE HEADING LINE-COUNT 0(2).
TOP-OF-PAGE.
  WRITE sy-pagno.
  ULINE.
END-OF-PAGE.
  ULINE.
  WRITE 'Footer'.
START-OF-SELECTION.
  NEW-PAGE LINE-COUNT 6.
  DO 10 TIMES.
    WRITE / sy-index.
  ENDDO.

Addition 4

... LINE-SIZE width

Effect

This addition sets the page width of the current list level to the value in width and sets sy-linsz to this value. The line width determines the number of characters in the line buffer as well as the number of columns in the list displayed. width expects a data object of type i. The value of width must not be negative. If the value of width is equal to 0 or greater than 1023, the line width is set to a default width, which is based on the window width of the current [dynpro](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_glosry.htm "Glossary Entry") (sy-scols), but is at least as wide as the width of a standard sized GUI window. For the basic list, the addition overrides the page width specified in the introductory program statement.

The addition has an effect only if no output has yet been sent to the current list level. The page width of a list that has already been written cannot be changed.

Note

The current maximum line width is stored in the constants slist\_max\_linesize of the [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") SLIST. A type slist\_max\_listline of type c and length slist\_max\_linesize is also defined there.

Example

Creates a basic list and details lists with various page widths. Only the standard title of the standard page header is displayed.

REPORT demo NO STANDARD PAGE HEADING.
START-OF-SELECTION.
  NEW-PAGE WITH-TITLE LINE-SIZE 40.
  WRITE 'Basic list'.
AT LINE-SELECTION.
  NEW-PAGE WITH-TITLE LINE-SIZE 20.
  WRITE 'Secondary list'.

Addition 5

... NO-TOPOFPAGE

Effect

This addition suppresses the event [TOP-OF-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page.htm) on the new page and on all automatically created pages of the current list level up to the next statement NEW-PAGE. If the addition NO-TOPOFPAGE is not specified, the event TOP-OF-PAGE is raised before the output is sent to a new page.

Example

The following program generates six pages. The event TOP-OF-PAGE is raised only on the first page.

REPORT demo NO STANDARD PAGE HEADING.
START-OF-SELECTION.
  ULINE.
  NEW-PAGE NO-TOPOFPAGE LINE-COUNT 2.
  DO 10 TIMES.
    WRITE / sy-index.
  ENDDO.
TOP-OF-PAGE.
  WRITE 'Basic list'.


### abapnew-page_print.htm

---
title: "Syntax"
description: |
  ...  PRINT ON NEW-SECTION PARAMETERS pri_params ARCHIVE PARAMETERS arc_params NO DIALOG    PRINT OFF  ... Extras: 1. ... PRINT ON NEW-SECTION(#!ABAP_ADDITION_1@1@) 2. ... PARAMETERS pri_params(#!ABAP_ADDITION_2@2@) 3. ... ARCHIVE PARAMETERS arc_para
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_print.htm"
abapFile: "abapnew-page_print.htm"
keywords: ["select", "do", "while", "if", "try", "catch", "class", "data", "types", "abapnew", "page", "print"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Creating Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists.htm) →  [NEW-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page.htm) → 

NEW-PAGE - spool\_options

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_shortref.htm)

Syntax

... *{* PRINT ON *\[*NEW-SECTION*\]* PARAMETERS pri\_params
                             *\[*ARCHIVE PARAMETERS arc\_params*\]*
                             NO DIALOG *}*
  *|* *{* PRINT OFF *}* ...

Extras:

[1\. ... PRINT ON *\[*NEW-SECTION*\]*](#!ABAP_ADDITION_1@1@)
[2\. ... PARAMETERS pri\_params](#!ABAP_ADDITION_2@2@)
[3\. ... ARCHIVE PARAMETERS arc\_params](#!ABAP_ADDITION_3@3@)
[4\. ... NO DIALOG](#!ABAP_ADDITION_4@4@)
[5\. ... PRINT OFF](#!ABAP_ADDITION_5@5@)

Effect

The addition PRINT ON writes all subsequent output statements to a [spool list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm). The additions *\[*ARCHIVE*\]* PARAMETERS are used to define the spool parameters and the archiving parameters of the [spool request](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenspool_request_glosry.htm "Glossary Entry"). The addition PRINT OFF closes a spool list that has been started with the addition PRINT ON.

Addition 1

... PRINT ON *\[*NEW-SECTION*\]*

Effect

The addition PRINT ON creates a new [spool list level](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_list_level_glosry.htm "Glossary Entry"). The first output statement after NEW-PAGE PRINT ON opens a new [spool request](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenspool_request_glosry.htm "Glossary Entry") and writes to a [spool list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_list_glosry.htm "Glossary Entry") in the [SAP spool system](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_spool_system_glosry.htm "Glossary Entry"). The number of the spool request is passed to sy-spono by the first output statement. While it is being created, the spool list is sent page by page to the SAP spool system.

-   If the current list is a screen list, its creation is interrupted and the new spool list level is stacked in it.
    
-   If the current list is a [spool list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm) not created with NEW-PAGE PRINT ON, its creation is interrupted and the new spool list level is stacked in it.
    
-   If the current list is a [spool list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm) created using NEW-PAGE PRINT ON and the addition NEW-SECTION is not used, a handleable exception of the class CX\_SY\_NESTED\_PRINT\_ON is raised.
    
-   If the current list is a [spool list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm) created using NEW-PAGE PRINT ON, the addition NEW-SECTION is used, the specified spool parameters match those of the new list, and the spool parameter PRNEW in the structure pri\_params is initial, no new spool request is opened and the output is written to the current spool list. If the spool parameters define the output of a cover sheet, the cover sheet is printed again before the following output as a spacer sheet.
    
-   If the current list is a [spool list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm) created using NEW-PAGE PRINT ON, the addition NEW-SECTION is used, and the specified spool parameters do not match those of the new list or the spool parameter PRNEW in structure pri\_params is not initial, the current spool request is closed implicitly by NEW-PAGE PRINT OFF and a new spool request is created.
    

It is not possible to use NEW-PAGE PRINT ON to stack another spool list level directly on to a spool list level created using NEW-PAGE PRINT ON.

A spool list level created using NEW-PAGE PRINT ON can be closed by either NEW-PAGE PRINT OFF, NEW-PAGE PRINT ON NEW-SECTION, the end of the program, or by leaving a dynpro sequence.

Notes

-   Each statement NEW-PAGE PRINT ON should be closed explicitly using NEW-PAGE PRINT OFF before the program end or before leaving a dynpro sequence.
    
-   The addition NEW-SECTION can be used to avoid the exception CX\_SY\_NESTED\_PRINT\_ON. When using NEW-SECTION, the output can also be continued into the previous spool list, which is not possible when an exception is handled with CATCH.
    
-   As well as the addition NEW-SECTION, the obsolete statement [NEW-SECTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-section.htm) can also be used outside of classes. However it does not enable spool parameters to be specified.
    

Executable Example

[Lists, Spooling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_list_abexa.htm).

Addition 2

... PARAMETERS pri\_params

Addition 3

... ARCHIVE PARAMETERS arc\_params

Addition 4

... NO DIALOG

Effect

These additions provide the spool request with [spool parameters and archiving parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters.htm). The latter are necessary if the spool list is archived using [ArchiveLink](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_archivelink_glosry.htm "Glossary Entry").

The addition PARAMETERS passes the spool parameters in a structure pri\_params of data type PRI\_PARAMS from ABAP Dictionary. If archiving is specified in pri\_params, archiving parameters must be passed using the addition ARCHIVE PARAMETERS in a structure arc\_params of data type ARC\_PARAMS from ABAP Dictionary.

Structures of data types PRI\_PARAMS and ARC\_PARAMS must be filled by the function module [GET\_PRINT\_PARAMETERS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_function.htm). When the function module is called, either individual spool parameters or all spool parameters can be set in the program and/or a spool dialog window displayed. The function module creates a set of valid spool and archiving parameters for use as pri\_params and arc\_params and adds these to its output parameters.

If the structures pri\_params or arc\_params are initial, the spool parameters or archiving parameters created by a call of the function modules GET\_PRINT\_PARAMETERS with initial input values are used.

The addition NO DIALOG suppresses the spool dialog window that by default appears when using the addition PRINT ON.

Notes

-   These additions must always be used as indicated here. It is particularly important that the standard spool dialog box be suppressed. When using the default spool dialog window, the Back function is not available because the system cannot return to a point before a statement after spooling has been switched on by such a statement. Printing can only be exited using Exit, which ends the entire program. If the user exits the GUI window by choosing Cancel, inconsistent spool parameters can be produced. Instead, the spool dialog window can be displayed by calling the function module [GET\_PRINT\_PARAMETERS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_function.htm). This function module has an output parameter VALID that indicates the consistency of the spool parameters created.
    
-   The use of the addition NO DIALOG without simultaneously passing spool parameters is allowed only outside of ABAP Objects and produces a warning in the syntax check. In other objects, the spool parameters are derived from the user master record, if possible.
    
-   As well as the additions shown here, there is a range of other additions for an [obsolete specification of spool parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_print_obsolete.htm), which should no longer be used.
    

Example

Creates spool lists during the list event [AT LINE-SELECTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm). The spool parameters are defined by the function module GET\_PRINT\_PARAMETERS before the basic list is created.

REPORT demo NO STANDARD PAGE HEADING.
DATA: spfli\_wa TYPE spfli,
      sflight\_wa TYPE sflight.
DATA: print\_parameters TYPE pri\_params,
      valid\_flag       TYPE c LENGTH 1.
START-OF-SELECTION.
  CALL FUNCTION 'GET\_PRINT\_PARAMETERS'
    IMPORTING
      out\_parameters       = print\_parameters
      valid                = valid\_flag
    EXCEPTIONS
      invalid\_print\_params = 2
      OTHERS               = 4.
  IF valid\_flag = 'X' AND sy-subrc = 0.
    SELECT carrid, connid
           FROM spfli
           INTO CORRESPONDING FIELDS OF @spfli\_wa.
      WRITE: / spfli\_wa-carrid, spfli\_wa-connid.
      HIDE:    spfli\_wa-carrid, spfli\_wa-connid.
    ENDSELECT.
  ELSE.
    ...
  ENDIF.
AT LINE-SELECTION.
  NEW-PAGE PRINT ON PARAMETERS print\_parameters
                    NO DIALOG.
  SELECT \*
         FROM sflight
         WHERE carrid = @spfli\_wa-carrid AND
               connid = @spfli\_wa-connid
         INTO @sflight\_wa.
    WRITE: / sflight\_wa-carrid, sflight\_wa-connid,
             sflight\_wa-fldate ...
  ENDSELECT.
  NEW-PAGE PRINT OFF.

Addition 5

... PRINT OFF

Effect

The addition PRINT OFF closes a [spool list level](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_list_level_glosry.htm "Glossary Entry") created using NEW-PAGE PRINT ON, sends the current page to the SAP spool system, and releases the associated spool request. Output statements that follow NEW-PAGE PRINT OFF write to the screen list or spool list where the spool list level closed by PRINT OFF was [stacked](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_spool.htm). When the system returns to the print list, the system field sy-spono is switched to the number of the associated spool request directly when the statement NEW-PAGE PRINT OFF is executed.

NEW-PAGE PRINT OFF is ignored by spool list levels not been created using NEW-PAGE PRINT ON.

Note

At the end of the program and at every list event [AT LINE-SELECTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm), [AT PFnn](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_pfnn.htm), and [AT USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm), the statement NEW-PAGE PRINT OFF is executed implicitly.

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Handleable Exceptions

CX\_SY\_NESTED\_PRINT\_ON

-   Cause: Stacked NEW-PAGE PRINT ON.
    Runtime error: NESTED\_PRINT\_ON


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / HIDE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Creating Lists / HIDE

Included pages: 2


### abaphide.htm

---
title: "HIDE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaphide_shortref.htm) Syntax HIDE dobj. Effect This statement stores the content of a variable dobj together with the current list line whose line number is contained in sy-linno in the hide area(https://help.sap.com/doc
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaphide.htm"
abapFile: "abaphide.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "field-symbol", "abaphide"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Creating Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists.htm) → 

HIDE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaphide_shortref.htm)

Syntax

HIDE dobj.

Effect

This statement stores the content of a variable dobj together with the current list line whose line number is contained in sy-linno in the [hide area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhide_area_glosry.htm "Glossary Entry") of the current list level. The data type of the variable dobj must be [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") and no field symbols or components of [boxed components](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenboxed_component_glosry.htm "Glossary Entry") can be specified that point to rows of internal tables, and no class attributes can be specified. The saved values can be read as followed:

-   Any user action on a displayed screen list that causes a list event assigns all values saved using HIDE to the relevant variables.
    
-   If a list line of a list level is read or modified using the statements [READ LINE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapread_line.htm) or [MODIFY LINE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapmodify_line.htm), all the values of this line saved using HIDE are assigned to the relevant variables.
    

Notes

-   The HIDE statement works independently of whether the [list cursor](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_cursor_glosry.htm "Glossary Entry") was set. In particular, variables for empty list lines can be stored (that is, lines in which the list cursor was positioned using statements like [SKIP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapskip.htm)).
    
-   The HIDE statement should be executed directly in the statement that has set the list cursor in the line.
    
-   Using the HIDE statement on a field symbol can cause runtime errors. The syntax check displays a warning.
    

Example

Saving square numbers and cubic numbers for a list of numbers. The example shows that any variable can be stored independently of the row content. In the real world, one would more likely save only the number and execute the calculation, when required, in the the event block for [AT LINE-SELECTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm).

REPORT ...
DATA: square TYPE i,
      cube   TYPE i.
START-OF-SELECTION.
  FORMAT HOTSPOT.
  DO 10 TIMES.
    square = sy-index \*\* 2.
    cube   = sy-index \*\* 3.
    WRITE / sy-index.
    HIDE: square, cube.
  ENDDO.
AT LINE-SELECTION.
  WRITE: square, cube.

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Non-Handleable Exceptions

-   Cause: The field is too long for HIDE.
    Runtime error: HIDE\_FIELD\_TOO\_LARGE
    
-   Cause: HIDE in a table row or a component in a table row is not possible.
    Runtime error: HIDE\_ILLEGAL\_ITAB\_SYMBOL
    
-   Cause: HIDE in a local field is not possible.
    Runtime error: HIDE\_NO\_LOCAL: HIDE
    
-   Cause: HIDE is not possible on an empty page.
    Runtime error: HIDE\_ON\_EMPTY\_PAGE
    
-   Cause: Illegal field
    Runtime error: HIDE\_NOT\_GLOBAL
    
-   Cause: Permitted number of HIDE statements per list line exceeded
    Runtime error: HIDE\_TOO\_MANY\_HIDES
    

Continue
![Example](exa.gif "Example") [Lists, HIDE Technique](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_hide_abexa.htm)


### abenlist_hide_abexa.htm

---
title: "Lists, HIDE Technique"
description: |
  This example demonstrates how to implement program-driven data passes for lists to the ABAP program using HIDE. Source Code REPORT demo_list_hide NO STANDARD PAGE HEADING. TABLES: spfli, sbook. DATA: num TYPE i, dat TYPE d. START-OF-SELECTION. num = 0. SET PF-STATUS 'FLIGHT'. GET spfli. num += 1.
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_hide_abexa.htm"
abapFile: "abenlist_hide_abexa.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "abenlist", "hide", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Creating Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists.htm) →  [HIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaphide.htm) → 

Lists, HIDE Technique

This example demonstrates how to implement program-driven data passes for lists to the ABAP program using HIDE.

Source Code

REPORT demo\_list\_hide NO STANDARD PAGE HEADING.
TABLES: spfli, sbook.
DATA: num TYPE i,
      dat TYPE d.
START-OF-SELECTION.
  num = 0.
  SET PF-STATUS 'FLIGHT'.
GET spfli.
  num += 1.
  WRITE: / spfli-carrid, spfli-connid,
           spfli-cityfrom, spfli-cityto.
  HIDE:    spfli-carrid, spfli-connid, num.
END-OF-SELECTION.
  CLEAR num.
TOP-OF-PAGE.
  WRITE 'List of Flights'.
  ULINE.
  WRITE 'CA  CONN FROM                 TO'.
  ULINE.
TOP-OF-PAGE DURING LINE-SELECTION.
  CASE sy-pfkey.
    WHEN 'BOOKING'.
      WRITE sy-lisel.
      ULINE.
    WHEN 'WIND'.
      WRITE:  'Booking', sbook-bookid,
           /  'Date   ', sbook-fldate.
      ULINE.
  ENDCASE.
AT USER-COMMAND.
  CASE sy-ucomm.
    WHEN 'SELE'.
      IF num NE 0.
        SET PF-STATUS 'BOOKING'.
        CLEAR dat.
        SELECT \* FROM sbook WHERE carrid = spfli-carrid
                            AND   connid = spfli-connid.
          IF sbook-fldate NE dat.
            dat = sbook-fldate.
            SKIP.
            WRITE / sbook-fldate.
            POSITION 16.
          ELSE.
            NEW-LINE.
            POSITION 16.
          ENDIF.
          WRITE sbook-bookid.
          HIDE: sbook-bookid, sbook-fldate, sbook-custtype,
                sbook-smoker, sbook-luggweight, sbook-class.
        ENDSELECT.
        IF sy-subrc NE 0.
          WRITE / 'No bookings for this flight'.
        ENDIF.
        num = 0.
        CLEAR sbook-bookid.
      ENDIF.
    WHEN 'INFO'.
      IF NOT sbook-bookid IS INITIAL.
        SET PF-STATUS 'WIND'.
        SET TITLEBAR 'BKI'.
        WINDOW STARTING AT 30 5 ENDING AT  60 10.
        WRITE: 'Customer type   :', sbook-custtype,
             / 'Smoker          :', sbook-smoker,
             / 'Luggage weigtht :', sbook-luggweight UNIT 'KG',
             / 'Class           :', sbook-class.
      ENDIF.
  ENDCASE.

Description

At START-OF-SELECTION time, the status FLIGHT is set for the basic list. In the status FLIGHT, the function key F2 and a pushbutton are assigned the function code SELE (text SELECT). This means the event AT USER-COMMAND is triggered when the user double-clicks, presses F2, or chooses the pushbutton SELECT.

The three fields spfli-carrid, spfli-connid, and num are written to the [Hide](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhide_area_glosry.htm "Glossary Entry") area while the basic list is created. After a line is selected, the details list defined for the function code SELE in AT USER-COMMAND is displayed. After the AT USER-COMMAND event, all fields of the selected line that were stored in the Hide area are loaded again. num is used to check whether a line from the actual list was selected. The details list is given the status BOOKING, where F2 is assigned the function code INFO (with the text Booking Information) The details list displays data which can be selected using the Hide fields of the basic list. For each list line displayed, the system stores additional information in the [Hide](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhide_area_glosry.htm "Glossary Entry") area.

If the user selects a line of the details list, the system displays the stored information in a dialog box with the status WIND. For the WIND status, the default values are applied when the list status is synchronized. sbook-bookid is used to check whether a valid line was selected.

The program itself sets all page headers and the title bar of the dialog box.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Processing Lists in the List Buffer / READ LINE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Processing Lists in the List Buffer / DESCRIBE LIST

Included pages: 2


### abapdescribe_list.htm

---
title: "DESCRIBE LIST"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm) Syntax DESCRIBE LIST  NUMBER OF  LINESPAGES n  LINE linno PAGE page  PAGE pagno page_properties(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list.htm"
abapFile: "abapdescribe_list.htm"
keywords: ["select", "insert", "do", "if", "class", "data", "abapdescribe", "list"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Processing Lists in the List Buffer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_complex.htm) → 

DESCRIBE LIST

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm)

Syntax

DESCRIBE LIST *{* *{*NUMBER OF  *{*LINES*|*PAGES*}* n*}*
              *|* *{*LINE linno PAGE page*}*
              *|* *{*PAGE pagno [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm)*}* *}*
              *\[*INDEX idx*\]*.

Alternatives:

[1\. ... NUMBER OF *{*LINES*|*PAGES*}* n](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LINE linno PAGE page](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... PAGE pagno page\_properties](#!ABAP_ALTERNATIVE_3@3@)

Addition:

[... INDEX idx](#!ABAP_ONE_ADD@1@)

Effect

This statement assigns the properties of a list stored in a list buffer to the variables n, page, or the variables specified in [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm).

System Fields

sy-subrc

Meaning

0

The list property was successfully specified.

4

The line specified in linno or page specified in pagno cannot be found.

8

The list level specified in idx cannot be found.

Note

The statement DESCRIBE LIST should only be used for completed lists, because not all properties of a list can be read when it is being created.

Addition

... INDEX idx

Effect

The list level can be specified with the addition INDEX, where idx expects a data object (which contains the list index) of type i. The value of idx must be greater than or equal to 0. If the addition INDEX is not specified, the list level 0 (the basic list itself) is selected when the basic list is created and the list level at which the event was raised (sy-listi) is selected when a list event is processed. If the list level specified in idx does not exist, the variables are not changed and sy-subrc is set to the value 8.

Alternative 1

... NUMBER OF *{*LINES*|*PAGES*}* n

Effect

If specified, LINES expects the number of lines, PAGES expects the number of pages in the list saved in n. n expects a data object of the type i. The number of lines is counted from the first to the last line described by an output statement and contains the page headers and page footers. The empty lines inserted automatically between the list pages are not counted.

Alternative 2

... LINE linno PAGE page

Effect

The corresponding page for the line number specified in linno is determined and stored in page. linno and page expect data objects of the type i. If the line specified in linno does not exist, page is not changed and sy-subrc is set to 4. The page headers and page footers are included in the line count, but not the empty lines inserted automatically between the list pages.

Alternative 3

... PAGE pagno page\_properties

Effect

Various properties [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm) for the page number specified in pagno are determined and passed to the specified variables. At least one addition must be specified after pagno. pagno expects the data type i. If the page specified in pagno does not exist, the variables are not changed and sy-subrc is set to the value 4.

Example

Determines some properties of the last page of the list currently displayed using two DESCRIBE statements in a list event.

DATA: last\_page  TYPE i,
      lines      TYPE i,
      first\_line TYPE i,
      top\_lines  TYPE i.
...
AT LINE-SELECTION.
  DESCRIBE LIST: NUMBER OF PAGES last\_page,
                 PAGE last\_page LINES lines
                                FIRST-LINE first\_line
                                TOP-LINES  top\_lines.

Continue
[DESCRIBE LIST - page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm)


### abapdescribe_list_page_properties.htm

---
title: "Syntax"
description: |
  ... LINE-SIZE width LINE-COUNT page_lines LINES lines FIRST-LINE first_line TOP-LINES top_lines TITLE-LINES title_lines HEAD-LINES header_lines END-LINES footer_lines ... Extras: 1. ... LINE-SIZE width(#!ABAP_ADDITION_1@1@) 2
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm"
abapFile: "abapdescribe_list_page_properties.htm"
keywords: ["insert", "do", "try", "class", "data", "abapdescribe", "list", "page", "properties"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Processing Lists in the List Buffer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_complex.htm) →  [DESCRIBE LIST](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list.htm) → 

DESCRIBE LIST - page\_properties

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm)

Syntax

... *\[*LINE-SIZE width*\]*
    *\[*LINE-COUNT page\_lines*\]*
    *\[*LINES lines*\]*
    *\[*FIRST-LINE first\_line*\]*
    *\[*TOP-LINES top\_lines*\]*
    *\[*TITLE-LINES title\_lines*\]*
    *\[*HEAD-LINES header\_lines*\]*
    *\[*END-LINES footer\_lines*\]* ...

Extras:

[1\. ... LINE-SIZE width](#!ABAP_ADDITION_1@1@)
[2\. ... LINE-COUNT page\_lines](#!ABAP_ADDITION_2@2@)
[3\. ... LINES lines](#!ABAP_ADDITION_3@3@)
[4\. ... FIRST-LINE first\_line](#!ABAP_ADDITION_4@4@)
[5\. ... TOP-LINES top\_lines](#!ABAP_ADDITION_5@5@)
[6\. ... TITLE-LINES title\_lines](#!ABAP_ADDITION_6@6@)
[7\. ... HEAD-LINES header\_lines](#!ABAP_ADDITION_7@7@)
[8\. ... END-LINES footer\_lines](#!ABAP_ADDITION_8@8@)

Effect

Determines the properties of pages using DESCRIBE LIST. The data type i is expected for all target fields.

Addition 1

... LINE-SIZE width

Effect

Inserts the line length of the page defined using the addition LINE-SIZE of the statement at the start of the program or of [NEW-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page.htm) after width.

Addition 2

... LINE-COUNT page\_lines

Effect

Inserts the page length defined using the addition LINE-COUNT of the statement at the start of the program or of NEW-PAGE after page\_lines.

Addition 3

... LINES lines

Effect

Inserts the number of lines shown on the page including the [page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") and [page footer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") after lines.

Addition 4

... FIRST-LINE first\_line

Effect

Inserts the line number of the first line of the page, with respect to the whole list, after first\_line. The [page headers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") and [page footers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") are included in the line count, but not the empty lines inserted automatically between the list pages.

Addition 5

... TOP-LINES top\_lines

Effect

Inserts the number of lines of the [page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") of the page after top\_lines. The standard page header and the lines shown by the event TOP-OF-PAGE are included in the count.

Addition 6

... TITLE-LINES title\_lines

Effect

Inserts the number of lines of the standard title of the [standard page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_page_header_glosry.htm "Glossary Entry") of the page after title\_lines.

Addition 7

... HEAD-LINES header\_lines

Effect

Inserts the number of lines of the column headers of the [standard page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_page_header_glosry.htm "Glossary Entry") of the page after header\_lines.

Addition 8

... END-LINES footer\_lines

Effect

Inserts the number of lines reserved by the addition LINE-COUNT of the statement at the start of the program for the [page footer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") after footer\_lines.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Processing Lists in the List Buffer / MODIFY LINE

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Processing Lists in the List Buffer / DESCRIBE LIST

Included pages: 2


### abapdescribe_list.htm

---
title: "DESCRIBE LIST"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm) Syntax DESCRIBE LIST  NUMBER OF  LINESPAGES n  LINE linno PAGE page  PAGE pagno page_properties(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list.htm"
abapFile: "abapdescribe_list.htm"
keywords: ["select", "insert", "do", "if", "class", "data", "abapdescribe", "list"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Processing Lists in the List Buffer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_complex.htm) → 

DESCRIBE LIST

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm)

Syntax

DESCRIBE LIST *{* *{*NUMBER OF  *{*LINES*|*PAGES*}* n*}*
              *|* *{*LINE linno PAGE page*}*
              *|* *{*PAGE pagno [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm)*}* *}*
              *\[*INDEX idx*\]*.

Alternatives:

[1\. ... NUMBER OF *{*LINES*|*PAGES*}* n](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LINE linno PAGE page](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... PAGE pagno page\_properties](#!ABAP_ALTERNATIVE_3@3@)

Addition:

[... INDEX idx](#!ABAP_ONE_ADD@1@)

Effect

This statement assigns the properties of a list stored in a list buffer to the variables n, page, or the variables specified in [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm).

System Fields

sy-subrc

Meaning

0

The list property was successfully specified.

4

The line specified in linno or page specified in pagno cannot be found.

8

The list level specified in idx cannot be found.

Note

The statement DESCRIBE LIST should only be used for completed lists, because not all properties of a list can be read when it is being created.

Addition

... INDEX idx

Effect

The list level can be specified with the addition INDEX, where idx expects a data object (which contains the list index) of type i. The value of idx must be greater than or equal to 0. If the addition INDEX is not specified, the list level 0 (the basic list itself) is selected when the basic list is created and the list level at which the event was raised (sy-listi) is selected when a list event is processed. If the list level specified in idx does not exist, the variables are not changed and sy-subrc is set to the value 8.

Alternative 1

... NUMBER OF *{*LINES*|*PAGES*}* n

Effect

If specified, LINES expects the number of lines, PAGES expects the number of pages in the list saved in n. n expects a data object of the type i. The number of lines is counted from the first to the last line described by an output statement and contains the page headers and page footers. The empty lines inserted automatically between the list pages are not counted.

Alternative 2

... LINE linno PAGE page

Effect

The corresponding page for the line number specified in linno is determined and stored in page. linno and page expect data objects of the type i. If the line specified in linno does not exist, page is not changed and sy-subrc is set to 4. The page headers and page footers are included in the line count, but not the empty lines inserted automatically between the list pages.

Alternative 3

... PAGE pagno page\_properties

Effect

Various properties [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm) for the page number specified in pagno are determined and passed to the specified variables. At least one addition must be specified after pagno. pagno expects the data type i. If the page specified in pagno does not exist, the variables are not changed and sy-subrc is set to the value 4.

Example

Determines some properties of the last page of the list currently displayed using two DESCRIBE statements in a list event.

DATA: last\_page  TYPE i,
      lines      TYPE i,
      first\_line TYPE i,
      top\_lines  TYPE i.
...
AT LINE-SELECTION.
  DESCRIBE LIST: NUMBER OF PAGES last\_page,
                 PAGE last\_page LINES lines
                                FIRST-LINE first\_line
                                TOP-LINES  top\_lines.

Continue
[DESCRIBE LIST - page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm)


### abapdescribe_list_page_properties.htm

---
title: "Syntax"
description: |
  ... LINE-SIZE width LINE-COUNT page_lines LINES lines FIRST-LINE first_line TOP-LINES top_lines TITLE-LINES title_lines HEAD-LINES header_lines END-LINES footer_lines ... Extras: 1. ... LINE-SIZE width(#!ABAP_ADDITION_1@1@) 2
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm"
abapFile: "abapdescribe_list_page_properties.htm"
keywords: ["insert", "do", "try", "class", "data", "abapdescribe", "list", "page", "properties"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Processing Lists in the List Buffer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_complex.htm) →  [DESCRIBE LIST](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list.htm) → 

DESCRIBE LIST - page\_properties

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm)

Syntax

... *\[*LINE-SIZE width*\]*
    *\[*LINE-COUNT page\_lines*\]*
    *\[*LINES lines*\]*
    *\[*FIRST-LINE first\_line*\]*
    *\[*TOP-LINES top\_lines*\]*
    *\[*TITLE-LINES title\_lines*\]*
    *\[*HEAD-LINES header\_lines*\]*
    *\[*END-LINES footer\_lines*\]* ...

Extras:

[1\. ... LINE-SIZE width](#!ABAP_ADDITION_1@1@)
[2\. ... LINE-COUNT page\_lines](#!ABAP_ADDITION_2@2@)
[3\. ... LINES lines](#!ABAP_ADDITION_3@3@)
[4\. ... FIRST-LINE first\_line](#!ABAP_ADDITION_4@4@)
[5\. ... TOP-LINES top\_lines](#!ABAP_ADDITION_5@5@)
[6\. ... TITLE-LINES title\_lines](#!ABAP_ADDITION_6@6@)
[7\. ... HEAD-LINES header\_lines](#!ABAP_ADDITION_7@7@)
[8\. ... END-LINES footer\_lines](#!ABAP_ADDITION_8@8@)

Effect

Determines the properties of pages using DESCRIBE LIST. The data type i is expected for all target fields.

Addition 1

... LINE-SIZE width

Effect

Inserts the line length of the page defined using the addition LINE-SIZE of the statement at the start of the program or of [NEW-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page.htm) after width.

Addition 2

... LINE-COUNT page\_lines

Effect

Inserts the page length defined using the addition LINE-COUNT of the statement at the start of the program or of NEW-PAGE after page\_lines.

Addition 3

... LINES lines

Effect

Inserts the number of lines shown on the page including the [page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") and [page footer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") after lines.

Addition 4

... FIRST-LINE first\_line

Effect

Inserts the line number of the first line of the page, with respect to the whole list, after first\_line. The [page headers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") and [page footers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") are included in the line count, but not the empty lines inserted automatically between the list pages.

Addition 5

... TOP-LINES top\_lines

Effect

Inserts the number of lines of the [page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") of the page after top\_lines. The standard page header and the lines shown by the event TOP-OF-PAGE are included in the count.

Addition 6

... TITLE-LINES title\_lines

Effect

Inserts the number of lines of the standard title of the [standard page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_page_header_glosry.htm "Glossary Entry") of the page after title\_lines.

Addition 7

... HEAD-LINES header\_lines

Effect

Inserts the number of lines of the column headers of the [standard page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_page_header_glosry.htm "Glossary Entry") of the page after header\_lines.

Addition 8

... END-LINES footer\_lines

Effect

Inserts the number of lines reserved by the addition LINE-COUNT of the statement at the start of the program for the [page footer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") after footer\_lines.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Processing Lists in the List Buffer / SCROLL LIST

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Processing Lists in the List Buffer / DESCRIBE LIST

Included pages: 2


### abapdescribe_list.htm

---
title: "DESCRIBE LIST"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm) Syntax DESCRIBE LIST  NUMBER OF  LINESPAGES n  LINE linno PAGE page  PAGE pagno page_properties(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list.htm"
abapFile: "abapdescribe_list.htm"
keywords: ["select", "insert", "do", "if", "class", "data", "abapdescribe", "list"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Processing Lists in the List Buffer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_complex.htm) → 

DESCRIBE LIST

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm)

Syntax

DESCRIBE LIST *{* *{*NUMBER OF  *{*LINES*|*PAGES*}* n*}*
              *|* *{*LINE linno PAGE page*}*
              *|* *{*PAGE pagno [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm)*}* *}*
              *\[*INDEX idx*\]*.

Alternatives:

[1\. ... NUMBER OF *{*LINES*|*PAGES*}* n](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LINE linno PAGE page](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... PAGE pagno page\_properties](#!ABAP_ALTERNATIVE_3@3@)

Addition:

[... INDEX idx](#!ABAP_ONE_ADD@1@)

Effect

This statement assigns the properties of a list stored in a list buffer to the variables n, page, or the variables specified in [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm).

System Fields

sy-subrc

Meaning

0

The list property was successfully specified.

4

The line specified in linno or page specified in pagno cannot be found.

8

The list level specified in idx cannot be found.

Note

The statement DESCRIBE LIST should only be used for completed lists, because not all properties of a list can be read when it is being created.

Addition

... INDEX idx

Effect

The list level can be specified with the addition INDEX, where idx expects a data object (which contains the list index) of type i. The value of idx must be greater than or equal to 0. If the addition INDEX is not specified, the list level 0 (the basic list itself) is selected when the basic list is created and the list level at which the event was raised (sy-listi) is selected when a list event is processed. If the list level specified in idx does not exist, the variables are not changed and sy-subrc is set to the value 8.

Alternative 1

... NUMBER OF *{*LINES*|*PAGES*}* n

Effect

If specified, LINES expects the number of lines, PAGES expects the number of pages in the list saved in n. n expects a data object of the type i. The number of lines is counted from the first to the last line described by an output statement and contains the page headers and page footers. The empty lines inserted automatically between the list pages are not counted.

Alternative 2

... LINE linno PAGE page

Effect

The corresponding page for the line number specified in linno is determined and stored in page. linno and page expect data objects of the type i. If the line specified in linno does not exist, page is not changed and sy-subrc is set to 4. The page headers and page footers are included in the line count, but not the empty lines inserted automatically between the list pages.

Alternative 3

... PAGE pagno page\_properties

Effect

Various properties [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm) for the page number specified in pagno are determined and passed to the specified variables. At least one addition must be specified after pagno. pagno expects the data type i. If the page specified in pagno does not exist, the variables are not changed and sy-subrc is set to the value 4.

Example

Determines some properties of the last page of the list currently displayed using two DESCRIBE statements in a list event.

DATA: last\_page  TYPE i,
      lines      TYPE i,
      first\_line TYPE i,
      top\_lines  TYPE i.
...
AT LINE-SELECTION.
  DESCRIBE LIST: NUMBER OF PAGES last\_page,
                 PAGE last\_page LINES lines
                                FIRST-LINE first\_line
                                TOP-LINES  top\_lines.

Continue
[DESCRIBE LIST - page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm)


### abapdescribe_list_page_properties.htm

---
title: "Syntax"
description: |
  ... LINE-SIZE width LINE-COUNT page_lines LINES lines FIRST-LINE first_line TOP-LINES top_lines TITLE-LINES title_lines HEAD-LINES header_lines END-LINES footer_lines ... Extras: 1. ... LINE-SIZE width(#!ABAP_ADDITION_1@1@) 2
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm"
abapFile: "abapdescribe_list_page_properties.htm"
keywords: ["insert", "do", "try", "class", "data", "abapdescribe", "list", "page", "properties"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Processing Lists in the List Buffer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_complex.htm) →  [DESCRIBE LIST](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list.htm) → 

DESCRIBE LIST - page\_properties

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm)

Syntax

... *\[*LINE-SIZE width*\]*
    *\[*LINE-COUNT page\_lines*\]*
    *\[*LINES lines*\]*
    *\[*FIRST-LINE first\_line*\]*
    *\[*TOP-LINES top\_lines*\]*
    *\[*TITLE-LINES title\_lines*\]*
    *\[*HEAD-LINES header\_lines*\]*
    *\[*END-LINES footer\_lines*\]* ...

Extras:

[1\. ... LINE-SIZE width](#!ABAP_ADDITION_1@1@)
[2\. ... LINE-COUNT page\_lines](#!ABAP_ADDITION_2@2@)
[3\. ... LINES lines](#!ABAP_ADDITION_3@3@)
[4\. ... FIRST-LINE first\_line](#!ABAP_ADDITION_4@4@)
[5\. ... TOP-LINES top\_lines](#!ABAP_ADDITION_5@5@)
[6\. ... TITLE-LINES title\_lines](#!ABAP_ADDITION_6@6@)
[7\. ... HEAD-LINES header\_lines](#!ABAP_ADDITION_7@7@)
[8\. ... END-LINES footer\_lines](#!ABAP_ADDITION_8@8@)

Effect

Determines the properties of pages using DESCRIBE LIST. The data type i is expected for all target fields.

Addition 1

... LINE-SIZE width

Effect

Inserts the line length of the page defined using the addition LINE-SIZE of the statement at the start of the program or of [NEW-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page.htm) after width.

Addition 2

... LINE-COUNT page\_lines

Effect

Inserts the page length defined using the addition LINE-COUNT of the statement at the start of the program or of NEW-PAGE after page\_lines.

Addition 3

... LINES lines

Effect

Inserts the number of lines shown on the page including the [page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") and [page footer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") after lines.

Addition 4

... FIRST-LINE first\_line

Effect

Inserts the line number of the first line of the page, with respect to the whole list, after first\_line. The [page headers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") and [page footers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") are included in the line count, but not the empty lines inserted automatically between the list pages.

Addition 5

... TOP-LINES top\_lines

Effect

Inserts the number of lines of the [page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") of the page after top\_lines. The standard page header and the lines shown by the event TOP-OF-PAGE are included in the count.

Addition 6

... TITLE-LINES title\_lines

Effect

Inserts the number of lines of the standard title of the [standard page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_page_header_glosry.htm "Glossary Entry") of the page after title\_lines.

Addition 7

... HEAD-LINES header\_lines

Effect

Inserts the number of lines of the column headers of the [standard page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_page_header_glosry.htm "Glossary Entry") of the page after header\_lines.

Addition 8

... END-LINES footer\_lines

Effect

Inserts the number of lines reserved by the addition LINE-COUNT of the statement at the start of the program for the [page footer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") after footer\_lines.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Processing Lists in the List Buffer / DESCRIBE LIST

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Processing Lists in the List Buffer / DESCRIBE LIST

Included pages: 2


### abapdescribe_list.htm

---
title: "DESCRIBE LIST"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm) Syntax DESCRIBE LIST  NUMBER OF  LINESPAGES n  LINE linno PAGE page  PAGE pagno page_properties(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list.htm"
abapFile: "abapdescribe_list.htm"
keywords: ["select", "insert", "do", "if", "class", "data", "abapdescribe", "list"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Processing Lists in the List Buffer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_complex.htm) → 

DESCRIBE LIST

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm)

Syntax

DESCRIBE LIST *{* *{*NUMBER OF  *{*LINES*|*PAGES*}* n*}*
              *|* *{*LINE linno PAGE page*}*
              *|* *{*PAGE pagno [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm)*}* *}*
              *\[*INDEX idx*\]*.

Alternatives:

[1\. ... NUMBER OF *{*LINES*|*PAGES*}* n](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... LINE linno PAGE page](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... PAGE pagno page\_properties](#!ABAP_ALTERNATIVE_3@3@)

Addition:

[... INDEX idx](#!ABAP_ONE_ADD@1@)

Effect

This statement assigns the properties of a list stored in a list buffer to the variables n, page, or the variables specified in [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm).

System Fields

sy-subrc

Meaning

0

The list property was successfully specified.

4

The line specified in linno or page specified in pagno cannot be found.

8

The list level specified in idx cannot be found.

Note

The statement DESCRIBE LIST should only be used for completed lists, because not all properties of a list can be read when it is being created.

Addition

... INDEX idx

Effect

The list level can be specified with the addition INDEX, where idx expects a data object (which contains the list index) of type i. The value of idx must be greater than or equal to 0. If the addition INDEX is not specified, the list level 0 (the basic list itself) is selected when the basic list is created and the list level at which the event was raised (sy-listi) is selected when a list event is processed. If the list level specified in idx does not exist, the variables are not changed and sy-subrc is set to the value 8.

Alternative 1

... NUMBER OF *{*LINES*|*PAGES*}* n

Effect

If specified, LINES expects the number of lines, PAGES expects the number of pages in the list saved in n. n expects a data object of the type i. The number of lines is counted from the first to the last line described by an output statement and contains the page headers and page footers. The empty lines inserted automatically between the list pages are not counted.

Alternative 2

... LINE linno PAGE page

Effect

The corresponding page for the line number specified in linno is determined and stored in page. linno and page expect data objects of the type i. If the line specified in linno does not exist, page is not changed and sy-subrc is set to 4. The page headers and page footers are included in the line count, but not the empty lines inserted automatically between the list pages.

Alternative 3

... PAGE pagno page\_properties

Effect

Various properties [page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm) for the page number specified in pagno are determined and passed to the specified variables. At least one addition must be specified after pagno. pagno expects the data type i. If the page specified in pagno does not exist, the variables are not changed and sy-subrc is set to the value 4.

Example

Determines some properties of the last page of the list currently displayed using two DESCRIBE statements in a list event.

DATA: last\_page  TYPE i,
      lines      TYPE i,
      first\_line TYPE i,
      top\_lines  TYPE i.
...
AT LINE-SELECTION.
  DESCRIBE LIST: NUMBER OF PAGES last\_page,
                 PAGE last\_page LINES lines
                                FIRST-LINE first\_line
                                TOP-LINES  top\_lines.

Continue
[DESCRIBE LIST - page\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm)


### abapdescribe_list_page_properties.htm

---
title: "Syntax"
description: |
  ... LINE-SIZE width LINE-COUNT page_lines LINES lines FIRST-LINE first_line TOP-LINES top_lines TITLE-LINES title_lines HEAD-LINES header_lines END-LINES footer_lines ... Extras: 1. ... LINE-SIZE width(#!ABAP_ADDITION_1@1@) 2
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_page_properties.htm"
abapFile: "abapdescribe_list_page_properties.htm"
keywords: ["insert", "do", "try", "class", "data", "abapdescribe", "list", "page", "properties"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Processing Lists in the List Buffer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_complex.htm) →  [DESCRIBE LIST](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list.htm) → 

DESCRIBE LIST - page\_properties

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdescribe_list_shortref.htm)

Syntax

... *\[*LINE-SIZE width*\]*
    *\[*LINE-COUNT page\_lines*\]*
    *\[*LINES lines*\]*
    *\[*FIRST-LINE first\_line*\]*
    *\[*TOP-LINES top\_lines*\]*
    *\[*TITLE-LINES title\_lines*\]*
    *\[*HEAD-LINES header\_lines*\]*
    *\[*END-LINES footer\_lines*\]* ...

Extras:

[1\. ... LINE-SIZE width](#!ABAP_ADDITION_1@1@)
[2\. ... LINE-COUNT page\_lines](#!ABAP_ADDITION_2@2@)
[3\. ... LINES lines](#!ABAP_ADDITION_3@3@)
[4\. ... FIRST-LINE first\_line](#!ABAP_ADDITION_4@4@)
[5\. ... TOP-LINES top\_lines](#!ABAP_ADDITION_5@5@)
[6\. ... TITLE-LINES title\_lines](#!ABAP_ADDITION_6@6@)
[7\. ... HEAD-LINES header\_lines](#!ABAP_ADDITION_7@7@)
[8\. ... END-LINES footer\_lines](#!ABAP_ADDITION_8@8@)

Effect

Determines the properties of pages using DESCRIBE LIST. The data type i is expected for all target fields.

Addition 1

... LINE-SIZE width

Effect

Inserts the line length of the page defined using the addition LINE-SIZE of the statement at the start of the program or of [NEW-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page.htm) after width.

Addition 2

... LINE-COUNT page\_lines

Effect

Inserts the page length defined using the addition LINE-COUNT of the statement at the start of the program or of NEW-PAGE after page\_lines.

Addition 3

... LINES lines

Effect

Inserts the number of lines shown on the page including the [page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") and [page footer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") after lines.

Addition 4

... FIRST-LINE first\_line

Effect

Inserts the line number of the first line of the page, with respect to the whole list, after first\_line. The [page headers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") and [page footers](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") are included in the line count, but not the empty lines inserted automatically between the list pages.

Addition 5

... TOP-LINES top\_lines

Effect

Inserts the number of lines of the [page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") of the page after top\_lines. The standard page header and the lines shown by the event TOP-OF-PAGE are included in the count.

Addition 6

... TITLE-LINES title\_lines

Effect

Inserts the number of lines of the standard title of the [standard page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_page_header_glosry.htm "Glossary Entry") of the page after title\_lines.

Addition 7

... HEAD-LINES header\_lines

Effect

Inserts the number of lines of the column headers of the [standard page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_page_header_glosry.htm "Glossary Entry") of the page after header\_lines.

Addition 8

... END-LINES footer\_lines

Effect

Inserts the number of lines reserved by the addition LINE-COUNT of the statement at the start of the program for the [page footer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") after footer\_lines.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Displaying Lists / LEAVE TO LIST-PROCESSING

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Displaying Lists / LEAVE TO LIST-PROCESSING

Included pages: 2


### abapleave_to_list-processing.htm

---
title: "LEAVE TO LIST-PROCESSING"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapleave_to_list-process_shortref.htm) Syntax LEAVE TO LIST-PROCESSING AND RETURN TO SCREEN dynnr. Addition: ... AND RETURN TO SCREEN dynnr(#!ABAP_ONE_ADD@1@) Effect This statement can be executed during PBO(ht
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapleave_to_list-processing.htm"
abapFile: "abapleave_to_list-processing.htm"
keywords: ["select", "do", "while", "if", "case", "try", "class", "data", "abapleave", "list", "processing"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Displaying Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlists_displayed.htm) → 

LEAVE TO LIST-PROCESSING

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapleave_to_list-process_shortref.htm)

Syntax

LEAVE TO LIST-PROCESSING *\[*AND RETURN TO SCREEN dynnr*\]*.

Addition:

[... AND RETURN TO SCREEN dynnr](#!ABAP_ONE_ADD@1@)

Effect

This statement can be executed during [PBO](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpbo_glosry.htm "Glossary Entry") and [PAI](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpai_glosry.htm "Glossary Entry") processing. After the current dynpro is processed, this statement interrupts the current [dynpro sequence](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_sequence_glosry.htm "Glossary Entry"), starts the list processor, and displays the basic list. The basic list consists of any list output of all PBO and PAI modules of the dynpro sequence executed to this point. The statement is ignored in the event blocks for [reporting events](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenreporting_event_glosry.htm "Glossary Entry") and [list events](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_event_glosry.htm "Glossary Entry").

The [screen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscreen_glosry.htm "Glossary Entry") of the [list dynpro](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_dynpro_glosry.htm "Glossary Entry") of the list processor replaces the screen shown in the [popup level](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpop-up_level_glosry.htm "Glossary Entry") 0. Any modal dialog windows stacked above this are hidden while the list is being displayed. The GUI status set in the dynpro sequence is used. Any list events raised by user actions in the GUI window of the list dynpro call the event blocks of the current [main program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmain_program_glosry.htm "Glossary Entry"). Any details lists created there are displayed by the list processor in the GUI window of the basic list (unless the statement [WINDOW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwindow.htm) is used).

The user can exit the list processor or list display by selecting the functions Back, Exit, or Cancel in the display for list level 0, or by means of a program that uses the [LEAVE LIST-PROCESSING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapleave_list-processing.htm) statement. By default, the interrupted dynpro sequence resumes in both cases with the PBO processing of the dynpro in which the list processor was called.

Addition

... AND RETURN TO SCREEN dynnr

Effect

Using the addition AND RETURN TO SCREEN, another dynpro can be specified in dynnr for continuing PBO processing. dynnr expects a character-like data object that contains the number of a dynpro in the current main program.

Notes

-   If the current dynpro is displayed in a dialog box, the list processor also displays the lists in this window.
    
-   If the value 0 is specified in dynnr, the current dynpro sequence is closed after the list processor is exited.
    

Executable Example

[Calling Lists from Dynpro Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenleave_to_list_proc_abexa.htm)

Continue
![Example](exa.gif "Example") [Calling Lists from Dynpro Processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenleave_to_list_proc_abexa.htm)


### abenleave_to_list_proc_abexa.htm

---
title: "Calling Lists from Dynpro Processing"
description: |
  This example shows how to switch from dynpro processing to list processing. Source Code REPORT demo_leave_to_list_processing . TABLES demo_conn. DATA: wa_spfli TYPE spfli, flightdate TYPE sflight-fldate. CALL SCREEN 100. MODULE status_0100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODUL
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenleave_to_list_proc_abexa.htm"
abapFile: "abenleave_to_list_proc_abexa.htm"
keywords: ["select", "do", "while", "if", "case", "class", "data", "abenleave", "list", "proc", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Displaying Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlists_displayed.htm) →  [LEAVE TO LIST-PROCESSING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapleave_to_list-processing.htm) → 

Calling Lists from Dynpro Processing

This example shows how to switch from dynpro processing to list processing.

Source Code

REPORT demo\_leave\_to\_list\_processing .
TABLES demo\_conn.
DATA: wa\_spfli TYPE spfli,
      flightdate TYPE sflight-fldate.
CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command\_0100.
  CALL SCREEN 500.
  SET SCREEN 100.
ENDMODULE.
MODULE call\_list\_500 OUTPUT.
  LEAVE TO LIST-PROCESSING AND RETURN TO SCREEN 0.
  SET PF-STATUS space.
  SUPPRESS DIALOG.
  SELECT  carrid, connid, cityfrom, cityto
    FROM  spfli
    WHERE carrid = @demo\_conn-carrid
    INTO  CORRESPONDING FIELDS OF @wa\_spfli.
    WRITE: / wa\_spfli-carrid, wa\_spfli-connid,
             wa\_spfli-cityfrom, wa\_spfli-cityto.
    HIDE: wa\_spfli-carrid, wa\_spfli-connid.
  ENDSELECT.
  CLEAR wa\_spfli-carrid.
ENDMODULE.
TOP-OF-PAGE.
  WRITE text-001 COLOR COL\_HEADING.
  ULINE.
TOP-OF-PAGE DURING LINE-SELECTION.
  WRITE sy-lisel COLOR COL\_HEADING.
  ULINE.
AT LINE-SELECTION.
  CHECK NOT wa\_spfli-carrid IS INITIAL.
  SELECT  fldate
    FROM  sflight
    WHERE carrid = @wa\_spfli-carrid AND
          connid = @wa\_spfli-connid
    INTO  @flightdate.
    WRITE / flightdate.
  ENDSELECT.
  CLEAR wa\_spfli-carrid.

Description

This example switches to list processing while processing dynpro 100. The screen layout of dynpro 100 has a single input field, the component CARRID of the structure SDYN\_CONN from ABAP Dictionary. The flow logic of dynpro 100 is:

PROCESS BEFORE OUTPUT.
  MODULE status\_0100.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE user\_command\_0100.

In the PAI module user\_command\_0100, CALL SCREEN is used to call dynpro 500. Dynpro 500 encapsulates a basic list. It has the following flow logic:

PROCESS BEFORE OUTPUT.
  MODULE call\_list\_500.
PROCESS AFTER INPUT.

The module call\_list\_500 defines the basic list and switches to list processing. After returning from the list display, the system branches to the next dynpro 0, which means that dynpro 500 represents a dynpro sequence with only one dynpro. When list processing is complete, the system goes back to a point after the call point in user\_command\_0100.

If the user selects a line on the basic list, a details list appears. This is done using the event block AT LINE-SELECTION. The program also contains event blocks for TOP-OF-PAGE and TOP-OF-PAGE DURING LINE-SELECTION, which define page headers for both the basic list and details list.

Since there is only one list system in this program, there is no need for case distinctions within the list events.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Displaying Lists / WINDOW

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Displaying Lists / WINDOW

Included pages: 2


### abapwindow.htm

---
title: "WINDOW"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwindow_shortref.htm) Syntax WINDOW STARTING AT col1 lin1 ENDING  AT col2 lin2. Effect This statement initiates the display of the current details list in a dialog box. It only works in the event blocks for an in
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwindow.htm"
abapFile: "abapwindow.htm"
keywords: ["select", "do", "if", "try", "class", "data", "abapwindow"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Displaying Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlists_displayed.htm) → 

WINDOW

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwindow_shortref.htm)

Syntax

WINDOW STARTING AT col1 lin1
       *\[*ENDING  AT col2 lin2*\]*.

Effect

This statement initiates the display of the current details list in a dialog box. It only works in the event blocks for an interactive list event. If there are multiple WINDOW statements in an event block, the last one is valid.

The upper left corner is determined for the column and the row by the values in col1 and lin1. The values are based on the GUI window of the basic list. The lower right corner is set automatically. The maximum lower right corner can either be specified in col2 and lin2 or is specified using the lower right corner of the GUI window where the list event took place.

col1, lin1, col2, and lin2 expect data objects of the type i. The values of all data objects should lie within the GUI window of the basic list and the values of col1 and lin1 should be less than those of col2 and lin2. If not, the behavior is undefined.

If no GUI status is set using [SET PF-STATUS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_pf-status_list.htm) and an event block is defined using [AT LINE-SELECTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm) or [AT PFnn](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_pfnn.htm), the system automatically uses a [standard list status](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_list_status_glosry.htm "Glossary Entry") suitable for the dialog box without a [menu bar](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmenu_bar_glosry.htm "Glossary Entry") and [system toolbar](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_toolbar_glosry.htm "Glossary Entry"). This includes pushbuttons for the predefined function codes "PICK" (only for AT LINE-SELECTION), "PRI", "%SC", "%SC+", and "RW" in the [application toolbar](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_toolbar_glosry.htm "Glossary Entry").

Note

If a GUI status is set using SET PF-STATUS, this should be created in [Menu Painter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmenu_painter_glosry.htm "Glossary Entry") as a dialog box status; the list template should also be included.

Example

Displays the details of an airline in a dialog box after a row is selected.

DATA: scarr\_wa TYPE scarr,
      col      TYPE i,
      lin      TYPE i.
START-OF-SELECTION.
   SELECT carrid
          FROM scarr
          INTO scarr\_wa-carrid.
    WRITE / scarr\_wa-carrid.
    HIDE  scarr\_wa-carrid.
  ENDSELECT.
  CLEAR scarr\_wa-carrid.
AT LINE-SELECTION.
  col = sy-cucol + 40.
  lin = sy-curow + 2.
  WINDOW STARTING AT sy-cucol sy-curow
         ENDING   AT col lin.
  IF sy-lsind = 1 AND
     scarr\_wa-carrid IS NOT INITIAL.
    SELECT SINGLE carrname, url
           FROM scarr
           WHERE carrid = @scarr\_wa-carrid
           INTO (@scarr\_wa-carrname, @scarr\_wa-url).
    WRITE: scarr\_wa-carrname, / scarr\_wa-url.
  ENDIF.

Continue
![Example](exa.gif "Example") [Lists, Dialog Boxes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_window_abexa.htm)


### abenlist_window_abexa.htm

---
title: "Lists, Dialog Boxes"
description: |
  The example shows how to display a details list in the dialog box. Source Code REPORT demo_list_window NO STANDARD PAGE HEADING. START-OF-SELECTION. SET PF-STATUS 'BASIC'. WRITE 'Select line for a demonstration of windows'. AT USER-COMMAND. CASE sy-ucomm. WHEN 'SELE'. IF sy-lsind = 1. SET PF-STATU
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_window_abexa.htm"
abapFile: "abenlist_window_abexa.htm"
keywords: ["select", "insert", "do", "if", "case", "class", "abenlist", "window", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Displaying Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlists_displayed.htm) →  [WINDOW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwindow.htm) → 

Lists, Dialog Boxes

The example shows how to display a details list in the dialog box.

Source Code

REPORT demo\_list\_window NO STANDARD PAGE HEADING.
START-OF-SELECTION.
  SET PF-STATUS 'BASIC'.
  WRITE 'Select line for a demonstration of windows'.
AT USER-COMMAND.
  CASE sy-ucomm.
    WHEN 'SELE'.
      IF sy-lsind = 1.
        SET PF-STATUS 'DIALOG'.
        SET TITLEBAR 'WI1'.
        WINDOW STARTING AT 5 3 ENDING AT 40 10.
        WRITE 'Select line for a second window'.
      ELSEIF sy-lsind = 2.
        SET PF-STATUS 'DIALOG' EXCLUDING 'SELE'.
        SET TITLEBAR 'WI2'.
        WINDOW STARTING AT 45 10 ENDING AT 60 12.
        WRITE 'Last window'.
      ENDIF.
  ENDCASE.

Description

This program sets status BASIC for the basic list. In the status BASIC, the default function code PICK for the key F2 is replaced by the user-defined function code SELE (text SELECT) and SELE is inserted in the application toolbar.

For this reason, SELECT, F2, and double-clicking with the mouse all raise the event AT USER-COMMAND. In the corresponding processing block, list levels 1 and 2 have the status DIALOG and appear as a dialog box. Like in the status BASIC, the default function code PICK is replaced in the status DIALOG by the function code SELE which is inserted in the application toolbar after Cancel.

Titles WI1 and WI2 are defined for the dialog boxes. In the second dialog box, the function code SELE has been disabled using the addition EXCLUDING in the statement SET PF-STATUS.

The system displays horizontal scroll bars in the dialog boxes since the list width of the dialog boxes is not adjusted and therefore corresponds to the standard width of the basic list.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Displaying Lists / GET CURSOR - List

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Displaying Lists / GET CURSOR - List

Included pages: 3


### abapget_cursor_list.htm

---
title: "GET CURSOR - List"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_shortref.htm) Syntax GET CURSOR  FIELD field  field_properties(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list_field.htm)  LINE line  line_proper
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list.htm"
abapFile: "abapget_cursor_list.htm"
keywords: ["do", "if", "class", "data", "field-symbol", "abapget", "cursor", "list"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Displaying Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlists_displayed.htm) → 

GET CURSOR - List

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_shortref.htm)

Syntax

GET CURSOR *{* *{*FIELD field *\[* [field\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list_field.htm)*\]**}*
           *|* *{*LINE line *\[* [line\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list_field.htm)*\]**}* *}*.

Variants:

[1\. GET CURSOR FIELD field *\[*field\_properties*\]*.](#!ABAP_VARIANT_1@1@)
[2\. GET CURSOR LINE line *\[*line\_properties*\]*.](#!ABAP_VARIANT_2@2@)

Effect

If this statement is specified in list processing, it passes the name of the output field or the number of the list line on which the screen cursor in the displayed list is positioned (after the user action) to the variables field or line, depending on how FIELD or LINE is specified. Further information on the cursor position can be read if required.

System Fields

sy-subrc

Meaning

0

The cursor is on a field or a list line and the statement was executed successfully.

4

The cursor is not on any field or any list line.

Variant 1

GET CURSOR FIELD field *\[*field\_properties*\]*.

Effect

Returns the name of the displayed field in field after a user action. This name is where the cursor is positioned in the currently displayed list. field expects a character-like variable. The addition [field\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list_field.htm) can be used to read further information about the cursor position.

If the screen cursor is on a subarea displayed using an [offset/length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length.htm) of a structure, the following rules apply:

-   The subarea of the structure has been displayed using the name of the structure:
    

-   If the subarea includes the entire structure, the name of the structure is returned.

-   If the subarea only includes a part of the structure, the name of the component is returned in which the subarea begins.

-   The subarea of the structure has been displayed using the name of a component of the structure:
    

-   The name of the component is returned in which the subarea begins.

These rules also apply to substructures.

The addition FIELD can only be used to determine the names of global data objects of the ABAP program. If the cursor is positioned on the output of a data object that is not visible in the current context or a literal, field is initialized. This has no influence on the other additions or on sy-subrc.

If the cursor is on the output area of a data object that was accessed in the WRITE statement using a field symbol, the name of the data object is returned and not the name of the field symbol.

Variant 2

GET CURSOR LINE line *\[*line\_properties*\]*.

Effect

Returns the number of the list line in line after a user action. This line is where the cursor is positioned in the currently displayed list. line expects a variable of type i. The addition [line\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list_line.htm) can be used to read further information about the cursor position.

Continue
[GET CURSOR - field\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list_field.htm)
[GET CURSOR - line\_properties](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list_line.htm)


### abapget_cursor_list_field.htm

---
title: "Syntax"
description: |
  ... VALUE val LENGTH len DISPLAYMEMORY OFFSET off LINE lin. Extras: 1. ... VALUE val(#!ABAP_ADDITION_1@1@) 2. ... LENGTH len(#!ABAP_ADDITION_2@2@) 3. ... DISPLAYMEMORY OFFSET off(#!ABAP_ADDITION_3@3@) 4. ... LINE lin(#!ABAP_ADDITION_4
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list_field.htm"
abapFile: "abapget_cursor_list_field.htm"
keywords: ["do", "if", "class", "data", "abapget", "cursor", "list", "field"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Displaying Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlists_displayed.htm) →  [GET CURSOR - List](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list.htm) → 

GET CURSOR - field\_properties

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_shortref.htm)

Syntax

... *\[*VALUE val*\]* *\[*LENGTH len*\]*
    *\[**\[*DISPLAY*|*MEMORY*\]* OFFSET off*\]* *\[*LINE lin*\]*.

Extras:

[1\. ... VALUE val](#!ABAP_ADDITION_1@1@)
[2\. ... LENGTH len](#!ABAP_ADDITION_2@2@)
[3\. ... *\[*DISPLAY*|*MEMORY*\]* OFFSET off](#!ABAP_ADDITION_3@3@)
[4\. ... LINE lin](#!ABAP_ADDITION_4@4@)

Effect

Using these additions, further information about the cursor position can be read during list processing with the addition FIELD of the [GET CURSOR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list.htm) statement.

Addition 1

... VALUE val

Effect

The addition VALUE assigns the formatted content of the output area on which the cursor is positioned to the data object val. val expects a character-like variable.

Addition 2

... LENGTH len

Effect

The addition LENGTH assigns the length of the output area on which the cursor is positioned to the data object len. len expects a variable of the type i.

Addition 3

... *\[*DISPLAY*|*MEMORY*\]* OFFSET off

Effect

The addition OFFSET without an addition or with the addition DISPLAY assigns the position of the cursor in the output area on which it is positioned to the data object off. off expects a variable of the type i. Counting begins at 0.

The addition OFFSET with the addition MEMORY assigns the offset of the character in the area of the data object in the list buffer (on whose output the cursor is positioned) to the data object off. If the cursor is on one of the characters < or > for characters cut off in the display, the position of the character in the list buffer that is overwritten by the character is assigned. off expects a variable of the type i.

Note

If [Subfields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenoffset_length.htm) is displayed in lists, the returned offset is counted starting from the offset of the subfield.

Addition 4

... LINE lin

Effect

The addition LINE assigns the number of the list line on which the cursor is positioned to the data object lin. lin expects a variable of the type i.


### abapget_cursor_list_line.htm

---
title: "Syntax"
description: |
  ... VALUE val LENGTH len DISPLAYMEMORY OFFSET off. Extras: 1. ... VALUE val(#!ABAP_ADDITION_1@1@) 2. ... LENGTH len(#!ABAP_ADDITION_2@2@) 3. ... DISPLAYMEMORY OFFSET off(#!ABAP_ADDITION_3@3@) Effect Using these additions, further information abo
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list_line.htm"
abapFile: "abapget_cursor_list_line.htm"
keywords: ["do", "if", "class", "data", "abapget", "cursor", "list", "line"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Displaying Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlists_displayed.htm) →  [GET CURSOR - List](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list.htm) → 

GET CURSOR - line\_properties

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_shortref.htm)

Syntax

... *\[*VALUE val*\]* *\[*LENGTH len*\]* *\[**\[*DISPLAY*|*MEMORY*\]* OFFSET off*\]*.

Extras:

[1\. ... VALUE val](#!ABAP_ADDITION_1@1@)
[2\. ... LENGTH len](#!ABAP_ADDITION_2@2@)
[3\. ... *\[*DISPLAY*|*MEMORY*\]* OFFSET off](#!ABAP_ADDITION_3@3@)

Effect

Using these additions, further information about the cursor position can be read using the addition LINE of the statement [GET CURSOR](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapget_cursor_list.htm).

Addition 1

... VALUE val

Effect

The addition VALUE assigns the formatted content of the list line on which the cursor is positioned to the data object val. val expects a character-like variable.

Addition 2

... LENGTH len

Effect

The addition LENGTH assigns the line length set using the addition LINE-SIZE of the statement introducing the program or using NEW-PAGE (this is the line on which the cursor is positioned) to the data object len. len expects a variable of the type i.

Addition 3

... *\[*DISPLAY*|*MEMORY*\]* OFFSET off

Effect

The addition OFFSET without an addition or with the addition DISPLAY assigns the position of the cursor in the displayed line on which it is positioned to the data object off. off expects a variable of the type i.

The addition OFFSET with the addition MEMORY assigns the position of the character in the list buffer line (on whose output the cursor is currently positioned) to the data object off. If the cursor is on one of the characters < or > for characters cut off in the display, the position of the character in the list buffer that is overwritten by the character is assigned. off expects a variable of the type i.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Spooling Lists / spool parameter

**Files**: 4 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Spooling Lists / spool parameter

Included pages: 4


### abenprint_parameters.htm

---
title: "Note"
description: |
  The content of the structures PRI_PARAMS and ARC_PARAMS cannot be modified directly in programs; only the function module GET_PRINT_PARAMETERS can be used for this. Spool Dialog Box(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_window.htm) Setting Program-Dri
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters.htm"
abapFile: "abenprint_parameters.htm"
keywords: ["do", "if", "try", "class", "data", "abenprint", "parameters"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Spooling Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm) → 

spool parameter

For every [spool request](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_spool.htm), spool parameters must be defined that are used to format the spool list when the list is created, and to control the request.

In the ABAP statements [NEW-PAGE PRINT ON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_print.htm) and [SUBMIT TO SAP-SPOOL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapsubmit_print_parameters.htm) the spool parameters are specified in a structure of type PRI\_PARAMS from ABAP Dictionary. Spool parameters can be enhanced by archiving parameters if the data of the spool request is to be archived using ArchiveLink. To do this, optical archiving using [ArchiveLink](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_archivelink_glosry.htm "Glossary Entry") is switched on (archiving mode 2 or 3) in the spool parameters. Archiving parameters are specified in a structure of type ARC\_PARAMS from ABAP Dictionary.

The spool parameters are specified either explicitly or implicitly. The end user can set them directly in the spool dialog box or the spool parameters can be set in the program code.

-   [Spool Dialog Box](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_window.htm)

-   [Setting Program-Driven Spool Parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_function.htm)

-   [Overview of All Spool Parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

Note

The content of the structures PRI\_PARAMS and ARC\_PARAMS cannot be modified directly in programs; only the function module GET\_PRINT\_PARAMETERS can be used for this.

Continue
[Spool Dialog Box](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_window.htm)
[Setting Program-Driven Spool Parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_function.htm)
[Overview of All Spool Parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)


### abenprint_parameters_window.htm

---
title: "Spool Dialog Box"
description: |
  The spool dialog box makes it possible to interactively determine all spool parameters and checks the input values for consistency and completeness. The call is either automatic or program controlled. -   The spool dialog box appears automatically if a user chooses Execute and Print on the selection
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_window.htm"
abapFile: "abenprint_parameters_window.htm"
keywords: ["select", "do", "if", "case", "method", "class", "abenprint", "parameters", "window"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Spooling Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm) →  [spool parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters.htm) → 

Spool Dialog Box

The spool dialog box makes it possible to interactively determine all spool parameters and checks the input values for consistency and completeness. The call is either automatic or program controlled.

-   The spool dialog box appears automatically if a user chooses Execute and Print on the selection screen, and also when [spooling screen lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_screen.htm). In these cases, the spool dialog box cannot be suppressed.

-   The GET\_PRINT\_PARAMETERS function module can be used to call the spool dialog box in a program.

When the spool dialog box is called automatically, the SET\_PRINT\_PARAMETERS function module can be used to set standard values. The SET\_PRINT\_PARAMETERS function module mainly has the same import parameters as the GET\_PRINT\_PARAMETERS function module (refer to [Overview of All Spool Parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)) and no export parameters. An additional input parameter called FOOT\_LINE is used when [spooling a screen list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_screen.htm) and defines that a footer is printed. It is only respected here.

Notes

-   Displaying the spool dialog box using GET\_PRINT\_PARAMETERS is the recommended method for program-driven spooling, and thereby decouples the dialog from the statements [NEW-PAGE PRINT ON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_print.htm) and [SUBMIT TO SAP SPOOL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapsubmit_list_options.htm). It is still possible to call the spool dialog box with the latter, however, the functions Back or Cancel cannot be processed properly.

-   The standard values for the spool dialog box must be set before sending the selection screen or list to the screen when the spool dialog box is called automatically. It is advisable to use SET\_PRINT\_PARAMETERS only at the [INITIALIZATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapinitialization.htm) event of an executable program.

-   Using SET\_PRINT\_PARAMETERS only allows the setting those spool parameters that are stored in components of the PRI\_PARAMS structure.


### abenprint_parameters_function.htm

---
title: "Setting Program-Driven Spool Parameters"
description: |
  Spool and archiving parameters can only be set in a program using the following function module: GET_PRINT_PARAMETERS. If the corresponding structures are changed directly and then the parameters in question used in NEW-PAGE PRINT ON or SUBMIT TO SAP-SPOOL, a runtime error occurs. The GET_PRINT_
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_function.htm"
abapFile: "abenprint_parameters_function.htm"
keywords: ["do", "if", "case", "class", "abenprint", "parameters", "function"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Spooling Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm) →  [spool parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters.htm) → 

Setting Program-Driven Spool Parameters

Spool and archiving parameters can only be set in a program using the following function module: GET\_PRINT\_PARAMETERS. If the corresponding structures are changed directly and then the parameters in question used in NEW-PAGE PRINT ON or SUBMIT TO SAP-SPOOL, a runtime error occurs. The GET\_PRINT\_PARAMETERS function module can be used to execute the following functions:

-   Creating a complete set of spool and archiving parameters.

-   Determining the spool parameters that are currently valid during spooling

-   Changing individual spool parameters

-   Interactive querying of the spool parameters in the spool dialog box

The interface parameters for the function module are listed in [Overview of All Spool Parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm).

The [spool dialog box](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_window.htm) is displayed by default and can be switched off using the parameter NO\_DIALOG. The values passed to the function module are used as the default values in the spool dialog box and can be overwritten there.

The function module gets all parameters that have not been set from the system, taking some values from the user master record. Dependent parameters are set automatically. If the function module is unable to generate a record with valid spool and archiving parameters, it generates an exception. The generated records are either complete or empty. The export parameter VALID (if the spool dialog box is being used) indicates whether a complete record could be created.

Notes

-   For GET\_PRINT\_PARAMETERS, the completeness of the parameter records and the run capability of the spool request are of primary importance. The function module does not carry out a complete consistency test like the spool dialog box. Consistency is only established in cases where it is significant for the run capability of the spool request. Inconsistent entries are partly ignored, partly replaced. For example:

-   The LINE\_SIZE parameter or LINE\_COUNT parameter can be used to set values that are not compatible with the LAYOUT parameter and lead to truncated output. Such inconsistencies are recognized in the spool dialog box.

-   Even if invalid values are passed to DESTINATION, it is still possible to set IMMEDIATELY to "X". The function module replaces the output device with a standard value (LP01) and initializes IMMEDIATELY. This causes the spool system to store the request using the settings that go with the default printer.

-   The GET\_PRINT\_PARAMETERS function module can be called multiple times consecutively. For example, the spool dialog box can be called at the start of a program if the user enters the basic setting. When it is called again, the parameter records created in this way can be passed collectively to the PRI\_PARAMS and ARC\_PARAMS import parameters of the function module and overwritten there. This enables the spooling of wide lists in landscape format or narrow lists in portrait format with otherwise unchanged settings.


### abenprint_parameters_overview.htm

---
title: "Overview of All Spool Parameters"
description: |
  -   Spool Parameters(#abenprint-parameters-overview-1--------archiving-parameters---@ITOC@@ABENPRINT_PARAMETERS_OVERVIEW_2) -   Control Parameters(#abenprint-parameters-overview-3--------output-parameters-of-get--print--parameters---@ITOC@@ABENPRINT_PARAMETERS_OVERVIEW_4) Spool Parameters The fo
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm"
abapFile: "abenprint_parameters_overview.htm"
keywords: ["select", "delete", "do", "if", "case", "class", "data", "abenprint", "parameters", "overview"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Spooling Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm) →  [spool parameter](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters.htm) → 

Overview of All Spool Parameters

-   [Spool Parameters](#abenprint-parameters-overview-1--------archiving-parameters---@ITOC@@ABENPRINT_PARAMETERS_OVERVIEW_2)

-   [Control Parameters](#abenprint-parameters-overview-3--------output-parameters-of-get--print--parameters---@ITOC@@ABENPRINT_PARAMETERS_OVERVIEW_4)

Spool Parameters

The following table lists all spool parameters by their associated input parameters in the function modules [GET\_PRINT\_PARAMETERS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_function.htm) and [SET\_PRINT\_PARAMETERS.](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_window.htm) The second column shows the label in the spool dialog window. The third column contains the name of the component in the structure PRI\_PARAMS whose content, however, cannot be modified directly in a program.

Input Parameter

Dialog Field

Component

Meaning

IN\_PARAMETERS

\-

\-

Full structure of type PRI\_PARAMS; any single values passed in parallel overwrite the associated component.

ARCHIVE\_MODE

Archive mode

ARMOD

If "1" print only (default), if "2" archive only, if "3" print and archive.

AUTHORITY

Authorization

PRBER

Authorization value for authorization object S\_SPO\_ACT. This can be used to check whether or not a user is allowed to carry out certain actions on the spool request.

COPIES

Number of copies

PRCOP

Number or printouts, default 1.

COVER\_PAGE

Selection cover page (if "PARAMSEL" passed to MODE)

PRBIG

If 'X', a cover page with the input values of the selection layout is printed, default " ".

DATA\_SET

\-

PRDSN

Template for the name of the spool file, default is empty.

DEFAULT\_SPOOL\_SIZE (GET\_PRINT\_PARAMETERS only)

Spool request has a width of maximum 255 characters

\-

If "X", line break forced after the 255th column, default " ".

DEPARTMENT

Department

PRABT

Department name for the SAP cover page, default taken from user address.

DESTINATION

Output device

PDEST

Name of a printer or fax machine, default taken from user master data.

DRAFT (GET\_PRINT\_PARAMETERS only)

Text only

\-

If "X" only text is printed, default is " ".

EXPIRATION

Retention period

PEXPI

Number of days for which the spool request is retained by the spool system, default is 8.

FOOT\_LINE (SET\_PRINT\_PARAMETERS only)

\-

FOOTL

If "X" footer printed (only if spooling screen lists) whose content can be modified in the spool dialog window under Parameters, default is empty.

HOST\_COVERPAGE

OS cover page

PRUNX

If "X" the operating system cover page is printed, default is " ".

IMMEDIATELY

Time of printing

PRIMM

If "X" the spool request is sent immediately, if "A" the spool request is printed at a later time (only for non-front-end printers), if " " the spool request must be printed manually, default taken from user master data.

LAYOUT

Formatting

PAART

Page format, depending on the output device, different formats with different maximum page lengths and widths can be specified, default defined internally.

LINE\_COUNT

Lines (subproperty of Formatting)

LINCT

Number of lines per page, works like the addition LINE-COUNT in an introductory statement, 0 (unlimited number of lines) is not possible, the maximum number depends on LAYOUT, default defined internally. Overwritten by REPORT if the value "BATCH" is passed for MODE.

LINE\_SIZE

Columns (subproperty of Formatting)

LINSZ

Characters per list line, works like the addition LINE-SIZE in an introductory statement, maximum depends on LAYOUT, default defined internally. Overwritten by REPORT if the value "BATCH" is passed for MODE.

LIST\_NAME

Name

PLIST

The name of the spool request if not printed immediately, default is a combination of the start of the program name from the parameter REPORT and the user name

LIST\_TEXT

Title

PRTXT

Description text for the spool request, appears on the default cover page and is displayed in the output controller instead of LIST\_NAME, default is empty.

NEW\_LIST\_ID

New spool request

PRNEW

If "X" (default) a new spool request is created, otherwise the system attempts to attach the spool request to an existing request, works only if LIST\_NAME, DESTINATION, COPIES, and LAYOUT match and PROTECT\_LIST is empty.

NO\_FRAMES (GET\_PRINT\_PARAMETERS only)

No frame characters

\-

If "X" no frame characters are printed, default is " ".

PRIORITY

Print priority

PRIOT

"1" (high) to "9" (low), default is "1".

PROTECT\_LIST (GET\_PRINT\_PARAMETERS only)

Protection from attachments

\-

If "X" no further requests can be attached to the spool request, default is " ".

RECEIVER

Receiver

PRREC

Receiver name for the SAP cover page, default taken from user address.

RELEASE

Delete immediately after printing

PRREL

If "X" spool request is deleted immediately after printing, otherwise after EXPIRATION, default taken from user master data.

REPORT (GET\_PRINT\_PARAMETERS only)

\-

\-

If MODE is the same as "BATCH", the name of the program to be started must be entered in REPORT. The list rows per page (LINE\_COUNT) and the characters per list row (LINE\_SIZE) are then taken from the introductory program statement of the specified program. Still the default for the first part of the name of the spool request overwritten by LIST\_NAME (the default for this is sy-repid).

SAP\_COVER\_PAGE

SAP cover sheet

PRSAP

If "X" a standard cover page with standard information is created, if "D" (default) the cover page printed depends on the settings of the printer, if " " no cover page is created.

SUPPRESS\_SHADING (GET\_PRINT\_PARAMETERS only)

Colors/shading suppressed in the printout

\-

If "X" colors/shading are suppressed in the printout, default is " ".

TYPE

\-

PTYPE

Type of the spool request.

UC\_DISPLAY\_MODE (GET\_PRINT\_PARAMETERS only)

Character format

\-

Unicode spool output, if "1" characters are printed with the output length one, if "2" all characters are printed in their own output lengths, if "3" all characters are printed with the length two.

WITH\_STRUCTURE (GET\_PRINT\_PARAMETERS only)

Spool list with structure information

\-

If "X" structure information is also printed (for ACC and RTL output), default is " ".

\-

Print All, Print from Page ... to

\-

Restricts the number of pages printed, default is Print All.

Notes

-   The input parameters of GET\_PRINT\_PARAMETERS that do not have a component in the structure PRI\_PARAMS are not passed to a spool request explicitly during NEW-PAGE PRINT ON and SUBMIT TO SAP-SPOOL and are defined internally by the function module instead.

-   Using SET\_PRINT\_PARAMETERS only allows the setting those spool parameters that are stored in components of the PRI\_PARAMS structure.

-   The spool parameters LINE\_COUNT and LINE\_SIZE do not overwrite the additions LINE-COUNT and LINE-SIZE of the introductory statement of a program specified using REPORT if the value "BATCH" is passed to the parameter MODE. In this case, the corresponding input fields in the spool dialog box are not ready for input. If these values exceed the maximum values defined by LAYOUT, the list cannot be spooled.

-   The values of the components of the structure PRI\_PARAMS are usually intended for internal use only and do not always match the values specified directly, such as in the addition LINE-SIZE.

Archiving Parameters

The following table lists all archiving parameters by their associated input parameters in the function modules GET\_PRINT\_PARAMETERS and SET\_PRINT\_PARAMETERS. The second column shows the label in the spool dialog window. The third column contains the name of the component in the structure ARC\_PARAMS whose content, however, cannot be modified directly in a program.

Input Parameter

Dialog Field

Component

Meaning

IN\_ARCHIVE\_PARAMETERS

\-

\-

Full structure of type ARC\_PARAMS, any single values passed in parallel overwrite the associated component.

AR\_OBJECT

Document type

AR\_OBJECT

Document type of the archiving object.

ARCHIVE\_ID

\-

ARCHIVE\_ID

Target archive of the archiving request.

ARCHIVE\_INFO

Information

INFO

Information ID for the archiving request.

ARCHIVE\_TEXT

Text

ARCTEXT

Description text of the archiving request.

SAP\_OBJECT

Object type

SAP\_OBJECT

Object type of the SAP object.

Notes

-   Requests can be archived only if these parameters are specified consistently and in full. Archiving works across all applications. With the exception of certain basic settings, no other actions are required. If spool lists need to be saved specific to an application, some special actions must be taken. For more information, see the ArchiveLink documentation on [SAP Help Portal](http://help.sap.com).

-   When archiving long lists, it may be useful to write index information to the list using [PRINT-CONTROL INDEX-LINE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprint-control.htm). This makes it easier to search the archived list at a later date.

Control Parameters

The following table lists the control parameters of the function module GET\_PRINT\_PARAMETERS.

Input Parameter

Meaning

MODE

Possible values "BATCH", "CURRENT", "DEFVALS", "DISPLAY", "PARAMS", "PARAMSEL" (see below)

NO\_DIALOG

If "X" no spool dialog window is displayed

The following table shows the values that can be passed to MODE.

MODE

Effect

"BATCH"

The function module gets spool parameters for a background request. The executable program to be started must be specified in the import parameter REPORT. If this executable program contains the additions LINE-COUNT or LINE-SIZE in the REPORT statement, they are used as non-modifiable values in the spool dialog window. The function Save is displayed on the spool dialog window instead of Print.

"CURRENT"

The function module is used to determine the current spool parameters after spooling has been activated. If nothing is being spooled, the default values are used.

"DEFVALS"

Always gets the default values.

"DISPLAY"

The spool parameters are displayed in the spool dialog box but cannot be changed.

"PARAMS"

Standard setting, the user can choose Print or Cancel on the spool dialog window.

"PARAMSEL"

Like "PARAMS", however the additional checkbox Selection Cover Page appears on the spool dialog window.

Output Parameters of GET\_PRINT\_PARAMETERS

The following table lists the output parameters of the function module GET\_PRINT\_PARAMETERS.

Output Parameter

Meaning

OUT\_PARAMETERS

Set of spool parameters in a structure of the type PRI\_PARAMS. Either complete or empty-

OUT\_ARCHIVE\_PARAMETERS

Set of archiving parameters in a structure of the type ARC\_PARAMS. Either complete or empty.

VALID

If "X", all spool parameters or archiving parameters are present and printing or archiving is possible. If " ", the structures are empty and printing or archiving is not possible. VALID is " " if Cancel is used to exit the spool dialog window.

VALID\_FOR\_SPOOL\_CREATION

If "X", enough spool parameters are available to create a spool request. There is no guarantee, however, that this request can be printed or archived. If " ", the structures are empty and a spool request cannot be created. This is different from VALID only if the spool dialog box is not displayed. If the spool dialog box is displayed, VALID\_FOR\_SPOOL\_CREATION is filled just like VALID.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Spooling Lists / Spool Control

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Spooling Lists / Spool Control

Included pages: 3


### abenprint_control.htm

---
title: "Spool Control"
description: |
  Configuring the Upper and Left Margins The statement SET MARGIN(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_margin.htm) can be used to define the upper and left margins of a spool list. Archiving Information in Spool Lists When spooling is active, the statement PRINT-CONTRO
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_control.htm"
abapFile: "abenprint_control.htm"
keywords: ["do", "class", "abenprint", "control"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Spooling Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm) → 

Spool Control

Configuring the Upper and Left Margins

The statement [SET MARGIN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_margin.htm) can be used to define the upper and left margins of a spool list.

Archiving Information in Spool Lists

When spooling is active, the statement [PRINT-CONTROL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprint-control.htm) can be used to write formatting information for optical archiving to the spool system.

Obsolete Formatting of Spool Lists

When spooling is active, an [obsolete variant](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprint-control_obsolete.htm) of the statement PRINT-CONTROL can be used to write control statements for output devices (printers) to the spool system.

Continue
[SET MARGIN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_margin.htm)
[PRINT-CONTROL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprint-control.htm)


### abapset_margin.htm

---
title: "SET MARGIN"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_margin_shortref.htm) Syntax SET MARGIN macol marow. Effect This statement defines the left margin of a spool list as the columns specified in macol, and the upper margin as the rows specified in marow, and s
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_margin.htm"
abapFile: "abapset_margin.htm"
keywords: ["select", "insert", "do", "while", "if", "try", "class", "data", "abapset", "margin"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Spooling Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm) →  [Spool Control](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_control.htm) → 

SET MARGIN

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_margin_shortref.htm)

Syntax

SET MARGIN macol *\[*marow*\]*.

Effect

This statement defines the left margin of a spool list as the columns specified in macol, and the upper margin as the rows specified in marow, and sets the system fields sy-macol and sy-marow to these values. macol and marow expect data objects with the type i, with values within the current page width and page length. If macol or marow contain invalid values, the associated operand is ignored.

The set values apply to the current page and all subsequent pages until the next SET MARGIN statement. If more than one SET MARGIN statement is specified on a page, the last one is used.

SET MARGIN is ignored when screen lists are displayed. The set margins are only inserted in the list as blanks or empty lines if a list page is sent to the SAP spool system. This applies to spool lists created using [NEW-PAGE PRINT ON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_print.htm), [SUBMIT TO SAP-SPOOL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapsubmit_list_options.htm), and by the selection of Execute and Print on the [selection screen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselection_screen_glosry.htm "Glossary Entry"). SET MARGIN also applies if a screen list is spooled while it is being displayed, when Print (function code "PRI") is selected.

Note

For printers with an active list driver, margins can be defined in millimeters in the spool dialog. When pages are sent from the spool system to the printer, the pages, including the margins set using SET MARGIN, are positioned within these margins.


### abapprint-control.htm

---
title: "PRINT-CONTROL"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprint-control_shortref.htm) Syntax PRINT-CONTROL INDEX-LINE index_line. Effect In spool lists, this statement creates index entries for optical archiving using ArchiveLink(https://help.sap.com/doc/abapdocu_754_index_
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprint-control.htm"
abapFile: "abapprint-control.htm"
keywords: ["select", "insert", "do", "if", "try", "class", "data", "abapprint", "control"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Spooling Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint.htm) →  [Spool Control](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_control.htm) → 

PRINT-CONTROL

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapprint-control_shortref.htm)

Syntax

PRINT-CONTROL INDEX-LINE index\_line.

Effect

In spool lists, this statement creates index entries for optical archiving using [ArchiveLink](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_archivelink_glosry.htm "Glossary Entry"). This applies only to spool lists created using [NEW-PAGE PRINT ON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_print.htm), [SUBMIT TO SAP-SPOOL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapsubmit_list_options.htm), and when selecting Execute and Print on the [selection screen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselection_screen_glosry.htm "Glossary Entry"). It does not work for screen lists spooled from the display by selecting Print (function code "PRI").

This statement inserts the content of the data object index\_line into the current spool list as an index line. Index\_line must be a flat character-like data object. If the [list cursor](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_cursor_glosry.htm "Glossary Entry") of an output statement has been set in the current list line, the index line is inserted after the end of the line. Index lines can be used for the following purposes:

-   As DAIN lines whose structure is defined DKEY. Here, they improve the performance of searches in archived spool lists.
    
-   As DARC lines, they enable hypertext links to other archived objects.
    

An index line is sent to the spool system as a part of the spool list and is displayed there, although not included in the print output. When a list is archived using [ArchiveLink](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_archivelink_glosry.htm "Glossary Entry"), the spool system divides it into a data file and a description file. The data file contains the actual spool lists, and the description file contains the index lines.

Note

To enable the associated ArchiveLink search function to be used when an archived spool list is displayed or for the links to work, the index lines must contain certain information. This information must follow a fixed naming convention and must be described in the [SAP Help Portal](http://help.sap.com) in the ArchiveLink documentation.

Example

Inserting index lines in a list of square numbers. After every hundredth line, index lines for archiving are created (DAIN lines) using the statement PRINT-CONTROL. The structure of the DAIN lines is defined at the start of the list in two additional index lines (DKEY lines). If the user selects Execute and Print on the [selection screen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselection_screen_glosry.htm "Glossary Entry") and archives the list in the spool dialog, the archived list can be searched for the indexes. For more information, see the ArchiveLink documentation on the [SAP Help Portal](http://help.sap.com).

PARAMETERS number TYPE i.
DATA: index  TYPE i,
      square TYPE decfloat16,
      numb   TYPE i,
      num    TYPE c LENGTH 4,
      dkey   TYPE c LENGTH 100,
      dain   TYPE c LENGTH 100.
dkey ='DKEYIndex'.
dkey+44 = '0'.
dkey+47 = '3'.
PRINT-CONTROL INDEX-LINE dkey.
CLEAR dkey.
dkey ='DKEYNumber'.
dkey+44 = '3'.
dkey+47 = '4'.
PRINT-CONTROL INDEX-LINE dkey.
index = 0.
DO number TIMES.
  index += 1.
  IF index = 100.
    numb = sy-index / 100.
    WRITE numb TO num LEFT-JUSTIFIED.
    dain = 'DAIN' && 'IDX' && num.
    PRINT-CONTROL INDEX-LINE dain.
    index = 0.
  ENDIF.
  square = sy-index \*\* 2.
  WRITE: / sy-index, square STYLE cl\_abap\_math=>scientific.
ENDDO.


---


## ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Event Blocks for Lists

**Files**: 10 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / SAP GUI User Dialogs / Classic Lists / Event Blocks for Lists

Included pages: 10


### abenabap_lists_interactive.htm

---
title: "Event Blocks for Lists"
description: |
  List events appear during the creation of a list, and following certain user actions on a displayed list. They used to process lists in the ABAP program. We differentiate between events during list creation, and interactive list events for processing user actions in a displayed list. The events duri
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_interactive.htm"
abapFile: "abenabap_lists_interactive.htm"
keywords: ["select", "do", "if", "class", "abenabap", "lists", "interactive"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) → 

Event Blocks for Lists

List events appear during the creation of a list, and following certain user actions on a displayed list. They used to process lists in the ABAP program. We differentiate between events during list creation, and interactive list events for processing user actions in a displayed list.

The events during list creation,

-   [TOP-OF-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page.htm)

-   [END-OF-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapend-of-page.htm)

make it possible to define page headers and footers independently of the actual page length, which is particularly helpful for the output of spool lists on different paper formats.

The events following user actions on displayed lists,

-   [AT LINE-SELECTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm)

-   [AT USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm)

-   [AT PFnn](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_pfnn.htm)

, enable you to create details lists.

The following statement can be used to trigger a list-event in a program-controlled manner:

-   [SET USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_user-command.htm)

Notes

-   After the execution of each event block for lists, the statement [NEW-LINE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-line.htm) is executed implicitly as in every [event block](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenevent_blocks.htm).

-   List events can be raised as program-driven events using the statement [SET USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_user-command.htm), instead of by user action on a displayed list.

Continue
[TOP-OF-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page.htm)
[END-OF-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapend-of-page.htm)
[AT list\_event](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_list_event.htm)
[SET USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_user-command.htm)


### abaptop-of-page.htm

---
title: "TOP-OF-PAGE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page_shortref.htm) Syntax TOP-OF-PAGE DURING LINE-SELECTION. Addition: ... DURING LINE-SELECTION(#!ABAP_ONE_ADD@1@) Effect This statement defines an event block whose event is raised by the ABAP runtim
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page.htm"
abapFile: "abaptop-of-page.htm"
keywords: ["select", "do", "if", "try", "class", "abaptop", "page"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Event Blocks for Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_interactive.htm) → 

TOP-OF-PAGE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page_shortref.htm)

Syntax

TOP-OF-PAGE *\[*DURING LINE-SELECTION*\]*.

Addition:

[... DURING LINE-SELECTION](#!ABAP_ONE_ADD@1@)

Effect

This statement defines an event block whose event is raised by the [ABAP runtime environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_runtime_envir_glosry.htm "Glossary Entry") when a list is created. This occurs when a new page begins (that is, immediately before the first line on a new page is produced). All list output produced in the event block is placed below the standard page header of the list. It is not possible to produce lines than are available on the page within the event block. The statement [NEW-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page.htm) is ignored within this event block.

The entire output written to the list in the event block is part of the [page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") of the current list page. The top page header cannot be moved when scrolling vertically in a list displayed on the screen.

For each TOP-OF-PAGE event, the placeholders "&1" - "&9" are replaced by the content of the system fields sy-tvar0 - sy-tvar9 in the standard heading and the column headings of the standard page header when a basic list is created. Values can be assigned to these system fields in the program.

Addition

... DURING LINE-SELECTION

Effect

If no addition is specified, an event block is raised for the event TOP-OF-PAGE when a basic list is created. If the addition DURING LINE-SELECTION is specified, an event block is raised for the events in question when details lists are created. System fields like sy-lsind must be used to distinguish between the individual details lists.

Continue
![Example](exa.gif "Example") [Lists, Page Header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_top_of_page_abexa.htm)


### abenlist_top_of_page_abexa.htm

---
title: "Lists, Page Header"
description: |
  The example shows how to define the page header at the TOP-OF-PAGE event. Source Code REPORT demo_list_top_of_page NO STANDARD PAGE HEADING LINE-SIZE 80 LINE-COUNT 7. DATA: h1(10) TYPE c VALUE '    Number', h2(10) TYPE c VALUE '    Square', h3(10) TYPE c VALUE '      Cube', n1 TYPE i, n2 TYPE i,
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_top_of_page_abexa.htm"
abapFile: "abenlist_top_of_page_abexa.htm"
keywords: ["select", "do", "if", "class", "data", "abenlist", "top", "page", "abexa"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Event Blocks for Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_interactive.htm) →  [TOP-OF-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page.htm) → 

Lists, Page Header

The example shows how to define the page header at the TOP-OF-PAGE event.

Source Code

REPORT demo\_list\_top\_of\_page NO STANDARD PAGE HEADING
                             LINE-SIZE 80 LINE-COUNT 7.
DATA: h1(10) TYPE c VALUE '    Number',
      h2(10) TYPE c VALUE '    Square',
      h3(10) TYPE c VALUE '      Cube',
      n1 TYPE i, n2 TYPE i, n3 TYPE i,
      x TYPE i.
TOP-OF-PAGE.
  x = sy-colno + 8.  POSITION x. WRITE h1.
  x = sy-colno + 8.  POSITION x. WRITE h2.
  x = sy-colno + 8.  POSITION x. WRITE h3.
  x = sy-colno + 16. POSITION x. WRITE sy-pagno.
  ULINE.
START-OF-SELECTION.
  DO 10 TIMES.
    n1 = sy-index. n2 = sy-index \*\* 2. n3 = sy-index \*\* 3.
    NEW-LINE.
    WRITE: n1 UNDER h1,
           n2 UNDER h2,
           n3 UNDER h3.
  ENDDO.

Description

This program creates a two-page list. In the user-defined page header, column titles are placed in relative position to each other using the system field sy-colno and the POSITION statement. The actual list output is positioned under the fields of the header line using the addition UNDER of the WRITE statement. The line feeds are made using NEW-LINE.

The different output positions of the individual fields result from the ABAP default of representing character strings as left-justified and numeric fields as right-justified. The alignment can be adjusted using the formatting options LEFT-JUSTIFIED, RIGHT-JUSTIFIED, and CENTERED of the WRITE statement (see [WRITE - format\_options](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwrite_to_options.htm)).


### abaptop-of-page.htm

---
title: "TOP-OF-PAGE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page_shortref.htm) Syntax TOP-OF-PAGE DURING LINE-SELECTION. Addition: ... DURING LINE-SELECTION(#!ABAP_ONE_ADD@1@) Effect This statement defines an event block whose event is raised by the ABAP runtim
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page.htm"
abapFile: "abaptop-of-page.htm"
keywords: ["select", "do", "if", "try", "class", "abaptop", "page"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Event Blocks for Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_interactive.htm) → 

TOP-OF-PAGE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptop-of-page_shortref.htm)

Syntax

TOP-OF-PAGE *\[*DURING LINE-SELECTION*\]*.

Addition:

[... DURING LINE-SELECTION](#!ABAP_ONE_ADD@1@)

Effect

This statement defines an event block whose event is raised by the [ABAP runtime environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_runtime_envir_glosry.htm "Glossary Entry") when a list is created. This occurs when a new page begins (that is, immediately before the first line on a new page is produced). All list output produced in the event block is placed below the standard page header of the list. It is not possible to produce lines than are available on the page within the event block. The statement [NEW-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page.htm) is ignored within this event block.

The entire output written to the list in the event block is part of the [page header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_header_glosry.htm "Glossary Entry") of the current list page. The top page header cannot be moved when scrolling vertically in a list displayed on the screen.

For each TOP-OF-PAGE event, the placeholders "&1" - "&9" are replaced by the content of the system fields sy-tvar0 - sy-tvar9 in the standard heading and the column headings of the standard page header when a basic list is created. Values can be assigned to these system fields in the program.

Addition

... DURING LINE-SELECTION

Effect

If no addition is specified, an event block is raised for the event TOP-OF-PAGE when a basic list is created. If the addition DURING LINE-SELECTION is specified, an event block is raised for the events in question when details lists are created. System fields like sy-lsind must be used to distinguish between the individual details lists.

Continue
![Example](exa.gif "Example") [Lists, Page Header](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_top_of_page_abexa.htm)


### abapend-of-page.htm

---
title: "END-OF-PAGE"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapend-of-page_shortref.htm) Syntax END-OF-PAGE. Effect This statement defines an event block, whose event is triggered by the ABAP runtime environment(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapend-of-page.htm"
abapFile: "abapend-of-page.htm"
keywords: ["select", "loop", "do", "if", "try", "class", "data", "types", "abapend", "page"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Event Blocks for Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_interactive.htm) → 

END-OF-PAGE

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapend-of-page_shortref.htm)

Syntax

END-OF-PAGE.

Effect

This statement defines an event block, whose event is triggered by the [ABAP runtime environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_runtime_envir_glosry.htm "Glossary Entry") during the creation of a basic list at the following time:

-   If lines were reserved in the addition [LINE-COUNT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapreport_list_options.htm) of the introductory program statement for a [page footer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") that was reached by a write operation on this page. List output made in the event block is placed in this area. Output statements that exceed the reserved area are ignored.
    
-   If no lines were reserved in the addition [LINE-COUNT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapreport_list_options.htm) for a [page footer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenpage_footer_glosry.htm "Glossary Entry") and the end of page was reached by a write operation on this page. List outputs made in the event block have no effect.
    

Note

The event END-OF-PAGE is inended for writing list outputs in the page footer and is triggered only when the page footer or end of page is reached. Statements such as [NEW-PAGE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page.htm) do not trigger the event.

Example

This program displays a list of flights and creates a page for each connection with a header line and footer line.

REPORT demo\_page\_header\_footer NO STANDARD PAGE HEADING
                               LINE-COUNT 0(1).
TYPES: BEGIN OF sflight\_tab\_type,
         carrid TYPE sflight-carrid,
         connid TYPE sflight-connid,
         fldate TYPE sflight-fldate,
       END OF sflight\_tab\_type.
PARAMETERS p\_carrid TYPE sflight-carrid.
DATA: sflight\_tab TYPE TABLE OF sflight\_tab\_type,
      sflight\_wa  LIKE LINE OF sflight\_tab.
DATA lines TYPE i.
TOP-OF-PAGE.
  WRITE: / sflight\_wa-carrid, sflight\_wa-connid.
  ULINE.
END-OF-PAGE.
  ULINE.
START-OF-SELECTION.
  SELECT carrid, connid, fldate
         FROM sflight
         WHERE carrid = @p\_carrid
         ORDER BY carrid, connid
         INTO CORRESPONDING FIELDS OF TABLE @sflight\_tab.
  LOOP AT sflight\_tab INTO sflight\_wa.
    AT NEW connid.
      SELECT COUNT( DISTINCT fldate )
             FROM sflight
             WHERE carrid = @sflight\_wa-carrid AND
                   connid = @sflight\_wa-connid
             INTO @lines.
      lines += 3.
      NEW-PAGE LINE-COUNT lines.
    ENDAT.
    WRITE / sflight\_wa-fldate.
  ENDLOOP.


### abapat_list_event.htm

---
title: "Syntax"
description: |
  AT  LINE-SELECTION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm)  USER-COMMAND(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm)  PFnn(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_pfnn.htm). Ef
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_list_event.htm"
abapFile: "abapat_list_event.htm"
keywords: ["select", "do", "if", "class", "data", "abapat", "list", "event"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Event Blocks for Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_interactive.htm) → 

AT list\_event

Syntax

AT  [LINE-SELECTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm)
  *|* [USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm)
  *|* [PFnn](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_pfnn.htm).

Effect

Defines event blocks for interactive list processing. The associated events occur if the screen cursor is positioned on a line in a displayed list and the user chooses an appropriate function. Each interactive list event increases the system field sy-lsind by one.

If the cursor is positioned on a line in a list displayed on the screen in an interactive list event, all the values stored using [HIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaphide.htm) and belonging to the line in question are assigned the respective variables and the following system fields are filled with data:

System Field

Meaning

sy-cpage

Page number of the first displayed page of the list from which the event was raised

sy-cucol

Position of the column in the GUI window from which the event was raised (counting starts with 2)

sy-curow

Position of the line in the GUI window from which the event was raised (counting starts with 1)

sy-lilli

Number of the line from which the event was raised

sy-lisel

Content of the line that raised the event (is limited to the first 255 characters)

sy-listi

Index of the list from which the event was raised

sy-lsind

Index of the list level that was created in the event block

sy-staco

Number of the first column displayed in the list from which the event was raised (counting starts with 1)

sy-staro

Number of the first line of the first page displayed of the list from which the event was raised (counting starts with 1)

sy-ucomm

Function code to which the user action that raised the event is assigned

After each list event AT LINE-SELECTION, AT PFnn, and AT USER-COMMAND, the statement [NEW-PAGE PRINT OFF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_print.htm) is executed explicitly.

Note

The list event [AT PFnn](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_pfnn.htm) is obsolete and the other two list events (preferably [AT USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm)) should be used instead.

Continue
[AT LINE-SELECTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm)
[AT USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm)


### abapat_line-selection.htm

---
title: "AT LINE-SELECTION"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection_shortref.htm) Syntax AT LINE-SELECTION. Effect This statement defines an event block whose event is raised by the ABAP runtime environment(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/a
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm"
abapFile: "abapat_line-selection.htm"
keywords: ["select", "do", "if", "try", "class", "abapat", "line", "selection"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Event Blocks for Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_interactive.htm) →  [AT list\_event](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_list_event.htm) → 

AT LINE-SELECTION

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection_shortref.htm)

Syntax

AT LINE-SELECTION.

Effect

This statement defines an event block whose event is raised by the [ABAP runtime environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_runtime_envir_glosry.htm "Glossary Entry") when a screen list is displayed. This is provided the screen cursor is a list line and a function is selected using the function code PICK. By defining this event block, the [standard list status](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstandard_list_status_glosry.htm "Glossary Entry") is enhanced automatically in such a way that the function code F2 and, with it, the double-click mouse function is associated with the function code PICK.

Note

If the function key F2 is associated with a function code other than PICK, each double click raises its event, usually AT USER-COMMAND, and not AT LINE-SELECTION.

Example

This program works with the standard list status. Selecting a line with the left mouse key raises the event AT LINE-SELECTION and creates details lists.

REPORT demo\_at\_line\_selection.
START-OF-SELECTION.
  WRITE 'Click me!' COLOR = 5 HOTSPOT.
AT LINE-SELECTION.
  WRITE: / 'You clicked list', sy-listi,
         / 'You are on list', sy-lsind.
  IF sy-lsind < 20.
    SKIP.
    WRITE: 'More ...' COLOR = 5 HOTSPOT.
  ENDIF.


### abapat_user-command.htm

---
title: "AT USER-COMMAND"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command_shortref.htm) Syntax AT USER-COMMAND. Effect This statement defines an event block whose event is raised by the ABAP runtime environment(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abena
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm"
abapFile: "abapat_user-command.htm"
keywords: ["select", "do", "if", "case", "try", "class", "abapat", "user", "command"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Event Blocks for Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_interactive.htm) →  [AT list\_event](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_list_event.htm) → 

AT USER-COMMAND

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command_shortref.htm)

Syntax

AT USER-COMMAND.

Effect

This statement defines an event block whose event is raised by the [ABAP runtime environment](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_runtime_envir_glosry.htm "Glossary Entry") if, when a screen is displayed, a function with a self-defined function code is chosen. The function code is available in the system field sy-ucomm when processing starts.

Self-defined function codes are all those that include character combinations, except for the following:

-   The function codes "PICK" and "PFnn" ("nn" stands for 01 to 24) do not raise the event AT USER-COMMAND, but the events AT LINE-SELECTION and AT PFnn instead.
    
-   All function codes that start with the character "%" are interpreted as system functions and do not raise the event AT USER-COMMAND. The system functions for lists are listed in the following table 1.
    
-   The function codes in the following table 2, likewise, do not raise the event AT USER-COMMAND, but are handled by the list processor.
    

Table 1

Function Code

Function

%CTX

Calls a context menu

%EX

Exit

%PC

Save to file

%PRI

Spool

%SC

Search for ...

%SC+

Find next

%SL

Save in Office

%ST

Save in report tree

Table 2

Function Code

Function

BACK

Back

P-

Scroll to previous page

P--

Scroll to first page

P+

Scroll to next page

P++

Scroll to last page

PFILE name

Saves list lines in a [text file](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfile_glosry.htm "Glossary Entry") named "abap.lst" in standard character format in the standard directory on the [AS Instance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapplication_server_glosry.htm "Glossary Entry") [host computer](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenhost_computer_glosry.htm "Glossary Entry"). If a name is entered using name, this is converted to lowercase letters and used as the file name.

PL-

Scroll to first line of the page

PL-n

Scroll back n lines

PL+

Scroll to last line of the page

PL+n

Scroll forward n lines

PNOP

None

PP-

Scroll back one page

PP-n

Scroll back n pages

PP+

Scroll forward one page

PP+n

Scroll forward n pages

PPn

Scroll to beginning of page n

PRI, PRINT

Spool

PS--

Scroll to first column

PS++

Scroll to last column

PS-

Scroll one column to the left

PS-n

Scroll n columns to the left

PS+

Scroll one column to the right

PS+n

Scroll n columns to the right

PSn

Scroll to column n

PZn

Scroll to line n

RW

Cancel

Example

This program works with a self-defined GUI status MYLIST. The function associated there with the function code MY\_SELECTION raises the event AT USER-COMMAND when the list is displayed and also creates details lists.

REPORT demo\_at\_user\_command.
START-OF-SELECTION.
  SET PF-STATUS 'MYLIST'.
  WRITE 'List line'.
AT USER-COMMAND.
  IF sy-lsind = 20.
    SET PF-STATUS 'MYLIST' EXCLUDING 'MY\_SELECTION'.
  ENDIF.
  CASE sy-ucomm.
    WHEN 'MY\_SELECTION'.
      WRITE: / 'You worked on list', sy-listi,
             / 'You are on list', sy-lsind.
    ...
  ENDCASE.


### abapat_list_event.htm

---
title: "Syntax"
description: |
  AT  LINE-SELECTION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm)  USER-COMMAND(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm)  PFnn(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_pfnn.htm). Ef
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_list_event.htm"
abapFile: "abapat_list_event.htm"
keywords: ["select", "do", "if", "class", "data", "abapat", "list", "event"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Event Blocks for Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_interactive.htm) → 

AT list\_event

Syntax

AT  [LINE-SELECTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm)
  *|* [USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm)
  *|* [PFnn](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_pfnn.htm).

Effect

Defines event blocks for interactive list processing. The associated events occur if the screen cursor is positioned on a line in a displayed list and the user chooses an appropriate function. Each interactive list event increases the system field sy-lsind by one.

If the cursor is positioned on a line in a list displayed on the screen in an interactive list event, all the values stored using [HIDE](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaphide.htm) and belonging to the line in question are assigned the respective variables and the following system fields are filled with data:

System Field

Meaning

sy-cpage

Page number of the first displayed page of the list from which the event was raised

sy-cucol

Position of the column in the GUI window from which the event was raised (counting starts with 2)

sy-curow

Position of the line in the GUI window from which the event was raised (counting starts with 1)

sy-lilli

Number of the line from which the event was raised

sy-lisel

Content of the line that raised the event (is limited to the first 255 characters)

sy-listi

Index of the list from which the event was raised

sy-lsind

Index of the list level that was created in the event block

sy-staco

Number of the first column displayed in the list from which the event was raised (counting starts with 1)

sy-staro

Number of the first line of the first page displayed of the list from which the event was raised (counting starts with 1)

sy-ucomm

Function code to which the user action that raised the event is assigned

After each list event AT LINE-SELECTION, AT PFnn, and AT USER-COMMAND, the statement [NEW-PAGE PRINT OFF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnew-page_print.htm) is executed explicitly.

Note

The list event [AT PFnn](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_pfnn.htm) is obsolete and the other two list events (preferably [AT USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm)) should be used instead.

Continue
[AT LINE-SELECTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm)
[AT USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm)


### abapset_user-command.htm

---
title: "SET USER-COMMAND"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_user-command_shortref.htm) Syntax SET USER-COMMAND fcode. Effect Raises a list event with a function code specified in fcode. fcode must be a character-like data object(https://help.sap.com/doc/abapdocu_754_index_
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_user-command.htm"
abapFile: "abapset_user-command.htm"
keywords: ["select", "do", "if", "case", "try", "class", "data", "abapset", "user", "command"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_screens.htm) →  [Classic Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_dynpro_list.htm) →  [Event Blocks for Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_lists_interactive.htm) → 

SET USER-COMMAND

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapset_user-command_shortref.htm)

Syntax

SET USER-COMMAND fcode.

Effect

Raises a list event with a function code specified in fcode. fcode must be a [character-like data object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencharlike_data_object_glosry.htm "Glossary Entry"). This statement can be used when creating a list. After completion, but before display of the current list, the runtime environment responds as if a user action were performed in the displayed list using the function code specified in fcode.

The assignment of list events to function codes corresponds to the description under [AT USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm):

-   The predefined function codes of the tables specified under AT USER-COMMAND are caught by the runtime environment
    
-   The function codes "PICK" and "PFnn" raise the events [AT LINE-SELECTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_line-selection.htm) or [AT PFnn](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_pfnn.htm)
    
-   all other functions raise the event [AT USER-COMMAND](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapat_user-command.htm)
    

If the corresponding event block is implemented, the value of sy-lsind is increased by one and the event block is executed.

If multiple SET USER-COMMAND statements are used when creating a list, all are ignored except the last one.

Notes

-   The function code "PICK" only raises an event if the cursor is positioned on a list line.
    
-   If a function code is assigned to the Return key in the current [GUI status](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengui_status_glosry.htm "Glossary Entry"), this function code is used instead of the one specified in fcode.
    

Example

Creates (program-driven) one basic list and two details lists and displays a search dialog box in the second details list using the predefined function code "%SC". The statement SET CURSOR is used to position the cursor in a list line in the event block AT LINE-SELECTION to enable the function code "PICK".

START-OF-SELECTION.
  SET USER-COMMAND 'MYCOMM'.
  WRITE 'Basic List'.
AT USER-COMMAND.
  CASE sy-ucomm.
    WHEN 'MYCOMM'.
      WRITE 'Details List from USER-COMMAND,'.
      WRITE: 'SY-LSIND', sy-lsind.
      SET CURSOR LINE 1.
      SET USER-COMMAND 'PICK'.
  ENDCASE.
AT LINE-SELECTION.
  WRITE 'Details List from LINE-SELECTION,'.
  WRITE: 'SY-LSIND', sy-lsind.
  SET USER-COMMAND '%SC'.


---


## ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Predefined Data Objects

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Predefined Data Objects

Included pages: 3


### abenbuilt_in_obsolete.htm

---
title: "Obsolete Predefined Data Objects"
description: |
  -   Obsolete System Fields(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_fields_obsolete.htm) -   The predefined structure screen(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscreen_structure_obsolete.htm) Obsolete System Fields(https://help.sap.com/do
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_obsolete.htm"
abapFile: "abenbuilt_in_obsolete.htm"
keywords: ["do", "data", "abenbuilt", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) → 

Obsolete Predefined Data Objects

-   [Obsolete System Fields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_fields_obsolete.htm)

-   [The predefined structure screen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscreen_structure_obsolete.htm)

Continue
[Obsolete System Fields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_fields_obsolete.htm)
[The Built-In Structure screen](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscreen_structure_obsolete.htm)


### abensystem_fields_obsolete.htm

---
title: "Obsolete System Fields"
description: |
  -   Former System Fields(#abensystem-fields-obsolete-1--------spool-parameters---@ITOC@@ABENSYSTEM_FIELDS_OBSOLETE_2) Former System Fields The following system fields(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_field_glosry.htm 'Glossary Entry') are obsolete and should
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_fields_obsolete.htm"
abapFile: "abensystem_fields_obsolete.htm"
keywords: ["select", "delete", "loop", "do", "if", "try", "data", "internal-table", "abensystem", "fields", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Predefined Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_obsolete.htm) → 

Obsolete System Fields

-   [Former System Fields](#abensystem-fields-obsolete-1--------spool-parameters---@ITOC@@ABENSYSTEM_FIELDS_OBSOLETE_2)

Former System Fields

The following [system fields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_field_glosry.htm "Glossary Entry") are obsolete and should no longer be used. Many originate from the R/2 era. The transition from R/2 to R/3 retained some system fields which are no longer provided with data.

Name

Type

Length

Content

sy-appli

x

2

In R/2, ID for which SAP applications are installed. No longer filled.

sy-batzd

c

1

In R/2, ID for daily background scheduling. No longer filled.

sy-batzm

c

1

In R/2, ID for monthly background scheduling. No longer filled.

sy-batzo

c

1

In R/2, ID for single background scheduling. No longer filled.

sy-batzs

c

1

In R/2, ID for immediate background scheduling. No longer filled.

sy-batzw

c

1

In R/2, ID for weekly background scheduling. No longer filled.

sy-brep4

c

4

In R/2, ID for immediate spool output for background processing. No longer filled.

sy-bspld

c

1

In R/2, ID for immediate spool output for background processing. No longer filled.

sy-ccurs

p

9

In R/2, rate specification / result field from CURRENCY CONVERSION. No longer filled.

sy-ccurt

p

9

In R/2, table rate from CURRENCY CONVERSION. No longer filled.

sy-cdate

d

\-

In R/2, rate date from CURRENCY CONVERSION. No longer filled.

sy-ctabl

c

4

In R/2, rate table from CURRENCY CONVERSION. No longer filled.

sy-ctype

c

1

In R/2, rate type from CURRENCY CONVERSION. No longer filled.

sy-dcsys

c

4

Dialog system of the R/2 system. No longer filled.

sy-fmkey

c

3

Former function code menu. No longer filled.

sy-locdb

c

1

Local database (not implemented).

sy-locop

c

1

Local database operation (not implemented).

sy-lstat

c

16

Program-driven name for list levels. Can be provided with values when lists are created by the ABAP program. The value that applies when a list is completed is saved with the list. After an interactive list event, sy-lstat is set to the value assigned to it when the list where the event occurred was created. sy-lstat is no longer defined and should therefore no longer be used.

sy-macdb

c

4

Previously, name of file for matchcode access. No longer filled.

sy-marky

c

1

Current line letter for the obsolete statement MARK from the R/2 system.

sy-msgli

c

60

Not documented. No longer filled.

sy-pagct

i

\-

In R/2, maximum number of pages per list. No longer filled.

sy-prefx

c

3

Prefix for background jobs. No longer filled.

sy-sfnam

c

30

Not documented.

sy-sponr

n

10

In R/2, spool files were edited using the statement TRANSFER, which also set sy-sponr. No longer filled.

sy-tfdsn

c

8

Former name of the external repository file for extracts. No longer filled.

sy-tmaxl

i

\-

Former maximum number of entries in an internal table. No longer filled.

sy-tname

c

12

Former name of an internal table after a read/write. No longer filled.

sy-toccu

i

\-

In the statements DESCRIBE TABLE, LOOP AT, and READ TABLE, sy-toccu was formerly given the value for the initial main memory requirements of the addressed internal table. No longer filled.

sy-tpagi

i

\-

Previously, ID whether an internal table is stored in the paging area. No longer filled.

sy-ttabc

i

\-

Former index of the last row read from an internal table. No longer filled.

sy-ttabi

i

\-

Former offset of internal tables in the program memory. No longer filled.

sy-waers

c

5

Former company code currency after posting segment is read. No longer filled.

sy-willi

i

\-

In R/2, number of the selected row of a list in details lists in a GUI window. Use sy-lilli instead.

sy-winco

i

\-

In R/2, cursor position in details lists in a GUI window. Use sy-cucol instead.

sy-windi

i

\-

In R/2, index of the list in details lists in a GUI window. Use sy-lsind instead.

sy-winro

i

\-

In R/2, cursor position in details lists in a GUI window. Use sy-curow instead.

sy-winsl

c

79

In R/2, content of the selected row in details lists in a GUI window. Use sy-lisel instead.

sy-winx1

i

\-

In R/2, window coordinates in details lists in a GUI window. No longer used.

sy-winx2

i

\-

In R/2, window coordinates in details lists in a GUI window. No longer used.

sy-winy1

i

\-

In R/2, window coordinates in details lists in a GUI window. No longer used.

sy-winy2

i

\-

In R/2, window coordinates in details lists in a GUI window. No longer used.

Spool Parameters

[Spool parameters](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters.htm) are passed from the runtime environment to the spool system in a structure of type PRI\_PARAMS. Before this structure was introduced, [system fields](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensystem_field_glosry.htm "Glossary Entry") were used. When spooling is activated today, a subset of the structure PRI\_PARAMS is still written to system fields of the same name. This information is redundant and should not be used.

Name

Type

Length

Content

sy-paart

c

16

[Formatting](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-pdest

c

4

[Output device](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-pexpi

n

1

[Retention period](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-plist

c

12

[Name of spool request](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-prabt

c

12

[Department name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-prbig

c

1

[Cover sheet](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-prcop

n

3

[Number of copies](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-prdsn

c

6

[Name of the spool file](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-primm

c

1

[Print now](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-prnew

c

1

[New spool request](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-prrec

c

12

[Recipient name](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-prrel

c

1

[Delete now](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-prtxt

c

68

[Description text](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)

sy-rtitl

c

70

[Title of the spooler program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprint_parameters_overview.htm)


### abenscreen_structure_obsolete.htm

---
title: "The Built-In Structure screen"
description: |
  In dynpro(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_glosry.htm 'Glossary Entry') processing in dialog modules, the built-in data object screen of the data type SCREEN from ABAP Dictionary is available. It can be addressed explicitly there and implicitly in obsolete shor
version: "7.54"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenscreen_structure_obsolete.htm"
abapFile: "abenscreen_structure_obsolete.htm"
keywords: ["loop", "do", "if", "try", "data", "abenscreen", "structure", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Predefined Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_obsolete.htm) → 

The Built-In Structure screen

In [dynpro](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendynpro_glosry.htm "Glossary Entry") processing in dialog modules, the built-in data object screen of the data type SCREEN from ABAP Dictionary is available. It can be addressed explicitly there and implicitly in obsolete short forms.

-   [LOOP AT SCREEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenloop_at_screen_obsolete.htm)

-   [MODIFY SCREEN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmodify_screen_obsolete.htm)

can be used. A data object screen declared explicitly in the current context obscures the built-in structure.

Notes

-   Instead of the built-in structure screen, use explicitly declared work areas of the type SCREEN in the long forms of the statements above.

-   LOOP AT SCREEN INTO screen or MODIFY SCREEN FROM screen should not be used to access the obsolete built-in structure, even in the long forms.


---


## ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Declarations / Data Types and Data Objects

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Declarations / Data Types and Data Objects

Included pages: 5


### abentypes_data_obsolete.htm

---
title: "Data Types and Data Objects"
description: |
  -   TYPES - implicit(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_implicit.htm) -   Wrong Lengths(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclaration_wrong_length.htm) -   Anonymous Components(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/e
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_data_obsolete.htm"
abapFile: "abentypes_data_obsolete.htm"
keywords: ["do", "if", "data", "types", "abentypes", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobsolete_declarations.htm) → 

Data Types and Data Objects

-   [TYPES - implicit](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_implicit.htm)

-   [Wrong Lengths](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclaration_wrong_length.htm)

-   [Anonymous Components](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenanonymous_components.htm)

-   [TYPES - CLIENT SPECIFIED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_client_specified.htm)

Continue
[TYPES - implicit](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_implicit.htm)
[Wrong Lengths](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclaration_wrong_length.htm)
[Anonymous Components](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenanonymous_components.htm)
[TYPES - CLIENT SPECIFIED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_client_specified.htm)


### abaptypes_implicit.htm

---
title: "TYPES - implicit"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_shortref.htm) Obsolete Syntax TYPES  dtype    dtype(len)    dtype LENGTH len    dtype TYPE cnpx    dtype(len) TYPE p   dtype TYPE p LENGTH len   dt
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_implicit.htm"
abapFile: "abaptypes_implicit.htm"
keywords: ["do", "if", "class", "data", "types", "abaptypes", "implicit"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobsolete_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_data_obsolete.htm) → 

TYPES - implicit

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_shortref.htm)

Obsolete Syntax

TYPES *{* dtype *}*
    *|* *{* dtype(len) *}*
    *|* *{* dtype LENGTH len *}*
    *|* *{* dtype TYPE c*|*n*|*p*|*x *}*
    *|* *{* dtype(len) TYPE p*}*
    *|* *{* dtype TYPE p LENGTH len*}*
    *|* *{* dtype TYPE p DECIMALS dec*}*.

Effect

Obsolete short forms of the statement [TYPES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes.htm) with reference to a built-in elementary type [abap\_type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_simple.htm).

-   If TYPE abap\_type is not specified, the type is set implicitly to the standard type c.
    
-   If len or dec is not specified for the ABAP types c, n, p, and x, the length is set to the [type-friendly standard length](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_complete.htm). No decimal places are set for p. This is only permitted outside of classes or interfaces.
    

Note

All additions should be specified in full, to make them easier to read.

Bad Example

TYPES: t1,
       t2 TYPE p.

Good Example

TYPES: t1 TYPE c LENGTH 1,
       t2 TYPE p LENGTH 8 DECIMALS 0.


### abendeclaration_wrong_length.htm

---
title: "Wrong Lengths"
description: |
  Obsolete Syntax ... dtype(len)dobj(len) TYPE dfit ... Effect Lengths specified in declarations(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) using the statements TYPES, DATA, STATICS, and CONSTANTS and the built-in ABAP types d, f, i, and t are i
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendeclaration_wrong_length.htm"
abapFile: "abendeclaration_wrong_length.htm"
keywords: ["do", "if", "class", "data", "types", "abendeclaration", "wrong", "length"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobsolete_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_data_obsolete.htm) → 

Wrong Lengths

Obsolete Syntax

... dtype(len)*|*dobj(len) TYPE d*|*f*|*i*|*t ...

Effect

Lengths specified in [declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_declarations.htm) using the statements TYPES, DATA, STATICS, and CONSTANTS and the built-in ABAP types d, f, i, and t are ignored. Only the predefined [fixed lengths](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbuilt_in_types_complete.htm) can be specified. Lengths specified in this way produce syntax errors in classes and interfaces and syntax warnings elsewhere.

Note

This obsolete length specification is only possible with the obsolete parenthesis syntax and not with the recommended addition LENGTH.

Bad Example

DATA: f1(8) TYPE d,
      f2(4) TYPE i.

Good Example

DATA: f1 TYPE d,
      f2 TYPE i.


### abenanonymous_components.htm

---
title: "Anonymous Components"
description: |
  Obsolete Syntax DATA: BEGIN OF struc, ... '...', ... space(len) TYPE c, ... END OF struc. Effect If text field literals(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_field_literal_glosry.htm 'Glossary Entry') or the constant space(https://help.sap.com/doc/abapdocu_7
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenanonymous_components.htm"
abapFile: "abenanonymous_components.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenanonymous", "components"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobsolete_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_data_obsolete.htm) → 

Anonymous Components

Obsolete Syntax

DATA: BEGIN OF struc,
        ...
        '...',
        ...
        space(len) *\[*TYPE c*\]*,
        ...
      END OF struc.

Effect

If [text field literals](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentext_field_literal_glosry.htm "Glossary Entry") or the constant [space](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenspace.htm) (the latter also with a length specified in parentheses) are specified within the [definition of a structure](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_struc.htm) using DATA, CONSTANTS, or STATICS, nameless text fields are included at this position as anonymous components. For literals, the initial value and the length of these components correspond to the content. If space is specified, a text field filled with blanks is created. These anonymous text fields cannot be addressed explicitly in programs. In particular, structures never contain components with the name space. Anonymous components can only be accessed using the structure name and by specifying appropriate offsets/lengths.

Notes

-   Anonymous components must not be specified in classes or interfaces.

-   These anonymous components can be replaced easily by named components. Named components increase the function of anonymous components by allowing them to be accessed explicitly, without limiting their role as, for example, filler fields.


### abaptypes_client_specified.htm

---
title: "TYPES - CLIENT SPECIFIED"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_shortref.htm) Obsolete Syntax TYPES dtype TYPE cds_entity CLIENT SPECIFIED clnt. Effect The statement TYPES uses the addition CLIENT SPECIFIED to define a structured type constructed from all components of a CDS
version: "7.54"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_client_specified.htm"
abapFile: "abaptypes_client_specified.htm"
keywords: ["select", "do", "if", "try", "method", "data", "types", "internal-table", "abaptypes", "client", "specified"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobsolete_declarations.htm) →  [Data Types and Data Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentypes_data_obsolete.htm) → 

TYPES - CLIENT SPECIFIED

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptypes_shortref.htm)

Obsolete Syntax

TYPES dtype TYPE cds\_entity CLIENT SPECIFIED clnt.

Effect

The statement TYPES uses the addition CLIENT SPECIFIED to define a structured type constructed from all components of a [CDS entity](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_entity_glosry.htm "Glossary Entry") cds\_entity and that also has an initial component clnt with the type of a [client column](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclient_column_glosry.htm "Glossary Entry").

cds\_entity expects the name of a non-abstract [CDS entity](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_entity_glosry.htm "Glossary Entry"), namely:

-   The name of a [CDS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_view_glosry.htm "Glossary Entry") view as defined in the CDS DDL statement [DEFINE VIEW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_f1_define_view.htm).
    
-   The name of a [CDS table function](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_table_function_glosry.htm "Glossary Entry") as defined in the CDS DDL statement [DEFINE TABLE FUNCTION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_f1_define_table_function.htm).
    
-   The name of a [CDS hierarchy](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_hierarchy_glosry.htm "Glossary Entry") as defined in the CDS DDL statement [DEFINE HIERARCHY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_f1_define_hierarchy.htm).
    

Any name for the client column that complies with the [naming conventions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abennaming_conventions.htm) can be specified for clnt.

Notes

-   A structure of a type defined using this statement can be used as a work area of a [SELECT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect.htm) statement for CDS entities in which [implicit client handling](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenopen_sql_client_handling.htm) is disabled using the obsolete statement [CLIENT SPECIFIED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect_client_obsolete.htm)s. [USING](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect_client.htm) is used to switch implicit client handling and not disable it, which means the addition CLIENT SPECIFIED is also obsolete for TYPES.
    
-   If the statement is used for a [client-specific CDS table function](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencds_func_client_handling.htm), a structured type is produced that matches the row structure of the return value of the associated [AMDP function implementation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenamdp_function_methods.htm). This type is not, however, required in ABAP programs, since the AMDP function implementation cannot be called like a regular function method
    
-   The name specified for clnt has absolutely no dependency on the actual name of a client column in a data source of a CDS view.
    
-   Abstract [CDS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabstract_entity_glosry.htm "Glossary Entry") entities cannot be specified.
    

Example

Defines a row type scarr\_spfli\_clnt for an internal table used as a target area when a client-specific CDS view is accessed using the obsolete addition [CLIENT SPECIFIED](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect_client_obsolete.htm) of the SELECT statement. If the addition CLIENT SPECIFIED of the statement TYPES is not used, the column clnt would not exist in the table scarr\_spfli\_clnt and could not be used as a target range.

TYPES scarr\_spfli\_clnt TYPE demo\_cds\_scarr\_spfli CLIENT SPECIFIED clnt.
DATA scarr\_spfli\_clnt TYPE TABLE OF scarr\_spfli\_clnt WITH EMPTY KEY.
SELECT \*
       FROM demo\_cds\_scarr\_spfli CLIENT SPECIFIED
       INTO TABLE @scarr\_spfli\_clnt.

The following example shows how the recommended addition [USING ALL CLIENTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapselect_client.htm) is used, for which no special target area is required.

DATA scarr\_spfli TYPE TABLE OF demo\_cds\_scarr\_spfli WITH EMPTY KEY.
SELECT \*
       FROM demo\_cds\_scarr\_spfli USING ALL CLIENTS
       INTO TABLE @scarr\_spfli.


---


## ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Declarations / Interface work areas

**Files**: 3 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Declarations / Interface work areas

Included pages: 3


### abeninterface_areas_obsolete.htm

---
title: "Interface work areas"
description: |
  Interface work areas are created only once for each program group(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprogram_group_glosry.htm 'Glossary Entry') and shared by the main program(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmain_program_glosry.htm 'Gloss
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterface_areas_obsolete.htm"
abapFile: "abeninterface_areas_obsolete.htm"
keywords: ["do", "if", "try", "data", "abeninterface", "areas", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobsolete_declarations.htm) → 

Interface work areas

Interface work areas are created only once for each [program group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprogram_group_glosry.htm "Glossary Entry") and shared by the [main program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmain_program_glosry.htm "Glossary Entry") and its additional loaded programs. The assignment of programs to program groups can be dependent on user actions, field contents, and switches, which means that interface work areas are extremely error-prone, with respect to their functions and to their maintainability. The only interface work areas that can still be used for special purposes are [table work areas](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_work_area_glosry.htm "Glossary Entry") declared using [TABLES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptables.htm). The following declarations are completely obsolete:

-   [DATA - COMMON PART](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_common.htm)

-   [TABLES \*](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptables_asterisk.htm)

The statement [NODES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapnodes.htm) (once required for interface work areas between logical databases and executable programs) is also no longer required if you no longer work with logical databases.

Continue
[DATA - COMMON PART](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_common.htm)
[TABLES \*](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptables_asterisk.htm)


### abapdata_common.htm

---
title: "DATA - COMMON PART"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_common_part_shortref.htm) Obsolete Syntax DATA BEGIN OF COMMON PART name. ... DATA ... ... DATA END OF COMMON PART name. Effect This variant of the statement DATA(https://help.sap.com/doc/abapdocu
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_common.htm"
abapFile: "abapdata_common.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abapdata", "common"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobsolete_declarations.htm) →  [Interface work areas](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterface_areas_obsolete.htm) → 

DATA - COMMON PART

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata_common_part_shortref.htm)

Obsolete Syntax

DATA BEGIN OF COMMON PART *\[*name*\]*.
  ...
  DATA ...
  ...
DATA END OF COMMON PART *\[*name*\]*.

Effect

This variant of the statement [DATA](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapdata.htm) with the additions BEGIN OF COMMON PART and END OF COMMON PART defines a global [interface work area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterface_work_area_glosry.htm "Glossary Entry"), that can be used jointly by the programs of a [program group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprogram_group_glosry.htm "Glossary Entry"). All data objects declared between these statements using DATA are part of this [common area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencommon_area_glosry.htm "Glossary Entry").

The addition COMMON PART can only be used in the global declaration part of an ABAP program. Multiple common [data areas](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_area_glosry.htm "Glossary Entry") can be declared in a program, but they cannot be nested. Every common data area must be given a unique name using the name addition. The addition name can be omitted only if there is just one common data area in a program.

The following rules apply:

-   In all programs in a program group that declare common data areas with the same name, these areas must have identical layouts. Common data areas are hence viewed as structures whose [structure fragment view](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenunicode_fragment_view_glosry.htm "Glossary Entry") must be identical and whose deep components must be compatible (pairwise). If not, the runtime error LOAD\_COMMON\_PART\_STRUCT occurs.
    
-   In common data areas it is not possible to declare [object reference variables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobject_refer_variable_glosry.htm "Glossary Entry") with the static type of program-local classes and interfaces, nor is it possible to declare [data reference variables](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendata_reference_variable_glosry.htm "Glossary Entry") with the static type of program-local structured types.
    

Notes

-   The use of common data areas in otherwise independent programs can be very problematic, with regard to both the maintainability and the functions. Therefore, common data areas should no longer be used. The parameter interfaces of [procedures](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprocedure_glosry.htm "Glossary Entry") are available for exchanging data between programs.
    
-   Common data areas for various programs are generally declared in an [include program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninclude_program_glosry.htm "Glossary Entry") that is embedded in all programs involved. However, multiple use of include programs is no longer recommended.
    
-   For more information about issues related to interface work areas, see [Program Groups in External Procedure Calls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprogram_groups.htm).
    

Example

In this example, a common data area struc is declared in the include program part. By incorporating the include program, the three programs param, sum and dis have shared access to the data area struc if they are part of a program group. The latter is accomplished by loading the programs sum and disp into the program group of param using external subroutine calls. The subroutine display in the program disp outputs the input values to the program param and the result of the summation in the subroutine summing.

\* INCLUDE part.
DATA: BEGIN OF COMMON PART struc,
        f1 TYPE i,
        f2 TYPE i,
        s  TYPE i,
      END OF COMMON PART struc.
PROGRAM param.
INCLUDE part.
PARAMETERS:
  p1 TYPE i DEFAULT 20,
  p2 TYPE i DEFAULT 90.
f1 = p1.
f2 = p2.
PERFORM summming IN PROGRAM sum.
PROGRAM sum.
INCLUDE part.
FORM summing.
  s = f1 + f2.
  PERFORM display IN PROGRAM disp.
ENDFORM.
PROGRAM disp.
INCLUDE part.
FORM display.
  WRITE: / f1, f2, s.
ENDFORM.


### abaptables_asterisk.htm

---
title: "Obsolete Syntax"
description: |
  TABLES table_wa. Effect This statement declares an additional table work area(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_work_area_glosry.htm 'Glossary Entry') table_wa, whose data type, like that of the regular TABLES(https://help.sap.com/doc/abapdocu_754_index_h
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptables_asterisk.htm"
abapFile: "abaptables_asterisk.htm"
keywords: ["select", "do", "try", "class", "data", "types", "abaptables", "asterisk"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Declarations](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobsolete_declarations.htm) →  [Interface work areas](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterface_areas_obsolete.htm) → 

TABLES \*

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptables_plus_shortref.htm)

Obsolete Syntax

TABLES \*table\_wa.

Effect

This statement declares an additional [table work area](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentable_work_area_glosry.htm "Glossary Entry") \*table\_wa, whose data type, like that of the regular [TABLES](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaptables.htm) statement with its [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") structured data type table\_wa, is taken from ABAP Dictionary.

The additional table work area can be used just like the regular table work area. This applies in particular to obsolete [database accesses](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendatabase_access_obsolete.htm).

Note

The statement TABLES cannot be used in classes. The addition TYPE can be used to reference the data types in ABAP Dictionary and declare any number of separate work areas.

Bad Example

Declaration of a regular and additional table work area and their use in obsolete short forms of the SELECT statement.

TABLES: scarr, \*scarr.
SELECT SINGLE \*
       FROM scarr
       WHERE carrid = 'LH'.
SELECT SINGLE \*
       FROM \*scarr
       WHERE carrid = 'UA'.

Good Example

Declares two work areas using DATA and how they are used in the INTO clause of the SELECT statement.

DATA: scarr1 TYPE scarr,
      scarr2 TYPE scarr.
SELECT SINGLE \*
       FROM scarr
       WHERE carrid = 'LH'
       INTO @scarr1.
SELECT SINGLE \*
       FROM scarr
       WHERE carrid = 'UA'
       INTO @scarr2.


---


## ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Object Creation

**Files**: 2 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Object Creation

Included pages: 2


### abenassign_obsolete.htm

---
title: "Obsolete Object Creation"
description: |
  This section describes the creation of a local data object with the statement ASSIGN LOCAL COPY(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_local_copy.htm). ASSIGN LOCAL COPY(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_local_copy.htm)
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenassign_obsolete.htm"
abapFile: "abenassign_obsolete.htm"
keywords: ["do", "data", "abenassign", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) → 

Obsolete Object Creation

This section describes the creation of a local data object with the statement [ASSIGN LOCAL COPY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_local_copy.htm).

Continue
[ASSIGN LOCAL COPY](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_local_copy.htm)


### abapassign_local_copy.htm

---
title: "ASSIGN LOCAL COPY"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_local_copy_shortref.htm) Obsolete Syntax ASSIGN LOCAL COPY OF  INITIAL mem_area  INITIAL LINE OF itab(itab_name)  MAIN TABLE FIELD (name)  TO <fs> casting_spec. E
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_local_copy.htm"
abapFile: "abapassign_local_copy.htm"
keywords: ["do", "if", "case", "try", "class", "data", "internal-table", "field-symbol", "abapassign", "local", "copy"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Object Creation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenassign_obsolete.htm) → 

ASSIGN LOCAL COPY

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_local_copy_shortref.htm)

Obsolete Syntax

ASSIGN LOCAL COPY
  OF *{* *{**\[*INITIAL*\]* mem\_area*}*
     *|* *{*INITIAL LINE OF *{*itab*|*(itab\_name)*}**}*
     *|* *{*MAIN TABLE FIELD (name)*}* *}*
  TO <fs> casting\_spec.

Extras:

[1\. ... mem\_area](#!ABAP_ADDITION_1@1@)
[2\. ... MAIN TABLE FIELD (name)](#!ABAP_ADDITION_2@2@)
[3\. ... casting\_spec](#!ABAP_ADDITION_3@3@)

Effect

Obsolete creation of a local data object. This variant of the [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign.htm) statement can only be used in [subroutines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensubroutine_glosry.htm "Glossary Entry") and [function modules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunction_module_glosry.htm "Glossary Entry"). The [field symbol](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfield_symbol_glosry.htm "Glossary Entry") <fs> must be declared locally in the procedure.

Like the regular statement [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign.htm), the statement ASSIGN LOCAL COPY assigns a memory area mem\_area to the field symbol <fs>. Unlike the regular statement ASSIGN, the field symbol does not reference the memory area specified in mem\_area after the successful assignment. Instead, an [anonymous data object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenanonymous_data_object_glosry.htm "Glossary Entry") is created in the local data area of the procedure. After the successful execution of the statement, the field symbol points to the new data object. The new data object is treated as follows:

-   The size of the memory area of the new data object conforms to either the data in mem\_area or the [line type](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrow_type_glosry.htm "Glossary Entry")of an internal table if LINE OF is specified. The internal table can be specified directly as itab or as the content of a [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like field itab\_name.
    
-   The data type with which the new data object is to be handled conforms to the data in casting\_spec as is the case when using the regular ASSIGN.
    
-   The initial content of the new data object is copied from the memory area specified in mem\_area when specifying mem\_area without the addition INITIAL. Otherwise it is initialized according to type.
    

Limitation of the memory area [range\_spec](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_range.htm), which can occur in the regular ASSIGN statement implicitly and explicitly, occurs only implicitly in accordance with the rules that also apply to the normal ASSIGN.

Note

The creation of a local data object using the statement ASSIGN LOCAL COPY is replaced by the statement CREATE DATA with subsequent dereferencing in the regular ASSIGN statement.

Addition 1

... mem\_area

Syntax of mem\_area

... *{* dobj*\[*+off*\]**\[*(len)*\]*
    *|* (name)
    *|* oref->(attr\_name)
    *|* *{*class*|*(class\_name)*}*\=>*{*attr*|*(attr\_name)*}*
    *|* dref->\* *}* ...

Effect

The specifications made in mem\_area are a subset of the [specifications](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_mem_area.htm) in the regular ASSIGN statement. They have the same function except for the following restrictions:

-   If the addition INITIAL is used before mem\_area, the data object name must be character-like and [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry").
    
-   If the addition INITIAL is used before mem\_area, the data object dref cannot be typed [generically](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengeneric_data_type_glosry.htm "Glossary Entry") when using the dereferencing operator \->\*.
    

Addition 2

... MAIN TABLE FIELD (name)

This addition is for internal use only.
It must not be used in application programs.

Effect

This addition is a special form of the specified memory area mem\_area that can only be used in this variant of the ASSIGN statement. It has the same function as the obsolete [TABLE FIELD (name)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_table_field.htm) in a regular ASSIGN with the exception that the search area is restricted to the current [main program group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmain_program_group_glosry.htm "Glossary Entry").

Addition 3

... casting\_spec

Effect

If specified, casting\_spec is the same as a regular [ASSIGN](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapassign_casting.htm) with the limitation that if the addition INITIAL is used before mem\_area and an internal tables is specified, no explicit specifications can be made. This means, the field symbol copies the data type of the data object in mem\_area or the line type of the internal table.

Example

A typical use of the statement ASSIGN LOCAL COPY was the creation of a local copy of a global data object.

DATA g\_dobj TYPE i.
...
CLEAR g\_dobj.
PERFORM subroutine1.
...
FORM subroutine1.
  FIELD-SYMBOLS <l\_dobj> TYPE ANY.
  ASSIGN LOCAL COPY OF g\_dobj TO <l\_dobj>.
  <l\_dobj> += 1.
  cl\_demo\_output=>write\_data( <l\_dobj> ).
  cl\_demo\_output=>display\_data( g\_dobj ).
ENDFORM.

The following subroutine shows how the same functions can be universally implemented with a data reference.

DATA g\_dobj TYPE i.
...
CLEAR g\_dobj.
PERFORM subroutine2.
...
FORM subroutine2.
  DATA dref TYPE REF TO data.
  FIELD-SYMBOLS <l\_dobj> TYPE ANY.
  CREATE DATA dref LIKE g\_dobj.
  ASSIGN dref->\* TO <l\_dobj>.
  <l\_dobj> = g\_dobj.
  <l\_dobj> += 1.
  cl\_demo\_output=>write\_data( <l\_dobj> ).
  cl\_demo\_output=>display\_data( g\_dobj ).
ENDFORM.


---


## ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Data and Communication Interfaces

**Files**: 17 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP − Reference / Obsolete Language Elements / Obsolete Data and Communication Interfaces

Included pages: 17


### abenextern_obsolete.htm

---
title: "Obsolete Data and Communication Interfaces"
description: |
  -   Transactional RFC(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_obsolete.htm) -   ABAP and XML(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_obsolete.htm) -   CPI-C Interface(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm"
abapFile: "abenextern_obsolete.htm"
keywords: ["do", "data", "abenextern", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) → 

Obsolete Data and Communication Interfaces

-   [Transactional RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_obsolete.htm)

-   [ABAP and XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_obsolete.htm)

-   [CPI-C Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_cpic.htm)

-   [ABAP and JavaScript](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_java_script.htm)

Continue
[Obsolete Transactional RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_obsolete.htm)
[Obsolete Wait](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwait_obsolete.htm)
[Obsolete XML Binding](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_obsolete.htm)
[CPI-C Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_cpic.htm)
[ABAP and JavaScript](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_java_script.htm)


### abenrfc_obsolete.htm

---
title: "Obsolete Transactional RFC"
description: |
  -   CALL FUNCTION - IN BACKGROUND TASK(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_background_task.htm) Note Transactional remote function call (tRFC)(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentrfc_1_glosry.htm 'Glossary Entry') and its enhan
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_obsolete.htm"
abapFile: "abenrfc_obsolete.htm"
keywords: ["do", "try", "data", "abenrfc", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) → 

Obsolete Transactional RFC

-   [CALL FUNCTION - IN BACKGROUND TASK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_background_task.htm)

Note

[Transactional remote function call (tRFC)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentrfc_1_glosry.htm "Glossary Entry") and its enhancement, [queued remote function call (qRFC)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenqueued_remote_function_glosry.htm "Glossary Entry"), have been replaced by [background RFC (bgRFC)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbg_remote_function_glosry.htm "Glossary Entry"). It is strongly recommended that bgRFC is used instead of tRFC.

Continue
[CALL FUNCTION - IN BACKGROUND TASK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_background_task.htm)


### abapcall_function_background_task.htm

---
title: "CALL FUNCTION - IN BACKGROUND TASK"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_shortref.htm) Obsolete Syntax CALL FUNCTION func IN BACKGROUND TASK AS SEPARATE UNIT DESTINATION dest parameter_list(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_f
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_background_task.htm"
abapFile: "abapcall_function_background_task.htm"
keywords: ["delete", "do", "if", "try", "data", "abapcall", "function", "background", "task"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) →  [Obsolete Transactional RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_obsolete.htm) → 

CALL FUNCTION - IN BACKGROUND TASK

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_shortref.htm)

Obsolete Syntax

CALL FUNCTION func IN BACKGROUND TASK
                   *\[*AS SEPARATE UNIT*\]*
                   *\[*DESTINATION dest*\]*
                   [parameter\_list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_background_para.htm).

Addition:

[... AS SEPARATE UNIT](#!ABAP_ONE_ADD@1@)

Effect

Transactional call (tRFC) of a [remote-enabled function module](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenremote_enabled_fm_glosry.htm "Glossary Entry") specified in func using the [RFC interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_interface_glosry.htm "Glossary Entry"). Using the addition DESTINATION, a unique [destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_destination.htm) can be specified in dest. If the destination is not specified, the destination "NONE" is used implicitly. func and dest expect character-like data objects.

The transactional call registers the name of the called function, together with the destination and the actual parameters passed in [parameter\_list](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_background_para.htm) for the current [SAP LUW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_luw_glosry.htm "Glossary Entry") in the database tables ARFCSSTATE and ARFCSDATA of the current [AS ABAP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_nw_abap_glosry.htm "Glossary Entry") under a unique transaction ID (abbreviated as TID, stored in a structure of type ARFCTID from ABAP Dictionary, viewed using transaction SM58). After registration, the calling program is continued after the statement CALL FUNCTION.

When the [COMMIT WORK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommit.htm) statement is executed, the function modules registered for the current SAP LUW are started in the order in which they were registered. The statement [ROLLBACK WORK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaprollback.htm) deletes all previous registrations for the current SAP LUW.

If the specified destination is not available when COMMIT WORK is executed, an [executable program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenexecutable_program_glosry.htm "Glossary Entry") called RSARFCSE is started in [background processing](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbackround_processing_glosry.htm "Glossary Entry"). By default, this tries to start the function modules registered for a SAP LUW in their destination every 15 minutes and up to 30 times. Changes can be made to these parameters using transaction SM59. If the destination does not become available within the defined time, it is recorded in the database table ARFCSDATA as the entry "CPICERR". By default, this entry in database table ARFCSSTATE is deleted after eight days.

Note

[background RFC (bgRFC)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbg_remote_function_glosry.htm "Glossary Entry") executed with the statement [CALL FUNCTION IN BACKGROUND UNIT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_background_unit.htm) is the enhanced successor technology of transactional RFC (tRFC) and makes this technology obsolete. It is strongly recommended to use bgRFC instead of tRFC.

More Information

More information about tRFC can be found in the RFC documentation on [SAP Help Portal](http://help.sap.com).

Addition

... AS SEPARATE UNIT

Effect

When using the addition AS SEPARATE UNIT, the relevant function module is executed in a separate [RFC session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_session_glosry.htm "Glossary Entry"), in which the global data of the function group is not influenced by previous calls. Each function module that is registered with the addition AS SEPARATE UNIT is given a separate transaction ID. Without the addition AS SEPARATE UNIT, the usual [description](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_context.htm) applies to the [RFC session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_session_glosry.htm "Glossary Entry") of the called function modules. This means that, when using the same [RFC destination](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendestination_glosry.htm "Glossary Entry") for multiple calls of function modules belonging to the same function group, the global data of this function group is accessed collectively.

Notes

-   The function module ID\_OF\_BACKGROUNDTASK can be used after a transactional RFC to determine the transactional ID (TID) of the current [SAP LUW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_luw_glosry.htm "Glossary Entry").
    
-   The transactional RFC (tRFC) is suitable for realizing LUWs in distributed environments (a typical application is ALE). Note that, although the execution of the function modules within a transaction ID is specified, the order of the [LUWs](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenluw_glosry.htm "Glossary Entry") on the RFC servers is not necessarily the same as the order of the SAP LUWs on the RFC client. To ensure the same serialization is also used on RFC servers, the tRFC can be enhanced as ([queued RFC (qRFC)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenqrfc_glosry.htm "Glossary Entry")). For this, the function module TRFC\_SET\_QUEUE\_NAME can be called before a transactional RFC. More information about qRFC can be found in the RFC documentation on [SAP Help Portal](http://help.sap.com).
    
-   If [tRFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentrfc_2_glosry.htm "Glossary Entry") or [qRFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenqrfc_glosry.htm "Glossary Entry") are registered in a [dialog module](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendialog_module_object_glosry.htm "Glossary Entry") and are not started with COMMIT WORK, they are not executed by the COMMIT WORK of the caller.
    
-   The new variant [CALL FUNCTION IN BACKGROUND UNIT](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_background_unit.htm) ([bgRFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbgrfc_glosry.htm "Glossary Entry")) includes and enhances the existing tRFC and qRFC variants. For this reason, we strongly recommend using bgRFC instead of tRFC.
    
-   The statements [COMMIT WORK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommit.htm) and [ROLLBACK WORK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abaprollback.htm) must not be executed within a LUW. In addition, no implicit [database commit](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendatabase_commit_glosry.htm "Glossary Entry") can be triggered there.
    
-   When handling the registration entries in the database tables ARFCSSTATE and ARFCSDATA, note that they are subject to the regular administration rules for a [database LUW](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendatabase_luw_glosry.htm "Glossary Entry"). For example, the database LUW is ended by a [database rollback](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendatabase_rollback_glosry.htm "Glossary Entry"), all registration entries of the current database LUW are deleted.


### abenrfc_obsolete.htm

---
title: "Obsolete Transactional RFC"
description: |
  -   CALL FUNCTION - IN BACKGROUND TASK(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_background_task.htm) Note Transactional remote function call (tRFC)(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentrfc_1_glosry.htm 'Glossary Entry') and its enhan
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_obsolete.htm"
abapFile: "abenrfc_obsolete.htm"
keywords: ["do", "try", "data", "abenrfc", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) → 

Obsolete Transactional RFC

-   [CALL FUNCTION - IN BACKGROUND TASK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_background_task.htm)

Note

[Transactional remote function call (tRFC)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentrfc_1_glosry.htm "Glossary Entry") and its enhancement, [queued remote function call (qRFC)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenqueued_remote_function_glosry.htm "Glossary Entry"), have been replaced by [background RFC (bgRFC)](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenbg_remote_function_glosry.htm "Glossary Entry"). It is strongly recommended that bgRFC is used instead of tRFC.

Continue
[CALL FUNCTION - IN BACKGROUND TASK](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_function_background_task.htm)


### abenwait_obsolete.htm

---
title: "Obsolete Wait"
description: |
  -   WAIT UNTIL - Short Form(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_obsolete.htm) WAIT UNTIL - Short Form(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_obsolete.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwait_obsolete.htm"
abapFile: "abenwait_obsolete.htm"
keywords: ["do", "data", "abenwait", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) → 

Obsolete Wait

-   [WAIT UNTIL - Short Form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_obsolete.htm)

Continue
[WAIT UNTIL - Short Form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_obsolete.htm)


### abapwait_obsolete.htm

---
title: "WAIT UNTIL - Short Form"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_shortref.htm) Obsolete Syntax WAIT UNTIL log_exp(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogexp.htm) UP TO sec SECONDS. Effect This statement works in the same way as WAIT FOR ASY
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_obsolete.htm"
abapFile: "abapwait_obsolete.htm"
keywords: ["do", "try", "data", "abapwait", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) →  [Obsolete Wait](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwait_obsolete.htm) → 

WAIT UNTIL - Short Form

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_shortref.htm)

Obsolete Syntax

WAIT UNTIL [log\_exp](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlogexp.htm) *\[*UP TO sec SECONDS*\]*.

Effect

This statement works in the same way as

[WAIT FOR ASYNCHRONOUS TASKS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_until.htm) UNTIL logexp *\[*UP TO sec SECONDS*\]*.

Note

The complete form using FOR ASYNCHRONOUS TASKS should always be used. This addition indicates that an [asynchronous RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenasynchronous_rfc_glosry.htm "Glossary Entry") is expected and distinguishes the statement from [WAIT FOR MESSAGING CHANNELS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_amc.htm) or [WAIT FOR PUSH CHANNELS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_apc.htm), which are waiting for messages from [ABAP Messaging Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_messaging_channels_glosry.htm "Glossary Entry") or [ABAP Push Channels](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_push_channels_glosry.htm "Glossary Entry").


### abenwait_obsolete.htm

---
title: "Obsolete Wait"
description: |
  -   WAIT UNTIL - Short Form(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_obsolete.htm) WAIT UNTIL - Short Form(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_obsolete.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenwait_obsolete.htm"
abapFile: "abenwait_obsolete.htm"
keywords: ["do", "data", "abenwait", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) → 

Obsolete Wait

-   [WAIT UNTIL - Short Form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_obsolete.htm)

Continue
[WAIT UNTIL - Short Form](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapwait_obsolete.htm)


### abenabap_xml_obsolete.htm

---
title: "Obsolete XML Binding"
description: |
  -   CALL TRANSFORMATION - OBJECTS(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_objects.htm) CALL TRANSFORMATION - OBJECTS(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_objects.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_obsolete.htm"
abapFile: "abenabap_xml_obsolete.htm"
keywords: ["do", "data", "abenabap", "xml", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) → 

Obsolete XML Binding

-   [CALL TRANSFORMATION - OBJECTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_objects.htm)

Continue
[CALL TRANSFORMATION - OBJECTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_objects.htm)


### abapcall_transformation_objects.htm

---
title: "CALL TRANSFORMATION - OBJECTS"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_shortref.htm) Obsolete Syntax ... OBJECTS o1 = e1 o2 = e2 ...(otab) ... Effect This addition of the statement CALL TRANSFORMATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_objects.htm"
abapFile: "abapcall_transformation_objects.htm"
keywords: ["do", "try", "method", "data", "internal-table", "abapcall", "transformation", "objects"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) →  [Obsolete XML Binding](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_obsolete.htm) → 

CALL TRANSFORMATION - OBJECTS

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_shortref.htm)

Obsolete Syntax

... OBJECTS *{*o1 = e1 o2 = e2 ...*}**|*(otab) ...

Effect

This addition of the statement [CALL TRANSFORMATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm) can be used to pass object references e1 e2 ... to an XSL transformation as external objects o1 o2 ... to call their methods here.

Instead of using a static parameter list, the objects can be passed dynamically as value pairs in the columns of the internal table otab with the type ABAP\_TRANS\_OBJBIND\_TAB from the [type group](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentype_group_1_glosry.htm "Glossary Entry") ABAP.

Note

The addition OBJECTS is obsolete. External objects are handled like parameters and object references must be passed accordingly with the addition [PARAMETERS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation.htm).


### abenabap_xml_obsolete.htm

---
title: "Obsolete XML Binding"
description: |
  -   CALL TRANSFORMATION - OBJECTS(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_objects.htm) CALL TRANSFORMATION - OBJECTS(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_objects.htm)
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_xml_obsolete.htm"
abapFile: "abenabap_xml_obsolete.htm"
keywords: ["do", "data", "abenabap", "xml", "obsolete"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) → 

Obsolete XML Binding

-   [CALL TRANSFORMATION - OBJECTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_objects.htm)

Continue
[CALL TRANSFORMATION - OBJECTS](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcall_transformation_objects.htm)


### abenabap_cpic.htm

---
title: "CPI-C Interface"
description: |
  This section describes cross-system communications between two ABAP programs as realized using the COMMUNICATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication.htm) statement. Note SDK for CPI-C is no longer supported. The CPI-C libraries and the documentation for pro
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_cpic.htm"
abapFile: "abenabap_cpic.htm"
keywords: ["do", "try", "data", "abenabap", "cpic"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) → 

CPI-C Interface

This section describes cross-system communications between two ABAP programs as realized using the [COMMUNICATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication.htm) statement.

Note

SDK for CPI-C is no longer supported. The CPI-C libraries and the documentation for programming are no longer delivered. For new programs, SDK and the libraries for [RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_glosry.htm "Glossary Entry") must be used. The API for CPI-C was retained to support existing programs and for internal technical purposes.

Continue
[COMMUNICATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication.htm)


### abapcommunication.htm

---
title: "COMMUNICATION"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_shortref.htm) Obsolete Syntax COMMUNICATION comstep(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_comstep.htm) ID id  cpic_options(https://help.sap.com/doc/abapdocu_
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication.htm"
abapFile: "abapcommunication.htm"
keywords: ["do", "while", "if", "case", "try", "class", "data", "types", "abapcommunication"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) →  [CPI-C Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_cpic.htm) → 

COMMUNICATION

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_shortref.htm)

Obsolete Syntax

COMMUNICATION [comstep](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_comstep.htm) ID id *\[* [cpic\_options](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_options.htm)*\]*.

Effect

This statement enables cross-system communication between two ABAP programs, or between an ABAP program and a program written in another programming language. The whole communication process takes place in individual communication steps, which involve repeated execution of the COMMUNICATION statement with the corresponding additions [comstep](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_comstep.htm). For both partner programs, communication is based on the [CPI-C](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencpi-c_glosry.htm "Glossary Entry") interface, which has been defined as a communication standard by IBM as a part of the SAA standard. This interface provides the following functions in the form of the CPI-C starter set:

-   Creating, accepting, and closing a connection
    
-   Sending and receiving data
    

Coordination of the individual communication steps, recording any errors that occur in the database table TCPIC and, if necessary, data conversion, take place in the individual programs themselves. The parameters that determined the physical partner system for a connection are administrated in the database table TXCOM.

Once the connection is initialized, the system writes an eight-digit connection number in the data object id. This number can be used to identify individual connections. As standard, 2\*\*16 connections are possible for each calling program. id expects only [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like data types, with a minimum length of eight digits.

After initialization, the connection must be created. Then, in the first connection step, all the necessary administration data is sent to the partner system. The data sent in this connection step must have a specific structure and must be available in an [EBCDIC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenebcdic_glosry.htm "Glossary Entry") format. The example below shows how a specifically formed structure can be converted into the EBCDIC format. The subsequent response also exists in EBCDIC format. After this initial connection has been established, data can be transferred without the need for further conversion.

In communications, the [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry") in the called program must not be changed. Screen output is ignored or, in the case of list output to the SAP spool system, is diverted if the statement NEW-PAGE is entered beforehand. [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_glosry.htm "Glossary Entry") of types I, S, and W are ignored, while types A and E cause the program to terminate.

Notes

-   The statement COMMUNICATION is not supported in classes and should not appear in programs anymore, since support for the direct programming of the CPI-C interface has largely been discontinued. Instead, only the [RFC interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_interface_glosry.htm "Glossary Entry") is to be used for communication between programs. However, the function of the statement is maintained for supporting existing programs and for internal purposes.
    
-   The EBCDIC format is used in the first connection step because the CPI-C interface was mainly used for connections to R/2 systems.
    

Example

In the simplest case, an ABAP program calls a subroutine in an ABAP program of another [AS ABAP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_nw_abap_glosry.htm "Glossary Entry"). To enable this, the calling program must register on the other system by specifying the type of CPI-C service, the logon data, the programs and subroutines, and the type of error handling. The registration is performed by sending a specific structure to the other system in EBCDIC format.

The following example shows a schematic representation of the communication between two ABAP programs P1 and P2 without querying return values. The calling program P1 first creates the connection and sends a field connect\_xstr that contains the content of the connect structure converted into EBCDIC format, with the necessary data. After the connection is confirmed by P2, P1 sends the actual, unconverted application data in the buffer b. When this data has been received, P2 sends a confirmation to P1. The connection from P1 is then closed again and the content of the buffer ("Answer") is produced as output.

PROGRAM p1.
DATA: d    TYPE c LENGTH 8,
      id   TYPE c LENGTH 8,
      b TYPE c LENGTH 10,
      len  TYPE x LENGTH 4,
      dat  TYPE xstring,
      stat TYPE xstring,
      BEGIN OF connect,
        header   TYPE c LENGTH 12 VALUE 'CONNCPIC1',
        client   TYPE c LENGTH  3 VALUE '001',
        user     TYPE c LENGTH 12 VALUE 'BONDJ',
        password TYPE c LENGTH  8 VALUE '007',
        language TYPE c LENGTH  1 VALUE 'E',
        corr     TYPE c LENGTH  1 VALUE ' ',
        program  TYPE c LENGTH  8 VALUE 'P2',
        routine  TYPE c LENGTH 30 VALUE 'CPIC\_START',
      END OF connect,
      connect\_str  TYPE c LENGTH 75,
      connect\_xstr TYPE x LENGTH 75,
      connect\_ret  TYPE x LENGTH 75,
      converter TYPE REF TO cl\_abap\_conv\_out\_ce.
connect\_str = connect.
converter = cl\_abap\_conv\_out\_ce=>create( encoding = '0101' ).
converter->write( data = connect\_str ).
connect\_xstr = converter->get\_buffer( ).
d = ...
COMMUNICATION INIT
  DESTINATION d
  ID id.
COMMUNICATION ALLOCATE
  ID id.
COMMUNICATION SEND
  BUFFER connect\_xstr
  ID id.
                        PROGRAM p2.
                        DATA:
                          id   TYPE c LENGTH 8,
                          b TYPE c LENGTH 10,
                          len  TYPE x LENGTH 4,
                          dat  TYPE xstring,
                          stat TYPE xstring.
                        FORM cpic\_start.
                          COMMUNICATION ACCEPT
                            ID id.
COMMUNICATION RECEIVE
  BUFFER     connect\_ret
  DATAINFO   dat
  STATUSINFO stat
  RECEIVED   len
  ID id.
b = 'Request'.
COMMUNICATION SEND
  BUFFER b
  ID id.
                          COMMUNICATION RECEIVE
                            BUFFER     b
                            RECEIVED   len
                            DATAINFO   dat
                            STATUSINFO stat
                            ID         id.
                          IF b = 'Request'.
                            b = 'Answer'.
                          ENDIF.
                          COMMUNICATION SEND
                            BUFFER     b
                            ID         id.
                        ENDFORM.
CLEAR b.
COMMUNICATION RECEIVE
  BUFFER     b
  DATAINFO   dat
  STATUSINFO stat
  RECEIVED   len
  ID         id.
WRITE / b.
COMMUNICATION DEALLOCATE ID id.

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Non-Handleable Exceptions

-   Cause: No authorization to accept a CPIC connection.
    Runtime error: COMMUNICATION\_ACCEPT\_NO\_AUTH
    
-   Cause: No authorization to open a CPIC connection.
    Runtime error: COMMUNICATION\_INIT\_NO\_AUTH
    

Continue
[COMMUNICATION - comstep](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_comstep.htm)
[COMMUNICATION - cpic\_options](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_options.htm)


### abapcommunication_comstep.htm

---
title: "COMMUNICATION - comstep"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_shortref.htm) Obsolete Syntax ... INIT DESTINATION dest  ALLOCATE  ACCEPT  SEND BUFFER buf  RECEIVE BUFFER buf DATAINFO dat STATUSINFO stat  DEALLOCATE ... Alternatives: 1
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_comstep.htm"
abapFile: "abapcommunication_comstep.htm"
keywords: ["do", "if", "try", "data", "types", "abapcommunication", "comstep"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) →  [CPI-C Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_cpic.htm) →  [COMMUNICATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication.htm) → 

COMMUNICATION - comstep

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_shortref.htm)

Obsolete Syntax

... *{*INIT DESTINATION dest*}*
  *|* ALLOCATE
  *|* ACCEPT
  *|* *{*SEND BUFFER buf*}*
  *|* *{*RECEIVE BUFFER buf DATAINFO dat STATUSINFO stat*}*
  *|* DEALLOCATE ...

Alternatives:

[1\. ... INIT DESTINATION dest](#!ABAP_ALTERNATIVE_1@1@)
[2\. ... ALLOCATE](#!ABAP_ALTERNATIVE_2@2@)
[3\. ... ACCEPT](#!ABAP_ALTERNATIVE_3@3@)
[4\. ... SEND BUFFER buf](#!ABAP_ALTERNATIVE_4@4@)
[5\. ... RECEIVE BUFFER buf DATAINFO dat STATUSINFO stat](#!ABAP_ALTERNATIVE_5@5@)
[6\. ... DEALLOCATE](#!ABAP_ALTERNATIVE_6@6@)

Effect

There are different alternatives for specifying comstep, each of which is responsible for a connection step.

Alternative 1

... INIT DESTINATION  dest

Effect

The connection between the programs initialized by specifying dest. dest expects a [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like data object of the length 8 and, when executing the statement, the data object contains a value from the column SDEST of the database table TXCOM.

On initialization, the system automatically executes an authorization check on the [authorization object](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenauthorization_object_glosry.htm "Glossary Entry") S\_CPIC. The authorization can be checked before the connection is established using the function module AUTHORITY\_CHECK\_CPIC.

Alternative 2

... ALLOCATE

Effect

Establishes a connection to the partner identified in the previous addition DESTINATION. At the same time, a start request is passed to the partner, if it is a program.

Alternative 3

... ACCEPT

Effect

This addition can be used to accept the established connection in a called partner program. After authentication, the called program is in receive status.

Alternative 4

... SEND BUFFER buf

Effect

Sends data to the partner program. A data object can be specified for buf, for which all [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") elementary types are permitted and the memory requirement of 32000 bytes cannot be exceeded. If the statement COMMUNICATION is executed, the content of buf is passed to the partner program.

Notes

-   A connection step opened with SEND must be followed by a connection step opened with RECEIVE.
    
-   Information loss, for example as a result of different number formats between the communication partners, is avoided if only character-like types are used for transferring the data. Furthermore, the data is only transferred completely if the sending and receiving buffers have the same structure and length.
    

Alternative 5

... RECEIVE BUFFER buf DATAINFO dat STATUSINFO stat

Effect

Receives data from the partner program. A data object can be specified for buf, for which all flat elementary types are permitted and the memory requirement of 32000 bytes cannot be exceeded. On execution of the statement COMMUNICATION, the content of buf is received by the partner program.

After the execution of the statement, the data object dat contains information about whether the data is sent completely and the content of the data object stat indicates whether the current program is in send or receive mode. Only byte-like data objects are allowed for dat and stat, the length should not be less than 4 bytes. The encoding for the values in dat and stat can be extracted from the [include program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninclude_program_glosry.htm "Glossary Entry") RSCPICDF. Here, data objects with a descriptive name and [start values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstart_value_glosry.htm "Glossary Entry") are declared which can be compared with dat and stat.

Note

A connection step opened with RECEIVE must be followed by a connection step opened with SEND.

Alternative 6

... DEALLOCATE

Effect

The connection is terminated and all memory areas are released.


### abapcommunication_options.htm

---
title: "Obsolete Syntax"
description: |
  ... RETURNCODE rc LENGTH leng RECEIVED rec HOLD. Extras: 1. ... RETURNCODE  rc(#!ABAP_ADDITION_1@1@) 2. ... LENGTH leng(#!ABAP_ADDITION_2@2@) 3. ... RECEIVED rec(#!ABAP_ADDITION_3@3@) 4. ... HOLD(#!ABAP_ADDITION_4@4@) Effect Additional additions for the st
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_options.htm"
abapFile: "abapcommunication_options.htm"
keywords: ["do", "if", "case", "try", "data", "abapcommunication", "options"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) →  [CPI-C Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_cpic.htm) →  [COMMUNICATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication.htm) → 

COMMUNICATION - cpic\_options

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_shortref.htm)

Obsolete Syntax

... *\[*RETURNCODE rc*\]*
    *\[*LENGTH leng*\]*
    *\[*RECEIVED rec*\]*
    *\[*HOLD*\]*.

Extras:

[1\. ... RETURNCODE  rc](#!ABAP_ADDITION_1@1@)
[2\. ... LENGTH leng](#!ABAP_ADDITION_2@2@)
[3\. ... RECEIVED rec](#!ABAP_ADDITION_3@3@)
[4\. ... HOLD](#!ABAP_ADDITION_4@4@)

Effect

Additional additions for the statement COMMUNICATION.

Addition 1

... RETURNCODE  rc

Effect

This addition can be specified for any communication steps and receives the return code in rc. rc expects the data type i. The meaning of the return codes is encoded in the [include program](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninclude_program_glosry.htm "Glossary Entry") RSCPICDF. Here, data objects with descriptive names and [start values](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstart_value_glosry.htm "Glossary Entry") are declared and can be compared with rc. The following table contains a list of possible return codes.

rc

Data Object from RSCPICDF

0

CM\_OK

1

CM\_ALLOCATE\_FAILURE\_NO\_RETRY

2

CM\_ALLOCATE\_FAILURE\_RETRY

3

CM\_CONVERSATION\_TYPE\_MISMATCH

6

CM\_SECURITY\_NOT\_VALID

8

CM\_SYNC\_LVL\_NOT\_SUPPORTED\_PGM

9

CM\_TPN\_NOT\_RECOGNIZED

10

CM\_TP\_NOT\_AVAILABLE\_NO\_RETRY

11

CM\_TP\_NOT\_AVAILABLE\_RETRY

12

CM\_DEALLOCATED\_ABEND

13

CM\_DEALLOCATED\_NORMAL

14

CM\_PARAMETER\_ERROR

15

CM\_PRODUCT\_SPECIFIC\_ERROR

16

CM\_PROGRAM\_ERROR\_NO\_TRUNC

18

CM\_PROGRAM\_ERROR\_NO\_TRUNC

19

CM\_PROGRAM\_ERROR\_TRUNC

26

CM\_RESOURCE\_FAILURE\_NO\_RETRY

27

CM\_RESOURCE\_FAILURE\_RETRY

28

CM\_UNSUCCESSFUL

The same return codes are also written to the system field sy-subrc.

Addition 2

... LENGTH leng

Effect

This addition can only be specified in the communication steps SEND and RECEIVE. As a result, the data buffer buffer is only sent or received in the length leng. The length leng expects a data object of the data type i.

Addition 3

... RECEIVED rec

Effect

This addition can only be specified for the communication step RECEIVE. The data object rec contains the number of bytes received by the partner program. Only byte-like data objects of length 4 are allowed for rec.

Addition 4

... HOLD

Effect

This addition can only be specified for the communication step RECEIVE. It prevents the [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry") being changed when receiving data to avoid the possible loss of the [database cursor](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendatabase_cursor_glosry.htm "Glossary Entry"). In this case, the current work process waits until all data has been received.


### abapcommunication.htm

---
title: "COMMUNICATION"
description: |
  Quick Reference(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_shortref.htm) Obsolete Syntax COMMUNICATION comstep(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_comstep.htm) ID id  cpic_options(https://help.sap.com/doc/abapdocu_
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication.htm"
abapFile: "abapcommunication.htm"
keywords: ["do", "while", "if", "case", "try", "class", "data", "types", "abapcommunication"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) →  [CPI-C Interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_cpic.htm) → 

COMMUNICATION

[Quick Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_shortref.htm)

Obsolete Syntax

COMMUNICATION [comstep](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_comstep.htm) ID id *\[* [cpic\_options](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_options.htm)*\]*.

Effect

This statement enables cross-system communication between two ABAP programs, or between an ABAP program and a program written in another programming language. The whole communication process takes place in individual communication steps, which involve repeated execution of the COMMUNICATION statement with the corresponding additions [comstep](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_comstep.htm). For both partner programs, communication is based on the [CPI-C](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencpi-c_glosry.htm "Glossary Entry") interface, which has been defined as a communication standard by IBM as a part of the SAA standard. This interface provides the following functions in the form of the CPI-C starter set:

-   Creating, accepting, and closing a connection
    
-   Sending and receiving data
    

Coordination of the individual communication steps, recording any errors that occur in the database table TCPIC and, if necessary, data conversion, take place in the individual programs themselves. The parameters that determined the physical partner system for a connection are administrated in the database table TXCOM.

Once the connection is initialized, the system writes an eight-digit connection number in the data object id. This number can be used to identify individual connections. As standard, 2\*\*16 connections are possible for each calling program. id expects only [flat](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenflat_glosry.htm "Glossary Entry") character-like data types, with a minimum length of eight digits.

After initialization, the connection must be created. Then, in the first connection step, all the necessary administration data is sent to the partner system. The data sent in this connection step must have a specific structure and must be available in an [EBCDIC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenebcdic_glosry.htm "Glossary Entry") format. The example below shows how a specifically formed structure can be converted into the EBCDIC format. The subsequent response also exists in EBCDIC format. After this initial connection has been established, data can be transferred without the need for further conversion.

In communications, the [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry") in the called program must not be changed. Screen output is ignored or, in the case of list output to the SAP spool system, is diverted if the statement NEW-PAGE is entered beforehand. [Messages](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmessage_glosry.htm "Glossary Entry") of types I, S, and W are ignored, while types A and E cause the program to terminate.

Notes

-   The statement COMMUNICATION is not supported in classes and should not appear in programs anymore, since support for the direct programming of the CPI-C interface has largely been discontinued. Instead, only the [RFC interface](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_interface_glosry.htm "Glossary Entry") is to be used for communication between programs. However, the function of the statement is maintained for supporting existing programs and for internal purposes.
    
-   The EBCDIC format is used in the first connection step because the CPI-C interface was mainly used for connections to R/2 systems.
    

Example

In the simplest case, an ABAP program calls a subroutine in an ABAP program of another [AS ABAP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_nw_abap_glosry.htm "Glossary Entry"). To enable this, the calling program must register on the other system by specifying the type of CPI-C service, the logon data, the programs and subroutines, and the type of error handling. The registration is performed by sending a specific structure to the other system in EBCDIC format.

The following example shows a schematic representation of the communication between two ABAP programs P1 and P2 without querying return values. The calling program P1 first creates the connection and sends a field connect\_xstr that contains the content of the connect structure converted into EBCDIC format, with the necessary data. After the connection is confirmed by P2, P1 sends the actual, unconverted application data in the buffer b. When this data has been received, P2 sends a confirmation to P1. The connection from P1 is then closed again and the content of the buffer ("Answer") is produced as output.

PROGRAM p1.
DATA: d    TYPE c LENGTH 8,
      id   TYPE c LENGTH 8,
      b TYPE c LENGTH 10,
      len  TYPE x LENGTH 4,
      dat  TYPE xstring,
      stat TYPE xstring,
      BEGIN OF connect,
        header   TYPE c LENGTH 12 VALUE 'CONNCPIC1',
        client   TYPE c LENGTH  3 VALUE '001',
        user     TYPE c LENGTH 12 VALUE 'BONDJ',
        password TYPE c LENGTH  8 VALUE '007',
        language TYPE c LENGTH  1 VALUE 'E',
        corr     TYPE c LENGTH  1 VALUE ' ',
        program  TYPE c LENGTH  8 VALUE 'P2',
        routine  TYPE c LENGTH 30 VALUE 'CPIC\_START',
      END OF connect,
      connect\_str  TYPE c LENGTH 75,
      connect\_xstr TYPE x LENGTH 75,
      connect\_ret  TYPE x LENGTH 75,
      converter TYPE REF TO cl\_abap\_conv\_out\_ce.
connect\_str = connect.
converter = cl\_abap\_conv\_out\_ce=>create( encoding = '0101' ).
converter->write( data = connect\_str ).
connect\_xstr = converter->get\_buffer( ).
d = ...
COMMUNICATION INIT
  DESTINATION d
  ID id.
COMMUNICATION ALLOCATE
  ID id.
COMMUNICATION SEND
  BUFFER connect\_xstr
  ID id.
                        PROGRAM p2.
                        DATA:
                          id   TYPE c LENGTH 8,
                          b TYPE c LENGTH 10,
                          len  TYPE x LENGTH 4,
                          dat  TYPE xstring,
                          stat TYPE xstring.
                        FORM cpic\_start.
                          COMMUNICATION ACCEPT
                            ID id.
COMMUNICATION RECEIVE
  BUFFER     connect\_ret
  DATAINFO   dat
  STATUSINFO stat
  RECEIVED   len
  ID id.
b = 'Request'.
COMMUNICATION SEND
  BUFFER b
  ID id.
                          COMMUNICATION RECEIVE
                            BUFFER     b
                            RECEIVED   len
                            DATAINFO   dat
                            STATUSINFO stat
                            ID         id.
                          IF b = 'Request'.
                            b = 'Answer'.
                          ENDIF.
                          COMMUNICATION SEND
                            BUFFER     b
                            ID         id.
                        ENDFORM.
CLEAR b.
COMMUNICATION RECEIVE
  BUFFER     b
  DATAINFO   dat
  STATUSINFO stat
  RECEIVED   len
  ID         id.
WRITE / b.
COMMUNICATION DEALLOCATE ID id.

[Exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_language_exceptions.htm)

Non-Handleable Exceptions

-   Cause: No authorization to accept a CPIC connection.
    Runtime error: COMMUNICATION\_ACCEPT\_NO\_AUTH
    
-   Cause: No authorization to open a CPIC connection.
    Runtime error: COMMUNICATION\_INIT\_NO\_AUTH
    

Continue
[COMMUNICATION - comstep](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_comstep.htm)
[COMMUNICATION - cpic\_options](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication_options.htm)


### abenabap_cpic.htm

---
title: "CPI-C Interface"
description: |
  This section describes cross-system communications between two ABAP programs as realized using the COMMUNICATION(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication.htm) statement. Note SDK for CPI-C is no longer supported. The CPI-C libraries and the documentation for pro
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_cpic.htm"
abapFile: "abenabap_cpic.htm"
keywords: ["do", "try", "data", "abenabap", "cpic"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) → 

CPI-C Interface

This section describes cross-system communications between two ABAP programs as realized using the [COMMUNICATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication.htm) statement.

Note

SDK for CPI-C is no longer supported. The CPI-C libraries and the documentation for programming are no longer delivered. For new programs, SDK and the libraries for [RFC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenrfc_glosry.htm "Glossary Entry") must be used. The API for CPI-C was retained to support existing programs and for internal technical purposes.

Continue
[COMMUNICATION](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abapcommunication.htm)


### abenabap_java_script.htm

---
title: "ABAP and JavaScript"
description: |
  In the kernel of an AS ABAP, a JavaScript (JS) Engine is integrated, in which execute JavaScript programs can be executed either in normal or in debugging mode (server-side scripting). The JavaScript (JS) Engine used supports JavaScript Version 1.5. Proxies can be used to bind script variables to da
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_java_script.htm"
abapFile: "abenabap_java_script.htm"
keywords: ["do", "method", "class", "data", "abenabap", "java", "script"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP − Reference](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obsolete.htm) →  [Obsolete Data and Communication Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenextern_obsolete.htm) → 

ABAP and JavaScript

In the kernel of an AS ABAP, a JavaScript (JS) Engine is integrated, in which execute JavaScript programs can be executed either in normal or in debugging mode (server-side scripting). The JavaScript (JS) Engine used supports JavaScript Version 1.5. Proxies can be used to bind script variables to data objects in ABAP programs.

The class CL\_JAVA\_SCRIPT realizes an API, which can be used in ABAP programs, for the JavaScript (JS) Engine implemented in the kernel. This class encapsulates the JavaScript C Engine API and makes methods and attributes available to the ABAP programmer to perform JavaScript programs.

Note

Support for the binding of JavaScript to ABAP is scheduled to be stopped. This means that the class CL\_JAVA\_SCRIPT can no longer be used.

Example

The program DEMO\_JAVA\_SCRIPT\_MINI\_EDITOR is an example of a minimal JavaScript editor in which JavaScript programs can be edited, executed, and tested. This program was created using ABAP methods only and uses the class CL\_JAVA\_SCRIPT.


---


## ABAP Keyword Documentation / ABAP Programming Guidelines / Architecture / Object-Oriented Programming

**Files**: 8 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP Programming Guidelines / Architecture / Object-Oriented Programming

Included pages: 8


### abenobj_oriented_guidl.htm

---
title: "Object-Oriented Programming"
description: |
  Achieving an optimal object-oriented design is not an easy task and this is not the subject of these programming guidelines. It is definitely worth consulting the relevant literature for this topic. The rules below are limited to basic recommendations (for making source codes easier to understand an
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobj_oriented_guidl.htm"
abapFile: "abenobj_oriented_guidl.htm"
keywords: ["do", "if", "method", "class", "data", "types", "internal-table", "abenobj", "oriented", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) → 

Object-Oriented Programming

Achieving an optimal object-oriented design is not an easy task and this is not the subject of these programming guidelines. It is definitely worth consulting the relevant literature for this topic. The rules below are limited to basic recommendations (for making source codes easier to understand and maintain) and ABAP specifics on working with global and local classes.

Developers who have experience with object-oriented development in other programming languages should be aware of the differences between ABAP Objects and Java:

-   In Java, all superior data objects (especially container variables such as strings) are modeled using classes. By contrast, ABAP provides very powerful, predefined types. Besides the predefined ABAP strings, internal tables are also provided that are used for structured data storage. These tables represent the most powerful ABAP type. Therefore, it is generally not beneficial to implement own container types using ABAP classes.

-   Java reaches a high processing speed for methods, by using optimizations and JIT compilation. In ABAP, however, the high processing speed is primarily attained using very powerful and complex individual statements. This is another reason why implementing own container classes is usually not beneficial. Direct access to a suitable internal table, for example, is always faster than handwritten access logic in ABAP.

Of course, you can transfer algorithms and a general class structure to ABAP, from an application written in another object-oriented programming language. However, the greater the depth, the greater the differences. Therefore, you need to make appropriate modifications, in order to transfer a detailed design in a different language to ABAP Objects.

-   [Encapsulation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenencapsulation_guidl.htm "Guideline")

-   [Modularization](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmodularization_guidl.htm "Guideline")

-   [Static Classes and Singletons](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_class_singleton_guidl.htm "Guideline")

-   [Inheritance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninheritance_guidl.htm "Guideline")

-   [Class References and Interface References](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ref_interf_ref_guidl.htm "Guideline")

-   [Local Types for Global Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlocal_type_glob_class_guidl.htm "Guideline")

-   [Instance Constructor](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_constructor_guidl.htm "Guideline")

Continue
[Encapsulation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenencapsulation_guidl.htm)
[Modularization](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmodularization_guidl.htm)
[Static Classes and Singletons](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_class_singleton_guidl.htm)
[Inheritance](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninheritance_guidl.htm)
[Class References and Interface References](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ref_interf_ref_guidl.htm)
[Local Types for Global Classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlocal_type_glob_class_guidl.htm)
[Instance Constructor](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_constructor_guidl.htm)


### abenencapsulation_guidl.htm

---
title: "Encapsulation"
description: |
  Background A program that is created based on the procedural programming model and that includes many procedures and global variables is usually difficult to understand because the numerous possible interdependencies of these publicly accessible variables and procedures are difficult to comprehend .
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenencapsulation_guidl.htm"
abapFile: "abenencapsulation_guidl.htm"
keywords: ["do", "if", "method", "class", "data", "abenencapsulation", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) →  [Object-Oriented Programming](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobj_oriented_guidl.htm) → 

Encapsulation

Background

A program that is created based on the procedural programming model and that includes many procedures and global variables is usually difficult to understand because the numerous possible interdependencies of these publicly accessible variables and procedures are difficult to comprehend . The object-oriented approach solves this particular problem by providing visibility sections that are not public. This enables readers who want to get an overview of how the software functions to restrict the overview to the public interfaces of the classes involved. The non-public visibility sections only contain details of the implementation that are not important for a view from the outside.

Of course, this clear overview benefit is only realized in places where the developer makes use of the non-public visibility sections. The same applies to the non-public object generation and final classes, where it is becomes immediately clear whether objects can also be generated outside of the class or whether derived classes can exist.

For the development or the design of an application, it is useful to encapsulate as restrictively as possible initially, and to undo the encapsulation only where required.

Rule

Exploit the benefits of encapsulation

Utilize the encapsulation options provided in the form of non-public visibility sections, non-public object generation, and final classes as much as possible. The use of units that are encapsulated in such a way should preferably be free of side effects.

Details

This simple rule provides practical access to object-oriented programming that results in programs that are more robust and more easily maintainable than if you use procedural ABAP, and without a prolonged object-oriented design phase. To use encapsulation appropriately, do the following:

-   Keep the number of public components of a class as small as possible (components that may be private or protected should therefore be created in the corresponding visibility section as well).

-   Declare public attributes only as READ-ONLY.

-   Consider the private instantiation of classes.

-   Mark classes that are not intended as superclasses as [FINAL](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninheritance_guidl.htm "Guideline").

Conversely, within an encapsulated unit, that is, within a class, you should avoid accessing more global data directly. Within methods, you should generally modify attributes of the class only. Write access to global data outside the class is not recommended. Accessing data in this way should only be done using specially marked methods, if at all. The use of methods of a class should not evoke any side effects outside the class itself.


### abenmodularization_guidl.htm

---
title: "Modularization"
description: |
  Background The main programming model that was propagated before the implementation of ABAP Objects was structured programming: -   In this model, the programs are split into procedures as appropriate. -   Sequences, branches, and loops are the only control structures permitted. The implementation o
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmodularization_guidl.htm"
abapFile: "abenmodularization_guidl.htm"
keywords: ["loop", "do", "while", "if", "case", "method", "class", "data", "internal-table", "abenmodularization", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) →  [Object-Oriented Programming](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobj_oriented_guidl.htm) → 

Modularization

Background

The main programming model that was propagated before the implementation of ABAP Objects was structured programming:

-   In this model, the programs are split into procedures as appropriate.

-   Sequences, branches, and loops are the only control structures permitted.

The implementation of object-oriented programming languages such as ABAP Objects does not make structured programming obsolete. Object-oriented programming is based on the structured programming and enhances and supplements it.

With regard to ABAP, you must note that ABAP is still a programming language of the fourth generation (4GL) that has been developed especially for application programming in the SAP environment, that is, for mass data processing in business applications. Therefore, ABAP includes significantly more language elements than an elementary programming language in which the more complex functions are usually stored in libraries. This ranges from simple statements for string processing, which are provided as methods of string classes in other object-oriented languages such as Java, to the processing of complex mass data objects, such as internal tables, to very complex statements for operating interfaces such as ABAP SQL or for calling data transformations (XML), for which other languages have entire class hierarchies.

As already [mentioned](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobj_oriented_guidl.htm "Guideline"), the performance of the ABAP language is therefore optimized mainly for the execution of its complex statements for mass data processing and less for the individual method call.

Rule

Modularize rather than atomize

Modularize your program in classes, but not to the extent that there is an individual method for every trivial function. Methods that consist of only one or just a few statements should be an exception in ABAP and not the rule.

Details

You should only use [methods of ABAP Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") for the implementation of functions; there are very good reasons for this. But ABAP remains ABAP, and the good reasons for using a well-structured program are not invalidated by the implementation of ABAP Objects. Indeed, the ABAP language elements proven and tested in so many application cases are still valid today, are undergoing continuously development, and should be used in their present form in ABAP Objects as well.

A well-structured classic ABAP program, for instance a function group that fulfills a specific task and is modularized using subroutines, should therefore be transferable to a class without any major changes to the implementation, while being provided with all the additional benefits of ABAP Objects.

However, the modularization at the level of a few single statements is and will remain untypical for ABAP. On the one hand this is because of performance reasons, because the costs for the method call must remain low in comparison to the costs for executing the implementation. For example, instead of providing the get\_attribute methods typical for other object-oriented languages that only set their return value to the value of an attribute attribute, you should use public READ-ONLY attributes in ABAP. (If reads on an attribute are associated with further actions, for example, authorization checks, get\_attribute methods are appropriate of course.) On the other hand, virtually all non-fundamental statements of ABAP (all language elements that do not have any equivalent in an elementary language like Java) already play the same role that the methods of system classes assume in other programming languages. The use of a statement like this corresponds to a method call, and another encapsulation is usually not necessary.

Also, for legibility and maintainability reasons, a method with a [reasonable size](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenproc_volume_guidl.htm "Guideline") is preferable to splitting into atomic units, that is, into methods with only one or two statements.

Exception

Procedures that encapsulate nothing but the call of another procedure are an exception. A single procedure call represents the implementation of an entire procedure. This applies in particular to function modules and subroutines, which can only be created in [exceptional cases](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") anyway. They should include exactly one [method call](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunct_module_subroutine_guidl.htm "Guideline"), which delegates the implementation to ABAP Objects. In this case, the improved security through the stricter checks in ABAP Objects outweighs the disadvantages of very short procedures.

Bad Example

The following source code shows the rudimentary implementation of a string class in ABAP Objects. The methods of this class each contain only a single statement. A consumer must create objects of the class and call the methods to handle the strings.

CLASS cl\_string DEFINITION PUBLIC.
   PUBLIC SECTION.
     METHODS:
       constructor IMPORTING value        TYPE string OPTIONAL,
       set\_string  IMPORTING value        TYPE string,
       get\_string  RETURNING VALUE(value) TYPE string,
       shift\_left  IMPORTING places       TYPE i,
       shift\_right IMPORTING places       TYPE i,
       ...
    PRIVATE SECTION.
      DATA string TYPE string.
ENDCLASS.

CLASS cl\_string IMPLEMENTATION.
   METHOD constructor.
     string = value.
   ENDMETHOD.
   METHOD set\_string.
     string = value.
   ENDMETHOD.
   METHOD get\_string.
     value = string.
   ENDMETHOD.
   METHOD shift\_left.
     SHIFT string LEFT BY places PLACES.
   ENDMETHOD.
   METHOD shift\_right.
     SHIFT string RIGHT BY places PLACES.
   ENDMETHOD.
   ...
ENDCLASS.
...

CLASS application IMPLEMENTATION.
  ...
   METHOD do\_something.
     DATA string TYPE REF TO cl\_string.
     CREATE OBJECT string EXPORTING value = 'abcde'.
     ...
     string->shift\_left( ... ).
     ...
    ENDMETHOD.
  ...
ENDCLASS.

Good Example

The following source code shows the handling of strings typical to ABAP. A method directly declares a data object of type string and directly uses the corresponding ABAP statements for processing.

CLASS application IMPLEMENTATION.
  ...
   METHOD do\_something.
     DATA string TYPE string.
     ...
     SHIFT string LEFT BY ... PLACES.
     ...
   ENDMETHOD.
  ...
ENDCLASS.

There is a corresponding built-in function for almost every string processing statement. They can also be used in operand positions, negating another reason for the encapsulation of statements in methods. The statement SHIFT LEFT in this example can be replaced as follows, whereas shift\_left is a built-in function:

string = shift\_left( val = string places = ... ).


### abenstatic_class_singleton_guidl.htm

---
title: "Static Classes and Singletons"
description: |
  Background The classes of ABAP Objects support two types of components: -   Instance components (instance attributes, instance events and instance methods). You can only address the instance components of a class using instances of the class (objects). -   Static components (static attributes, stati
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_class_singleton_guidl.htm"
abapFile: "abenstatic_class_singleton_guidl.htm"
keywords: ["delete", "do", "if", "case", "try", "catch", "method", "class", "data", "types", "abenstatic", "singleton", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) →  [Object-Oriented Programming](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobj_oriented_guidl.htm) → 

Static Classes and Singletons

Background

The classes of ABAP Objects support two types of components:

-   Instance components (instance attributes, instance events and instance methods). You can only address the instance components of a class using instances of the class (objects).

-   Static components (static attributes, static events and static methods). The static components of a class can be addressed using an object and also using the name of the class. This means they can be used independently of a class instance.

A class that only contains static components and no instance components is referred to as a static class. A global static class is loaded once with its class pool into the current [internal session](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninternal_session_glosry.htm "Glossary Entry"). Like every ABAP program, it cannot be explicitly deleted from the session. The static methods (declared using CLASS-METHODS) of a class cannot be redefined in subclasses.

A singleton is a design pattern where the class has the task of creating objects. The class ensures that only one object exists for every internal session that is made available to consumers.

Rule

Do not use static classes

Use objects instead of static classes. If you do not want multiple instantiation, you can use singletons.

Details

If no real object-oriented design exists that would use the multiple instantiation of classes, for example, this often produces classes that only contain static methods (declared using CLASS-METHODS), when [ABAP Objects](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") are used. These methods are then used as simple procedures. However, even if multiple instantiation is not explicitly required, object creation is preferable to the use of static classes, for the reasons listed below. You can use the singleton design pattern to prevent multiple instantiation:

-   Explicit object creation is essential for object-oriented programming. Static classes, however, are implicitly loaded the first time they are used, and the corresponding static constructor — if available — is executed. They are persisted in the memory for as long as the current internal session exists. Therefore, if you use static classes, you cannot actually control the time of initialization. You have no way of releasing the memory occupied by the attributes, as soon as the class function is no longer required.

-   Another important argument against the use of static classes are the limited functions of the static constructor, in comparison to an instance constructor. A static constructor has no parameter interface and cannot propagate any [exceptions](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenerror_handling_guidl.htm "Guideline"). This is why you cannot always respond appropriately to an error situation in the static constructor, which can cause a runtime error in extreme cases. However, the exceptions of an instance constructor can be handled.

-   By using static classes, you restrict your polymorphism options, which are actually provided by object-oriented programming. On the one hand, you cannot redefine static methods. On the other hand, access is not possible using reference variables (the other “pillar” of polymorphism). However, it is worth keeping the option of polymorphism open:

-   Even if you initially do not plan to overwrite the behavior of a method later on using inheritance or redefinition, this is a request that frequently arises in the course of the further development.

-   When implementing unit tests with ABAP Unit, redefining the behavior of certain methods, to resolve problematic dependencies, is often unavoidable.

To keep the option of redefinition open, you should always use instance methods instead of static methods.

You can express the retrieval of a singleton object and the subsequent call of an instance method, by using the very compact form of a chained method call:

cl\_singleton=>get\_instance( )->do\_something( ).

Since an additional object reference variable and an additional factory call are omitted, there are no aesthetic disadvantages related to the use of a singleton design pattern.

Exception

Classes that only cover trivial functions can still be implemented as static classes. Here you must accurately assess whether one of the previously mentioned aspects has any effect. The need for a class constructor can be an indicator here. Once a static class requires a nontrivial class constructor to provide the required functions, you should use objects instead.

Bad Example

The following source code shows a static class with purely static methods and how one of these methods is used. In general, it is not immediately obvious from the source code whether the method call also calls the static constructor or whether this has already happened earlier (following a simple attribute access, for example).

CLASS static\_class DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: class\_constructor,
                   meth1,
                   meth2,
                   ...
ENDCLASS.
...
static\_class=>meth1( ).
...

Good Example

The following source code shows an implementation of the singleton design pattern. A static method allows access to the only object of the class.

CLASS singleton\_class DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    CLASS-METHODS get\_instance
    RETURNING VALUE(r\_instance) TYPE REF TO singleton\_class
    RAISING cx\_some\_failure.
  METHODS constructor
    RAISING cx\_some\_failure.
  METHODS: meth1,
           meth2.
           ...
  PRIVATE SECTION.
    CLASS-DATA instance TYPE REF TO singleton\_class.
ENDCLASS.

CLASS singleton\_class IMPLEMENTATION.
  METHOD get\_instance.
    IF instance IS NOT BOUND.
      CREATE OBJECT instance.
    ENDIF.
    r\_instance = instance.
  ENDMETHOD.
  ...
ENDCLASS.

...
  TRY.
     singleton\_class=>get\_instance( )->meth1( ).
   CATCH cx\_some\_failure.
     ...
  ENDTRY.

In the above example, the get\_instance method is used to return the object reference to the object created with the first call. Therefore, this example would appear to violate the rule [modularize rather than atomize](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenmodularization_guidl.htm "Guideline"). This rule states that no method should be created in ABAP that only returns the value of an attribute. However, this objection is not justified here, because the main task of the get\_instance method is to enable the object consumer to control the time of object creation. This is necessary to enable the consumer to respond (in the usual way) to any exceptional situation during the object creation process.

In special cases, where object creation is performed without parameters and is always successful, you can omit the get\_instance method and publish the object reference using a READ-ONLY attribute. In this case, the object is created within the static constructor. Therefore, this approach is still afflicted with some of the problems of static classes described in other sections.


### abeninheritance_guidl.htm

---
title: "Inheritance"
description: |
  Background Inheritance is the method by which subclasses are derived from a superclass while inheriting the components of the superclass. A subclass can be made more specific by declaring new components and redefining instance methods. ABAP Objects supports simple inheritance, in which a class can h
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninheritance_guidl.htm"
abapFile: "abeninheritance_guidl.htm"
keywords: ["do", "while", "if", "method", "class", "abeninheritance", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) →  [Object-Oriented Programming](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobj_oriented_guidl.htm) → 

Inheritance

Background

Inheritance is the method by which subclasses are derived from a superclass while inheriting the components of the superclass. A subclass can be made more specific by declaring new components and redefining instance methods. ABAP Objects supports simple inheritance, in which a class can have multiple subclasses but only one direct superclass. (Despite this, the interface concept does enable something like multiple inheritance to take place, at least with regard to attributes and method declarations. Method implementations, on the other hand, are not inherited when an interface is included.) This creates an inheritance hierarchy in an inheritance tree, with a unique path running from each subclass to a root class. In ABAP Objects, all classes are subclasses of the predefined abstract root class object. Final classes (classes defined using the addition FINAL) close the bottom of a path in the inheritance tree.

Rule

Avoid using deep inheritance hierarchies

Avoid using deep inheritance hierarchies, since they are often difficult to maintain.

Details

Deep inheritance hierarchies are examples of successful reuse, but are also the source of maintenance problems, due to the complexity inherent in the large number of classes involved.

-   The behavior of classes deep down in the inheritance hierarchy is difficult to predict, since they potentially inherit from a large number of methods.

-   Classes with a lot of subclasses exert great influence on the system as a whole, making the consequences of modifications to a superclass hard to predict.

-   A large number of subclasses may also indicate an unsuitable level of abstraction.

To prevent unintended reuse of your classes by inheritance, we recommend that you use final classes to close the paths of inheritance trees.

Note

If your main aim is to exploit the possibilities of polymorphy, then interfaces are often a preferable solution to inheritance. If all you want to do is use interfaces, then method interfaces should be used instead of abstract classes. These can be used to create composite interfaces. In ABAP, on the other hand, a composite interface is impossible due to the nature of simple inheritance using classes.


### abenclass_ref_interf_ref_guidl.htm

---
title: "Class References and Interface References"
description: |
  Background Interface components in objects can be addressed using a class reference variable or an interface reference variable. If you use a class reference variable, the interface component is addressed using the name of the interface and the interface component selector (~). If you use a suitable
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenclass_ref_interf_ref_guidl.htm"
abapFile: "abenclass_ref_interf_ref_guidl.htm"
keywords: ["select", "do", "if", "method", "class", "data", "abenclass", "ref", "interf", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) →  [Object-Oriented Programming](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobj_oriented_guidl.htm) → 

Class References and Interface References

Background

Interface components in objects can be addressed using a class reference variable or an interface reference variable. If you use a class reference variable, the interface component is addressed using the name of the interface and the interface component selector (~). If you use a suitable interface reference variable, the component is addressed directly using its name.

Rule

Address interface components using interface reference variables

From outside a class, only access its interface components using a relevant interface reference variable; do not use the interface component selector (~).

Details

Accessing interface components externally using an interface reference variable makes code easier to understand because it is clear that the user of the class is interested in exactly the aspect provided by the interface. Accessing interface components using a class reference variable, on the other hand, suggests that components are used that are not provided by an interface. As a rule, only use the interface component selector within classes and interfaces, to address the interfaces included there. If you want to provide an interface component of an included interface as a separate component, you can declare an alias name by using ALIASES.

Bad Example

The following source code shows an interface method call using a class reference variable and the interface component selector (~); this is not recommended, as mentioned in the rule above.

CLASS cl\_class DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if\_intf.
  ...
ENDCLASS.
...
    DATA cref TYPE REF TO cl\_class.
    ...
    cref->if\_intf~meth( ).
    ...

Good Example

The following source code shows the method call from the above example, but using an interface reference variable. Instead of cref->if\_intf~meth, iref->meth is used to express that components of a class are accessed that are on the same hierarchy level as all public components, but in another part of the public interface.

CLASS cl\_class DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if\_intf.
     ...
ENDCLASS.
...
     DATA iref TYPE REF TO if\_intf.
     ...
     iref->meth( ).
     ...


### abenlocal_type_glob_class_guidl.htm

---
title: "Local Types for Global Classes"
description: |
  Background Within class pools, as in virtually any other ABAP program, data types, local interfaces, and local classes can be defined to ensure a better structure of the implementation of the global class. From a technical point of view, these optional declaration parts, together with the declaratio
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlocal_type_glob_class_guidl.htm"
abapFile: "abenlocal_type_glob_class_guidl.htm"
keywords: ["do", "if", "try", "method", "class", "data", "types", "abenlocal", "type", "glob", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) →  [Object-Oriented Programming](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobj_oriented_guidl.htm) → 

Local Types for Global Classes

Background

Within class pools, as in virtually any other ABAP program, data types, local interfaces, and local classes can be defined to ensure a better structure of the implementation of the global class. From a technical point of view, these optional declaration parts, together with the declaration part of the global class, form the global declaration part of the [class pool](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declar_guidl.htm "Guideline").

These local declarations in a class pool are invisible outside the class pool, which means they can only be used as followed:

-   In the private visibility section (PRIVATE SECTION) of the declarations in the global class

-   Within the method implementations in the global class

These two usage types have different technical visibility requirements because friends of a global class have access to its private visibility section. Local type declarations that are used in the PRIVATE SECTION must therefore be accessible for any possible friends of the class, whereas those type declarations that are only used within the method implementations are completely meaningless for other classes.

In general, local classes consist of the declaration part and the associated method implementations. These are invisible to the friends of the global class and have thus technically the same visibility requirements as local type declarations that are only used within the implementation.

Local data types, interfaces, and classes within a class pool are saved in dedicated include programs. The following two areas are distinguished:

-   Class-relevant local definitions

-   Local definitions/implementations

These areas match the different technical visibility requirements. The internal names of the include programs end with CCDEF or CCIMP, which is why they are also known as CCDEF or CCIMP includes.

Rule

Position local declarations appropriately

Position the local declarations of a class pool at appropriate positions depending on the requirements. Types that are only used within the implementation of the global class need to be in a different position than types that are also addressed in the PRIVATE SECTION of the global class.

Details

From the perspective of a class pool, all local type definitions and the associated implementations of local classes can be saved in the Class-Relevant Local Definitions area. However, such an approach is disadvantageous from the dependency management perspective. Dependent classes (subclasses and friends of the global class) only have to be invalidated for changes to the local type declarations of a class pool that are used in the PRIVATE SECTION of the global class. But technically speaking, this invalidation occurs for all changes in the Class-Relevant Local Definitions area (the CCDEF include). For this reason, the additional area Local Definitions/Implementations (the CCIMP include) exists, which is intended for local type declarations that are only used within the class implementation of the global class, and for the implementation part of local classes. If this area is changed, dependent classes are not invalidated.

To prevent unnecessary new generations of other classes that are based on unwanted technical dependencies, the class-local types must be defined in the class pool at the appropriate positions after changes have been made to the global class:

-   All types used only within the method implementations of the global class should be declared under Local Definitions/Implementations (CCIMP include). The local classes should be implemented here as well.

-   Only those types that can also be referenced in the PRIVATE SECTION should be defined under Class-Relevant Local Definitions (CCDEF include).

Declarations and implementations of a local class are only supposed to be distributed across the areas Local Definitions/Implementations and Class-Relevant Local Definitions if they are to be referenced in the PRIVATE SECTION. However, if the local class is only used within the implementation of the global class, both the declaration and the implementation are to be carried out in the Local Definitions/Implementations.

Note

The rule specified here specializes the general rule [implement global declarations centrally](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenglobal_declar_guidl.htm "Guideline") with respect to class pools. They are especially oriented toward the external call of methods of their respective global class and are therefore particularly integrated within a dependency network. For this reason, the rule just mentioned cannot apply to its full extent.

Note

[Test classes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentest_class_glosry.htm "Glossary Entry") should only be created in [test includes](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abentest_include_glosry.htm "Glossary Entry").


### abeninstance_constructor_guidl.htm

---
title: "Instance Constructor"
description: |
  Background When you define an ABAP class, you specify who creates an instance of this class or who may access the instance constructor of the class. To do this, you use the addition CREATE of the statement CLASS ... DEFINITION. The addition CREATE PUBLIC is the default setting and allows for the ins
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninstance_constructor_guidl.htm"
abapFile: "abeninstance_constructor_guidl.htm"
keywords: ["do", "if", "case", "method", "class", "types", "abeninstance", "constructor", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) →  [Object-Oriented Programming](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenobj_oriented_guidl.htm) → 

Instance Constructor

Background

When you define an ABAP class, you specify who creates an instance of this class or who may access the instance constructor of the class. To do this, you use the addition CREATE of the statement CLASS ... DEFINITION. The addition CREATE PUBLIC is the default setting and allows for the instancing by any user of the class. By specifying CREATE PROTECTED, you can restrict the object creation to the class itself and its subclasses. Using the addition CREATE PRIVATE addition, objects can only be created by the class itself. The restriction of the object creation to the class itself is useful in connection with the [singleton design pattern](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenstatic_class_singleton_guidl.htm "Guideline"), for example, where the class itself performs the object creation.

From a technical point of view, the instance constructor can be declared in all visibility sections that are more general or equal to the instantiation specified in the addition CREATE of the statement CLASS ... DEFINITION, using the statement METHODS constructor. However, the actual visibility is controlled by the addition CREATE.

Rule

Declare the instance constructor in the public visibility section.

Always declare the instance constructor of a global class in its public visibility section and independently of the instantiation specified by the addition CREATE in the class definition.

Details

The components of global classes are stored internally, separated according to the visibility section they belong to. Depending on the usage type of the class, only parts of the class are respected by ABAP Compiler in compilations. This procedure requires that the constructor of a global class is always declared in the public visibility section of the class. For these technical reasons, the instance constructor of a global class is always supposed to be declared in the public visibility section (PUBLIC SECTION). If it is declared in another visibility section, this may produce unjustified syntax errors in individual cases when global classes are used.

Exception

The technical restrictions mentioned only apply to the processing of global classes. Within local classes, the instance constructor can also be defined in other visibility sections. However, this positioning should correspond with the visibility section specified using the addition CREATE. A strategy like this enables you to use types for the interface of the instance constructor of a local class that are only accessible in a restricted visibility section.


---


## ABAP Keyword Documentation / ABAP Programming Guidelines / Architecture / User Interfaces

**Files**: 5 | **Difficulty**: intermediate

# ABAP Keyword Documentation / ABAP Programming Guidelines / Architecture / User Interfaces

Included pages: 5


### abenuser_interfaces_guidl.htm

---
title: "User Interfaces"
description: |
  The user interface is the interface between a (human) user and a machine, in this case between the user and the ABAP program that is running. In the ABAP environment, graphical user interfaces (GUIs) are used which can be operated using a keyboard, mouse, or other input devices. They are based on as
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenuser_interfaces_guidl.htm"
abapFile: "abenuser_interfaces_guidl.htm"
keywords: ["select", "do", "case", "class", "abenuser", "interfaces", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) → 

User Interfaces

The user interface is the interface between a (human) user and a machine, in this case between the user and the ABAP program that is running. In the ABAP environment, graphical user interfaces (GUIs) are used which can be operated using a keyboard, mouse, or other input devices. They are based on assorted interface technologies and use either SAP's own SAP GUI or are Web-based technologies that create HTML pages displayed using Web browsers.

-   [Selecting the User Interface Technology](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterface_tech_guidl.htm "Guideline")

-   [Encapsulating Classic User Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenencap_class_interf_guidl.htm "Guideline")

-   [Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_guidl.htm "Guideline")

-   [Accessibility](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenaccessibility_guidl.htm "Guideline")

Continue
[Selecting the User Interface Technology](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterface_tech_guidl.htm)
[Encapsulating Classic User Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenencap_class_interf_guidl.htm)
[Lists](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_guidl.htm)
[Accessibility](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenaccessibility_guidl.htm)


### abeninterface_tech_guidl.htm

---
title: "Selecting the User Interface Technology"
description: |
  Background Various UI technologies can be used in the ABAP environment. We distinguish between classic technologies, which are based on the SAP GUI and are almost completely integrated into the ABAP language, and new Web-based technologies, which display the UI in a Web browser and are accessed thro
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abeninterface_tech_guidl.htm"
abapFile: "abeninterface_tech_guidl.htm"
keywords: ["select", "do", "if", "case", "try", "class", "data", "abeninterface", "tech", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) →  [User Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenuser_interfaces_guidl.htm) → 

Selecting the User Interface Technology

Background

Various UI technologies can be used in the ABAP environment. We distinguish between classic technologies, which are based on the SAP GUI and are almost completely integrated into the ABAP language, and new Web-based technologies, which display the UI in a Web browser and are accessed through object-oriented interfaces in ABAP.

The classic SAP GUI technologies are:

-   Classic dynpros
    A classic dynpro is a component of an ABAP program. It is created using Screen Painter in ABAP Workbench and called using either a transaction code or the CALL SCREEN statement. Every time a dynpro is called, a dynpro sequence is started.

-   Selection screens
    A selection screen is a specific classic dynpro that is not created manually in Screen Painter. Instead, it is defined using the ABAP statements PARAMETERS, SELECT-OPTIONS, and SELECTION-SCREEN. A selection screen is called either implicitly when executable programs are started or explicitly using the CALL SELECTION-SCREEN statement.

-   Classic lists
    Classic lists are used to output data in a structured and formatted manner. The formatted data is stored in a list buffer using specific ABAP statements (such as WRITE, FORMAT) and displayed on a special system dynpro. Classic lists are called either automatically (when an executable program is run) or with the LEAVE TO LIST-PROCESSING statement.

The new Web-based technologies are:

-   Business Server Pages
    Business Server Pages (BSP) are the counterpart to JavaServer Pages (JSP). BSPs are HTML pages with content that is partly dynamic. The dynamic content is created by server-side scripts that are written in ABAP. In AS ABAP, this type of script occurs as a generated ABAP Objects class. You create Business Server Pages using Web Application Builder in ABAP Workbench.

-   Web Dynpro ABAP
    Web Dynpro ABAP is a technology for creating platform-independent, Web-based interfaces. The architecture of Web Dynpro is based on the Model View Controller approach (MVC) for [SoC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenseperation_concerns_guidl.htm "Guideline"). The three components of the model view controller are the data model, which describes the application, the presentation view, and the program controller for responding to user actions. Web Dynpro applications are created using Web Dynpro Explorer in ABAP Workbench and appear in AS ABAP using generated ABAP Objects classes.

-   SAPUI5
    SAPUI5 is a tool set for developing user interfaces for Web applications in HTML5. SAPUI5 supports the Model View Controller (MVC) approach and based on the user interface elements delivered in JavaScript and CSS libraries. The data connection to the application server is established using the data formats [XML](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenxml_glosry.htm "Glossary Entry"), [JSON](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenjson_glosry.htm "Glossary Entry") or OData. User interfaces developed with SAPUI5 can be connected to SAP and non-SAP platforms. In particular, SAPUI5 user interfaces can be developed for ABAP applications of [AS ABAP](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abensap_nw_abap_glosry.htm "Glossary Entry"). The connection is established using [ICF](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenicf_glosry.htm "Glossary Entry") and [APC](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenapc_glosry.htm "Glossary Entry").

Rule

Use Web Dynpro ABAP or SAPUI5

Use Web Dynpro ABAP or SAPUI5 whenever possible to create the UIs of new application programs.

Details

Web Dynpro ABAP and SAPUI5 are SAP's standard UI technologies for developing modern Web applications in the ABAP environment. The MVC approach automatically ensures a separation of presentation logic and application logic, based on the [SoC principle](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenseperation_concerns_guidl.htm "Guideline").

Compared to Web Dynpro, the BSP technology is much more fundamental. An MVC approach for the SoC is supported, but developers are still responsible for the implementation. BSPs can be regarded as the predecessor technology of Web Dynpro ABAP. The use of BSPs is now restricted to cases where a Web application is based on a single HTML page, for which scripting is required and the function cannot be implemented with Web Dynpro ABAP.

The classic SAP UI technology (classic dynpros based on the SAP GUI, including selection screens and lists) is no longer sufficient for modern and flexible business applications where the user interface must be accessible in a portal, for example. The MVC approach is not supported by frameworks or by any relevant tools.

Exception

The various UI technologies are not interoperable. In other words, it is usually not possible to switch parts of an application based on classical dynpros (including selection screens and classic lists) to Web Dynpro ABAP or SAPUI5. In addition, the commonly implemented dynpro programming model was previously not very oriented toward SoC. This makes it difficult or even impossible to implement a changeover for the purpose of further development. Consequently, in exceptional cases, classic dynpros and/or selection screens might be required if a new development needs to be included in an existing framework. For these exceptional cases, the following rules have been devised to ensure that these obsolete UI technologies are handled using a more modern approach.

Notes

-   In general, the UI technology of an application that is strictly modeled on the [separation of concerns](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenseperation_concerns_guidl.htm "Guideline") can be replaced without any problems (see example below).

-   Web Dynpro ABAP and SAPUI5 are not part of the ABAP language. Specific guidelines regarding their use are not in the scope of these programming guidelines, which focus mainly on using the ABAP language to implement services.

Example

The transaction DEMO\_CR\_CAR\_RENTAL is called. Now two user interfaces can be selected for a car rental example:

-   A UI based on classic dynpros and selection screens. However, according to the above rule, using this UI technology in application programs is no longer recommended.

-   A modern UI based on Web Dynpro ABAP

Since the example application strictly separates all concerns, you can use it with different UIs without having to make adjustments to the application and persistence logic. The SoC is therefore a critical prerequisite for potential changeovers from classic dynpros to Web Dynpro ABAP.


### abenencap_class_interf_guidl.htm

---
title: "Encapsulating Classic User Interfaces"
description: |
  Background The separation of concerns(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenseperation_concerns_guidl.htm 'Guideline') is one of the basic rules of these ABAP programming guidelines. This separation, which refers to a strict division of ABAP code into parts for presentatio
version: "7.54"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenencap_class_interf_guidl.htm"
abapFile: "abenencap_class_interf_guidl.htm"
keywords: ["select", "do", "if", "case", "method", "class", "data", "abenencap", "interf", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) →  [User Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenuser_interfaces_guidl.htm) → 

Encapsulating Classic User Interfaces

Background

The [separation of concerns](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenseperation_concerns_guidl.htm "Guideline") is one of the basic rules of these ABAP programming guidelines. This separation, which refers to a strict division of ABAP code into parts for presentation services, application services, and persistence services, is also technically possible for classic dynpro-based UI technologies. The MVC approach is not directly supported, but SoC can also be achieved through the consistent use of the available encapsulation technologies.

However, SoC was rarely implemented in classic dialog programming. Here, presentation logic, application logic, and persistence logic were often combined in a monolithic module pool.

Rule

Encapsulate classic dynpros and selection screens

Only create classic dynpros and selection screens in programs in a logical layer specifically provided for this purpose. You can use function groups as the program type.

Details

When using classic UI technologies, you need to separate the display logic from the application logic for the following reasons:

-   Reuse individual components

-   Automated program logic tests, irrespective of the UI

-   Change the UI technology

In addition, the communication between classic dynpros/selection screens and ABAP programs is implemented using global variables. This poses conceptual problems and cannot be combined with a modern, object-oriented approach for application programs.

Since class pools do not support classic dynpros and selection screens, you can only use function groups for encapsulation. In this role, a function group must be considered a global class. Here, the data of the global declaration part assumes the role of the private attributes, and the function modules assume the role of the public methods. The relevant procedure is demonstrated in DEMO\_CR\_CAR\_RENTAL\_SCREENS of package SABAP\_DEMOS\_CAR\_RENTAL\_DYNPRO. It applies to selection screens.

Besides UI elements, these function groups can only contain display logic in the form of local classes. The application logic communicates with the display logic using the function modules of this function group. You can still call the first dynpro of a dynpro sequence using a transaction code. This method is used in cases where the user starts the application.

The guidelines described in this book are also valid in function groups. It is especially important that the [dialog modules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendial_mod_event_block_guidl.htm "Guideline") (PBO and PAI), which are called by the dynpro, or the [event blocks](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abendial_mod_event_block_guidl.htm "Guideline") for selection screen processing do not contain any program logic. Instead they should directly delegate the processing to the relevant methods of the local classes. The same applies to the [function modules](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenfunct_module_subroutine_guidl.htm "Guideline") that act as the external interface. In addition, you must [restrict](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenselect_table_type_guidl.htm "Guideline") the scope of the function group global data to the minimum scope required for communicating with dynpros.

Exception

Following the above rule means you cannot use standard selection screens. Therefore, it is necessary to make an exception to this rule for executable programs that are executed during background processing. This is because the required parameter interface must be a standard selection screen defined directly in the program. An encapsulation in a function group is not possible here. However, in this case, the events of selection screen processing should only call one appropriate method of a local class within the executable program.

Bad Example

A classic dialog program - usually a single module pool - processes all the facets of an application.

Good Example

The following source code shows a part of a function group DEMO\_CR\_CAR\_RENTAL\_SCREENS with expanded include programs. This function group encapsulates the dynpro and selection screen for transaction DEMO\_CR\_CAR\_RENTAL, following the above rule. The connection to the application layer is established exclusively using the if\_demo\_cr\_car\_rentl\_service interface, which is also used in the Web Dynpro application of this transaction.

FUNCTION-POOL demo\_cr\_car\_rental\_screens.

\* Top Include

SELECTION-SCREEN BEGIN OF SCREEN 200 TITLE text-ccr.
PARAMETERS g\_name TYPE demo\_cr\_customer\_name.
SELECTION-SCREEN END OF SCREEN 200.

TABLES demo\_cr\_scustomer\_cntrl.

CONTROLS: customers TYPE TABLEVIEW USING SCREEN 0100,
          reservations TYPE TABLEVIEW USING SCREEN 0100.

DATA g\_ok\_code TYPE sy-ucomm.

DATA: g\_customers TYPE TABLE OF demo\_cr\_scustomer\_cntrl,
      g\_customer LIKE LINE OF g\_customers.

DATA: g\_reservations TYPE TABLE OF demo\_cr\_sreservation\_cntrl,
      g\_reservation LIKE LINE OF g\_reservations.

\* Local Class Declarations

CLASS screen\_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA car\_rental\_service
       TYPE REF TO if\_demo\_cr\_car\_rentl\_service.
    CLASS-METHODS: class\_constructor,
                   status\_0100,
                   user\_command\_0100,
                   cancel.
  PRIVATE SECTION.
    CLASS-METHODS: customer\_search\_by\_id,
                   ...
ENDCLASS.

CLASS customer\_table DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: change\_tc\_attr,
                   mark.
ENDCLASS.
...
\* Function Module

FUNCTION demo\_cr\_call\_car\_rental\_screen.
  CALL SCREEN 100.
ENDFUNCTION.
\* PBO Modules

MODULE status\_0100 OUTPUT.
  screen\_handler=>status\_0100( ).
ENDMODULE.

MODULE customers\_change\_tc\_attr OUTPUT.
  customer\_table=>change\_tc\_attr( ).
ENDMODULE.
...
\* PAI Modules

MODULE cancel INPUT.
  screen\_handler=>cancel( ).
ENDMODULE.

MODULE user\_command\_0100 INPUT.
  screen\_handler=>user\_command\_0100( ).
ENDMODULE.

MODULE customers\_mark INPUT.
  customer\_table=>mark( ).
ENDMODULE.
...
\* Local Class Implementations
...

Dynpro 100 is called in a function module but can also be linked to a transaction code. In the classic PBO and PAI modules, methods of local classes are called. However the implementation of these methods is not shown here. There is a class for general screen handling and a class for each table control. The application layer is accessed using the specified interface for implementations of the class.


### abenlist_guidl.htm

---
title: "Lists"
description: |
  Background A list is a medium used for the structured and formatted output of data. The following lists are available in ABAP: -   Classic lists, which are written to a list buffer using ABAP statements and displayed on a special list dynpro. -   Output of the SAP List Viewer (ALV), which is display
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenlist_guidl.htm"
abapFile: "abenlist_guidl.htm"
keywords: ["select", "do", "while", "if", "case", "try", "method", "class", "data", "abenlist", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) →  [User Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenuser_interfaces_guidl.htm) → 

Lists

Background

A list is a medium used for the structured and formatted output of data. The following lists are available in ABAP:

-   Classic lists, which are written to a list buffer using ABAP statements and displayed on a special list dynpro.

-   Output of the SAP List Viewer (ALV), which is displayed in [GUI controls](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abengui_control_glosry.htm "Glossary Entry") during the processing of classic dynpros. ALV lists are accessed using classes, such as CL\_SALV\_TABLE (non-hierarchically tabular lists), CL\_SALV\_HIERSEQ\_TABLE (hierarchically sequential lists), or CL\_SALV\_TREE (hierarchically tabular lists).

Classic lists are the only option to send ABAP data from ABAP programs directly to the SAP spool system as print lists. If SAP List Viewer is used, the lists that are displayed in the viewer are automatically converted to classic print lists during printing.

Rule

Use SAP List Viewer

Do not use classic lists. If dynpro-based, classic UI technologies are still used, SAP List Viewer (ALV) or other GUI control-based technologies should be used instead of classic lists in production programs.

Details

Using classic lists is no longer recommended for the following reasons:

-   The processing of lists is based on global data and events of the ABAP runtime environment.

-   The list buffer that is used for classic lists is bound to an executable program or a dynpro sequence and not to classes and objects.

-   It is almost impossible to separate presentation logic and application logic when writing to lists.

-   The UI of a classic list is not standardized and thus usually not accessible.

The concept of classic lists is therefore mostly incompatible with the ABAP Objects concept, and classic lists cannot be encapsulated in function groups as easily as classic dynpros and selection screens.

While the application developer must ensure [accessibility](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenaccessibility_guidl.htm "Guideline") in classic lists with a great deal of effort, the ALV lists automatically comply with the accessibility requirements because the ALV already provides the required services, such as user-specific settings.

Exception

Small helper programs that are not intended for live use in application systems can continue to use classic lists for system-related console output. The WRITE list statement here assumes the same role as System.out.println(...) in Java or printf in C.

In cases in which an ALV output seems to be overdimensioned, other methods are possible, such as Textedit Control or Browser Control (or its wrapping in dynamic documents) for the formatted output of non-tabular content. As before, accessibility must be guaranteed here.

Note

For simple console output, XML-based output streams can be used. An example of this is shown by the class CL\_DEMO\_OUTPUT\_STREAM. The class CL\_DEMO\_OUTPUT demonstrates possible applications of this class. It is used in programs in the [ABA Example Library](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_examples.htm).

Bad Example

Executing the program DEMO\_CLASSICAL\_REPORTING produces a classic list output. However, according to the above rule, using classic lists in application programs is no longer recommended.

Good Example

Executing the program DEMO\_ALV\_REPORTING produces ALV lists with the same content and the same functions as the classic lists in the previous example. ALV lists replace classic lists in those cases in which classic dynpros are still used.


### abenaccessibility_guidl.htm

---
title: "Accessibility"
description: |
  Background Accessibility is a product standard(https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorrectness_quality_guidl.htm 'Guideline') that ensures that information technology products can also be used by people with impairments. For user interfaces, for instance, this means meet
version: "7.54"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenaccessibility_guidl.htm"
abapFile: "abenaccessibility_guidl.htm"
keywords: ["select", "do", "if", "class", "abenaccessibility", "guidl"]
---

* * *

AS ABAP Release 754, ©Copyright 2019 SAP SE. All rights reserved.

[ABAP Keyword Documentation](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap.htm) →  [ABAP Programming Guidelines](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenarchitecture_guidl.htm) →  [User Interfaces](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenuser_interfaces_guidl.htm) → 

Accessibility

Background

Accessibility is a [product standard](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencorrectness_quality_guidl.htm "Guideline") that ensures that information technology products can also be used by people with impairments. For user interfaces, for instance, this means meeting the needs of visually impaired or blind users in particular. These users usually need a screen reader program, which reads the content of the screen aloud.

Rule

Ensuring Accessibility

Make sure that your user interfaces are accessible, no matter what interface technology is used, so that they can be used by users with impairments.

Details

Primarily, user interfaces must be designed so that they can be processed by technologies such as screen readers or magnifiers. This means meeting the following requirements:

-   All input and output fields must have meaningful labels.

-   All table columns must have a header.

-   All icons must have a tooltip.

-   Information must not be expressed by color alone.

-   Input and output fields on the screen should be grouped as appropriate in frames, each with a meaningful title.

This is another reason to use the most up-to-date interface technologies, such as SAPUI5, Web Dynpro ABAP or ALV. These automatically only allow accessible interfaces, whereas application developers using older technologies such as classic screens or classic lists are themselves responsible for ensuring that the accessibility requirements are met. There are some checks in the [check tools](https://help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abencheck_correctness_guidl.htm "Guideline") for classic dynpros and selection screens that report violations of these rules (if they can be identified statically). However, for classic lists such checks are not possible until display.

Note

As regards using the browser control in classic dynpros, we refer here to the class CL\_HTMLTIDY. This class enables HTML files to be checked for formal correctness and accessibility. It is best to only display HTML files in a browser control if they have been checked by CL\_HTMLTIDY. The class CL\_ABAP\_BROWSER, which wraps the browser control for simple displays of HTML files, performs a check with CL\_HTMLTIDY by default.


---
