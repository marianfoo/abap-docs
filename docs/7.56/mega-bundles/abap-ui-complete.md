# ABAP UI - Complete Reference (7.56)

**Generated**: 2025-09-01T19:38:04.287Z
**Bundles Combined**: 51
**Category**: ui

---


## ABAP - Keyword Documentation / ABAP - Dictionary (DDIC) / DDIC - Built-In Data Types / DDIC - Properties of the Built-In Dictionary Types / DDIC - General Dictionary Types

**Files**: 4 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Dictionary (DDIC) / DDIC - Built-In Data Types / DDIC - Properties of the Built-In Dictionary Types / DDIC - Special Dictionary Types

Included pages: 6


### abenddic_builtin_types_special.htm

---
title: "DDIC - Special Dictionary Types"
description: |
  -   Date types and time types(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_date_time_types.htm) -   Special character-like types(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_special_character_types.htm) -   Currency fields(https://help.sap.com/doc/
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_special.htm"
abapFile: "abenddic_builtin_types_special.htm"
keywords: ["do", "data", "types", "abenddic", "builtin", "special"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Data Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_intro.htm) →  [DDIC - Properties of the Built-In Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_prop.htm) → 

DDIC - Special Dictionary Types

-   [Date types and time types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_date_time_types.htm)
-   [Special character-like types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_special_character_types.htm)
-   [Currency fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_currency_field.htm)
-   [Quantity fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_quantity_field.htm)
-   [Geodata Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_geo_data.htm)

Continue
[DDIC - Date Fields, Time Fields, and Time Stamp Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_date_time_types.htm)
[DDIC - Special Character-Like Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_special_character_types.htm)
[DDIC - Currency Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_currency_field.htm)
[DDIC - Quantity Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_quantity_field.htm)
[DDIC - Geodata Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_geo_data.htm)


### abenddic_date_time_types.htm

---
title: "DDIC - Date Fields, Time Fields, and Time Stamp Fields"
description: |
  The following data types in ABAP Dictionary describe date fields, time fields, and time stamp fields: -   Date Types, Time Types, and Time Stamp Types(#abenddic-date-time-types-1-------character-like-date-fields-and-time-fields---@ITOC@@ABENDDIC_DATE_TIME_TYPES_2) Date Types, Time Types, and Time
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_date_time_types.htm"
abapFile: "abenddic_date_time_types.htm"
keywords: ["insert", "do", "if", "case", "try", "data", "types", "abenddic", "date", "time"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Data Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_intro.htm) →  [DDIC - Properties of the Built-In Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_prop.htm) →  [DDIC - Special Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_special.htm) → 

DDIC - Date Fields, Time Fields, and Time Stamp Fields

The following data types in ABAP Dictionary describe date fields, time fields, and time stamp fields:

-   [Date Types, Time Types, and Time Stamp Types](#abenddic-date-time-types-1-------character-like-date-fields-and-time-fields---@ITOC@@ABENDDIC_DATE_TIME_TYPES_2)

Date Types, Time Types, and Time Stamp Types

The following built-in data types in ABAP Dictionary represent real date types, time types, and time stamp types in a database:

-   [DATN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for date fields in the database
-   [TIMN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for time fields in the database
-   [UTCLONG](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for time stamp fields in the database

Database fields with these types generally contain only valid values for dates, times, and time stamps in the internal representation of the database. These types are currently only supported by [SAP HANA databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenhana_database_glosry.htm "Glossary Entry").

Hints

-   The dictionary types DATN and TIMN are mapped to the character-like ABAP date type and time type [d](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_date_time.htm) or [t](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_date_time.htm). The built-in ABAP type [utclong](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_date_time.htm), on the other hand, provides a real time stamp type for UTCLONG.
-   The types DATN and TIMN are recommended for saving individual dates and times. Access to dates and times in the corresponding functions and expressions is optimized for these types. In the case of the dictionary types DATS and TIMS, such access may not be possible at all or they may need to be converted to real date and time types.
-   The output formats for fields on dynpros and Web dynpros and in the statements [WRITE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite-.htm) or [WRITE TO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to.htm) can be predefined for the types DATN, TIMN, and UTCLONG specific to each user in the [user master record](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuser_master_record_glosry.htm "Glossary Entry"). The output length required for formatted output is usually greater than the number of places in ABAP Dictionary.

Character-Like Date Fields and Time Fields

Instances of the following data types in ABAP Dictionary are created on the database using character-like fields:

-   [DATS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for [date fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendate_field_glosry.htm "Glossary Entry")
    
    From a technical perspective, the built-in data type DATS describes objects of the type CHAR with a length of 8 characters. It is intended to be used for a [calendar date](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencalendar_date_glosry.htm "Glossary Entry") with the format YYYYMMDD. This is not checked however when writing to or reading from database fields of this type. Automatic checks are only made for dynpro fields typed with reference to DATS. In ABAP, DATS is assigned to the special type [d](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_date_time.htm) and the associated rules apply.
    
-   [TIMS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for [time fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentime_field_glosry.htm "Glossary Entry")
    
    From a technical perspective, the built-in data type TIMS describes objects of the type CHAR with a length of 6 characters. It is intended to be used for a [time](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenday_time_glosry.htm "Glossary Entry") with the format HHMMSS. This is not checked however when writing to or reading from database fields of this type. Automatic checks are only made for dynpro fields typed with reference to TIMS. In ABAP, TIMS is assigned to the special type [t](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_date_time.htm) and the associated rules apply.
    
-   [ACCP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for posting periods
    
    From a technical perspective, the built-in data type ACCP describes objects of the type CHAR with a length of 6 characters. It is intended to be used for a posting period with the format YYYYMM. This is not checked however when writing to or reading from database fields of this type. Automatic checks are only made for dynpro fields typed with reference to ACCP.
    

Hints

-   If possible, the types DATN and TIMN should be used.
-   The output formats for fields on dynpros and Web Dynpros and in the statements [WRITE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite-.htm) or [WRITE TO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to.htm) can be predefined for the types DATS and TIMS specific to each user in the [user master record](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuser_master_record_glosry.htm "Glossary Entry"). The output length required for formatted output is usually greater than the number of places in ABAP Dictionary. If the output length is too short, any formatting characters are suppressed.
-   When a [dynpro field](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_field_glosry.htm "Glossary Entry") is represented with reference to the type ACCP (but not in the statements [WRITE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite-.htm) or [WRITE TO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to.htm)) and there is enough output length, a point is inserted between the year YYYY and the month MM.


### abenddic_special_character_types.htm

---
title: "DDIC - Special Character-Like Types"
description: |
  The following character-like data types in ABAP Dictionary have a special semantic meaning: -   NUMC(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for numeric texts(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennumeric_text_glosry.htm 'Gl
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_special_character_types.htm"
abapFile: "abenddic_special_character_types.htm"
keywords: ["do", "if", "try", "data", "types", "abenddic", "special", "character"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Data Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_intro.htm) →  [DDIC - Properties of the Built-In Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_prop.htm) →  [DDIC - Special Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_special.htm) → 

DDIC - Special Character-Like Types

The following character-like data types in ABAP Dictionary have a special semantic meaning:

-   [NUMC](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for [numeric texts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennumeric_text_glosry.htm "Glossary Entry")
    
    From a technical perspective, the built-in data type NUMC describes objects of the type CHAR with a maximum length of 255 characters. It is intended for numeric texts. This is not checked however when writing to or reading from database fields of this type. Automatic checks are only made for dynpro fields typed with reference to NUMC. In ABAP, NUMC is assigned to the special type [n](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_character.htm) and the associated rules apply.
    
-   [CLNT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for [client columns](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenclient_column_glosry.htm "Glossary Entry")
    
    From a technical perspective, the data type CLNT describes objects of the type CHAR with length 3. If the data type CLNT is used for the first key field of a DDIC database table, this makes the DDIC database table [client-dependent](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_database_tables_client.htm).
    
-   [LANG](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for [text language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_language_glosry.htm "Glossary Entry")
    
    From a technical perspective, the built-in data type LANG describes objects of the type CHAR with length 1. It is intended specifically for language keys. The [primary key](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprimary_key_glosry.htm "Glossary Entry") of a [text table](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_table_glosry.htm "Glossary Entry") consists of the [foreign key](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenforeign_key_glosry.htm "Glossary Entry") and a field of type LANG. Furthermore, a component of structures or DDIC database tables that has the data type LANG can be flagged as a text language. The text language is used to convert character-like components of the structure when importing data from [data clusters](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendata_cluster_glosry.htm "Glossary Entry") and in the binary [RFC protocol](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrfc_protocol.htm) for passing TABLES parameters between [MDMP systems](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmdmp-system_glosry.htm "Glossary Entry") and [Unicode systems](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenunicode_system_glosry.htm "Glossary Entry"). Furthermore, the text language can affect which lines of a database table are transported by the [Change and Transport System (CTS)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencts_glosry.htm "Glossary Entry"). Depending on settings in the CTS, only entries in the original language of the database table can be transported.
    

Hint

When the statements [WRITE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite-.htm) or [WRITE TO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to.htm) are used to represent a [dynpro field](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_field_glosry.htm "Glossary Entry") with the type LANG (and when a field that references this type is formatted), this field has an output length of 2 and is converted automatically from the single-character internal language ID to the matching two-character ISO ID using the [conversion routine](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_routine_glosry.htm "Glossary Entry") ISOLA (and back).


### abenddic_currency_field.htm

---
title: "DDIC - Currency Fields"
description: |
  A currency field is a component of a DDIC structure, DDIC database table, or DDIC view defined in ABAP Dictionary used to store an amount in a specific currency. A currency amount is an integer in the smallest unit of the currency. The integer is constructed from all figures in a currency field whil
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_currency_field.htm"
abapFile: "abenddic_currency_field.htm"
keywords: ["do", "while", "if", "case", "try", "method", "class", "data", "types", "abenddic", "currency", "field"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Data Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_intro.htm) →  [DDIC - Properties of the Built-In Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_prop.htm) →  [DDIC - Special Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_special.htm) → 

DDIC - Currency Fields

A currency field is a component of a DDIC structure, DDIC database table, or DDIC view defined in ABAP Dictionary used to store an amount in a specific currency. A currency amount is an integer in the smallest unit of the currency. The integer is constructed from all figures in a currency field while ignoring the position of the decimal separator.

A currency field can have data type CURR, DECFLOAT16, or DECFLOAT34. In case of data type CURR, a field is automatically interpreted as currency field and a reference to a currency key is mandatory. In case of the other data types, this reference is not mandatory, but if it is assigned, it turns the field into a currency field.

The currency key specifies the currency and the number of decimal places of a currency field. It is a component of a DDIC structure, DDIC database table, or DDIC view defined in ABAP Dictionary, has the type CUKY, and can contain a [currency ID](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencurrency_id_glosry.htm "Glossary Entry") from the DDIC database table TCURC.

By default, the number of decimal places for a currency is always two. Currencies with a different number of decimal places must also be entered in the table TCURX, where the number of decimal places can be defined explicitly.

-   [Handling in ABAP Dictionary](#abenddic-currency-field-1-------handling-in-dynpros---@ITOC@@ABENDDIC_CURRENCY_FIELD_2)
-   [Handling in ABAP Programs](#abenddic-currency-field-3---hints------currencies-are-handled-as-specified-by-the-data-saved-in-the-database-tables-tcur----of-the-package-sfib--the-exchange-rates-and-other-settings-can-be-maintained-in-transaction-ob08------currency-fields-are-defined-as-elements-of--cds-entities--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencds-entity-glosry-htm--glossary-entry---using--semantics-annotations--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencds-f1-element-annotation-htm----handling-in-abap-dictionary--a-data-element-of-data-type--curr--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-htm--is-handled-as-a-field-of-data-type--dec--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-int-pack-htm--and-is-stored-in-ddic-database-tables-in-the--bcd--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenbcd-glosry-htm--glossary-entry---format--when-creating-a-data-element-or-a-structure-component-of-the-data-type-curr-in-an-abap-dictionary--tool--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-tools-htm---a-number-of-decimal-places-other-than-zero-must-be-defined--the-standard-value-is-two-decimal-places---a-currency-field-of-data-type-decfloat16-or-decfloat34-is-handled-according-to-its-data-type---for-every-structure-component-of-data-type-curr--a-component-of-the-same-structure-or-of-a-different-ddic-structure--ddic-database-table--or-ddic-view-must-be-specified-as-a--reference-field--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-structures-sema-htm--with-the-data-type--cuky--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-htm---this-field-is-the--currency-key--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencurrency-key-glosry-htm--glossary-entry---that-defines-the-actual-currency--from-a-technical-perspective--the-data-type-cuky-is-handled-like-a-type-char-with-length-5---hints------the-number-of-decimal-places-for-the-currency-defined-by-the-currency-key-of-type-cuky-only-determines-the-formatting-and-checking-of-a-currency-field-on-a-dynpro--in-principal--it-is-independent-of-the-number-given-for-the-currency-field-of-type-curr--the-default-value-of-two-decimal-places-for-currency-fields-in-abap-dictionary-is-chosen-because-most-of-the-currencies-in-the-ddic-database-table-tcurc-have-two-decimal-places-and-are-not-entered-in-the-database-table-tcurx--it-is-not-advisable-to-use-any-other-value--since-in-this-case-any-unforeseen-operations-with-currency-keys-in-abap-programs-are-largely-ignored------the-conversion-function-currency--conversion---cds-view-entity--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencds-conversion-functions-v2-htm----cds-ddic-based-view--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencds-conversion-functions-v1-htm---in--abap-cds--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenabap-cds-glosry-htm--glossary-entry---also-assumes-two-decimal-places-for-currency-fields--if-the-function-for-currency-fields-is-used-with-other-amounts-of-decimal-places--unexpected-behavior-may-arise------as-in--general-packed-numbers--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-int-pack-htm---the-number-of-places-in-type-curr-should-be-odd---handling-in-dynpros--for-the-display-of-an-input-output-field-of-type-curr-on-a--dynpro--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abendynpro-glosry-htm--glossary-entry----the-content-is-displayed-as-character-like-content-and-in-accordance-with-a-type-dependent-mask--as-for-all--dynpro-fields--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abendynpro-field-glosry-htm--glossary-entry----here--the-positioning-of-the-decimal-point-for-a-currency-field-of-type-curr-on-a-dynpro-is-completely-independent-of-the-number-of-decimal-places-specified-by-the-data-element-in-abap-dictionary--greater-than-or-equal-to-one--the-default-value-is-two---the-number-of-decimal-places-on-a-dynpro-is-defined-as-follows-------when-displaying-a-dynpro-field-of-type-curr--the-reference-field-for-the-currency-key-is-searched-for-in-the-global-data-of-the-current-abap-program--the-content-of-this-field-must-be-a-valid--currency-id--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencurrency-id-glosry-htm--glossary-entry---from-the-ddic-database-table-tcurc--if-the-reference-field-is-not-found-or-there-is-no-entry-in-the-ddic-database-table-tcurx-with-the-content-of-the-field--the-currency-field-is-displayed-with-two-decimal-places-by-default-----------the-reference-field-is-either-defined-in-the-relevant-structure-in-abap-dictionary-or-was-defined-using-screen-painter-for-the-attributes-of-the-dynpro-field--it-does-not-have-to-be-present-on-the-dynpro-itself-----------if-the-currency-id-for-the-reference-field-is-found-in-the-database-table-tcurx--the-currency-field-is-displayed-with-the-decimal-places-specified-there--this-also-applies-to-initial-reference-fields---limitation--currency-fields-of-data-type-decfloat16-or-decfloat34-are-not-supported-on-dynpros---hint--a-dynpro-therefore-only-uses-the-string-of-digits-of-a-currency-field-from-the-abap-program--or-a--conversion-routine--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenconversion-routine-glosry-htm--glossary-entry---in-between--or-just-sends-this-string--any-information-about-currency-keys-and-decimal-places-is-not-passed-automatically--it-must-be-ensured-that-the-reference-field-for-pbo-is-filled-with-the-appropriate-value--for-pai--the-correct-currency-key-plays-a-part-in-the-automatic-format-check--especially-on-dynpros-in-which-currency-fields-are-displayed-in-differing-currencies--it-must-be-ensured-that-the-reference-field-is-transported-before-the-currency-by-using-the-statements--chain--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-dynpchain-htm--and--field--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-dynpfield-htm----handling-in-abap-programs--the-abap-type-that-corresponds-to-the-data-type-curr-is-p--an-abap-data-object-declared-with-reference-to-a-dictionary-type-of-type-curr-has-the-number-of-decimal-places-defined-there--greater-than-or-equal-to-one-and-the-default-is-two---these-decimal-places-are-respected-for-all-operations-and-calculations--as-for-all-packed-numbers--the-only-exceptions-are-the-programs-for-which-the-program-property--fixed-point-arithmetic--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenfixed-point-arithmetic-glosry-htm--glossary-entry---was-not-set---to-work-correctly-with-a-currency-field--all-digits-in-the-number-must-be-recorded-as-currency-amounts-in-the-smallest-possible-currency-units--regardless-of-the-number-of-decimal-places--this-occurs-automatically-sometimes--for-example--if--currency--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abapwrite-to-options-htm--is-used-after--write---to----https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abapwrite-to-htm---this-is-possible-for-currency-fields-of-data-types-curr--decfloat16--and-decfloat34--or-the-formatting-option--currency--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abapcompute-string-format-options-htm--in-an--embedded-expression--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenstring-templates-expressions-htm--of-a--string-template--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenstring-templates-htm---for-other-operations--the-following-restrictions-apply-------comparison--addition--subtraction--and-division-of-two-currency-fields-with-the-same-number-of-decimal-places-are-not-critical------multiplication-with-and-division-by-a-non-currency-dependent-number-is-not-critical------all-other-operations-are-critical--for-example----------multiplication-of-two-currency-fields----------operations-between-two-fields-with-different-currencies-that-include-assignments----------assignments-of-non-currency-dependent-numbers-to-currency-fields---accurate-results-should-not-be-expected-when-performing-critical-operations-if-the-number-of-decimal-places-in-the-program-does-not-match-the-number-in-the-currency---hints------for-currencies--one-of-the-data-types-for--decimal-floating-point-numbers--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-decimal-floating-point-htm--is-recommended-rather-than-the-data-type-curr--the-currency-compliant-formatting-is-supported-on-dynpros-by-output-styles-and-by-style-compatible-formatting-in-abap-programs--see-the--executable-example--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenwrite-style-abexa-htm-------the-methods-convert--curr--to--decfloat-and-convert--decfloat--to--curr-of-the-system-class--cl--abap--decfloat--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencl-abap-decfloat-doc-htm--convert-currency-amounts-to-decimal-floating-point-numbers--and-back--as-specified-by-a-currency-key--------abenddic-quantity-field-htm------title---ddic---quantity-fields--description------a-quantity-field-is-a-component-of-a-structure--ddic-database-table--or-view-defined-in-abap-dictionary-and-used-to-store-a-quantity-in-a-specific-unit--a-quantity-field-can-have-data-type-quan--decfloat16--or-decfloat34--in-case-of-data-type-quan--a-field-is-automatically-interpreted-as-quantity-fi-version---7-56--category---types--type---abap-reference--sourceurl---https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-quantity-field-htm--abapfile---abenddic-quantity-field-htm--keywords----do----if----case----try----data----types----abenddic----quantity----field---------------as-abap-release-756---copyright-2021-sap-se--all-rights-reserved----abap---keyword-documentation--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenabap-htm------abap---dictionary--ddic---https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenabap-dictionary-htm------ddic---built-in-data-types--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-intro-htm------ddic---properties-of-the-built-in-dictionary-types--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-prop-htm------ddic---special-dictionary-types--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-special-htm------ddic---quantity-fields--a-quantity-field-is-a-component-of-a-structure--ddic-database-table--or-view-defined-in-abap-dictionary-and-used-to-store-a-quantity-in-a-specific-unit--a-quantity-field-can-have-data-type-quan--decfloat16--or-decfloat34--in-case-of-data-type-quan--a-field-is-automatically-interpreted-as-quantity-field-and-a-reference-to-a-unit-key-is-mandatory--in-case-of-the-other-data-types--this-reference-is-not-mandatory--but-if-it-is-assigned--it-turns-the-field-into-a-quantity-field---the-unit-key-defines-the-unit-and-the-number-of-decimal-places--it-is-a-component-of-a-structure--ddic-database-table--or-ddic-view-of-type-unit-defined-in-abap-dictionary-and-can-contain-a--unit-id--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenunit-id-glosry-htm--glossary-entry---from-the-ddic-database-table-t006--------handling-in-abap-dictionary---abenddic-quantity-field-1-------handling-in-dynpros---ITOC@@ABENDDIC_QUANTITY_FIELD_2)
-   [Handling in ABAP Programs](#@@ITOC@@ABENDDIC_QUANTITY_FIELD_3)

Hints

-   Quantities and units are handled as specified by the data saved in the DDIC database tables T006... in the package SZME. This data can be maintained using the transaction CUNI.
-   Quantity fields are defined as elements of [CDS entities](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_entity_glosry.htm "Glossary Entry") using [semantics annotations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_element_annotation.htm).

Handling in ABAP Dictionary

A data element of data type [QUAN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) is handled as a field of data type [DEC](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_int_pack.htm) and is stored in DDIC database tables in the [BCD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbcd_glosry.htm "Glossary Entry") format. When creating a data element or a structure component of the data type QUAN in an ABAP Dictionary [tool](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_tools.htm), any number of decimal places can be defined. The default value is no decimal places.

A quantity field of data type DECFLOAT16 or DECFLOAT34 is handled according to its data type.

For every structure component of data type QUAN, a component of the same structure or of a different structure, DDIC database table, or DDIC view must be defined as a [reference field](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_structures_sema.htm) with the data type [UNIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm). This field is the [unit key](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenunit_glosry.htm "Glossary Entry") that defines the unit of the quantity. From a technical perspective, the data type UNIT is handled like a type CHAR with length 2.

Hints

-   The number of decimal places for the unit defined using the unit key of type UNIT only affects the formatting of a quantity field on a dynpro. In principal, it is independent of the number given for the quantity field of type QUAN.
-   As in [general packed numbers](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_int_pack.htm), the number of places in type QUAN should be odd.

Handling in Dynpros

For the display of an input/output field of type QUAN on a [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry"), the content is displayed as character-like content and in accordance with a type-dependent mask, as for all [dynpro fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_field_glosry.htm "Glossary Entry"). The system tries to create a display which suits the unit of the quantity field.

To determine the unit, the global data of the current ABAP program is searched for the reference field associated with the field for the unit key. The content of this field must be a valid [unit ID](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenunit_id_glosry.htm "Glossary Entry") from the DDIC database table T006. If the reference field is not found or if there is no entry in the DDIC database table T006 with the content of the field, the quantity field is displayed as a regular field of type DEC.

The reference field is either defined in the relevant structure in ABAP Dictionary or was defined using Screen Painter for the attributes of the dynpro field. It does not have to be present on the dynpro itself.

If the unit ID of the reference field is found in the column MSEHI of the DDIC database table T006 and the quantity field does not have any decimal places with a value other than 0 outside the accuracy defined in the column DECAN, the quantity field is displayed with this accuracy. For a unit without decimal places, the decimal separator is suppressed. If the quantity field has decimal places with a value other than 0 outside of its accuracy, however, it is displayed as a regular field of type DEC.

Limitation: Quantity fields of data type DECFLOAT16 or DECFLOAT34 are not supported on dynpros.

Hint

A display that matches the accuracy of a quantity field is only then possible if no information is lost. This makes it possible, for example, for average values (else integer units) to be displayed in a relevant quantity field.

Handling in ABAP Programs

The ABAP type that corresponds to the data type QUAN is p. An ABAP data object declared with reference to a dictionary type of type QUAN has the number of decimal places defined there. These decimal places are respected for all operations and calculations, as for all packed numbers.

The unit defined for a quantity field only plays a part in ABAP programs if it is specified after the addition [UNIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to_options.htm) of the statement [WRITE *\[*TO*\]*](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to.htm). The addition UNIT of the statement WRITE *\[*TO*\]* can be used only for quantity fields of data type QUAN, not for quantity fields of any other data type.


### abenddic_geo_data.htm

---
title: "DDIC - Geodata Types"
description: |
  The geodata type(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeo_data_type_glosry.htm 'Glossary Entry') GEOM_EWKB(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) is a built-in data type in ABAP Dictionary that describes the geometric pos
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_geo_data.htm"
abapFile: "abenddic_geo_data.htm"
keywords: ["do", "if", "try", "data", "types", "abenddic", "geo"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Data Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_intro.htm) →  [DDIC - Properties of the Built-In Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_prop.htm) →  [DDIC - Special Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_special.htm) → 

DDIC - Geodata Types

The [geodata type](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeo_data_type_glosry.htm "Glossary Entry") [GEOM\_EWKB](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) is a built-in data type in ABAP Dictionary that describes the geometric position in a given coordinate reference system.

It represents fields in the database that contain geometric data in the EWKB (Extended Well-Known Binary) format. This type is currently only supported on [SAP HANA databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenhana_database_glosry.htm "Glossary Entry") and references the database type ST\_GEOMETRY.

The internal representation of the geodata type GEOM\_EWKB is a [BLOB](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenblob_glosry.htm "Glossary Entry") (Binary Large Object) and the same rules and restrictions largely apply as to the type [RAWSTRING](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm). The type GEOM\_EWKB is mapped to the ABAP type [xstring](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_byte.htm).

At ABAP level, there is no semantic representation for geometric data. ABAP only allows geometric data to be passed between the application and the SAP HANA database. The SAP HANA database functions for geometric data types can be accessed using [AMDP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenamdp.htm).

If the data type GEOM\_EWKB is used for a structure component or a table field of a DDIC database table, the type must be assigned a [spatial reference system](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_database_tables_sptlrf.htm). This system cannot be changed once activated. The system has the ID 0 by default.

Hints

-   Columns of the data type GEOM\_EWKB are not supported as [BLOBs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenblob_glosry.htm "Glossary Entry") in [streaming and locators in ABAP SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstreams_locators.htm). To use columns of the data type GEOM\_EWKB in streaming and locators, they have to be converted to [JSON](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenjson_glosry.htm "Glossary Entry") format first. This can be done with the conversion function [AS\_GEO\_JSON](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_geo_conv_func.htm).
-   [NOT NULL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_database_tables_init.htm) cannot be set for a column of the type GEOM\_EWKB.


---


## ABAP - Keyword Documentation / ABAP - Dictionary (DDIC) / DDIC - Built-In Data Types / DDIC - Properties of the Built-In Dictionary Types / DDIC - Special Dictionary Types

**Files**: 6 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Dictionary (DDIC) / DDIC - Built-In Data Types / DDIC - Properties of the Built-In Dictionary Types / DDIC - Special Dictionary Types

Included pages: 6


### abenddic_builtin_types_special.htm

---
title: "DDIC - Special Dictionary Types"
description: |
  -   Date types and time types(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_date_time_types.htm) -   Special character-like types(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_special_character_types.htm) -   Currency fields(https://help.sap.com/doc/
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_special.htm"
abapFile: "abenddic_builtin_types_special.htm"
keywords: ["do", "data", "types", "abenddic", "builtin", "special"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Data Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_intro.htm) →  [DDIC - Properties of the Built-In Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_prop.htm) → 

DDIC - Special Dictionary Types

-   [Date types and time types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_date_time_types.htm)
-   [Special character-like types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_special_character_types.htm)
-   [Currency fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_currency_field.htm)
-   [Quantity fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_quantity_field.htm)
-   [Geodata Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_geo_data.htm)

Continue
[DDIC - Date Fields, Time Fields, and Time Stamp Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_date_time_types.htm)
[DDIC - Special Character-Like Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_special_character_types.htm)
[DDIC - Currency Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_currency_field.htm)
[DDIC - Quantity Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_quantity_field.htm)
[DDIC - Geodata Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_geo_data.htm)


### abenddic_date_time_types.htm

---
title: "DDIC - Date Fields, Time Fields, and Time Stamp Fields"
description: |
  The following data types in ABAP Dictionary describe date fields, time fields, and time stamp fields: -   Date Types, Time Types, and Time Stamp Types(#abenddic-date-time-types-1-------character-like-date-fields-and-time-fields---@ITOC@@ABENDDIC_DATE_TIME_TYPES_2) Date Types, Time Types, and Time
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_date_time_types.htm"
abapFile: "abenddic_date_time_types.htm"
keywords: ["insert", "do", "if", "case", "try", "data", "types", "abenddic", "date", "time"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Data Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_intro.htm) →  [DDIC - Properties of the Built-In Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_prop.htm) →  [DDIC - Special Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_special.htm) → 

DDIC - Date Fields, Time Fields, and Time Stamp Fields

The following data types in ABAP Dictionary describe date fields, time fields, and time stamp fields:

-   [Date Types, Time Types, and Time Stamp Types](#abenddic-date-time-types-1-------character-like-date-fields-and-time-fields---@ITOC@@ABENDDIC_DATE_TIME_TYPES_2)

Date Types, Time Types, and Time Stamp Types

The following built-in data types in ABAP Dictionary represent real date types, time types, and time stamp types in a database:

-   [DATN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for date fields in the database
-   [TIMN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for time fields in the database
-   [UTCLONG](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for time stamp fields in the database

Database fields with these types generally contain only valid values for dates, times, and time stamps in the internal representation of the database. These types are currently only supported by [SAP HANA databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenhana_database_glosry.htm "Glossary Entry").

Hints

-   The dictionary types DATN and TIMN are mapped to the character-like ABAP date type and time type [d](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_date_time.htm) or [t](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_date_time.htm). The built-in ABAP type [utclong](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_date_time.htm), on the other hand, provides a real time stamp type for UTCLONG.
-   The types DATN and TIMN are recommended for saving individual dates and times. Access to dates and times in the corresponding functions and expressions is optimized for these types. In the case of the dictionary types DATS and TIMS, such access may not be possible at all or they may need to be converted to real date and time types.
-   The output formats for fields on dynpros and Web dynpros and in the statements [WRITE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite-.htm) or [WRITE TO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to.htm) can be predefined for the types DATN, TIMN, and UTCLONG specific to each user in the [user master record](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuser_master_record_glosry.htm "Glossary Entry"). The output length required for formatted output is usually greater than the number of places in ABAP Dictionary.

Character-Like Date Fields and Time Fields

Instances of the following data types in ABAP Dictionary are created on the database using character-like fields:

-   [DATS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for [date fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendate_field_glosry.htm "Glossary Entry")
    
    From a technical perspective, the built-in data type DATS describes objects of the type CHAR with a length of 8 characters. It is intended to be used for a [calendar date](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencalendar_date_glosry.htm "Glossary Entry") with the format YYYYMMDD. This is not checked however when writing to or reading from database fields of this type. Automatic checks are only made for dynpro fields typed with reference to DATS. In ABAP, DATS is assigned to the special type [d](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_date_time.htm) and the associated rules apply.
    
-   [TIMS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for [time fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentime_field_glosry.htm "Glossary Entry")
    
    From a technical perspective, the built-in data type TIMS describes objects of the type CHAR with a length of 6 characters. It is intended to be used for a [time](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenday_time_glosry.htm "Glossary Entry") with the format HHMMSS. This is not checked however when writing to or reading from database fields of this type. Automatic checks are only made for dynpro fields typed with reference to TIMS. In ABAP, TIMS is assigned to the special type [t](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_date_time.htm) and the associated rules apply.
    
-   [ACCP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for posting periods
    
    From a technical perspective, the built-in data type ACCP describes objects of the type CHAR with a length of 6 characters. It is intended to be used for a posting period with the format YYYYMM. This is not checked however when writing to or reading from database fields of this type. Automatic checks are only made for dynpro fields typed with reference to ACCP.
    

Hints

-   If possible, the types DATN and TIMN should be used.
-   The output formats for fields on dynpros and Web Dynpros and in the statements [WRITE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite-.htm) or [WRITE TO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to.htm) can be predefined for the types DATS and TIMS specific to each user in the [user master record](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuser_master_record_glosry.htm "Glossary Entry"). The output length required for formatted output is usually greater than the number of places in ABAP Dictionary. If the output length is too short, any formatting characters are suppressed.
-   When a [dynpro field](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_field_glosry.htm "Glossary Entry") is represented with reference to the type ACCP (but not in the statements [WRITE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite-.htm) or [WRITE TO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to.htm)) and there is enough output length, a point is inserted between the year YYYY and the month MM.


### abenddic_special_character_types.htm

---
title: "DDIC - Special Character-Like Types"
description: |
  The following character-like data types in ABAP Dictionary have a special semantic meaning: -   NUMC(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for numeric texts(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennumeric_text_glosry.htm 'Gl
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_special_character_types.htm"
abapFile: "abenddic_special_character_types.htm"
keywords: ["do", "if", "try", "data", "types", "abenddic", "special", "character"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Data Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_intro.htm) →  [DDIC - Properties of the Built-In Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_prop.htm) →  [DDIC - Special Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_special.htm) → 

DDIC - Special Character-Like Types

The following character-like data types in ABAP Dictionary have a special semantic meaning:

-   [NUMC](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for [numeric texts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennumeric_text_glosry.htm "Glossary Entry")
    
    From a technical perspective, the built-in data type NUMC describes objects of the type CHAR with a maximum length of 255 characters. It is intended for numeric texts. This is not checked however when writing to or reading from database fields of this type. Automatic checks are only made for dynpro fields typed with reference to NUMC. In ABAP, NUMC is assigned to the special type [n](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_character.htm) and the associated rules apply.
    
-   [CLNT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for [client columns](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenclient_column_glosry.htm "Glossary Entry")
    
    From a technical perspective, the data type CLNT describes objects of the type CHAR with length 3. If the data type CLNT is used for the first key field of a DDIC database table, this makes the DDIC database table [client-dependent](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_database_tables_client.htm).
    
-   [LANG](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) for [text language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_language_glosry.htm "Glossary Entry")
    
    From a technical perspective, the built-in data type LANG describes objects of the type CHAR with length 1. It is intended specifically for language keys. The [primary key](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprimary_key_glosry.htm "Glossary Entry") of a [text table](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_table_glosry.htm "Glossary Entry") consists of the [foreign key](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenforeign_key_glosry.htm "Glossary Entry") and a field of type LANG. Furthermore, a component of structures or DDIC database tables that has the data type LANG can be flagged as a text language. The text language is used to convert character-like components of the structure when importing data from [data clusters](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendata_cluster_glosry.htm "Glossary Entry") and in the binary [RFC protocol](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrfc_protocol.htm) for passing TABLES parameters between [MDMP systems](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmdmp-system_glosry.htm "Glossary Entry") and [Unicode systems](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenunicode_system_glosry.htm "Glossary Entry"). Furthermore, the text language can affect which lines of a database table are transported by the [Change and Transport System (CTS)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencts_glosry.htm "Glossary Entry"). Depending on settings in the CTS, only entries in the original language of the database table can be transported.
    

Hint

When the statements [WRITE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite-.htm) or [WRITE TO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to.htm) are used to represent a [dynpro field](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_field_glosry.htm "Glossary Entry") with the type LANG (and when a field that references this type is formatted), this field has an output length of 2 and is converted automatically from the single-character internal language ID to the matching two-character ISO ID using the [conversion routine](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_routine_glosry.htm "Glossary Entry") ISOLA (and back).


### abenddic_currency_field.htm

---
title: "DDIC - Currency Fields"
description: |
  A currency field is a component of a DDIC structure, DDIC database table, or DDIC view defined in ABAP Dictionary used to store an amount in a specific currency. A currency amount is an integer in the smallest unit of the currency. The integer is constructed from all figures in a currency field whil
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_currency_field.htm"
abapFile: "abenddic_currency_field.htm"
keywords: ["do", "while", "if", "case", "try", "method", "class", "data", "types", "abenddic", "currency", "field"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Data Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_intro.htm) →  [DDIC - Properties of the Built-In Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_prop.htm) →  [DDIC - Special Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_special.htm) → 

DDIC - Currency Fields

A currency field is a component of a DDIC structure, DDIC database table, or DDIC view defined in ABAP Dictionary used to store an amount in a specific currency. A currency amount is an integer in the smallest unit of the currency. The integer is constructed from all figures in a currency field while ignoring the position of the decimal separator.

A currency field can have data type CURR, DECFLOAT16, or DECFLOAT34. In case of data type CURR, a field is automatically interpreted as currency field and a reference to a currency key is mandatory. In case of the other data types, this reference is not mandatory, but if it is assigned, it turns the field into a currency field.

The currency key specifies the currency and the number of decimal places of a currency field. It is a component of a DDIC structure, DDIC database table, or DDIC view defined in ABAP Dictionary, has the type CUKY, and can contain a [currency ID](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencurrency_id_glosry.htm "Glossary Entry") from the DDIC database table TCURC.

By default, the number of decimal places for a currency is always two. Currencies with a different number of decimal places must also be entered in the table TCURX, where the number of decimal places can be defined explicitly.

-   [Handling in ABAP Dictionary](#abenddic-currency-field-1-------handling-in-dynpros---@ITOC@@ABENDDIC_CURRENCY_FIELD_2)
-   [Handling in ABAP Programs](#abenddic-currency-field-3---hints------currencies-are-handled-as-specified-by-the-data-saved-in-the-database-tables-tcur----of-the-package-sfib--the-exchange-rates-and-other-settings-can-be-maintained-in-transaction-ob08------currency-fields-are-defined-as-elements-of--cds-entities--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencds-entity-glosry-htm--glossary-entry---using--semantics-annotations--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencds-f1-element-annotation-htm----handling-in-abap-dictionary--a-data-element-of-data-type--curr--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-htm--is-handled-as-a-field-of-data-type--dec--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-int-pack-htm--and-is-stored-in-ddic-database-tables-in-the--bcd--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenbcd-glosry-htm--glossary-entry---format--when-creating-a-data-element-or-a-structure-component-of-the-data-type-curr-in-an-abap-dictionary--tool--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-tools-htm---a-number-of-decimal-places-other-than-zero-must-be-defined--the-standard-value-is-two-decimal-places---a-currency-field-of-data-type-decfloat16-or-decfloat34-is-handled-according-to-its-data-type---for-every-structure-component-of-data-type-curr--a-component-of-the-same-structure-or-of-a-different-ddic-structure--ddic-database-table--or-ddic-view-must-be-specified-as-a--reference-field--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-structures-sema-htm--with-the-data-type--cuky--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-htm---this-field-is-the--currency-key--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencurrency-key-glosry-htm--glossary-entry---that-defines-the-actual-currency--from-a-technical-perspective--the-data-type-cuky-is-handled-like-a-type-char-with-length-5---hints------the-number-of-decimal-places-for-the-currency-defined-by-the-currency-key-of-type-cuky-only-determines-the-formatting-and-checking-of-a-currency-field-on-a-dynpro--in-principal--it-is-independent-of-the-number-given-for-the-currency-field-of-type-curr--the-default-value-of-two-decimal-places-for-currency-fields-in-abap-dictionary-is-chosen-because-most-of-the-currencies-in-the-ddic-database-table-tcurc-have-two-decimal-places-and-are-not-entered-in-the-database-table-tcurx--it-is-not-advisable-to-use-any-other-value--since-in-this-case-any-unforeseen-operations-with-currency-keys-in-abap-programs-are-largely-ignored------the-conversion-function-currency--conversion---cds-view-entity--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencds-conversion-functions-v2-htm----cds-ddic-based-view--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencds-conversion-functions-v1-htm---in--abap-cds--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenabap-cds-glosry-htm--glossary-entry---also-assumes-two-decimal-places-for-currency-fields--if-the-function-for-currency-fields-is-used-with-other-amounts-of-decimal-places--unexpected-behavior-may-arise------as-in--general-packed-numbers--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-int-pack-htm---the-number-of-places-in-type-curr-should-be-odd---handling-in-dynpros--for-the-display-of-an-input-output-field-of-type-curr-on-a--dynpro--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abendynpro-glosry-htm--glossary-entry----the-content-is-displayed-as-character-like-content-and-in-accordance-with-a-type-dependent-mask--as-for-all--dynpro-fields--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abendynpro-field-glosry-htm--glossary-entry----here--the-positioning-of-the-decimal-point-for-a-currency-field-of-type-curr-on-a-dynpro-is-completely-independent-of-the-number-of-decimal-places-specified-by-the-data-element-in-abap-dictionary--greater-than-or-equal-to-one--the-default-value-is-two---the-number-of-decimal-places-on-a-dynpro-is-defined-as-follows-------when-displaying-a-dynpro-field-of-type-curr--the-reference-field-for-the-currency-key-is-searched-for-in-the-global-data-of-the-current-abap-program--the-content-of-this-field-must-be-a-valid--currency-id--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencurrency-id-glosry-htm--glossary-entry---from-the-ddic-database-table-tcurc--if-the-reference-field-is-not-found-or-there-is-no-entry-in-the-ddic-database-table-tcurx-with-the-content-of-the-field--the-currency-field-is-displayed-with-two-decimal-places-by-default-----------the-reference-field-is-either-defined-in-the-relevant-structure-in-abap-dictionary-or-was-defined-using-screen-painter-for-the-attributes-of-the-dynpro-field--it-does-not-have-to-be-present-on-the-dynpro-itself-----------if-the-currency-id-for-the-reference-field-is-found-in-the-database-table-tcurx--the-currency-field-is-displayed-with-the-decimal-places-specified-there--this-also-applies-to-initial-reference-fields---limitation--currency-fields-of-data-type-decfloat16-or-decfloat34-are-not-supported-on-dynpros---hint--a-dynpro-therefore-only-uses-the-string-of-digits-of-a-currency-field-from-the-abap-program--or-a--conversion-routine--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenconversion-routine-glosry-htm--glossary-entry---in-between--or-just-sends-this-string--any-information-about-currency-keys-and-decimal-places-is-not-passed-automatically--it-must-be-ensured-that-the-reference-field-for-pbo-is-filled-with-the-appropriate-value--for-pai--the-correct-currency-key-plays-a-part-in-the-automatic-format-check--especially-on-dynpros-in-which-currency-fields-are-displayed-in-differing-currencies--it-must-be-ensured-that-the-reference-field-is-transported-before-the-currency-by-using-the-statements--chain--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-dynpchain-htm--and--field--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-dynpfield-htm----handling-in-abap-programs--the-abap-type-that-corresponds-to-the-data-type-curr-is-p--an-abap-data-object-declared-with-reference-to-a-dictionary-type-of-type-curr-has-the-number-of-decimal-places-defined-there--greater-than-or-equal-to-one-and-the-default-is-two---these-decimal-places-are-respected-for-all-operations-and-calculations--as-for-all-packed-numbers--the-only-exceptions-are-the-programs-for-which-the-program-property--fixed-point-arithmetic--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenfixed-point-arithmetic-glosry-htm--glossary-entry---was-not-set---to-work-correctly-with-a-currency-field--all-digits-in-the-number-must-be-recorded-as-currency-amounts-in-the-smallest-possible-currency-units--regardless-of-the-number-of-decimal-places--this-occurs-automatically-sometimes--for-example--if--currency--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abapwrite-to-options-htm--is-used-after--write---to----https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abapwrite-to-htm---this-is-possible-for-currency-fields-of-data-types-curr--decfloat16--and-decfloat34--or-the-formatting-option--currency--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abapcompute-string-format-options-htm--in-an--embedded-expression--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenstring-templates-expressions-htm--of-a--string-template--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenstring-templates-htm---for-other-operations--the-following-restrictions-apply-------comparison--addition--subtraction--and-division-of-two-currency-fields-with-the-same-number-of-decimal-places-are-not-critical------multiplication-with-and-division-by-a-non-currency-dependent-number-is-not-critical------all-other-operations-are-critical--for-example----------multiplication-of-two-currency-fields----------operations-between-two-fields-with-different-currencies-that-include-assignments----------assignments-of-non-currency-dependent-numbers-to-currency-fields---accurate-results-should-not-be-expected-when-performing-critical-operations-if-the-number-of-decimal-places-in-the-program-does-not-match-the-number-in-the-currency---hints------for-currencies--one-of-the-data-types-for--decimal-floating-point-numbers--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-decimal-floating-point-htm--is-recommended-rather-than-the-data-type-curr--the-currency-compliant-formatting-is-supported-on-dynpros-by-output-styles-and-by-style-compatible-formatting-in-abap-programs--see-the--executable-example--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenwrite-style-abexa-htm-------the-methods-convert--curr--to--decfloat-and-convert--decfloat--to--curr-of-the-system-class--cl--abap--decfloat--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abencl-abap-decfloat-doc-htm--convert-currency-amounts-to-decimal-floating-point-numbers--and-back--as-specified-by-a-currency-key--------abenddic-quantity-field-htm------title---ddic---quantity-fields--description------a-quantity-field-is-a-component-of-a-structure--ddic-database-table--or-view-defined-in-abap-dictionary-and-used-to-store-a-quantity-in-a-specific-unit--a-quantity-field-can-have-data-type-quan--decfloat16--or-decfloat34--in-case-of-data-type-quan--a-field-is-automatically-interpreted-as-quantity-fi-version---7-56--category---types--type---abap-reference--sourceurl---https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-quantity-field-htm--abapfile---abenddic-quantity-field-htm--keywords----do----if----case----try----data----types----abenddic----quantity----field---------------as-abap-release-756---copyright-2021-sap-se--all-rights-reserved----abap---keyword-documentation--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenabap-htm------abap---dictionary--ddic---https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenabap-dictionary-htm------ddic---built-in-data-types--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-intro-htm------ddic---properties-of-the-built-in-dictionary-types--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-prop-htm------ddic---special-dictionary-types--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenddic-builtin-types-special-htm------ddic---quantity-fields--a-quantity-field-is-a-component-of-a-structure--ddic-database-table--or-view-defined-in-abap-dictionary-and-used-to-store-a-quantity-in-a-specific-unit--a-quantity-field-can-have-data-type-quan--decfloat16--or-decfloat34--in-case-of-data-type-quan--a-field-is-automatically-interpreted-as-quantity-field-and-a-reference-to-a-unit-key-is-mandatory--in-case-of-the-other-data-types--this-reference-is-not-mandatory--but-if-it-is-assigned--it-turns-the-field-into-a-quantity-field---the-unit-key-defines-the-unit-and-the-number-of-decimal-places--it-is-a-component-of-a-structure--ddic-database-table--or-ddic-view-of-type-unit-defined-in-abap-dictionary-and-can-contain-a--unit-id--https---help-sap-com-doc-abapdocu-756-index-htm-7-56-en-us-abenunit-id-glosry-htm--glossary-entry---from-the-ddic-database-table-t006--------handling-in-abap-dictionary---abenddic-quantity-field-1-------handling-in-dynpros---ITOC@@ABENDDIC_QUANTITY_FIELD_2)
-   [Handling in ABAP Programs](#@@ITOC@@ABENDDIC_QUANTITY_FIELD_3)

Hints

-   Quantities and units are handled as specified by the data saved in the DDIC database tables T006... in the package SZME. This data can be maintained using the transaction CUNI.
-   Quantity fields are defined as elements of [CDS entities](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_entity_glosry.htm "Glossary Entry") using [semantics annotations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_element_annotation.htm).

Handling in ABAP Dictionary

A data element of data type [QUAN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) is handled as a field of data type [DEC](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_int_pack.htm) and is stored in DDIC database tables in the [BCD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbcd_glosry.htm "Glossary Entry") format. When creating a data element or a structure component of the data type QUAN in an ABAP Dictionary [tool](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_tools.htm), any number of decimal places can be defined. The default value is no decimal places.

A quantity field of data type DECFLOAT16 or DECFLOAT34 is handled according to its data type.

For every structure component of data type QUAN, a component of the same structure or of a different structure, DDIC database table, or DDIC view must be defined as a [reference field](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_structures_sema.htm) with the data type [UNIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm). This field is the [unit key](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenunit_glosry.htm "Glossary Entry") that defines the unit of the quantity. From a technical perspective, the data type UNIT is handled like a type CHAR with length 2.

Hints

-   The number of decimal places for the unit defined using the unit key of type UNIT only affects the formatting of a quantity field on a dynpro. In principal, it is independent of the number given for the quantity field of type QUAN.
-   As in [general packed numbers](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_int_pack.htm), the number of places in type QUAN should be odd.

Handling in Dynpros

For the display of an input/output field of type QUAN on a [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry"), the content is displayed as character-like content and in accordance with a type-dependent mask, as for all [dynpro fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_field_glosry.htm "Glossary Entry"). The system tries to create a display which suits the unit of the quantity field.

To determine the unit, the global data of the current ABAP program is searched for the reference field associated with the field for the unit key. The content of this field must be a valid [unit ID](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenunit_id_glosry.htm "Glossary Entry") from the DDIC database table T006. If the reference field is not found or if there is no entry in the DDIC database table T006 with the content of the field, the quantity field is displayed as a regular field of type DEC.

The reference field is either defined in the relevant structure in ABAP Dictionary or was defined using Screen Painter for the attributes of the dynpro field. It does not have to be present on the dynpro itself.

If the unit ID of the reference field is found in the column MSEHI of the DDIC database table T006 and the quantity field does not have any decimal places with a value other than 0 outside the accuracy defined in the column DECAN, the quantity field is displayed with this accuracy. For a unit without decimal places, the decimal separator is suppressed. If the quantity field has decimal places with a value other than 0 outside of its accuracy, however, it is displayed as a regular field of type DEC.

Limitation: Quantity fields of data type DECFLOAT16 or DECFLOAT34 are not supported on dynpros.

Hint

A display that matches the accuracy of a quantity field is only then possible if no information is lost. This makes it possible, for example, for average values (else integer units) to be displayed in a relevant quantity field.

Handling in ABAP Programs

The ABAP type that corresponds to the data type QUAN is p. An ABAP data object declared with reference to a dictionary type of type QUAN has the number of decimal places defined there. These decimal places are respected for all operations and calculations, as for all packed numbers.

The unit defined for a quantity field only plays a part in ABAP programs if it is specified after the addition [UNIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to_options.htm) of the statement [WRITE *\[*TO*\]*](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwrite_to.htm). The addition UNIT of the statement WRITE *\[*TO*\]* can be used only for quantity fields of data type QUAN, not for quantity fields of any other data type.


### abenddic_geo_data.htm

---
title: "DDIC - Geodata Types"
description: |
  The geodata type(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeo_data_type_glosry.htm 'Glossary Entry') GEOM_EWKB(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) is a built-in data type in ABAP Dictionary that describes the geometric pos
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_geo_data.htm"
abapFile: "abenddic_geo_data.htm"
keywords: ["do", "if", "try", "data", "types", "abenddic", "geo"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Data Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_intro.htm) →  [DDIC - Properties of the Built-In Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_prop.htm) →  [DDIC - Special Dictionary Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types_special.htm) → 

DDIC - Geodata Types

The [geodata type](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeo_data_type_glosry.htm "Glossary Entry") [GEOM\_EWKB](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm) is a built-in data type in ABAP Dictionary that describes the geometric position in a given coordinate reference system.

It represents fields in the database that contain geometric data in the EWKB (Extended Well-Known Binary) format. This type is currently only supported on [SAP HANA databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenhana_database_glosry.htm "Glossary Entry") and references the database type ST\_GEOMETRY.

The internal representation of the geodata type GEOM\_EWKB is a [BLOB](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenblob_glosry.htm "Glossary Entry") (Binary Large Object) and the same rules and restrictions largely apply as to the type [RAWSTRING](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_types.htm). The type GEOM\_EWKB is mapped to the ABAP type [xstring](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuiltin_types_byte.htm).

At ABAP level, there is no semantic representation for geometric data. ABAP only allows geometric data to be passed between the application and the SAP HANA database. The SAP HANA database functions for geometric data types can be accessed using [AMDP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenamdp.htm).

If the data type GEOM\_EWKB is used for a structure component or a table field of a DDIC database table, the type must be assigned a [spatial reference system](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_database_tables_sptlrf.htm). This system cannot be changed once activated. The system has the ID 0 by default.

Hints

-   Columns of the data type GEOM\_EWKB are not supported as [BLOBs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenblob_glosry.htm "Glossary Entry") in [streaming and locators in ABAP SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstreams_locators.htm). To use columns of the data type GEOM\_EWKB in streaming and locators, they have to be converted to [JSON](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenjson_glosry.htm "Glossary Entry") format first. This can be done with the conversion function [AS\_GEO\_JSON](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_geo_conv_func.htm).
-   [NOT NULL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_database_tables_init.htm) cannot be set for a column of the type GEOM\_EWKB.


---


## ABAP - Keyword Documentation / ABAP - Dictionary (DDIC) / DDIC - Built-In Functions / DDIC - Special Functions

**Files**: 3 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Dictionary (DDIC) / DDIC - Built-In Functions / DDIC - Special Functions

Included pages: 3


### abenddic_special_functions.htm

---
title: "DDIC - Special Functions"
description: |
  These built-in functions are delivered by SAP and are not provided as native functions on every database platform: -   Conversion functions(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_conversion_functions.htm) -   Date functions and time functions(https://help.sap.com/doc
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_special_functions.htm"
abapFile: "abenddic_special_functions.htm"
keywords: ["do", "data", "abenddic", "special", "functions"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_functions.htm) → 

DDIC - Special Functions

These built-in functions are delivered by SAP and are not provided as native functions on every database platform:

-   [Conversion functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_conversion_functions.htm)
-   [Date functions and time functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_date_time_functions.htm)

Continue
[DDIC - Conversion Functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_conversion_functions.htm)
[DDIC - Date Functions and Time Functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_date_time_functions.htm)


### abenddic_conversion_functions.htm

---
title: "DDIC - Conversion Functions"
description: |
  The following table shows the conversion functions that can be used by ABAP CDS(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_cds_glosry.htm 'Glossary Entry') and ABAP SQL(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_glosry.htm 'Glossary Entry').
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_conversion_functions.htm"
abapFile: "abenddic_conversion_functions.htm"
keywords: ["do", "if", "try", "data", "types", "abenddic", "conversion", "functions"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_functions.htm) →  [DDIC - Special Functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_special_functions.htm) → 

DDIC - Conversion Functions

The following table shows the conversion functions that can be used by [ABAP CDS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_cds_glosry.htm "Glossary Entry") and [ABAP SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_glosry.htm "Glossary Entry"). The last three columns indicate where a function can be used.

SQL Function

Result

ABAP CDS, DDIC-Based Views

ABAP CDS, View Entities

ABAP SQL

AS\_GEO\_JSON

Conversion of an argument of type GEOM\_EWKB to JSON format

\-

\-

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_geo_conv_func.htm)

BINTOHEX

Converts an argument of the type RAW to a string of the type CHAR

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conv_func_types_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conv_func_types_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_type_conv_func.htm)

CURRENCY\_CONVERSION

Conversion of currencies.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conv_func_unit_curr_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conv_func_unit_curr_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_curr_unit_conv_func.htm)

DECIMAL\_SHIFT

Setting the decimal separator

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conv_func_unit_curr_v1.htm)

\-

\-

FLTP\_TO\_DEC

Conversion of an argument of type FLTP to a packed number

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conv_func_types_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conv_func_types_v2.htm)

\-

HEXTOBIN

Converts an argument of the type CHAR or NUMC to a byte string of the type RAW

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conv_func_types_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conv_func_types_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_type_conv_func.htm)

TO\_BLOB

Converts an argument of the type RAW to a byte string (BLOB) of the type RAWSTRING

\-

\-

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_type_conv_func.htm)

TO\_CLOB

Converts an argument of the type SSTRING to a CLOB of the type STRING

\-

\-

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_type_conv_func.htm)

UNIT\_CONVERSION

Conversion of units

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conv_func_unit_curr_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conv_func_unit_curr_v2.htm)

\-

Descriptions of the possible operands and data types as well as the exact functionality can be found in the corresponding documentation for [ABAP CDS, DDIC-Based Views](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conversion_functions_v1.htm), [ABAP CDS, View Entities](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_conversion_functions_v2.htm) and [ABAP SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_conversion_functions.htm).


### abenddic_date_time_functions.htm

---
title: "DDIC - Date Functions and Time Functions"
description: |
  The following table shows the date and time functions that can be used by ABAP CDS(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_cds_glosry.htm 'Glossary Entry') and ABAP SQL(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_glosry.htm 'Glossary Entry'
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_date_time_functions.htm"
abapFile: "abenddic_date_time_functions.htm"
keywords: ["select", "do", "if", "try", "data", "types", "abenddic", "date", "time", "functions"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Dictionary (DDIC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dictionary.htm) →  [DDIC - Built-In Functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_builtin_functions.htm) →  [DDIC - Special Functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_special_functions.htm) → 

DDIC - Date Functions and Time Functions

The following table shows the date and time functions that can be used by [ABAP CDS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_cds_glosry.htm "Glossary Entry") and [ABAP SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_glosry.htm "Glossary Entry"). The last three columns indicate where a function can be used.

SQL Function

Result

ABAP CDS, DDIC-Based Views

ABAP CDS, View Entities

ABAP SQL

ABAP\_SYSTEM\_TIMEZONE

System time zone in AS ABAP.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timezone_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timezone_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_timezone_func.htm)

ABAP\_USER\_TIMEZONE

User time zone in AS ABAP.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timezone_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timezone_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_timezone_func.htm)

DATN\_ADD\_DAYS

Adds days to a date.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_func.htm)

DATN\_ADD\_MONTHS

Adds months to a date.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_func.htm)

DATN\_DAYS\_BETWEEN

Difference between two dates.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_func.htm)

DATS\_ADD\_DAYS

Adds days to a date.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_func.htm)

DATS\_ADD\_MONTHS

Adds months to a date.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_func.htm)

DATS\_DAYS\_BETWEEN

Difference between two dates.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_func.htm)

DATS\_FROM\_DATN

Converts a date from type DATN to type DATS.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_time_conversions.htm)

DATS\_IS\_VALID

Shows whether the argument is a valid date.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_func.htm)

DATS\_TIMS\_TO\_TSTMP

Time stamp for a local date and a local time.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_time_conversions.htm)

DATS\_TO\_DATN

Converts a date from type DATS to type DATN.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_time_conversions.htm)

TIMS\_FROM\_TIMN

Converts a time from type TIMN to type TIMS.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_time_conversions.htm)

TIMS\_IS\_VALID

Shows whether the argument is a valid time.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_time_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_time_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_time_func.htm)

TIMS\_TO\_TIMN

Converts a time from type TIMS to type TIMN.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_time_conversions.htm)

TSTMP\_ADD\_SECONDS

Adds seconds to a time stamp.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_timestamp_func.htm)

TSTMP\_CURRENT\_UTCTIMESTAMP

Current UTC time stamp.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_timestamp_func.htm)

TSTMP\_IS\_VALID

Shows whether the argument is a valid time stamp.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_timestamp_func.htm)

TSTMP\_SECONDS\_BETWEEN

Difference between two time stamps in seconds.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_timestamp_func.htm)

TSTMP\_TO\_DATS

Local date of a time stamp.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_time_conversions.htm)

TSTMP\_TO\_DST

Local daylight saving time marker of a time stamp.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_time_conversions.htm)

TSTMP\_TO\_TIMS

Local time of a time stamp.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_time_conversions.htm)

TSTMPL\_FROM\_UTCL

Converts a time stamp from type UTCLONG to type TIMESTAMPL.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_time_conversions.htm)

TSTMPL\_TO\_UTCL

Converts a time stamp from type TIMESTAMPL to type UTCLONG.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_conversions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_date_time_conversions.htm)

UTCL\_ADD\_SECONDS

Adds seconds to a UTC time stamp.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_timestamp_func.htm)

UTCL\_CURRENT

Returns the current UTC time stamp within a SELECT\-statement.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_timestamp_func.htm)

UTCL\_SECONDS\_BETWEEN

Difference between two UTC time stamps in seconds.

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v1.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_timestamp_functions_v2.htm)

[x](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_timestamp_func.htm)

Descriptions of the possible operands and data types can be found in the corresponding documentation for [ABAP CDS, DDIC-Based Views](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_functions_v1.htm), [ABAP CDS, View Entities](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_date_time_functions_v2.htm) and [ABAP SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_date_time_functions.htm).


---


## ABAP - Keyword Documentation / ABAP - Core Data Services (ABAP CDS) / ABAP CDS - Data Definitions / ABAP CDS - DDL for Data Definitions / ABAP CDS - CDS Entities / ABAP CDS - View Entities / CDS DDL - DEFINE VIEW ENTITY / CDS DDL - CDS View Entity, SELECT / CDS DDL - SELECT, CDS View Entity, Operands and Expressions / CDS DDL - CDS View Entity, Expressions / CDS DDL - CDS View Entity, Built-In Functions / CDS DDL - CDS View Entity, Special Functions / CDS DDL - CDS View Entity, Conversion Functions

**Files**: 3 | **Difficulty**: advanced

# ABAP - Keyword Documentation / ABAP - Core Data Services (ABAP CDS) / ABAP CDS - Data Definitions / ABAP CDS - DDL for Data Definitions / ABAP CDS - CDS entity extension / CDS DDL - EXTEND VIEW ddic_based

Included pages: 2


### abencds_extend_view.htm

---
title: "Syntax"
description: |
  @AbapCatalog.sqlViewAppendName: 'CDS_APPEND_VIEW'(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm) @extension_annot1(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm) @extension_an
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_extend_view.htm"
abapFile: "abencds_extend_view.htm"
keywords: ["select", "delete", "do", "if", "try", "data", "types", "abencds", "extend", "view"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Core Data Services (ABAP CDS)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds.htm) →  [ABAP CDS - Data Definitions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_entities.htm) →  [ABAP CDS - DDL for Data Definitions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_ddl_syntax.htm) →  [ABAP CDS - CDS entity extension](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_extension.htm) → 

CDS DDL - EXTEND VIEW ddic\_based

Syntax

[@AbapCatalog.sqlViewAppendName: 'CDS\_APPEND\_VIEW'](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm)
*\[*[@extension\_annot1](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm)*\]*
*\[*[@extension\_annot2](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm)*\]*
...
EXTEND VIEW ddic\_based\_view
       WITH cds\_view\_extension
            *\[*association1
             association2 ...*\]*
            { select\_list\_extension }
            *\[*GROUP BY field1, field2, ...  *\]*
            *\[*UNION *\[*ALL*\]* { ... }*\]* *\[*;*\]*

Additions:

[1\. ... GROUP BY field1, field2, ...](#!ABAP_ADDITION_1@1@)
[2\. ... UNION *\[*ALL*\]* { ... }](#!ABAP_ADDITION_2@2@)

Effect

Extends an existing [CDS DDIC-based view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_v1_view_glosry.htm "Glossary Entry") ddic\_based\_view using a [CDS view extension](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_extend_glosry.htm "Glossary Entry") cds\_view\_extension in the [CDS DDL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_ddl_glosry.htm "Glossary Entry"). An existing CDS DDIC-based view can have one or more CDS view extensions.

The extended CDS view ddic\_based\_view must be specified under the name of its [CDS entity](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_entity_glosry.htm "Glossary Entry"). The name of the [CDS-managed DDIC view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_mngdddic_view_glosry.htm "Glossary Entry") cannot be specified.

Prerequisite

As a prerequisite for the enhancement of the CDS view with the statement EXTEND VIEW, the elements of the [annotation array](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenannotation_array_glosry.htm "Glossary Entry") [AbapCatalog.viewEnhancementCategory\[ \]](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_anno_v1.htm) must be specified accordingly in its definition with [DEFINE VIEW](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_define_view_v1.htm):

-   By default or if only the value #PROJECTION\_LIST is specified, views without [aggregate expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_aggregate_functions_v1.htm) in the SELECT list and without a [UNION](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_union_v1.htm) clause can be extended.
-   In order to extend views that have [aggregate expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_aggregate_functions_v1.htm) in the SELECT list, the annotation array must contain the value #GROUP\_BY alongside #PROJECTION\_LIST.
-   In order to extend views that contain [UNION](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_union_v1.htm) clauses, the annotation array must contain the value #UNION alongside #PROJECTION\_LIST.
-   If the annotation array contains the value #NONE, the view cannot be extended.

Components of a view extension

View extensions can make additions to the original view, but it can't modify, overwrite, or delete elements from the original view. The following components are possible in a CDS view extension:

-   The annotation [AbapCatalog.sqlViewAppendName](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm) is mandatory. Further annotations [extension\_annot1](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm), [extension\_annot2](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm), ... can also be specified. This is optional.
-   New associations association1, association2 can be defined and exposed in the CDS view extension. The same rules apply that are described in topic [CDS DDL - DDIC-based view, ASSOCIATION](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_simple_association_v1.htm).
    
    Note: It is not allowed to define new [CDS compositions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_composition_glosry.htm "Glossary Entry") or [CDS to-parent associations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abento_parent_association_glosry.htm "Glossary Entry") in a view extension.
    
-   The elements of the extension list select\_list\_extension specified after EXTEND VIEW are added to the existing SELECT list. At least one element must be added. It is possible to access all fields of all data sources of the extended view in the extension list select\_list\_extension. The list can have all [elements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_select_list_entry_v1.htm) of a [SELECT list](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_select_list_v1.htm), namely:
    -   [field](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_field_v2.htm) of a data source
    -   [Input parameters](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_parameter_v1.htm) of the extended CDS view. It is not possible to specify new input parameters in a view extension.
    -   It can expose a [CDS association](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_select_list_association_v2.htm) of the extended view or a newly defined association
    -   Using a [path expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_path_expression_v1.htm), a field of an association target can be included. Path expressions are possible for associations of the extended view or for newly defined associations.
    -   [literals, session variables, expressions and functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_operands_and_expr_v1.htm)
        
        Note: To add aggregate expressions to a view extension, special rules apply. See below.
        
-   Aggregate expressions are possible in the SELECT list of a view extension only if the following conditions are met:
    -   The original view must contain [aggregate expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_aggregate_functions_v1.htm). If the original view does not contain any aggregate expressions, this is not possible.
    -   The extended view must be annotated with AbapCatalog.viewEnhancementCategory \[#PROJECTION\_LIST, #GROUP\_BY\]
    -   If non-aggregated elements are added to a CDS view with aggregate expressions, then the [GROUP-BY](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_group_by_v1.htm) clause must be extended using the addition GROUP BY
-   If the original view contains [UNION](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_union_v1.htm), equivalent UNION additions must be used in the statement EXTEND VIEW. As a prerequisite, the extended view must be annotated with AbapCatalog.viewEnhancementCategory \[#PROJECTION\_LIST, #UNION\]
    
    If an appended element already occurs in the existing SELECT list or if a different extension occurs, it must be given an alternative element name using AS.
    

Restrictions

-   CDS views with an explicit [name list](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_name_list_v1.htm) cannot currently be extended.
-   CDS view extensions themselves cannot be extended.
-   It is not possible to specify new input parameters in a view extension.
-   No addition [ROOT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_define_root_view_v1.htm) can be specified in the statement EXTEND VIEW to transform a regular view to a [root entity](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenroot_entity_glosry.htm "Glossary Entry").
-   An appended field cannot be defined as a key field using KEY.
-   It is not allowed to define new to-parent or composition associations in a view extension.
-   For views that have an element of data type LRAW or LCHR in the SELECT list, no view extension is possible and the annotation AbapCatalog.viewEnhancementCategory\[#NONE\] is enforced. The reason is that elements of data types LRAW or LCHR must always be in the last position of the SELECT list.

Naming

Two repository objects are created for a CDS view extension that is defined using EXTEND VIEW. A name must be specified for each of the two objects:

-   The actual name cds\_view\_extension of the CDS view extension is specified after the keywords EXTEND VIEW. This name follows the same rules as the name of an [DDIC append view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_append_view_glosry.htm "Glossary Entry"), but can have up to 30 characters.
-   The name CDS\_APPEND\_VIEW for an [append view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_append_view_glosry.htm "Glossary Entry") in ABAP Dictionary must be specified in quotation marks after the annotation [@AbapCatalog.sqlViewAppendName](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm). This name is subject to the same rules as the name of a [DDIC database view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendatabase_view_glosry.htm "Glossary Entry") in ABAP Dictionary, see topic [DDIC - Naming Rules for DDIC Views](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_view_names.htm). The new DDIC append view extends the [CDS-managed DDIC view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_mngdddic_view_glosry.htm "Glossary Entry") of the extended CDS view. The name given to the DDIC append view can no longer be changed after the CDS view extension is transported into a follow-on system.

The name of the new DDIC append view and of the actual CDS view extension should be located in the customer namespace (or in the namespace of a partner or special development) to protect it against being overwritten by upgrades or new releases.

-   Once the DDL source code of a CDS view extension has been transported, the actual name cds\_view\_extension and the name of the DDIC append view CDS\_APPEND\_VIEW can no longer be changed. The extended view ddic\_based\_view can also no longer be changed.

Note: The DDL source code of a CDS view extension does not need to have the same name as the CDS view extension entity, but it is advisable to use the name of the entity.

Hints

-   Currently it is not possible to define extension categories for CDS views. The following restrictions apply for this reason:
    -   CDS views have the property can be extended in any way with respect to the [extension category of DDIC structures](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_structures_enh_cat.htm). The consequences of this must be respected when extending a CDS view.
    -   The attributes of a CDS view defined using [annotations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_anno_v1.htm), such as switching on [table buffering](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentable_buffering_glosry.htm "Glossary Entry"), cannot currently be modified using extensions.
-   CDS view extensions specified with EXTEND ENTITY are recommended for CDS DDIC-based views only. However, for compatibility and migration reasons, it is also possible to extend [CDS projection views](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_projection_view_glosry.htm "Glossary Entry") or [CDS view entities](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_v2_view_glosry.htm "Glossary Entry") with the statement EXTEND VIEW. However, view extends defined using EXTEND VIEW don't support the syntax elements specific to projection views and CDS view entities. Therefore, it is recommended to use the statement [EXTEND VIEW ENTITY](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_extend_view_entity.htm) for extensions of CDS projection views and CDS view entities instead.
-   If, for some reason, a CDS projection view or a CDS view entity is extended with EXTEND VIEW, the [CDS-managed DDIC view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_mngdddic_view_glosry.htm "Glossary Entry") is deleted (as CDS projection views and CDS view entities do not have any DDIC artefacts), and entity annotations referring to the CDS-managed DDIC view are ignored.

Example

The following CDS view extension

@AbapCatalog.sqlViewAppendName: 'DEMO\_CDS\_EXTENS'
extend view demo\_cds\_original\_view with demo\_cds\_view\_extension  
  {
    spfli.distance,
    spfli.distid as unit
  };

adds two view fields to the existing CDS view

@AbapCatalog.sqlViewName: 'DEMO\_CDS\_ORIG'
@AccessControl.authorizationCheck: #NOT\_REQUIRED
@AbapCatalog.viewEnhancementCategory: \[#PROJECTION\_LIST\]
@EndUserText.label: 'Further information about the CDS entity'
define view demo\_cds\_original\_view  
  as select from
           spfli
      join scarr on
        scarr.carrid = spfli.carrid
    {
      key scarr.carrname     as carrier,
      key spfli.connid       as flight,
          spfli.cityfrom     as departure,
          spfli.cityto       as destination
    }; .

The DDIC append view DEMO\_CDS\_EXTENS is created in ABAP Dictionary. The program DEMO\_CDS\_VIEW\_EXTENSION uses the statement [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) to access the enhanced view and also displays the components of the dictionary structures in question.

Addition 1   

... GROUP BY field1, field2, ...

Effect

This addition must be specified if elements not defined using aggregate expressions are added to a view with [aggregate expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_aggregate_functions_v1.htm). These elements must be specified after GROUP BY add extend the [GROUP-BY](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_group_by_v1.htm) clause of the original view. With respect to the extended view, the extended GROUP-BY clause must follow the general rules for a GROUP-BY clause.

The addition cannot be specified if the definition of the original view does not contain any aggregate expressions in its SELECT list.

Hint

Extensions of a view with aggregate expressions require it to contain the annotation array viewEnhancementCategory\[ \] with the value #GROUP\_BY.

Example

The following CDS view extension

@AbapCatalog.sqlViewAppendName: 'DEMO\_CDS\_EXTAGG'
extend view demo\_cds\_aggregate with demo\_cds\_extend\_aggregate
  {
    connid,  
    sum(distance) as sum\_distance
  }
  group by
    connid;

extends the existing CDS view

@AbapCatalog.sqlViewName: 'DEMO\_CDS\_AGG'
@AccessControl.authorizationCheck: #NOT\_REQUIRED
@AbapCatalog.viewEnhancementCategory: \[#PROJECTION\_LIST,#GROUP\_BY\]
define view demo\_cds\_aggregate
  as select from
    spfli  
    {
      carrid,
      sum(fltime) as sum\_fltime
    }
    group by
      carrid; .

A database field connid and an aggregate expression sum(distance) are added to the SELECT list. Accordingly, the addition GROUP BY must be used to add the database field to the GROUP-BY clause of the original view.

Addition 2   

... UNION *\[*ALL*\]* { ... }

Effect

This addition must be specified when a view with [UNION](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_union_v1.htm) clauses is extended. A corresponding UNION addition must be specified for each UNION clause of the original view. The addition ALL must be specified each time it is specified in the associated UNION clause of the original view. The curly brackets can contain elements that extend the SELECT list of the associated UNION clause of the original view. As specified by the SELECT list extended using select\_list\_extension, the UNION clauses must be extended so that the rules for UNION clauses are not broken in the extended view.

The addition cannot be specified if the definition of the original view does not have a UNION clause.

Hint

Extensions of a view with UNION clauses require it to contain the annotation array viewEnhancementCategory\[ \] with the value #UNION.

Example

The following CDS view extension

@AbapCatalog.sqlViewAppendName: 'DEMO\_CDS\_EXTUNI'
extend view demo\_cds\_union with demo\_cds\_extend\_union
  {
    c as c3,
    d as c4
  }
union
  {
    f as c3,
    g as c4
  }
union all
  {
    k as c3,
    l as c4
  };

extends the existing CDS view

@AbapCatalog.sqlViewName: 'DEMO\_CDS\_UIO'
@AccessControl.authorizationCheck: #NOT\_REQUIRED
@AbapCatalog.viewEnhancementCategory: \[#PROJECTION\_LIST,#UNION\]
define view demo\_cds\_union
  as select from
    demo\_join1
    {
      a as c1,
      b as c2
    }
union select from
  demo\_join2
    {
      d as c1,
      e as c2
    }
union all select from
  demo\_join3
    {
      i as c1,
      j as c2
    }; .

The original view has two UNION clauses represented using corresponding UNION additions in the definition of the CDS view extension. Two elements with matching types are added to the three SELECT lists of the original view.

Continue
[CDS DDL - EXTEND VIEW, extension\_annot](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm)


### abencds_f1_extend_view_annotations.htm

---
title: "Syntax"
description: |
  ... @annotation(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotations_syntax.htm) ... Effect Specifies an annotation(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotation_glosry.htm 'Glossary Entry') annotation(https://help.sap.com/doc/abapdocu_
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm"
abapFile: "abencds_f1_extend_view_annotations.htm"
keywords: ["do", "if", "try", "data", "abencds", "extend", "view", "annotations"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Core Data Services (ABAP CDS)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds.htm) →  [ABAP CDS - Data Definitions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_entities.htm) →  [ABAP CDS - DDL for Data Definitions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_ddl_syntax.htm) →  [ABAP CDS - CDS entity extension](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_extension.htm) →  [CDS DDL - EXTEND VIEW ddic\_based](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_extend_view.htm) → 

CDS DDL - EXTEND VIEW, extension\_annot

Syntax

... @[annotation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotations_syntax.htm) ...

Effect

Specifies an [annotation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotation_glosry.htm "Glossary Entry") [annotation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotations_syntax.htm) as an extension annotation in the definition of a [CDS view extension](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_extend_glosry.htm "Glossary Entry") before the statement [EXTEND VIEW](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_extend_view.htm). The character @ must be placed in front of the name annotation of the annotation. The annotation should be defined as a CDS object in a [CDS annotation definition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_anno_definition_glosry.htm "Glossary Entry") and the annotation definition annotation [@Scope](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_define_anno_annos.htm) should be specified here using the value #EXTEND\_VIEW.

The following tables show the possible [ABAP annotations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_annotation_glosry.htm "Glossary Entry") that can be specified and their meanings. The ABAP annotations are evaluated by the ABAP runtime framework for every CDS entity. Annotations with other identifiers are usually [framework-specific annotations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotations_frmwrk.htm). These are not evaluated by the ABAP runtime framework but by other SAP frameworks instead.

The first column of the table shows the (possibly structured) name annotation of an ABAP annotation and the second column shows its meaning. The third column shows the possible [annotation values](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenannotation_value_glosry.htm "Glossary Entry"). The fourth column shows the default value which is used if the annotation is not used at all. The fifth column shows the default value set implicitly for value in accordance with the [annotation definition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_anno_definition_glosry.htm "Glossary Entry") if the annotation is specified without a value. If nothing is specified for the annotation value, the annotation should be specified without a value.

AbapCatalog Annotations

Technical settings of a CDS view extension.

Annotation

Meaning

Annotation Values

Default Value if Not Used

Default Value if Used Without Value

AbapCatalog.sqlViewAppendName

Name of the DDIC append view of the CDS view extension

Character string with a maximum of 16 characters consisting of letters, numbers and underscores and that starts with a [namespace prefix](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenname_space_prefix_glosry.htm "Glossary Entry").

\-

\-

Hints

-   Each definition of a CDS view extension must contain the ABAP annotation AbapCatalog.sqlViewAppendName that defines the name of the DDIC append view in ABAP Dictionary.
-   The name given to the DDIC append view can no longer be changed after the CDS view extension is transported into a follow-on system.


---


## ABAP - Keyword Documentation / ABAP - Core Data Services (ABAP CDS) / ABAP CDS - Data Definitions / ABAP CDS - DDL for Data Definitions / ABAP CDS - CDS Entities / ABAP CDS - DDIC-Based Entities / ABAP CDS - DDIC-Based Views / CDS DDL - DEFINE VIEW ddic_based / CDS DDL - DDIC-based View, SELECT / CDS DDL - DDIC-based View, SELECT, Operands and Expressions / CDS DDL - DDIC-based View, Expressions / CDS DDL - DDIC-Based View, Built-In Functions / CDS DDL - DDIC-based View, Special Functions / CDS DDL - DDIC-Based View, Conversion Functions

**Files**: 3 | **Difficulty**: advanced

# ABAP - Keyword Documentation / ABAP - Core Data Services (ABAP CDS) / ABAP CDS - Data Definitions / ABAP CDS - DDL for Data Definitions / ABAP CDS - CDS entity extension / CDS DDL - EXTEND VIEW ddic_based

Included pages: 2


### abencds_extend_view.htm

---
title: "Syntax"
description: |
  @AbapCatalog.sqlViewAppendName: 'CDS_APPEND_VIEW'(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm) @extension_annot1(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm) @extension_an
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_extend_view.htm"
abapFile: "abencds_extend_view.htm"
keywords: ["select", "delete", "do", "if", "try", "data", "types", "abencds", "extend", "view"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Core Data Services (ABAP CDS)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds.htm) →  [ABAP CDS - Data Definitions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_entities.htm) →  [ABAP CDS - DDL for Data Definitions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_ddl_syntax.htm) →  [ABAP CDS - CDS entity extension](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_extension.htm) → 

CDS DDL - EXTEND VIEW ddic\_based

Syntax

[@AbapCatalog.sqlViewAppendName: 'CDS\_APPEND\_VIEW'](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm)
*\[*[@extension\_annot1](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm)*\]*
*\[*[@extension\_annot2](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm)*\]*
...
EXTEND VIEW ddic\_based\_view
       WITH cds\_view\_extension
            *\[*association1
             association2 ...*\]*
            { select\_list\_extension }
            *\[*GROUP BY field1, field2, ...  *\]*
            *\[*UNION *\[*ALL*\]* { ... }*\]* *\[*;*\]*

Additions:

[1\. ... GROUP BY field1, field2, ...](#!ABAP_ADDITION_1@1@)
[2\. ... UNION *\[*ALL*\]* { ... }](#!ABAP_ADDITION_2@2@)

Effect

Extends an existing [CDS DDIC-based view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_v1_view_glosry.htm "Glossary Entry") ddic\_based\_view using a [CDS view extension](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_extend_glosry.htm "Glossary Entry") cds\_view\_extension in the [CDS DDL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_ddl_glosry.htm "Glossary Entry"). An existing CDS DDIC-based view can have one or more CDS view extensions.

The extended CDS view ddic\_based\_view must be specified under the name of its [CDS entity](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_entity_glosry.htm "Glossary Entry"). The name of the [CDS-managed DDIC view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_mngdddic_view_glosry.htm "Glossary Entry") cannot be specified.

Prerequisite

As a prerequisite for the enhancement of the CDS view with the statement EXTEND VIEW, the elements of the [annotation array](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenannotation_array_glosry.htm "Glossary Entry") [AbapCatalog.viewEnhancementCategory\[ \]](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_anno_v1.htm) must be specified accordingly in its definition with [DEFINE VIEW](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_define_view_v1.htm):

-   By default or if only the value #PROJECTION\_LIST is specified, views without [aggregate expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_aggregate_functions_v1.htm) in the SELECT list and without a [UNION](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_union_v1.htm) clause can be extended.
-   In order to extend views that have [aggregate expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_aggregate_functions_v1.htm) in the SELECT list, the annotation array must contain the value #GROUP\_BY alongside #PROJECTION\_LIST.
-   In order to extend views that contain [UNION](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_union_v1.htm) clauses, the annotation array must contain the value #UNION alongside #PROJECTION\_LIST.
-   If the annotation array contains the value #NONE, the view cannot be extended.

Components of a view extension

View extensions can make additions to the original view, but it can't modify, overwrite, or delete elements from the original view. The following components are possible in a CDS view extension:

-   The annotation [AbapCatalog.sqlViewAppendName](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm) is mandatory. Further annotations [extension\_annot1](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm), [extension\_annot2](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm), ... can also be specified. This is optional.
-   New associations association1, association2 can be defined and exposed in the CDS view extension. The same rules apply that are described in topic [CDS DDL - DDIC-based view, ASSOCIATION](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_simple_association_v1.htm).
    
    Note: It is not allowed to define new [CDS compositions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_composition_glosry.htm "Glossary Entry") or [CDS to-parent associations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abento_parent_association_glosry.htm "Glossary Entry") in a view extension.
    
-   The elements of the extension list select\_list\_extension specified after EXTEND VIEW are added to the existing SELECT list. At least one element must be added. It is possible to access all fields of all data sources of the extended view in the extension list select\_list\_extension. The list can have all [elements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_select_list_entry_v1.htm) of a [SELECT list](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_select_list_v1.htm), namely:
    -   [field](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_field_v2.htm) of a data source
    -   [Input parameters](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_parameter_v1.htm) of the extended CDS view. It is not possible to specify new input parameters in a view extension.
    -   It can expose a [CDS association](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_select_list_association_v2.htm) of the extended view or a newly defined association
    -   Using a [path expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_path_expression_v1.htm), a field of an association target can be included. Path expressions are possible for associations of the extended view or for newly defined associations.
    -   [literals, session variables, expressions and functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_operands_and_expr_v1.htm)
        
        Note: To add aggregate expressions to a view extension, special rules apply. See below.
        
-   Aggregate expressions are possible in the SELECT list of a view extension only if the following conditions are met:
    -   The original view must contain [aggregate expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_aggregate_functions_v1.htm). If the original view does not contain any aggregate expressions, this is not possible.
    -   The extended view must be annotated with AbapCatalog.viewEnhancementCategory \[#PROJECTION\_LIST, #GROUP\_BY\]
    -   If non-aggregated elements are added to a CDS view with aggregate expressions, then the [GROUP-BY](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_group_by_v1.htm) clause must be extended using the addition GROUP BY
-   If the original view contains [UNION](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_union_v1.htm), equivalent UNION additions must be used in the statement EXTEND VIEW. As a prerequisite, the extended view must be annotated with AbapCatalog.viewEnhancementCategory \[#PROJECTION\_LIST, #UNION\]
    
    If an appended element already occurs in the existing SELECT list or if a different extension occurs, it must be given an alternative element name using AS.
    

Restrictions

-   CDS views with an explicit [name list](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_name_list_v1.htm) cannot currently be extended.
-   CDS view extensions themselves cannot be extended.
-   It is not possible to specify new input parameters in a view extension.
-   No addition [ROOT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_define_root_view_v1.htm) can be specified in the statement EXTEND VIEW to transform a regular view to a [root entity](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenroot_entity_glosry.htm "Glossary Entry").
-   An appended field cannot be defined as a key field using KEY.
-   It is not allowed to define new to-parent or composition associations in a view extension.
-   For views that have an element of data type LRAW or LCHR in the SELECT list, no view extension is possible and the annotation AbapCatalog.viewEnhancementCategory\[#NONE\] is enforced. The reason is that elements of data types LRAW or LCHR must always be in the last position of the SELECT list.

Naming

Two repository objects are created for a CDS view extension that is defined using EXTEND VIEW. A name must be specified for each of the two objects:

-   The actual name cds\_view\_extension of the CDS view extension is specified after the keywords EXTEND VIEW. This name follows the same rules as the name of an [DDIC append view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_append_view_glosry.htm "Glossary Entry"), but can have up to 30 characters.
-   The name CDS\_APPEND\_VIEW for an [append view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_append_view_glosry.htm "Glossary Entry") in ABAP Dictionary must be specified in quotation marks after the annotation [@AbapCatalog.sqlViewAppendName](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm). This name is subject to the same rules as the name of a [DDIC database view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendatabase_view_glosry.htm "Glossary Entry") in ABAP Dictionary, see topic [DDIC - Naming Rules for DDIC Views](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_view_names.htm). The new DDIC append view extends the [CDS-managed DDIC view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_mngdddic_view_glosry.htm "Glossary Entry") of the extended CDS view. The name given to the DDIC append view can no longer be changed after the CDS view extension is transported into a follow-on system.

The name of the new DDIC append view and of the actual CDS view extension should be located in the customer namespace (or in the namespace of a partner or special development) to protect it against being overwritten by upgrades or new releases.

-   Once the DDL source code of a CDS view extension has been transported, the actual name cds\_view\_extension and the name of the DDIC append view CDS\_APPEND\_VIEW can no longer be changed. The extended view ddic\_based\_view can also no longer be changed.

Note: The DDL source code of a CDS view extension does not need to have the same name as the CDS view extension entity, but it is advisable to use the name of the entity.

Hints

-   Currently it is not possible to define extension categories for CDS views. The following restrictions apply for this reason:
    -   CDS views have the property can be extended in any way with respect to the [extension category of DDIC structures](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_structures_enh_cat.htm). The consequences of this must be respected when extending a CDS view.
    -   The attributes of a CDS view defined using [annotations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_anno_v1.htm), such as switching on [table buffering](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentable_buffering_glosry.htm "Glossary Entry"), cannot currently be modified using extensions.
-   CDS view extensions specified with EXTEND ENTITY are recommended for CDS DDIC-based views only. However, for compatibility and migration reasons, it is also possible to extend [CDS projection views](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_projection_view_glosry.htm "Glossary Entry") or [CDS view entities](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_v2_view_glosry.htm "Glossary Entry") with the statement EXTEND VIEW. However, view extends defined using EXTEND VIEW don't support the syntax elements specific to projection views and CDS view entities. Therefore, it is recommended to use the statement [EXTEND VIEW ENTITY](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_extend_view_entity.htm) for extensions of CDS projection views and CDS view entities instead.
-   If, for some reason, a CDS projection view or a CDS view entity is extended with EXTEND VIEW, the [CDS-managed DDIC view](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_mngdddic_view_glosry.htm "Glossary Entry") is deleted (as CDS projection views and CDS view entities do not have any DDIC artefacts), and entity annotations referring to the CDS-managed DDIC view are ignored.

Example

The following CDS view extension

@AbapCatalog.sqlViewAppendName: 'DEMO\_CDS\_EXTENS'
extend view demo\_cds\_original\_view with demo\_cds\_view\_extension  
  {
    spfli.distance,
    spfli.distid as unit
  };

adds two view fields to the existing CDS view

@AbapCatalog.sqlViewName: 'DEMO\_CDS\_ORIG'
@AccessControl.authorizationCheck: #NOT\_REQUIRED
@AbapCatalog.viewEnhancementCategory: \[#PROJECTION\_LIST\]
@EndUserText.label: 'Further information about the CDS entity'
define view demo\_cds\_original\_view  
  as select from
           spfli
      join scarr on
        scarr.carrid = spfli.carrid
    {
      key scarr.carrname     as carrier,
      key spfli.connid       as flight,
          spfli.cityfrom     as departure,
          spfli.cityto       as destination
    }; .

The DDIC append view DEMO\_CDS\_EXTENS is created in ABAP Dictionary. The program DEMO\_CDS\_VIEW\_EXTENSION uses the statement [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) to access the enhanced view and also displays the components of the dictionary structures in question.

Addition 1   

... GROUP BY field1, field2, ...

Effect

This addition must be specified if elements not defined using aggregate expressions are added to a view with [aggregate expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_aggregate_functions_v1.htm). These elements must be specified after GROUP BY add extend the [GROUP-BY](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_group_by_v1.htm) clause of the original view. With respect to the extended view, the extended GROUP-BY clause must follow the general rules for a GROUP-BY clause.

The addition cannot be specified if the definition of the original view does not contain any aggregate expressions in its SELECT list.

Hint

Extensions of a view with aggregate expressions require it to contain the annotation array viewEnhancementCategory\[ \] with the value #GROUP\_BY.

Example

The following CDS view extension

@AbapCatalog.sqlViewAppendName: 'DEMO\_CDS\_EXTAGG'
extend view demo\_cds\_aggregate with demo\_cds\_extend\_aggregate
  {
    connid,  
    sum(distance) as sum\_distance
  }
  group by
    connid;

extends the existing CDS view

@AbapCatalog.sqlViewName: 'DEMO\_CDS\_AGG'
@AccessControl.authorizationCheck: #NOT\_REQUIRED
@AbapCatalog.viewEnhancementCategory: \[#PROJECTION\_LIST,#GROUP\_BY\]
define view demo\_cds\_aggregate
  as select from
    spfli  
    {
      carrid,
      sum(fltime) as sum\_fltime
    }
    group by
      carrid; .

A database field connid and an aggregate expression sum(distance) are added to the SELECT list. Accordingly, the addition GROUP BY must be used to add the database field to the GROUP-BY clause of the original view.

Addition 2   

... UNION *\[*ALL*\]* { ... }

Effect

This addition must be specified when a view with [UNION](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_union_v1.htm) clauses is extended. A corresponding UNION addition must be specified for each UNION clause of the original view. The addition ALL must be specified each time it is specified in the associated UNION clause of the original view. The curly brackets can contain elements that extend the SELECT list of the associated UNION clause of the original view. As specified by the SELECT list extended using select\_list\_extension, the UNION clauses must be extended so that the rules for UNION clauses are not broken in the extended view.

The addition cannot be specified if the definition of the original view does not have a UNION clause.

Hint

Extensions of a view with UNION clauses require it to contain the annotation array viewEnhancementCategory\[ \] with the value #UNION.

Example

The following CDS view extension

@AbapCatalog.sqlViewAppendName: 'DEMO\_CDS\_EXTUNI'
extend view demo\_cds\_union with demo\_cds\_extend\_union
  {
    c as c3,
    d as c4
  }
union
  {
    f as c3,
    g as c4
  }
union all
  {
    k as c3,
    l as c4
  };

extends the existing CDS view

@AbapCatalog.sqlViewName: 'DEMO\_CDS\_UIO'
@AccessControl.authorizationCheck: #NOT\_REQUIRED
@AbapCatalog.viewEnhancementCategory: \[#PROJECTION\_LIST,#UNION\]
define view demo\_cds\_union
  as select from
    demo\_join1
    {
      a as c1,
      b as c2
    }
union select from
  demo\_join2
    {
      d as c1,
      e as c2
    }
union all select from
  demo\_join3
    {
      i as c1,
      j as c2
    }; .

The original view has two UNION clauses represented using corresponding UNION additions in the definition of the CDS view extension. Two elements with matching types are added to the three SELECT lists of the original view.

Continue
[CDS DDL - EXTEND VIEW, extension\_annot](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm)


### abencds_f1_extend_view_annotations.htm

---
title: "Syntax"
description: |
  ... @annotation(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotations_syntax.htm) ... Effect Specifies an annotation(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotation_glosry.htm 'Glossary Entry') annotation(https://help.sap.com/doc/abapdocu_
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_extend_view_annotations.htm"
abapFile: "abencds_f1_extend_view_annotations.htm"
keywords: ["do", "if", "try", "data", "abencds", "extend", "view", "annotations"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Core Data Services (ABAP CDS)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds.htm) →  [ABAP CDS - Data Definitions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_entities.htm) →  [ABAP CDS - DDL for Data Definitions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_ddl_syntax.htm) →  [ABAP CDS - CDS entity extension](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_extension.htm) →  [CDS DDL - EXTEND VIEW ddic\_based](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_extend_view.htm) → 

CDS DDL - EXTEND VIEW, extension\_annot

Syntax

... @[annotation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotations_syntax.htm) ...

Effect

Specifies an [annotation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotation_glosry.htm "Glossary Entry") [annotation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotations_syntax.htm) as an extension annotation in the definition of a [CDS view extension](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_view_extend_glosry.htm "Glossary Entry") before the statement [EXTEND VIEW](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_extend_view.htm). The character @ must be placed in front of the name annotation of the annotation. The annotation should be defined as a CDS object in a [CDS annotation definition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_anno_definition_glosry.htm "Glossary Entry") and the annotation definition annotation [@Scope](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_f1_define_anno_annos.htm) should be specified here using the value #EXTEND\_VIEW.

The following tables show the possible [ABAP annotations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_annotation_glosry.htm "Glossary Entry") that can be specified and their meanings. The ABAP annotations are evaluated by the ABAP runtime framework for every CDS entity. Annotations with other identifiers are usually [framework-specific annotations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_annotations_frmwrk.htm). These are not evaluated by the ABAP runtime framework but by other SAP frameworks instead.

The first column of the table shows the (possibly structured) name annotation of an ABAP annotation and the second column shows its meaning. The third column shows the possible [annotation values](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenannotation_value_glosry.htm "Glossary Entry"). The fourth column shows the default value which is used if the annotation is not used at all. The fifth column shows the default value set implicitly for value in accordance with the [annotation definition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_anno_definition_glosry.htm "Glossary Entry") if the annotation is specified without a value. If nothing is specified for the annotation value, the annotation should be specified without a value.

AbapCatalog Annotations

Technical settings of a CDS view extension.

Annotation

Meaning

Annotation Values

Default Value if Not Used

Default Value if Used Without Value

AbapCatalog.sqlViewAppendName

Name of the DDIC append view of the CDS view extension

Character string with a maximum of 16 characters consisting of letters, numbers and underscores and that starts with a [namespace prefix](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenname_space_prefix_glosry.htm "Glossary Entry").

\-

\-

Hints

-   Each definition of a CDS view extension must contain the ABAP annotation AbapCatalog.sqlViewAppendName that defines the name of the DDIC append view in ABAP Dictionary.
-   The name given to the DDIC append view can no longer be changed after the CDS view extension is transported into a follow-on system.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / Program Maintenance / Dynamic Program Development / Dynpro

**Files**: 8 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / Program Maintenance / Dynamic Program Development / Dynpro

Included pages: 8


### abenabap_generic_dynpro.htm

---
title: "Dynpro"
description: |
  The statements for creating and editing dynpros(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm 'Glossary Entry') are not released for application programming and cannot be used in application programs. Internal Statements for Editing Dynpros(https://help.sap.com
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_generic_dynpro.htm"
abapFile: "abenabap_generic_dynpro.htm"
keywords: ["do", "try", "abenabap", "generic", "dynpro"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Program Maintenance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_editing.htm) →  [Dynamic Program Development](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_language_dynamic.htm) → 

Dynpro

The statements for creating and editing [dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") are not released for application programming and cannot be used in application programs.

Continue
[Internal Statements for Editing Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_dynpro_internal.htm)


### abengeneric_dynpro_internal.htm

---
title: "Internal Statements for Editing Dynpros"
description: |
  These statements are for internal use only. Do not use them in application programs. -   EXPORT DYNPRO(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapexport_dynpro.htm) -   IMPORT DYNPRO(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapimport_dynpro.htm) -   DELETE
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_dynpro_internal.htm"
abapFile: "abengeneric_dynpro_internal.htm"
keywords: ["delete", "do", "abengeneric", "dynpro", "internal"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Program Maintenance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_editing.htm) →  [Dynamic Program Development](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_language_dynamic.htm) →  [Dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_generic_dynpro.htm) → 

Internal Statements for Editing Dynpros

These statements are for internal use only.
Do not use them in application programs.

-   [EXPORT DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapexport_dynpro.htm)
-   [IMPORT DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapimport_dynpro.htm)
-   [DELETE DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapdelete_dynpro.htm)
-   [SYNTAX-CHECK FOR DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsyntax-check_for_dynpro.htm)
-   [GENERATE DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapgenerate_dynpro.htm)

Continue
[EXPORT DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapexport_dynpro.htm)
[IMPORT DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapimport_dynpro.htm)
[DELETE DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapdelete_dynpro.htm)
[SYNTAX-CHECK FOR DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsyntax-check_for_dynpro.htm)
[GENERATE DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapgenerate_dynpro.htm)


### abapexport_dynpro.htm

---
title: "EXPORT DYNPRO"
description: |
  This statement is for internal use only. It must not be used in application programs. Syntax EXPORT DYNPRO h f e m ID id. Effect Exports the dynpro(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm 'Glossary Entry') with the name in the id. The dynpro information is
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapexport_dynpro.htm"
abapFile: "abapexport_dynpro.htm"
keywords: ["do", "if", "try", "internal-table", "abapexport", "dynpro"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Program Maintenance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_editing.htm) →  [Dynamic Program Development](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_language_dynamic.htm) →  [Dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_generic_dynpro.htm) →  [Internal Statements for Editing Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_dynpro_internal.htm) → 

EXPORT DYNPRO

This statement is for internal use only.
It must not be used in application programs.

Syntax

EXPORT DYNPRO h f e m ID id.

Effect

Exports the [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") with the name in the id. The dynpro information is taken from the structure h (dynpro header, dictionary structure D020S) and the internal tables f (field list, structure D021S), e (flow logic, structure D022S), and m (matchcode information, structure D023S). Standard tables without secondary keys can be specified for f, e, and m.


### abapimport_dynpro.htm

---
title: "IMPORT DYNPRO"
description: |
  This statement is for internal use only. It must not be used in application programs. Syntax IMPORT DYNPRO h f e m ID id. Effect The dynpro(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm 'Glossary Entry') specified in the structure id is imported. To enable this,
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapimport_dynpro.htm"
abapFile: "abapimport_dynpro.htm"
keywords: ["do", "if", "try", "data", "internal-table", "abapimport", "dynpro"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Program Maintenance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_editing.htm) →  [Dynamic Program Development](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_language_dynamic.htm) →  [Dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_generic_dynpro.htm) →  [Internal Statements for Editing Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_dynpro_internal.htm) → 

IMPORT DYNPRO

This statement is for internal use only.
It must not be used in application programs.

Syntax

IMPORT DYNPRO h f e m ID id.

Effect

The [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") specified in the structure id is imported. To enable this, the structure id must contain two components for the name of the program and the ID of the dynpro in the following order:

-   A component of type PROGNAME
-   A component of type SYDYNNR.

The dynpro information is loaded into the structure h (dynpro header, structure D020S) and into the internal tables f (field list, structure D021S), e (flow logic, structure D022S), and m (matchcode information, structure D023S). Standard tables without secondary keys can be specified for f, e, and m.

Hint

As an alternative to a structure, a character-like field (including string) can be specified for id, where the field contains the chained content of the structure components, including trailing blanks.

System Fields

sy-subrc

Meaning

0

The dynpro was imported.

4

The dynpro does not exist.

Example

Reading of the attributes of dynpro "0100" of the program DEMO\_DYNPRO.

DATA h TYPE d020s.
DATA f TYPE TABLE OF d021s.
DATA e TYPE TABLE OF d022s.
DATA m TYPE TABLE OF d023s.
DATA: BEGIN OF id,
         p TYPE progname VALUE 'DEMO\_DYNPRO',
         d TYPE sydynnr  VALUE '0100',
       END OF id.
IMPORT DYNPRO h f e m ID id.


### abapdelete_dynpro.htm

---
title: "DELETE DYNPRO"
description: |
  This statement is for internal use only. It must not be used in application programs. Syntax DELETE DYNPRO f. Effect Deletes the dynpro(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm 'Glossary Entry') with the name specified in the field f. System Fields sy-subrc
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapdelete_dynpro.htm"
abapFile: "abapdelete_dynpro.htm"
keywords: ["delete", "do", "if", "try", "data", "abapdelete", "dynpro"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Program Maintenance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_editing.htm) →  [Dynamic Program Development](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_language_dynamic.htm) →  [Dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_generic_dynpro.htm) →  [Internal Statements for Editing Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_dynpro_internal.htm) → 

DELETE DYNPRO

This statement is for internal use only.
It must not be used in application programs.

Syntax

DELETE DYNPRO f.

Effect

Deletes the [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") with the name specified in the field f.

System Fields

sy-subrc

Meaning

0

The dynpro was deleted.

4

The dynpro does not exist.

The content of f consists of the 40 character program name and the four digit [dynpro number](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_number_glosry.htm "Glossary Entry").

Example

DATA DYNPRONAME(44) VALUE 'SAPTEST'.
DYNPRONAME+40 = '0100'.
DELETE DYNPRO DYNPRONAME.


### abapsyntax-check_for_dynpro.htm

---
title: "SYNTAX-CHECK FOR DYNPRO"
description: |
  This statement is for internal use only. It must not be used in application programs. Syntax SYNTAX-CHECK FOR DYNPRO h f e m ...MESSAGE f1 ...LINE f2 ...WORD f3. Additions: 1. ... OFFSET f4(#!ABAP_ADDITION_1@1@) 2. ... TRACE-TABLE itab1(#!ABAP_ADDITION_2@2@) 3. ... MESSAGE-ID f5(#!ABAP_ADDI
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsyntax-check_for_dynpro.htm"
abapFile: "abapsyntax-check_for_dynpro.htm"
keywords: ["do", "if", "try", "data", "internal-table", "abapsyntax", "check", "for", "dynpro"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Program Maintenance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_editing.htm) →  [Dynamic Program Development](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_language_dynamic.htm) →  [Dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_generic_dynpro.htm) →  [Internal Statements for Editing Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_dynpro_internal.htm) → 

SYNTAX-CHECK FOR DYNPRO

This statement is for internal use only.
It must not be used in application programs.

Syntax

SYNTAX-CHECK FOR DYNPRO h f e m ...MESSAGE f1 ...LINE f2
                                ...WORD f3.

Additions:

[1\. ... OFFSET f4](#!ABAP_ADDITION_1@1@)
[2\. ... TRACE-TABLE itab1](#!ABAP_ADDITION_2@2@)
[3\. ... MESSAGE-ID f5](#!ABAP_ADDITION_3@3@)

Effect
The [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") description is taken from the structure h and the internal tables f, e, and m. The structure h (dynpro header) should correspond to the structure D020S, the internal table f (field list) to the structure D021S, the internal table e (flow logic) to the structure D022S, and the internal table m (matchcode information) to the structure D023S. Standard tables without secondary keys can be specified for f, e, and m.

Example

DATA: DHEAD    TYPE D020S,                   "dynpro header
      DFIELDS  TYPE TABLE OF D021S,          "field list
      DFLOWL   TYPE TABLE OF D022S,          "flow logic
      MCINFO   TYPE TABLE OF D023S.          "matchcode information

If a syntax error is detected during the check, the fields f1, f2, and f3 are filled as follows:

-   f1 contains the error message text.
-   f2 contains the dynpro line where the error occurred
-   f3 contains the incorrect word in the dynpro

System Fields

sy-subrc

Meaning

0

The dynpro has no syntax errors.

4

The dynpro has syntax errors.

Addition 1   

... OFFSET f4

Effect

When a syntax error occurs, the position of the incorrect word in the incorrect line is stored in this field.

Addition 2   

... TRACE-TABLE itab1

Effect

Any trace output is stored in this table. Trace output is automatically activated when this addition is specified. A standard table without secondary keys can be specified for itab1.

Addition 3   

... MESSAGE-ID f5

Effect

If a syntax error occurs, the key of the corresponding error message is returned in field f5. This key has the same structure as the key of table TRMSG.


### abapgenerate_dynpro.htm

---
title: "GENERATE DYNPRO"
description: |
  This statement is for internal use only. It must not be used in application programs. Syntax GENERATE DYNPRO h f e m ID g. ... MESSAGE f1 ... LINE f2 ... WORD f3. Additions: 1. ... OFFSET f4(#!ABAP_ADDITION_1@1@) 2. ... TRACE-FILE f5(#!ABAP_ADDITION_2@2@) Effect Generates the dynpro(https://
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapgenerate_dynpro.htm"
abapFile: "abapgenerate_dynpro.htm"
keywords: ["do", "if", "try", "internal-table", "abapgenerate", "dynpro"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Program Maintenance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_editing.htm) →  [Dynamic Program Development](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_language_dynamic.htm) →  [Dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_generic_dynpro.htm) →  [Internal Statements for Editing Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_dynpro_internal.htm) → 

GENERATE DYNPRO

This statement is for internal use only.
It must not be used in application programs.

Syntax

GENERATE DYNPRO h f e m ID g.
... MESSAGE f1 ... LINE f2 ... WORD f3.

Additions:

[1\. ... OFFSET f4](#!ABAP_ADDITION_1@1@)
[2\. ... TRACE-FILE f5](#!ABAP_ADDITION_2@2@)

Effect

Generates the [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") specified in the field g.
The source code is taken from the structure h and the internal tables f, e, and m. The field h( =dynpro header) should correspond to the structure D020S, the internal table f (=field list) should correspond to the structure D021S, the internal table e (=flow logic) should correspond to the structure D022S, and the internal table m (=matchcode information) should correspond to the structure D023S. Standard tables without secondary keys can be specified for f, e, and m.
If a syntax error occurs, the error message is stored in the field f1.
If a syntax error occurs, the number of the incorrect line is stored in the field f2.
By querying the return code, it is possible to determine whether this line refers to the flow logic or the field list.
If a syntax error occurs, the incorrect word is stored in the field f3.

System Fields

sy-subrc

Meaning

0

The dynpro was generated.

4

The dynpro could not be generated. The specified error position is in the flow logic.

8

The dynpro could not be generated. The specified error position is in the field list.

Addition 1   

... OFFSET f4

Effect

When a syntax error occurs, the position of the incorrect word in the incorrect line is stored in this field.

Addition 2   

... TRACE-FILE f5

Effect

Trace output is stored in this file. This addition automatically activates trace mode.


### abengeneric_dynpro_internal.htm

---
title: "Internal Statements for Editing Dynpros"
description: |
  These statements are for internal use only. Do not use them in application programs. -   EXPORT DYNPRO(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapexport_dynpro.htm) -   IMPORT DYNPRO(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapimport_dynpro.htm) -   DELETE
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_dynpro_internal.htm"
abapFile: "abengeneric_dynpro_internal.htm"
keywords: ["delete", "do", "abengeneric", "dynpro", "internal"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Program Maintenance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_editing.htm) →  [Dynamic Program Development](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_language_dynamic.htm) →  [Dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_generic_dynpro.htm) → 

Internal Statements for Editing Dynpros

These statements are for internal use only.
Do not use them in application programs.

-   [EXPORT DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapexport_dynpro.htm)
-   [IMPORT DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapimport_dynpro.htm)
-   [DELETE DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapdelete_dynpro.htm)
-   [SYNTAX-CHECK FOR DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsyntax-check_for_dynpro.htm)
-   [GENERATE DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapgenerate_dynpro.htm)

Continue
[EXPORT DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapexport_dynpro.htm)
[IMPORT DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapimport_dynpro.htm)
[DELETE DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapdelete_dynpro.htm)
[SYNTAX-CHECK FOR DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsyntax-check_for_dynpro.htm)
[GENERATE DYNPRO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapgenerate_dynpro.htm)


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Dynpro Fields

**Files**: 8 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Dynpro Flow and Dynpro Sequences

Included pages: 2


### abenabap_dynpros_processing.htm

---
title: "Dynpro Flow"
description: |
  Dynpros(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm 'Glossary Entry') are called either using transaction codes(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentransaction_code_glosry.htm 'Glossary Entry') or using the statement CALL SCREEN(h
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_processing.htm"
abapFile: "abenabap_dynpros_processing.htm"
keywords: ["do", "if", "case", "try", "abenabap", "dynpros", "processing"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) → 

dynpro - Dynpro Flow and Dynpro Sequences

Dynpro Flow

[Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") are called either using [transaction codes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentransaction_code_glosry.htm "Glossary Entry") or using the statement [CALL SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcall_screen.htm). The call raises the event [PBO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm "Glossary Entry") and its event block is processed in the [dynpro flow logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_flow_logic_glosry.htm "Glossary Entry"). Afterwards, the [screen layout](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_glosry.htm "Glossary Entry") of the dynpro is displayed in the current [popup level](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpop-up_level_glosry.htm "Glossary Entry") or in a new level (in the case of modal dialog boxes). After a user action in the user interface of this GUI window, the event [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry") (or [POH](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpoh_glosry.htm "Glossary Entry") or [POV](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpov_glosry.htm "Glossary Entry")) is raised and its event block is processed in the dynpro flow logic. In the event blocks of the dynpro flow logic, dialog modules of the associated ABAP program are called. When PAI processing is complete, the [next dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennext_dynpro_glosry.htm "Glossary Entry") of the current dynpro is called.

The display language of a general dynpro is the [logon language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogon_language_glosry.htm "Glossary Entry") and not the [text environment language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_env_langu_glosry.htm "Glossary Entry"), which can be set with statement [SET LOCALE LANGUAGE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_locale.htm).

Dynpro Sequence

Each dynpro has a next dynpro. In particular, a dynpro can also be its own special next dynpro. The next dynpro is either statically predefined or it is set in the ABAP program using the statements [SET SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_screen.htm) or [LEAVE TO SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapleave_screen.htm). In this way, a dynpro is automatically part of a dynpro sequence. Each next dynpro always belongs to a single popup level and is executed in a single GUI window. The number of the current dynpro can be taken from the system field sy-dynnr.

The flow of a dynpro sequence is determined by the respective next dynpro of the dynpro involved. During processing, a dynpro always has a next dynpro. At the start of processing, this is statically predefined, but it can be overwritten in the program. The first dynpro of a dynpro sequence is the initial dynpro. A dynpro sequence is ended by calling the next dynpro with the dynpro number 0.

If a dynpro sequence is embedded in another sequence, the calling dynpro sequence is continued after completion of a dynpro sequence. If the dynpro sequence is not embedded, the current program is ended.

Continue
![Example](exa.gif "Example") [dynpro - Dynpro Sequences](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_flow_abexa.htm)


### abendynpro_flow_abexa.htm

---
title: "Source Code"
description: |
  PROGRAM sapmdemo_screen_flow MESSAGE-ID demo_flight. TABLES: spfli, sairport, scarr. DATA: ok_code   TYPE c LENGTH 4, rcode     TYPE c LENGTH 5, old_spfli TYPE spfli.  PBO MODULE status_0100 OUTPUT. SET PF-STATUS 'TD0100'. SET TITLEBAR '100'. ENDMODULE. MODULE status_0200 OUTPUT. SET PF-STA
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_flow_abexa.htm"
abapFile: "abendynpro_flow_abexa.htm"
keywords: ["select", "update", "delete", "do", "if", "case", "data", "abendynpro", "flow", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Dynpro Flow and Dynpro Sequences](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_processing.htm) → 

dynpro - Dynpro Sequences

This example demonstrates how dynpro sequences behave.

Source Code

PROGRAM sapmdemo\_screen\_flow MESSAGE-ID demo\_flight.
TABLES: spfli,
        sairport,
        scarr.
DATA: ok\_code   TYPE c LENGTH 4,
      rcode     TYPE c LENGTH 5,
      old\_spfli TYPE spfli.
\* PBO
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'TD0100'.
  SET TITLEBAR '100'.
ENDMODULE.
MODULE status\_0200 OUTPUT.
  SET PF-STATUS 'TD0200'.
  SET TITLEBAR '100'.
ENDMODULE.
MODULE status\_0210 OUTPUT.
  SET PF-STATUS 'POPUP'.
  SET TITLEBAR 'POP'.
ENDMODULE.
\* PAI
MODULE user\_command\_0100 INPUT.
  CASE ok\_code.
    WHEN space.
      SELECT SINGLE \*
             FROM  spfli
             WHERE carrid      = @spfli-carrid
             AND   connid      = @spfli-connid
             INTO  @spfli.
      IF sy-subrc NE 0.
        MESSAGE e005 WITH spfli-carrid spfli-connid.
      ENDIF.
      old\_spfli = spfli.
      CLEAR ok\_code.
    WHEN 'CANC'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
    WHEN 'EXIT'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
    WHEN 'BACK'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
  ENDCASE.
ENDMODULE.
MODULE user\_command\_0200 INPUT.
  CASE ok\_code.
    WHEN 'SAVE'.
      UPDATE spfli.
      IF sy-subrc = 0.
        MESSAGE s001 WITH spfli-carrid spfli-connid.
      ELSE.
        MESSAGE a002 WITH spfli-carrid spfli-connid.
      ENDIF.
      CLEAR ok\_code.
    WHEN 'EXIT'.
      CLEAR ok\_code.
      PERFORM safety\_check USING rcode.
      IF rcode = 'EXIT'. SET SCREEN 0. LEAVE SCREEN. ENDIF.
    WHEN 'BACK'.
      CLEAR ok\_code.
      PERFORM safety\_check USING rcode.
      IF rcode = 'EXIT'. SET SCREEN 100. LEAVE SCREEN. ENDIF.
    WHEN 'DELE'.
      MESSAGE w011.
      DELETE FROM spfli
        WHERE carrid = @spfli-carrid
        AND connid = @spfli-connid.
  ENDCASE.
ENDMODULE.
MODULE check\_fr\_airport INPUT.
  SELECT SINGLE \*
         FROM  sairport
         WHERE id = @spfli-airpfrom
         INTO  @sairport.
  IF sy-subrc <> 0.
    MESSAGE e003 WITH spfli-airpfrom.
  ENDIF.
ENDMODULE.
MODULE check\_to\_airport INPUT.
  SELECT SINGLE \*
         FROM  sairport
         WHERE id = @spfli-airpto
         INTO  @sairport.
  IF sy-subrc <> 0.
    MESSAGE e004 WITH spfli-airpto.
  ENDIF.
ENDMODULE.
MODULE exit\_0100 INPUT.
  CASE ok\_code.
    WHEN 'CANC'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
    WHEN 'EXIT'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
    WHEN 'BACK'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
  ENDCASE.
ENDMODULE.
MODULE exit\_0200 INPUT.
  CASE ok\_code.
    WHEN 'CANC'.
      CLEAR ok\_code.
      SET SCREEN 100. LEAVE SCREEN.
  ENDCASE.
ENDMODULE.
MODULE user\_command\_0210 INPUT.
  CASE ok\_code.
    WHEN 'SAVE'. SET SCREEN 0. LEAVE SCREEN.
    WHEN 'EXIT'. SET SCREEN 0. LEAVE SCREEN.
    WHEN 'CANC'. SET SCREEN 0. LEAVE SCREEN.
  ENDCASE.
ENDMODULE.
MODULE read\_text\_0100 INPUT.
  SELECT SINGLE \*
         FROM scarr
         WHERE carrid = @spfli-carrid
         INTO @scarr.
ENDMODULE.
\* Subroutine
FORM safety\_check USING rcode.
  LOCAL ok\_code.
  rcode = 'EXIT'.
  CHECK spfli NE old\_spfli.
  CLEAR ok\_code.
  CALL SCREEN 210 STARTING AT 10 5.
  CASE ok\_code.
    WHEN 'SAVE'. UPDATE spfli.
    WHEN 'EXIT'.
    WHEN 'CANC'. CLEAR spfli.
  ENDCASE.
ENDFORM.

Description

The transaction DEMO\_SCREEN\_FLOW uses three dynpros. The dynpros 100 and 200 form a sequence. Dynpro 210 is a modal dialog box and is only called under special circumstances.

-   Dynpro 100: The user enters flight data, chooses Continue to request a detailed display of the flight data, or ends the transaction.
-   Dynpro 200: The system displays complete details about the flight in input fields. The user overwrites the displayed data to enter the changes.
-   Dynpro 210: The modal dialog box is only displayed if the user attempts to exit dynpro 200 by choosing Back or Exit without saving the values modified. It enables the user to save changes or cancel the operation.

This transaction is a good example of how a dynpro sequence is implemented. A closer look at dynpro 200 shows how the modal dialog box is called. When processing the BACK or EXIT function codes, the PAI module must check if the flight data has been changed since it was last displayed or saved. If this is the case, dynpro 210 is to be called as a modal dialog box. The following parts of the flow logic of dynpro 200 are relevant here:

PROCESS AFTER INPUT.
  MODULE exit\_0200 AT EXIT-COMMAND.
  ...
  MODULE user\_command\_0200.

The system calls two dialog modules at the PAI event. The user interface of transaction DEMO\_SCREEN\_FLOW offers the functions Back, Exit, and Cancel as return commands. On the screen of dynpro 200, the user should only be able to leave the screen directly and return to dynpro 100 using Cancel. The function code is processed in the module exit\_200. The next dynpro is set dynamically to 100, and dynpro 200 is terminated immediately using LEAVE SCREEN. All other function codes for the screen 200 are processed in the module user\_command\_200:

-   The Save function triggers a database update.
-   The Exit and Back functions call the subroutine safety\_check. This subroutine checks to see whether there is unsaved data on the screen, and, if required, calls dynpro 210.

If the Exit function is chosen (function code EXIT), the user leaves the transaction completely since the dynpro sequence is ended dynamically using SET SCREEN 0. If the user chooses Back (function code BACK), the next dynpro is changed dynamically to 100 using SET SCREEN 100.

The subroutine safety\_check first compares the current values of the dynpro fields with the values saved. If the values match, the user does not have to save and the subroutine terminates. If the values differ, safety\_check calls the modal dialog box of dynpro 210. This asks the user whether they want to save and returns the answer to the field ok\_code. The static next dynpro for dynpro 210 is 210. However, the processing logic (module user\_command\_210) always sets the next dynpro dynamically to 0, which returns control to the subroutine.

The following figure summarizes the flow of the dynpro sequences in the example:

![Figure](bdoc_dynpro_seq.gif)


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Dynpro Flow and Dynpro Sequences

**Files**: 2 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Dynpro Flow and Dynpro Sequences

Included pages: 2


### abenabap_dynpros_processing.htm

---
title: "Dynpro Flow"
description: |
  Dynpros(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm 'Glossary Entry') are called either using transaction codes(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentransaction_code_glosry.htm 'Glossary Entry') or using the statement CALL SCREEN(h
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_processing.htm"
abapFile: "abenabap_dynpros_processing.htm"
keywords: ["do", "if", "case", "try", "abenabap", "dynpros", "processing"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) → 

dynpro - Dynpro Flow and Dynpro Sequences

Dynpro Flow

[Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") are called either using [transaction codes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentransaction_code_glosry.htm "Glossary Entry") or using the statement [CALL SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcall_screen.htm). The call raises the event [PBO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm "Glossary Entry") and its event block is processed in the [dynpro flow logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_flow_logic_glosry.htm "Glossary Entry"). Afterwards, the [screen layout](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_glosry.htm "Glossary Entry") of the dynpro is displayed in the current [popup level](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpop-up_level_glosry.htm "Glossary Entry") or in a new level (in the case of modal dialog boxes). After a user action in the user interface of this GUI window, the event [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry") (or [POH](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpoh_glosry.htm "Glossary Entry") or [POV](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpov_glosry.htm "Glossary Entry")) is raised and its event block is processed in the dynpro flow logic. In the event blocks of the dynpro flow logic, dialog modules of the associated ABAP program are called. When PAI processing is complete, the [next dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennext_dynpro_glosry.htm "Glossary Entry") of the current dynpro is called.

The display language of a general dynpro is the [logon language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogon_language_glosry.htm "Glossary Entry") and not the [text environment language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_env_langu_glosry.htm "Glossary Entry"), which can be set with statement [SET LOCALE LANGUAGE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_locale.htm).

Dynpro Sequence

Each dynpro has a next dynpro. In particular, a dynpro can also be its own special next dynpro. The next dynpro is either statically predefined or it is set in the ABAP program using the statements [SET SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_screen.htm) or [LEAVE TO SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapleave_screen.htm). In this way, a dynpro is automatically part of a dynpro sequence. Each next dynpro always belongs to a single popup level and is executed in a single GUI window. The number of the current dynpro can be taken from the system field sy-dynnr.

The flow of a dynpro sequence is determined by the respective next dynpro of the dynpro involved. During processing, a dynpro always has a next dynpro. At the start of processing, this is statically predefined, but it can be overwritten in the program. The first dynpro of a dynpro sequence is the initial dynpro. A dynpro sequence is ended by calling the next dynpro with the dynpro number 0.

If a dynpro sequence is embedded in another sequence, the calling dynpro sequence is continued after completion of a dynpro sequence. If the dynpro sequence is not embedded, the current program is ended.

Continue
![Example](exa.gif "Example") [dynpro - Dynpro Sequences](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_flow_abexa.htm)


### abendynpro_flow_abexa.htm

---
title: "Source Code"
description: |
  PROGRAM sapmdemo_screen_flow MESSAGE-ID demo_flight. TABLES: spfli, sairport, scarr. DATA: ok_code   TYPE c LENGTH 4, rcode     TYPE c LENGTH 5, old_spfli TYPE spfli.  PBO MODULE status_0100 OUTPUT. SET PF-STATUS 'TD0100'. SET TITLEBAR '100'. ENDMODULE. MODULE status_0200 OUTPUT. SET PF-STA
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_flow_abexa.htm"
abapFile: "abendynpro_flow_abexa.htm"
keywords: ["select", "update", "delete", "do", "if", "case", "data", "abendynpro", "flow", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Dynpro Flow and Dynpro Sequences](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_processing.htm) → 

dynpro - Dynpro Sequences

This example demonstrates how dynpro sequences behave.

Source Code

PROGRAM sapmdemo\_screen\_flow MESSAGE-ID demo\_flight.
TABLES: spfli,
        sairport,
        scarr.
DATA: ok\_code   TYPE c LENGTH 4,
      rcode     TYPE c LENGTH 5,
      old\_spfli TYPE spfli.
\* PBO
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'TD0100'.
  SET TITLEBAR '100'.
ENDMODULE.
MODULE status\_0200 OUTPUT.
  SET PF-STATUS 'TD0200'.
  SET TITLEBAR '100'.
ENDMODULE.
MODULE status\_0210 OUTPUT.
  SET PF-STATUS 'POPUP'.
  SET TITLEBAR 'POP'.
ENDMODULE.
\* PAI
MODULE user\_command\_0100 INPUT.
  CASE ok\_code.
    WHEN space.
      SELECT SINGLE \*
             FROM  spfli
             WHERE carrid      = @spfli-carrid
             AND   connid      = @spfli-connid
             INTO  @spfli.
      IF sy-subrc NE 0.
        MESSAGE e005 WITH spfli-carrid spfli-connid.
      ENDIF.
      old\_spfli = spfli.
      CLEAR ok\_code.
    WHEN 'CANC'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
    WHEN 'EXIT'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
    WHEN 'BACK'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
  ENDCASE.
ENDMODULE.
MODULE user\_command\_0200 INPUT.
  CASE ok\_code.
    WHEN 'SAVE'.
      UPDATE spfli.
      IF sy-subrc = 0.
        MESSAGE s001 WITH spfli-carrid spfli-connid.
      ELSE.
        MESSAGE a002 WITH spfli-carrid spfli-connid.
      ENDIF.
      CLEAR ok\_code.
    WHEN 'EXIT'.
      CLEAR ok\_code.
      PERFORM safety\_check USING rcode.
      IF rcode = 'EXIT'. SET SCREEN 0. LEAVE SCREEN. ENDIF.
    WHEN 'BACK'.
      CLEAR ok\_code.
      PERFORM safety\_check USING rcode.
      IF rcode = 'EXIT'. SET SCREEN 100. LEAVE SCREEN. ENDIF.
    WHEN 'DELE'.
      MESSAGE w011.
      DELETE FROM spfli
        WHERE carrid = @spfli-carrid
        AND connid = @spfli-connid.
  ENDCASE.
ENDMODULE.
MODULE check\_fr\_airport INPUT.
  SELECT SINGLE \*
         FROM  sairport
         WHERE id = @spfli-airpfrom
         INTO  @sairport.
  IF sy-subrc <> 0.
    MESSAGE e003 WITH spfli-airpfrom.
  ENDIF.
ENDMODULE.
MODULE check\_to\_airport INPUT.
  SELECT SINGLE \*
         FROM  sairport
         WHERE id = @spfli-airpto
         INTO  @sairport.
  IF sy-subrc <> 0.
    MESSAGE e004 WITH spfli-airpto.
  ENDIF.
ENDMODULE.
MODULE exit\_0100 INPUT.
  CASE ok\_code.
    WHEN 'CANC'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
    WHEN 'EXIT'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
    WHEN 'BACK'.
      CLEAR ok\_code.
      SET SCREEN 0. LEAVE SCREEN.
  ENDCASE.
ENDMODULE.
MODULE exit\_0200 INPUT.
  CASE ok\_code.
    WHEN 'CANC'.
      CLEAR ok\_code.
      SET SCREEN 100. LEAVE SCREEN.
  ENDCASE.
ENDMODULE.
MODULE user\_command\_0210 INPUT.
  CASE ok\_code.
    WHEN 'SAVE'. SET SCREEN 0. LEAVE SCREEN.
    WHEN 'EXIT'. SET SCREEN 0. LEAVE SCREEN.
    WHEN 'CANC'. SET SCREEN 0. LEAVE SCREEN.
  ENDCASE.
ENDMODULE.
MODULE read\_text\_0100 INPUT.
  SELECT SINGLE \*
         FROM scarr
         WHERE carrid = @spfli-carrid
         INTO @scarr.
ENDMODULE.
\* Subroutine
FORM safety\_check USING rcode.
  LOCAL ok\_code.
  rcode = 'EXIT'.
  CHECK spfli NE old\_spfli.
  CLEAR ok\_code.
  CALL SCREEN 210 STARTING AT 10 5.
  CASE ok\_code.
    WHEN 'SAVE'. UPDATE spfli.
    WHEN 'EXIT'.
    WHEN 'CANC'. CLEAR spfli.
  ENDCASE.
ENDFORM.

Description

The transaction DEMO\_SCREEN\_FLOW uses three dynpros. The dynpros 100 and 200 form a sequence. Dynpro 210 is a modal dialog box and is only called under special circumstances.

-   Dynpro 100: The user enters flight data, chooses Continue to request a detailed display of the flight data, or ends the transaction.
-   Dynpro 200: The system displays complete details about the flight in input fields. The user overwrites the displayed data to enter the changes.
-   Dynpro 210: The modal dialog box is only displayed if the user attempts to exit dynpro 200 by choosing Back or Exit without saving the values modified. It enables the user to save changes or cancel the operation.

This transaction is a good example of how a dynpro sequence is implemented. A closer look at dynpro 200 shows how the modal dialog box is called. When processing the BACK or EXIT function codes, the PAI module must check if the flight data has been changed since it was last displayed or saved. If this is the case, dynpro 210 is to be called as a modal dialog box. The following parts of the flow logic of dynpro 200 are relevant here:

PROCESS AFTER INPUT.
  MODULE exit\_0200 AT EXIT-COMMAND.
  ...
  MODULE user\_command\_0200.

The system calls two dialog modules at the PAI event. The user interface of transaction DEMO\_SCREEN\_FLOW offers the functions Back, Exit, and Cancel as return commands. On the screen of dynpro 200, the user should only be able to leave the screen directly and return to dynpro 100 using Cancel. The function code is processed in the module exit\_200. The next dynpro is set dynamically to 100, and dynpro 200 is terminated immediately using LEAVE SCREEN. All other function codes for the screen 200 are processed in the module user\_command\_200:

-   The Save function triggers a database update.
-   The Exit and Back functions call the subroutine safety\_check. This subroutine checks to see whether there is unsaved data on the screen, and, if required, calls dynpro 210.

If the Exit function is chosen (function code EXIT), the user leaves the transaction completely since the dynpro sequence is ended dynamically using SET SCREEN 0. If the user chooses Back (function code BACK), the next dynpro is changed dynamically to 100 using SET SCREEN 100.

The subroutine safety\_check first compares the current values of the dynpro fields with the values saved. If the values match, the user does not have to save and the subroutine terminates. If the values differ, safety\_check calls the modal dialog box of dynpro 210. This asks the user whether they want to save and returns the answer to the field ok\_code. The static next dynpro for dynpro 210 is 210. However, the processing logic (module user\_command\_210) always sets the next dynpro dynamically to 0, which returns control to the subroutine.

The following figure summarizes the flow of the dynpro sequences in the example:

![Figure](bdoc_dynpro_seq.gif)


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Input Checks

**Files**: 7 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Input Checks

Included pages: 7


### abenabap_dynpros_checks.htm

---
title: "Hint"
description: |
  Obsolete input checks are possible using the additions VALUES(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield_value_select.htm) and SELECT(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield_value_select.htm) of the dynpro logic statement FIELD(https://hel
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks.htm"
abapFile: "abenabap_dynpros_checks.htm"
keywords: ["select", "do", "abenabap", "dynpros", "checks"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) → 

dynpro - Input Checks

Dynpros enables input values to be checked in the following ways:

-   [Automatic input checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks_auto.htm)
-   [Input checks in dialog modules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks_mod.htm)

Hint

Obsolete input checks are possible using the additions [VALUES](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield_value_select.htm) and [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield_value_select.htm) of the dynpro logic statement [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm). These checks are made before dialog modules are called.

Continue
[dynpro - Automatic Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks_auto.htm)
[dynpro - Input Checks in Dialog Modules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks_mod.htm)
[dynpro - Examples of Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_check_abexas.htm)


### abenabap_dynpros_checks_auto.htm

---
title: "Executable Example"
description: |
  Automatic Input Checks(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_auto_check_abexa.htm)
version: "7.56"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks_auto.htm"
abapFile: "abenabap_dynpros_checks_auto.htm"
keywords: ["do", "if", "try", "data", "abenabap", "dynpros", "checks", "auto"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks.htm) → 

dynpro - Automatic Input Checks

In the PAI event, the dynpro makes a series of automatic input checks. These checks take place before data transports to the ABAP program and before the dynpro flow logic is processed. Before these automatic input checks, a single dialog module can be called using an unconditional module call and with a special function type. This dialog module is usually used to bypass the checks and exit the dynpro directly.

If the automatic input checks find an error, a message appears in the status bar of the screen, and the corresponding fields remain ready for input. The user must correct the input and raise PAI again. The actual PAI processing does not start until there are no more errors.

The automatic input checks are performed in the following order:

-   Mandatory input
    
    If a field is defined as a mandatory field in Screen Painter, the user must enter a value for it before PAI can start.
    
-   Input format
    
    The values entered in an input field must match the data format of the associated dynpro field. For example, the format of a date field with the type DATS is an eight-character string with the format YYYYMMDD. All characters must be numbers and the characters MM and DD must be less than or equal to 12 or 31 respectively. The system also checks that the specified day is valid for the month.
    
-   Checks defined in the ABAP Dictionary
    
    If an input field in the Screen Painter is defined by being taken from the ABAP Dictionary, the dynpro checks the following:
    
    -   Does the entered value match any [foreign key relationship](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenforeign_key_dependency_glosry.htm "Glossary Entry") with a different database table? This means the check table is checked to verify whether the input value exists as a foreign key in the check table. This check only takes place, however, if the foreign key attribute is set for the input field in the Screen Painter. This input check is not necessarily identical with the [input help](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_value_help_auto.htm). The developers must ensure that the input help represents a subset of the content of the check table.
    -   Does the entered value exist as a [fixed value](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfixed_value_glosry.htm "Glossary Entry") of the domain of the field? This means that the definition of the domain of the field in the ABAP Dictionary is checked. The fixed values of the domain can also be used as an input help. The value table of a domain, however, is not checked. It is only used as a default value for the check tables of the fields that reference the domain.
    
    If necessary, the input check also triggers a [check on obsolete data](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenddic_deprecation.htm).
    

Executable Example

[Automatic Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_auto_check_abexa.htm)


### abenabap_dynpros_checks_mod.htm

---
title: "Checking Single Fields"
description: |
  If a warning or error message(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_field_messages.htm) is sent in a module mod whose call is combined with a FIELD(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) statement FIELD f MODULE mod. the input fiel
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks_mod.htm"
abapFile: "abenabap_dynpros_checks_mod.htm"
keywords: ["do", "if", "case", "data", "abenabap", "dynpros", "checks", "mod"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks.htm) → 

dynpro - Input Checks in Dialog Modules

Input checks in PAI modules are enabled by first transporting the content of the input fields to the ABAP program. This is where the content can then be checked. Any errors can be corrected on the screen before further modules are called. This is achieved by combining the statements [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) and [CHAIN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpchain.htm) of the dynpro flow logic with [messages](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_field_messages.htm).

-   [Checking Single Fields](#abenabap-dynpros-checks-mod-1-------checking-multiple-fields---@ITOC@@ABENABAP_DYNPROS_CHECKS_MOD_2)
-   [Defining Input-Enabled Fields and Data Transport](#abenabap-dynpros-checks-mod-3-------checking-fields-repeatedly---@ITOC@@ABENABAP_DYNPROS_CHECKS_MOD_4)
-   [Other Functions in the FIELD and CHAIN Statements](#@@ITOC@@ABENABAP_DYNPROS_CHECKS_MOD_5)

Checking Single Fields

If a [warning or error message](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_field_messages.htm) is sent in a module mod whose call is combined with a [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) statement

FIELD f MODULE mod.

the input field in question becomes the only input-enabled field on the current dynpro and the input can be repeated. If the field is only checked once, PAI resumes directly after the FIELD statement, and the preceding modules are not called again.

Checking Multiple Fields

If a [warning or error message](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_field_messages.htm) is sent in a module mod1, mod2, ... whose call takes place in a [processing chain](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpchain.htm)

CHAIN.
  FIELD: f1, f2,...
  MODULE mod1.
  FIELD: g1, g2,...
  MODULE mod2.
...
ENDCHAIN.

the input fields of all dynpro fields in the processing chain become input-enabled on the current dynpro. This includes fields after the [MODULE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpmodule.htm) statement in [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) statements. None of the other fields are input-enabled. Even when a MODULE statement is combined with a FIELD statement within a processing chain, all input fields in the chain become input-enabled and not just the field in question. If the fields in the processing chain are only checked once, PAI resumes directly after the CHAIN statement, and the preceding modules are not called again.

Defining Input-Enabled Fields and Data Transport

In the case of warnings and error messages, a [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) statement outside of a processing chain defines whether a single field is input-enabled. [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) statements between [CHAIN - ENDCHAIN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpchain.htm), on the other hand, define whether multiple fields are input-enabled. Here, all fields linked using FIELD are transported back to the screen layout without PBO processing taking place. This ensures that any changes to the field content are displayed before a message. This also applies to the sending of information messages, but no fields are input-enabled.

Checking Fields Repeatedly

It may be necessary to specify a single dynpro field in multiple [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) or [CHAIN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpchain.htm) statements. If an associated dialog module sends a warning or error message, PAI resumes after the user enters a new value. It is not possible to resume at the associated FIELD or CHAIN statement if the error field is also specified in an earlier FIELD or CHAIN statement.

Instead, all FIELD and CHAIN statements containing the error field must be repeated. PAI processing resumes at the first FIELD or CHAIN statement containing one or more of the fields in the FIELD or CHAIN statement in which the error occurred and which were modified the last time the screen layout was displayed.

Other Functions in the FIELD and CHAIN Statements

All functions of the statements [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) and [CHAIN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpchain.htm) used to defined data transport and for conditional module calls are also available in combination with warnings and error messages. The content of each field is transported after the FIELD statement in question. A warning or error message in a conditional module in a processing chain makes all fields in the chain input-enabled, although not all fields need to be transported.

If warnings or error messages are sent in dialog modules that are not linked with fields using FIELD or CHAIN, no dynpro fields become input-enabled. This makes a termination necessary, which itself requires a corresponding unconditional module call.

Executable Example

[Input Checks in Dialog Modules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_field_chain_abexa.htm)


### abeninput_check_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Automatic Input Checks(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_auto_check_abexa.htm) !Example(exa.gif 'Example') dynpro - Input Checks in Dialog Modules(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_fi
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_check_abexas.htm"
abapFile: "abeninput_check_abexas.htm"
keywords: ["do", "if", "abeninput", "check", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks.htm) → 

dynpro - Examples of Input Checks

Continue
![Example](exa.gif "Example") [dynpro - Automatic Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_auto_check_abexa.htm)
![Example](exa.gif "Example") [dynpro - Input Checks in Dialog Modules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_field_chain_abexa.htm)


### abendynpro_auto_check_abexa.htm

---
title: "Source Code"
description: |
  PROGRAM demo_dynpro_automatic_checks . DATA: ok_code TYPE sy-ucomm, date TYPE d. TABLES demo_conn. CALL SCREEN 100. MODULE init_screen_100 OUTPUT. SET PF-STATUS 'STATUS_100'. ENDMODULE. MODULE cancel INPUT. LEAVE PROGRAM. ENDMODULE. MODULE pai INPUT. MESSAGE i888(sabapdemos) WITH text-001. E
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_auto_check_abexa.htm"
abapFile: "abendynpro_auto_check_abexa.htm"
keywords: ["do", "try", "data", "abendynpro", "auto", "check", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks.htm) →  [dynpro - Examples of Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_check_abexas.htm) → 

dynpro - Automatic Input Checks

The example demonstrates what an automatic input check does.

Source Code

PROGRAM demo\_dynpro\_automatic\_checks .
DATA: ok\_code TYPE sy-ucomm,
      date TYPE d.
TABLES demo\_conn.
CALL SCREEN 100.
MODULE init\_screen\_100 OUTPUT.
  SET PF-STATUS 'STATUS\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE pai INPUT.
  MESSAGE i888(sabapdemos) WITH text-001.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The date field date taken from the program is assigned to the input field Date. The remaining input fields are the components CARRID, CONNID, and MARK of the structure DEMO\_CONN taken from ABAP Dictionary. All input fields are mandatory. The function code of the pushbutton is EXECUTE.

In the GUI status STATUS\_100, the symbol Cancel (F12) is activated by the function code CANCEL with the function type E. Additionally, the function key F8 is assigned the function code EXECUTE. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
  MODULE init\_screen\_100.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE pai.

The user must fill all input fields with valid values before the PAI module can be called:

-   All input fields must contain values
-   The date entry must have the correct format
-   The airline must exist in the check table SCARR.
-   The flight number must exist in the check table SPFLI and match the airline.
-   The marker MARK must be one of the fixed values of the domain S\_FLAG.

The user can exit the dynpro using Cancel (F12) without correctly entering all values, since the module call was programmed accordingly using AT EXIT-COMMAND.


### abendynpro_field_chain_abexa.htm

---
title: "Source Code"
description: |
  PROGRAM demo_dynpro_field_chain. DATA: ok_code TYPE sy-ucomm, input1 TYPE i, input2 TYPE i, input3 TYPE i, input4 TYPE i, input5 TYPE i, input6 TYPE i, sum TYPE i. CALL SCREEN 100. MODULE init_screen_100 OUTPUT. CLEAR: input1, input2, input3, input4, input5, input6. SET PF-STATUS 'STATUS_100'
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_field_chain_abexa.htm"
abapFile: "abendynpro_field_chain_abexa.htm"
keywords: ["do", "if", "data", "abendynpro", "field", "chain", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks.htm) →  [dynpro - Examples of Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_check_abexas.htm) → 

dynpro - Input Checks in Dialog Modules

This example demonstrates how to check input fields in dialog modules.

Source Code

PROGRAM demo\_dynpro\_field\_chain.
DATA: ok\_code TYPE sy-ucomm,
      input1 TYPE i, input2 TYPE i, input3 TYPE i,
      input4 TYPE i, input5 TYPE i, input6 TYPE i,
      sum TYPE i.
CALL SCREEN 100.
MODULE init\_screen\_100 OUTPUT.
  CLEAR: input1, input2, input3, input4, input5, input6.
  SET PF-STATUS 'STATUS\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE module\_1 INPUT.
  IF input1 < 50.
    MESSAGE e888(sabapdemos) WITH text-001 '50' text-002.
  ENDIF.
ENDMODULE.
MODULE module\_2 INPUT.
  IF input2 < 100.
    MESSAGE e888(sabapdemos) WITH text-001 '100' text-002.
  ENDIF.
ENDMODULE.
MODULE module\_3 INPUT.
  IF input3 < 150.
    MESSAGE e888(sabapdemos) WITH text-001 '150' text-002.
  ENDIF.
ENDMODULE.
MODULE chain\_module\_1 INPUT.
  IF input4 < 10.
    MESSAGE e888(sabapdemos) WITH text-003 '10' text-002.
  ENDIF.
ENDMODULE.
MODULE chain\_module\_2 INPUT.
  CLEAR sum.
  sum += input4.
  sum += input5.
  sum += input6.
  IF sum <= 100.
    MESSAGE e888(sabapdemos) WITH text-004 '100' text-002.
  ENDIF.
ENDMODULE.
MODULE execution INPUT.
  MESSAGE i888(sabapdemos) WITH text-005.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The input fields are assigned the dynpro fields input1 to input6. The function code of the pushbutton is EXECUTE.

In the GUI status STATUS\_100, the symbol Cancel (F12) is activated by the function code CANCEL with the function type E. The function key F8 is assigned the function code EXECUTE without a special function type. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
  MODULE init\_screen\_100.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  FIELD input1 MODULE module\_1.
  FIELD input2 MODULE module\_2.
  FIELD input3 MODULE module\_3.
  CHAIN.
    FIELD input4.
    MODULE chain\_module\_1.
    FIELD input5.
    FIELD input6 MODULE chain\_module\_2.
  ENDCHAIN.
  MODULE execution.

The fields input1 to input3 are checked separately in the modules module\_1 to module\_3. As long as the user does not enter a corresponding value, the screen layout is repeatedly displayed with the appropriate field ready for input.

The fields input4 to input6 are checked together in the processing chain. If input4 does not match the condition in chain\_module\_1, all three fields are made ready for input again. The same applies if the three fields do not fulfill the condition in chain\_module\_2.

The execution module, from which an information message is displayed, is not executed until all six fields fulfill the appropriate conditions.


### abeninput_check_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Automatic Input Checks(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_auto_check_abexa.htm) !Example(exa.gif 'Example') dynpro - Input Checks in Dialog Modules(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_fi
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_check_abexas.htm"
abapFile: "abeninput_check_abexas.htm"
keywords: ["do", "if", "abeninput", "check", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_checks.htm) → 

dynpro - Examples of Input Checks

Continue
![Example](exa.gif "Example") [dynpro - Automatic Input Checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_auto_check_abexa.htm)
![Example](exa.gif "Example") [dynpro - Input Checks in Dialog Modules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_field_chain_abexa.htm)


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Field Help, Input Help, and Dropdown List Boxes / dynpro - Input Help

**Files**: 4 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Field Help, Input Help, and Dropdown List Boxes / dynpro - Field Helps, Input Helps, and Dropdown List Boxes

Included pages: 6


### abeninput_help_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Field Help(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f1_help_abexa.htm) !Example(exa.gif 'Example') dynpro - Input Helps in the ABAP Dictionary(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f4_help_dic_a
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm"
abapFile: "abeninput_help_abexas.htm"
keywords: ["do", "if", "abeninput", "help", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) → 

dynpro - Field Helps, Input Helps, and Dropdown List Boxes

Continue
![Example](exa.gif "Example") [dynpro - Field Help](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f1_help_abexa.htm)
![Example](exa.gif "Example") [dynpro - Input Helps in the ABAP Dictionary](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f4_help_dic_abexa.htm)
![Example](exa.gif "Example") [dynpro - Input Help in Dialog Modules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f4_help_dial_abexa.htm)
![Example](exa.gif "Example") [dynpro - List Box with Value List from Input Help](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_drop1_abexa.htm)
![Example](exa.gif "Example") [dynpro - List Box with Value List from PBO Module](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_drop2_abexa.htm)


### abendynpro_f1_help_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_f1_help. DATA:  text     TYPE c LENGTH 30, docu_num TYPE c LENGTH 4, int      TYPE i, links    TYPE TABLE OF tline, field5   TYPE c LENGTH 10, field6   TYPE c LENGTH 10. TABLES demof1help. text = text-001. CALL SCREEN 100. MODULE cancel INPUT. LEAVE PROGRAM. ENDMODULE. MODULE
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f1_help_abexa.htm"
abapFile: "abendynpro_f1_help_abexa.htm"
keywords: ["do", "if", "case", "class", "data", "abendynpro", "help", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) →  [dynpro - Field Helps, Input Helps, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm) → 

dynpro - Field Help

This example demonstrates how a field help is implemented on dynpros.

Source Code

REPORT demo\_dynpro\_f1\_help.
DATA:  text     TYPE c LENGTH 30,
       docu\_num TYPE c LENGTH 4,
       int      TYPE i,
       links    TYPE TABLE OF tline,
       field5   TYPE c LENGTH 10,
       field6   TYPE c LENGTH 10.
TABLES demof1help.
text = text-001.
CALL SCREEN 100.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE f1\_help\_field4 INPUT.
  int += 1.
  CASE int.
    WHEN 1.
      docu\_num = '0100'.
    WHEN 2.
      docu\_num = '0200'.
      int = 0.
  ENDCASE.
ENDMODULE.
MODULE f1\_help\_field5 INPUT.
  CALL FUNCTION 'HELP\_OBJECT\_SHOW\_FOR\_FIELD'
       EXPORTING
            doklangu         = sy-langu
            doktitle         = text-002
            called\_for\_tab   = 'DEMOF1HELP'
            called\_for\_field = 'FIELD1'.
ENDMODULE.
MODULE f1\_help\_field6 INPUT.
  CALL FUNCTION 'HELP\_OBJECT\_SHOW'
       EXPORTING
            dokclass = 'TX'
            doklangu = sy-langu
            dokname  = 'DEMO\_FOR\_F1\_HELP'
            doktitle = text-003
       TABLES
            links    = links.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The input fields are assigned the fields DEMOF1HELP-FIELD1, DEMOF1HELP-FIELD2, DEMOF1HELP-FIELD3, and DEMOF1HELP-FIELD4 from the ABAP Dictionary and the fields field5 and field6 from the ABAP program. The function code of the pushbutton is CANCEL with the function type E. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
PROCESS ON HELP-REQUEST.
  FIELD demof1help-field4 MODULE f1\_help\_field4 WITH docu\_num.
  FIELD field5 MODULE f1\_help\_field5.
  FIELD field6 MODULE f1\_help\_field6.

The components FIELD1 through FIELD4 of the structure DEMOF1HELP refer to the data element DEMOF1TYPE. This data element is documented and two supplementary documentation objects with numbers 0100 and 0200 are created. The user sees the following field help:

-   If the user chooses F1 on the input field for DEMOF1HELP-FIELD1, the data element documentation of DEMOF1TYPE is displayed, since the field is not specified after PROCESS ON HELP-REQUEST.
-   If the user chooses F1 repeatedly for the input fields DEMOF1HELP-FIELD2 and DEMOF1HELP-FIELD3, the data element documentation is displayed, along with the supplementary documentation for either 0100 or 0200. The necessary assignments are stored statically in the database table THLPF.
-   If the user chooses F1 repeatedly for the input field DEMOF1HELP-FIELD4, the data element documentation is displayed, along with the supplementary documentation for either 0100 or 0200. The variable docu\_num is filled accordingly in the dialog module f1\_help\_field2.
-   If the user chooses F1 on the input field for field5, the data element documentation of DEMOF1TYPE is displayed since this is called in the dialog module f1\_help\_field5 by the function module HELP\_OBJECT\_SHOW\_FOR\_FIELD.
-   If the user chooses F1 on the input field for field6, the SAPscript document DEMO\_FOR\_F1\_HELP is displayed since this is called in the dialog module f1\_help\_field6 by the function module HELP\_OBJECT\_SHOW.


### abendynpro_f4_help_dic_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_f4_help_dictionary. TABLES demof4help. CALL SCREEN 100. MODULE cancel INPUT. LEAVE PROGRAM. ENDMODULE. Description The static next dynpro number of dynpro 100 is 100. The input fields are assigned the components of the structure DEMOF4HELP from the ABAP Dictionary. The functio
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f4_help_dic_abexa.htm"
abapFile: "abendynpro_f4_help_dic_abexa.htm"
keywords: ["do", "if", "data", "abendynpro", "help", "dic", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) →  [dynpro - Field Helps, Input Helps, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm) → 

dynpro - Input Helps in the ABAP Dictionary

This example demonstrates how input helps from the ABAP Dictionary can be used.

Source Code

REPORT demo\_dynpro\_f4\_help\_dictionary.
TABLES demof4help.
CALL SCREEN 100.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The input fields are assigned the components of the structure DEMOF4HELP from the ABAP Dictionary. The function code of the pushbutton is CANCEL with the function type E. When the user chooses the F4 help for the individual fields, the following is displayed:

-   The fields Date and Time refer to the components DATE\_FIELD and TIME\_FIELD of the DDIC structure. The data type is either DATS or TIMS. Consequently, the input help displayed here is either a calendar or a clock, both set to the current values by default.
-   The field Numbers refers to the component NUM\_FIELD of the DDIC structure. This component is based on the domain DEMO\_NUMBERS to which ten fixed values are assigned. These are displayed as the input help.
-   The first field Airline refers to the component CARRIER1 of the DDIC structure. This component is based on the data element DEMOF4DE. The search help DEMO\_F4\_DE with the parameter CARRID is assigned to this data element. The search help reads the columns CARRID and CARRNAME of the database table SCARR. Only SCARRNAME is specified but CARRID is flagged as an export parameter.
-   The second field Airline refers to the component CARRIER2 of the DDIC structure. This component is assigned the check table SCARR. The check table SCARR in turn is assigned the search help H\_SCARR which can display and export both columns CARRID and CARRNAME.
-   The field Connection Number refers to the component CONNID of the DDIC structure. This component is assigned the search help DEMO\_F4\_FIELD. The search help has two parameters, CARRID and CONNID, which are assigned to the components CARRIER2 and CONNID of the structure. The search help imports CARRIER, reads the associated data from the database table SPFLI, displays CARRIER and CONNID, and exports CONNID.


### abendynpro_f4_help_dial_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_f4_help_module . TYPES: BEGIN OF values, carrid TYPE spfli-carrid, connid TYPE spfli-connid, END OF values. DATA: carrier(3) TYPE c, connection(4) TYPE c. DATA: progname TYPE sy-repid, dynnum   TYPE sy-dynnr, dynpro_values TYPE TABLE OF dynpread, field_value LIKE LINE OF dyn
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f4_help_dial_abexa.htm"
abapFile: "abendynpro_f4_help_dial_abexa.htm"
keywords: ["select", "do", "if", "data", "types", "internal-table", "abendynpro", "help", "dial", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) →  [dynpro - Field Helps, Input Helps, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm) → 

dynpro - Input Help in Dialog Modules

This example demonstrates how input helps can be implemented in dialog modules.

Source Code

REPORT demo\_dynpro\_f4\_help\_module .
TYPES: BEGIN OF values,
         carrid TYPE spfli-carrid,
         connid TYPE spfli-connid,
       END OF values.
DATA: carrier(3) TYPE c,
      connection(4) TYPE c.
DATA: progname TYPE sy-repid,
      dynnum   TYPE sy-dynnr,
      dynpro\_values TYPE TABLE OF dynpread,
      field\_value LIKE LINE OF dynpro\_values,
      values\_tab TYPE TABLE OF values.
CALL SCREEN 100.
MODULE init OUTPUT.
  progname = sy-repid.
  dynnum   = sy-dynnr.
  CLEAR: field\_value, dynpro\_values.
  field\_value-fieldname = 'CARRIER'.
  APPEND field\_value TO dynpro\_values.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE value\_carrier INPUT.
  CALL FUNCTION 'F4IF\_FIELD\_VALUE\_REQUEST'
       EXPORTING
            tabname     = 'DEMOF4HELP'
            fieldname   = 'CARRIER1'
            dynpprog    = progname
            dynpnr      = dynnum
            dynprofield = 'CARRIER'.
ENDMODULE.
MODULE value\_connection INPUT.
  CALL FUNCTION 'DYNP\_VALUES\_READ'
       EXPORTING
            dyname             = progname
            dynumb             = dynnum
            translate\_to\_upper = 'X'
       TABLES
            dynpfields         = dynpro\_values.
  field\_value = dynpro\_values\[ 1 \].
  SELECT  carrid, connid
    FROM  spfli
    WHERE carrid = @( CONV #( field\_value-fieldvalue ) )
    INTO  CORRESPONDING FIELDS OF TABLE @values\_tab.
  CALL FUNCTION 'F4IF\_INT\_TABLE\_VALUE\_REQUEST'
       EXPORTING
            retfield    = 'CONNID'
            dynpprog    = progname
            dynpnr      = dynnum
            dynprofield = 'CONNECTION'
            value\_org   = 'S'
       TABLES
            value\_tab   = values\_tab.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The input fields are taken from the program fields carrier and connection. The function code of the pushbutton is CANCEL with the function type E. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
  MODULE init.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
PROCESS ON VALUE-REQUEST.
  FIELD carrier MODULE value\_carrier.
  FIELD connection MODULE value\_connection.

When selecting the F4 help for the individual fields, the user is shown the following types of input help:

-   For the airline, the module value\_carrier is called at POV. There, the function module F4IF\_FIELD\_VALUE\_REQUEST displays the input help of the component CARRIER1 of the structure DEMOF4HELP from the ABAP Dictionary, namely the search help DEMOF4DE. The selection of the user is passed to the dynpro field carrier.
-   For the connection, the module value\_connection is called at POV. There, the function module DYNP\_VALUES\_READ passes the value of the dynpro field carrier to the program. SELECT then extracts the matching values from the database table SPFLI into the internal table values\_tab and passes them to the function module F4IF\_INT\_TABLE\_VALUE\_REQUEST. The function module displays these values as an input help and passes the selection of the user to the dynpro field connection.


### abendynpro_drop1_abexa.htm

---
title: "Source Code"
description: |
  &--------------------------------------------------------------------- & Report  DEMO_DROPDOWN_LIST_BOX                                       &--------------------------------------------------------------------- REPORT demo_dropdown_list_box.  Dynpro Interfaces TABLES sdyn_conn
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_drop1_abexa.htm"
abapFile: "abendynpro_drop1_abexa.htm"
keywords: ["select", "insert", "do", "if", "case", "method", "class", "data", "types", "internal-table", "abendynpro", "drop1", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) →  [dynpro - Field Helps, Input Helps, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm) → 

dynpro - List Box with Value List from Input Help

This example demonstrates the recommended way to enable a dropdown list box.

Source Code

\*&---------------------------------------------------------------------\*
\*& Report  DEMO\_DROPDOWN\_LIST\_BOX                                      \*
\*&---------------------------------------------------------------------\*
REPORT demo\_dropdown\_list\_box.
\* Dynpro Interfaces
TABLES sdyn\_conn.
DATA   ok\_code TYPE sy-ucomm.
\* Local class definition
CLASS dynpro\_utilities DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS value\_help.
ENDCLASS.
\* Local class implementation
CLASS dynpro\_utilities IMPLEMENTATION.
  METHOD value\_help.
    TYPES: BEGIN OF carrid\_line,
             carrid   TYPE spfli-carrid,
             carrname TYPE scarr-carrname,
           END OF carrid\_line.
    DATA carrid\_list TYPE STANDARD TABLE OF carrid\_line.
    SELECT carrid, carrname
                FROM scarr
                INTO CORRESPONDING FIELDS OF TABLE @carrid\_list.
    CALL FUNCTION 'F4IF\_INT\_TABLE\_VALUE\_REQUEST'
         EXPORTING
              retfield        = 'CARRID'
              value\_org       = 'S'
         TABLES
              value\_tab       = carrid\_list
         EXCEPTIONS
              parameter\_error = 1
              no\_values\_found = 2
              OTHERS          = 3.
    IF sy-subrc <> 0.
      ...
    ENDIF.
  ENDMETHOD.
ENDCLASS.
\* Event Blocks and Dialog Modules
START-OF-SELECTION.
  CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command\_0100 INPUT.
  CASE ok\_code.
    WHEN 'SELECTED'.
      MESSAGE i888(sabapdemos) WITH sdyn\_conn-carrid.
  ENDCASE.
ENDMODULE.
MODULE create\_dropdown\_box INPUT.
  dynpro\_utilities=>value\_help( ).
ENDMODULE.

Description

The static dynpro number of dynpro 100 is 100. The screen layout contains a single input field, namely the component SDYN\_CONN-CARRID. Its attribute dropdown is "Listbox", the output length is 20, the attribute value list is empty, and it is assigned function code SELECTED. The functions BACK, EXIT, and CANCEL are defined in the GUI status with the function type E. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
  MODULE status\_0100.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE user\_command\_0100.
PROCESS ON VALUE-REQUEST.
  FIELD sdyn\_conn-carrid MODULE create\_dropdown\_box.

The user is not allowed to enter values in the screen field. When the user selects the input field on dynpro 100, the system displays a list box. The Value list attribute is empty, so the system launches the input mechanism. In this case, the event block PROCESS ON VALUE-REQUEST is created in the dynpro flow logic which overrides all other mechanisms. The system fills a two-column internal table in the corresponding dialog module and passes it to the input help using the function module F4IF\_INT\_TABLE\_VALUE\_REQUEST. The system inserts the two columns of the table into the list box.

When the user selects a line in the list box, the PAI event is raised using the function code SELECTED and the value in the first column of the internal table is copied to the input field.


### abendynpro_drop2_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_dropdown_listbox. DATA: name  TYPE vrm_id, list  TYPE vrm_values, value LIKE LINE OF list. DATA: wa_spfli TYPE spfli, ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. TABLES demof4help. name = 'DEMOF4HELP-CONNID'. CALL SCREEN 100. MODULE cancel INPUT. LEAVE PROGRAM. ENDMODULE
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_drop2_abexa.htm"
abapFile: "abendynpro_drop2_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "data", "internal-table", "abendynpro", "drop2", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) →  [dynpro - Field Helps, Input Helps, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm) → 

dynpro - List Box with Value List from PBO Module

This example demonstrates a non-recommended way to enable a dropdown list box.

Source Code

REPORT demo\_dynpro\_dropdown\_listbox.
DATA: name  TYPE vrm\_id,
      list  TYPE vrm\_values,
      value LIKE LINE OF list.
DATA: wa\_spfli TYPE spfli,
      ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
TABLES demof4help.
name = 'DEMOF4HELP-CONNID'.
CALL SCREEN 100.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE init\_listbox OUTPUT.
  CLEAR: demof4help-connid,
         list.
  SELECT  connid, cityfrom, cityto, deptime
          FROM spfli
          WHERE carrid = @demof4help-carrier2
          INTO CORRESPONDING FIELDS OF @wa\_spfli.
    value-key  = wa\_spfli-connid.
    WRITE wa\_spfli-deptime TO value-text USING EDIT MASK '\_\_:\_\_:\_\_'.
    value-text =
      |{ value-text } { wa\_spfli-cityfrom } { wa\_spfli-cityto }|.
    APPEND value TO list.
  ENDSELECT.
  IF sy-subrc <> 0.
    MESSAGE 'No connections for that airline' TYPE 'I' DISPLAY LIKE 'E'.
    LEAVE TO SCREEN 100.
  ENDIF.
  CALL FUNCTION 'VRM\_SET\_VALUES'
    EXPORTING
      id     = name
      values = list.
ENDMODULE.
MODULE user\_command\_100.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'CARRIER' AND NOT demof4help-carrier2 IS INITIAL.
    LEAVE TO SCREEN 200.
  ELSE.
    SET SCREEN 100.
  ENDIF.
ENDMODULE.
MODULE user\_command\_200.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'SELECTED'.
    MESSAGE i888(sabapdemos) WITH text-001 demof4help-carrier2
                                          demof4help-connid.
    CLEAR demof4help.
  ENDIF.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 200. The input field is assigned the component CARRIER2 of the structure DEMOF4HELP from the ABAP Dictionary. Its dropdown attribute is L, the output length is 15, the value list attribute is empty, and it is assigned the function code CARRIER. The function code of the pushbutton is CANCEL with the function type E. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE user\_command\_100.

The static next dynpro number of dynpro 200 is 100. The input field is assigned the component CONNID of the structure DEMOF4HELP from the ABAP Dictionary. Its dropdown attribute is L, the output length is 30, the value list attribute is A, and it is assigned the SELECTED function code. The function code of the pushbutton is CANCEL with the function type E. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
  MODULE init\_listbox.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE user\_command\_200.

The user is not allowed to enter values in the screen fields. When selecting the input field on dynpro 100, the user sees a value list in the list box derived from the input help of the DEMOF4HELP-CARRIER2 field. In this case, this is the search help H\_SCARR assigned to the SCARR check table in the ABAP Dictionary. The value list contains the names of the airlines. When the user selects an entry, the dynpro field is filled with the ID of the airline, and the event PAI is raised. The module user\_command\_100 checks the OK field and calls dynpro 200.

At the PBO event of dynpro 200, an internal table called list is filled with values from the database table SPFLI. The key component is filled with the flight connection numbers, and other relevant information is stored in the text field. The list table is passed to the VRM\_SET\_VALUES function module. When the user selects the input field on dynpro 200, the text column of the internal table is displayed in the list box. When the user selects an entry, the dynpro field is filled with the associated entry from the key column, and the event PAI is raised. The module user\_command\_200 checks and processes the OK field.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Field Help, Input Help, and Dropdown List Boxes / dynpro - Field Helps, Input Helps, and Dropdown List Boxes

**Files**: 6 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Field Help, Input Help, and Dropdown List Boxes / dynpro - Field Helps, Input Helps, and Dropdown List Boxes

Included pages: 6


### abeninput_help_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Field Help(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f1_help_abexa.htm) !Example(exa.gif 'Example') dynpro - Input Helps in the ABAP Dictionary(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f4_help_dic_a
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm"
abapFile: "abeninput_help_abexas.htm"
keywords: ["do", "if", "abeninput", "help", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) → 

dynpro - Field Helps, Input Helps, and Dropdown List Boxes

Continue
![Example](exa.gif "Example") [dynpro - Field Help](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f1_help_abexa.htm)
![Example](exa.gif "Example") [dynpro - Input Helps in the ABAP Dictionary](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f4_help_dic_abexa.htm)
![Example](exa.gif "Example") [dynpro - Input Help in Dialog Modules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f4_help_dial_abexa.htm)
![Example](exa.gif "Example") [dynpro - List Box with Value List from Input Help](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_drop1_abexa.htm)
![Example](exa.gif "Example") [dynpro - List Box with Value List from PBO Module](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_drop2_abexa.htm)


### abendynpro_f1_help_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_f1_help. DATA:  text     TYPE c LENGTH 30, docu_num TYPE c LENGTH 4, int      TYPE i, links    TYPE TABLE OF tline, field5   TYPE c LENGTH 10, field6   TYPE c LENGTH 10. TABLES demof1help. text = text-001. CALL SCREEN 100. MODULE cancel INPUT. LEAVE PROGRAM. ENDMODULE. MODULE
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f1_help_abexa.htm"
abapFile: "abendynpro_f1_help_abexa.htm"
keywords: ["do", "if", "case", "class", "data", "abendynpro", "help", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) →  [dynpro - Field Helps, Input Helps, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm) → 

dynpro - Field Help

This example demonstrates how a field help is implemented on dynpros.

Source Code

REPORT demo\_dynpro\_f1\_help.
DATA:  text     TYPE c LENGTH 30,
       docu\_num TYPE c LENGTH 4,
       int      TYPE i,
       links    TYPE TABLE OF tline,
       field5   TYPE c LENGTH 10,
       field6   TYPE c LENGTH 10.
TABLES demof1help.
text = text-001.
CALL SCREEN 100.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE f1\_help\_field4 INPUT.
  int += 1.
  CASE int.
    WHEN 1.
      docu\_num = '0100'.
    WHEN 2.
      docu\_num = '0200'.
      int = 0.
  ENDCASE.
ENDMODULE.
MODULE f1\_help\_field5 INPUT.
  CALL FUNCTION 'HELP\_OBJECT\_SHOW\_FOR\_FIELD'
       EXPORTING
            doklangu         = sy-langu
            doktitle         = text-002
            called\_for\_tab   = 'DEMOF1HELP'
            called\_for\_field = 'FIELD1'.
ENDMODULE.
MODULE f1\_help\_field6 INPUT.
  CALL FUNCTION 'HELP\_OBJECT\_SHOW'
       EXPORTING
            dokclass = 'TX'
            doklangu = sy-langu
            dokname  = 'DEMO\_FOR\_F1\_HELP'
            doktitle = text-003
       TABLES
            links    = links.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The input fields are assigned the fields DEMOF1HELP-FIELD1, DEMOF1HELP-FIELD2, DEMOF1HELP-FIELD3, and DEMOF1HELP-FIELD4 from the ABAP Dictionary and the fields field5 and field6 from the ABAP program. The function code of the pushbutton is CANCEL with the function type E. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
PROCESS ON HELP-REQUEST.
  FIELD demof1help-field4 MODULE f1\_help\_field4 WITH docu\_num.
  FIELD field5 MODULE f1\_help\_field5.
  FIELD field6 MODULE f1\_help\_field6.

The components FIELD1 through FIELD4 of the structure DEMOF1HELP refer to the data element DEMOF1TYPE. This data element is documented and two supplementary documentation objects with numbers 0100 and 0200 are created. The user sees the following field help:

-   If the user chooses F1 on the input field for DEMOF1HELP-FIELD1, the data element documentation of DEMOF1TYPE is displayed, since the field is not specified after PROCESS ON HELP-REQUEST.
-   If the user chooses F1 repeatedly for the input fields DEMOF1HELP-FIELD2 and DEMOF1HELP-FIELD3, the data element documentation is displayed, along with the supplementary documentation for either 0100 or 0200. The necessary assignments are stored statically in the database table THLPF.
-   If the user chooses F1 repeatedly for the input field DEMOF1HELP-FIELD4, the data element documentation is displayed, along with the supplementary documentation for either 0100 or 0200. The variable docu\_num is filled accordingly in the dialog module f1\_help\_field2.
-   If the user chooses F1 on the input field for field5, the data element documentation of DEMOF1TYPE is displayed since this is called in the dialog module f1\_help\_field5 by the function module HELP\_OBJECT\_SHOW\_FOR\_FIELD.
-   If the user chooses F1 on the input field for field6, the SAPscript document DEMO\_FOR\_F1\_HELP is displayed since this is called in the dialog module f1\_help\_field6 by the function module HELP\_OBJECT\_SHOW.


### abendynpro_f4_help_dic_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_f4_help_dictionary. TABLES demof4help. CALL SCREEN 100. MODULE cancel INPUT. LEAVE PROGRAM. ENDMODULE. Description The static next dynpro number of dynpro 100 is 100. The input fields are assigned the components of the structure DEMOF4HELP from the ABAP Dictionary. The functio
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f4_help_dic_abexa.htm"
abapFile: "abendynpro_f4_help_dic_abexa.htm"
keywords: ["do", "if", "data", "abendynpro", "help", "dic", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) →  [dynpro - Field Helps, Input Helps, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm) → 

dynpro - Input Helps in the ABAP Dictionary

This example demonstrates how input helps from the ABAP Dictionary can be used.

Source Code

REPORT demo\_dynpro\_f4\_help\_dictionary.
TABLES demof4help.
CALL SCREEN 100.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The input fields are assigned the components of the structure DEMOF4HELP from the ABAP Dictionary. The function code of the pushbutton is CANCEL with the function type E. When the user chooses the F4 help for the individual fields, the following is displayed:

-   The fields Date and Time refer to the components DATE\_FIELD and TIME\_FIELD of the DDIC structure. The data type is either DATS or TIMS. Consequently, the input help displayed here is either a calendar or a clock, both set to the current values by default.
-   The field Numbers refers to the component NUM\_FIELD of the DDIC structure. This component is based on the domain DEMO\_NUMBERS to which ten fixed values are assigned. These are displayed as the input help.
-   The first field Airline refers to the component CARRIER1 of the DDIC structure. This component is based on the data element DEMOF4DE. The search help DEMO\_F4\_DE with the parameter CARRID is assigned to this data element. The search help reads the columns CARRID and CARRNAME of the database table SCARR. Only SCARRNAME is specified but CARRID is flagged as an export parameter.
-   The second field Airline refers to the component CARRIER2 of the DDIC structure. This component is assigned the check table SCARR. The check table SCARR in turn is assigned the search help H\_SCARR which can display and export both columns CARRID and CARRNAME.
-   The field Connection Number refers to the component CONNID of the DDIC structure. This component is assigned the search help DEMO\_F4\_FIELD. The search help has two parameters, CARRID and CONNID, which are assigned to the components CARRIER2 and CONNID of the structure. The search help imports CARRIER, reads the associated data from the database table SPFLI, displays CARRIER and CONNID, and exports CONNID.


### abendynpro_f4_help_dial_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_f4_help_module . TYPES: BEGIN OF values, carrid TYPE spfli-carrid, connid TYPE spfli-connid, END OF values. DATA: carrier(3) TYPE c, connection(4) TYPE c. DATA: progname TYPE sy-repid, dynnum   TYPE sy-dynnr, dynpro_values TYPE TABLE OF dynpread, field_value LIKE LINE OF dyn
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_f4_help_dial_abexa.htm"
abapFile: "abendynpro_f4_help_dial_abexa.htm"
keywords: ["select", "do", "if", "data", "types", "internal-table", "abendynpro", "help", "dial", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) →  [dynpro - Field Helps, Input Helps, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm) → 

dynpro - Input Help in Dialog Modules

This example demonstrates how input helps can be implemented in dialog modules.

Source Code

REPORT demo\_dynpro\_f4\_help\_module .
TYPES: BEGIN OF values,
         carrid TYPE spfli-carrid,
         connid TYPE spfli-connid,
       END OF values.
DATA: carrier(3) TYPE c,
      connection(4) TYPE c.
DATA: progname TYPE sy-repid,
      dynnum   TYPE sy-dynnr,
      dynpro\_values TYPE TABLE OF dynpread,
      field\_value LIKE LINE OF dynpro\_values,
      values\_tab TYPE TABLE OF values.
CALL SCREEN 100.
MODULE init OUTPUT.
  progname = sy-repid.
  dynnum   = sy-dynnr.
  CLEAR: field\_value, dynpro\_values.
  field\_value-fieldname = 'CARRIER'.
  APPEND field\_value TO dynpro\_values.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE value\_carrier INPUT.
  CALL FUNCTION 'F4IF\_FIELD\_VALUE\_REQUEST'
       EXPORTING
            tabname     = 'DEMOF4HELP'
            fieldname   = 'CARRIER1'
            dynpprog    = progname
            dynpnr      = dynnum
            dynprofield = 'CARRIER'.
ENDMODULE.
MODULE value\_connection INPUT.
  CALL FUNCTION 'DYNP\_VALUES\_READ'
       EXPORTING
            dyname             = progname
            dynumb             = dynnum
            translate\_to\_upper = 'X'
       TABLES
            dynpfields         = dynpro\_values.
  field\_value = dynpro\_values\[ 1 \].
  SELECT  carrid, connid
    FROM  spfli
    WHERE carrid = @( CONV #( field\_value-fieldvalue ) )
    INTO  CORRESPONDING FIELDS OF TABLE @values\_tab.
  CALL FUNCTION 'F4IF\_INT\_TABLE\_VALUE\_REQUEST'
       EXPORTING
            retfield    = 'CONNID'
            dynpprog    = progname
            dynpnr      = dynnum
            dynprofield = 'CONNECTION'
            value\_org   = 'S'
       TABLES
            value\_tab   = values\_tab.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The input fields are taken from the program fields carrier and connection. The function code of the pushbutton is CANCEL with the function type E. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
  MODULE init.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
PROCESS ON VALUE-REQUEST.
  FIELD carrier MODULE value\_carrier.
  FIELD connection MODULE value\_connection.

When selecting the F4 help for the individual fields, the user is shown the following types of input help:

-   For the airline, the module value\_carrier is called at POV. There, the function module F4IF\_FIELD\_VALUE\_REQUEST displays the input help of the component CARRIER1 of the structure DEMOF4HELP from the ABAP Dictionary, namely the search help DEMOF4DE. The selection of the user is passed to the dynpro field carrier.
-   For the connection, the module value\_connection is called at POV. There, the function module DYNP\_VALUES\_READ passes the value of the dynpro field carrier to the program. SELECT then extracts the matching values from the database table SPFLI into the internal table values\_tab and passes them to the function module F4IF\_INT\_TABLE\_VALUE\_REQUEST. The function module displays these values as an input help and passes the selection of the user to the dynpro field connection.


### abendynpro_drop1_abexa.htm

---
title: "Source Code"
description: |
  &--------------------------------------------------------------------- & Report  DEMO_DROPDOWN_LIST_BOX                                       &--------------------------------------------------------------------- REPORT demo_dropdown_list_box.  Dynpro Interfaces TABLES sdyn_conn
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_drop1_abexa.htm"
abapFile: "abendynpro_drop1_abexa.htm"
keywords: ["select", "insert", "do", "if", "case", "method", "class", "data", "types", "internal-table", "abendynpro", "drop1", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) →  [dynpro - Field Helps, Input Helps, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm) → 

dynpro - List Box with Value List from Input Help

This example demonstrates the recommended way to enable a dropdown list box.

Source Code

\*&---------------------------------------------------------------------\*
\*& Report  DEMO\_DROPDOWN\_LIST\_BOX                                      \*
\*&---------------------------------------------------------------------\*
REPORT demo\_dropdown\_list\_box.
\* Dynpro Interfaces
TABLES sdyn\_conn.
DATA   ok\_code TYPE sy-ucomm.
\* Local class definition
CLASS dynpro\_utilities DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS value\_help.
ENDCLASS.
\* Local class implementation
CLASS dynpro\_utilities IMPLEMENTATION.
  METHOD value\_help.
    TYPES: BEGIN OF carrid\_line,
             carrid   TYPE spfli-carrid,
             carrname TYPE scarr-carrname,
           END OF carrid\_line.
    DATA carrid\_list TYPE STANDARD TABLE OF carrid\_line.
    SELECT carrid, carrname
                FROM scarr
                INTO CORRESPONDING FIELDS OF TABLE @carrid\_list.
    CALL FUNCTION 'F4IF\_INT\_TABLE\_VALUE\_REQUEST'
         EXPORTING
              retfield        = 'CARRID'
              value\_org       = 'S'
         TABLES
              value\_tab       = carrid\_list
         EXCEPTIONS
              parameter\_error = 1
              no\_values\_found = 2
              OTHERS          = 3.
    IF sy-subrc <> 0.
      ...
    ENDIF.
  ENDMETHOD.
ENDCLASS.
\* Event Blocks and Dialog Modules
START-OF-SELECTION.
  CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command\_0100 INPUT.
  CASE ok\_code.
    WHEN 'SELECTED'.
      MESSAGE i888(sabapdemos) WITH sdyn\_conn-carrid.
  ENDCASE.
ENDMODULE.
MODULE create\_dropdown\_box INPUT.
  dynpro\_utilities=>value\_help( ).
ENDMODULE.

Description

The static dynpro number of dynpro 100 is 100. The screen layout contains a single input field, namely the component SDYN\_CONN-CARRID. Its attribute dropdown is "Listbox", the output length is 20, the attribute value list is empty, and it is assigned function code SELECTED. The functions BACK, EXIT, and CANCEL are defined in the GUI status with the function type E. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
  MODULE status\_0100.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE user\_command\_0100.
PROCESS ON VALUE-REQUEST.
  FIELD sdyn\_conn-carrid MODULE create\_dropdown\_box.

The user is not allowed to enter values in the screen field. When the user selects the input field on dynpro 100, the system displays a list box. The Value list attribute is empty, so the system launches the input mechanism. In this case, the event block PROCESS ON VALUE-REQUEST is created in the dynpro flow logic which overrides all other mechanisms. The system fills a two-column internal table in the corresponding dialog module and passes it to the input help using the function module F4IF\_INT\_TABLE\_VALUE\_REQUEST. The system inserts the two columns of the table into the list box.

When the user selects a line in the list box, the PAI event is raised using the function code SELECTED and the value in the first column of the internal table is copied to the input field.


### abendynpro_drop2_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_dropdown_listbox. DATA: name  TYPE vrm_id, list  TYPE vrm_values, value LIKE LINE OF list. DATA: wa_spfli TYPE spfli, ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. TABLES demof4help. name = 'DEMOF4HELP-CONNID'. CALL SCREEN 100. MODULE cancel INPUT. LEAVE PROGRAM. ENDMODULE
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_drop2_abexa.htm"
abapFile: "abendynpro_drop2_abexa.htm"
keywords: ["select", "do", "if", "case", "try", "data", "internal-table", "abendynpro", "drop2", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Field Help, Input Help, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_help.htm) →  [dynpro - Field Helps, Input Helps, and Dropdown List Boxes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninput_help_abexas.htm) → 

dynpro - List Box with Value List from PBO Module

This example demonstrates a non-recommended way to enable a dropdown list box.

Source Code

REPORT demo\_dynpro\_dropdown\_listbox.
DATA: name  TYPE vrm\_id,
      list  TYPE vrm\_values,
      value LIKE LINE OF list.
DATA: wa\_spfli TYPE spfli,
      ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
TABLES demof4help.
name = 'DEMOF4HELP-CONNID'.
CALL SCREEN 100.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE init\_listbox OUTPUT.
  CLEAR: demof4help-connid,
         list.
  SELECT  connid, cityfrom, cityto, deptime
          FROM spfli
          WHERE carrid = @demof4help-carrier2
          INTO CORRESPONDING FIELDS OF @wa\_spfli.
    value-key  = wa\_spfli-connid.
    WRITE wa\_spfli-deptime TO value-text USING EDIT MASK '\_\_:\_\_:\_\_'.
    value-text =
      |{ value-text } { wa\_spfli-cityfrom } { wa\_spfli-cityto }|.
    APPEND value TO list.
  ENDSELECT.
  IF sy-subrc <> 0.
    MESSAGE 'No connections for that airline' TYPE 'I' DISPLAY LIKE 'E'.
    LEAVE TO SCREEN 100.
  ENDIF.
  CALL FUNCTION 'VRM\_SET\_VALUES'
    EXPORTING
      id     = name
      values = list.
ENDMODULE.
MODULE user\_command\_100.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'CARRIER' AND NOT demof4help-carrier2 IS INITIAL.
    LEAVE TO SCREEN 200.
  ELSE.
    SET SCREEN 100.
  ENDIF.
ENDMODULE.
MODULE user\_command\_200.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'SELECTED'.
    MESSAGE i888(sabapdemos) WITH text-001 demof4help-carrier2
                                          demof4help-connid.
    CLEAR demof4help.
  ENDIF.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 200. The input field is assigned the component CARRIER2 of the structure DEMOF4HELP from the ABAP Dictionary. Its dropdown attribute is L, the output length is 15, the value list attribute is empty, and it is assigned the function code CARRIER. The function code of the pushbutton is CANCEL with the function type E. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE user\_command\_100.

The static next dynpro number of dynpro 200 is 100. The input field is assigned the component CONNID of the structure DEMOF4HELP from the ABAP Dictionary. Its dropdown attribute is L, the output length is 30, the value list attribute is A, and it is assigned the SELECTED function code. The function code of the pushbutton is CANCEL with the function type E. The dynpro flow logic is as follows:

PROCESS BEFORE OUTPUT.
  MODULE init\_listbox.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE user\_command\_200.

The user is not allowed to enter values in the screen fields. When selecting the input field on dynpro 100, the user sees a value list in the list box derived from the input help of the DEMOF4HELP-CARRIER2 field. In this case, this is the search help H\_SCARR assigned to the SCARR check table in the ABAP Dictionary. The value list contains the names of the airlines. When the user selects an entry, the dynpro field is filled with the ID of the airline, and the event PAI is raised. The module user\_command\_100 checks the OK field and calls dynpro 200.

At the PBO event of dynpro 200, an internal table called list is filled with values from the database table SPFLI. The key component is filled with the flight connection numbers, and other relevant information is stored in the text field. The list table is passed to the VRM\_SET\_VALUES function module. When the user selects the input field on dynpro 200, the text column of the internal table is displayed in the list box. When the user selects an entry, the dynpro field is filled with the associated entry from the key column, and the event PAI is raised. The module user\_command\_200 checks and processes the OK field.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Statements in the Dynpro Flow Logic / dynpro - MODULE

**Files**: 6 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Statements in the Dynpro Flow Logic / dynpro - Subscreens, Tabstrips, and Splitter Controls

Included pages: 11


### abendynp_subscreens.htm

---
title: "Continue"
description: |
  dynpro - Including Subscreens Directly(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) dynpro - Tabstrip Controls(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm) dynpro - Splitter Controls(https://help.sap.com/doc/abapdocu_75
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm"
abapFile: "abendynp_subscreens.htm"
keywords: ["do", "try", "abendynp", "subscreens"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) → 

dynpro - Subscreens, Tabstrips, and Splitter Controls

Subscreens are screen layouts of special subscreen dynpros that can be included in other dynpros. Subscreens are either included directly, or using special [controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontrol_glosry.htm "Glossary Entry").

-   [Including Subscreens Directly](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm)
-   [Tabstrip Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm)
-   [Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm)

Continue
[dynpro - Including Subscreens Directly](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm)
[dynpro - Tabstrip Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm)
[dynpro - Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm)
[dynpro - CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm)
[dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm)


### abendynp_subscreen.htm

---
title: "Hint"
description: |
  Subscreens dynpros are defined like regular dynpros in the Screen Painter(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_painter_glosry.htm 'Glossary Entry') and are flagged there as regular dynpros. Selection screens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm"
abapFile: "abendynp_subscreen.htm"
keywords: ["select", "do", "if", "try", "abendynp", "subscreen"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Including Subscreens Directly

The statement [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) can be used to include other screen layouts directly in the [screen layout](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_glosry.htm "Glossary Entry") of a [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") in the form of subscreens. Here, subscreen areas must first be defined in the screen layout of the current dynpro. Every subscreen area has a unique name and can be configured to support changes in screen size. If the latter is defined, each size change in the current GUI window raises the [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry") event.

Subscreens are the screen layouts of special [subscreen dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry"). When a subscreen is included, the flow logic of the subscreen dynpro is also included. Subscreens can also include other subscreens. Subscreens cannot have their own OK field. Instead, user actions on subscreens pass the function codes to the OK field of the including dynpro. In the PAI event block of a subscreen dynpro, a [MODULE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpmodule.htm) statement is never executed with the AT EXIT-COMMAND addition.

Hint

Subscreens dynpros are defined like regular dynpros in the [Screen Painter](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_painter_glosry.htm "Glossary Entry") and are flagged there as regular dynpros. [Selection screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_subscreen.htm) can also be defined as subscreens.

Executable Example

[Dynpros, Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)


### abendynp_tabstrip.htm

---
title: "Hint"
description: |
  If a tab title is selected when browsing in the SAP GUI, input checks are not made, and data is not transported to the ABAP program. The entries are all checked and the data of all subscreens transported only if a user action raises the PAI event. When browsing in the ABAP program, the input is chec
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm"
abapFile: "abendynp_tabstrip.htm"
keywords: ["select", "do", "if", "try", "data", "abendynp", "tabstrip"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Tabstrip Controls

A tabstrip control is a screen element that consists of multiple tab pages. Every tab page contains a single-line [tab title](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_title_glosry.htm "Glossary Entry") linked with a function code and which can be used to select the tab page by clicking it once. Under the tab title, a tab page consists of a subscreen area. Each tab title must have a subscreen area assigned to it, in which any subscreens can be displayed. There are two ways to do this:

-   Browsing in SAP GUI
    
    A separate subscreen area is assigned to each tab title and the function codes of the tab titles are defined with the function type "P". If the user selects a tab title, the event PAI is not raised. The associated subscreens are included once in each individual subscreen area by using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement of the flow logic. If the user selects a tab title, the SAP GUI browses to the associated tab page and displays its subscreen.
    
-   Browsing in ABAP Programs
    
    The same subscreen area is assigned to each tab title, and the function codes of the tab titles are defined without [typing](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentyping_glosry.htm "Glossary Entry"). If the user selects a tab title, the event PAI is raised. The associated subscreen is included dynamically using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement of the flow logic in the subscreen area each time the user browses. In the ABAP program, the associated tab page must be activated using [CONTROLS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcontrols.htm) and the correct subscreen dynpro for the subscreen area must be specified.
    

Hint

If a tab title is selected when browsing in the SAP GUI, input checks are not made, and data is not transported to the ABAP program. The entries are all checked and the data of all subscreens transported only if a user action raises the PAI event. When browsing in the ABAP program, the input is checked each time a tab title is selected, and the current tab page data is transported to the ABAP program of the subscreen dynpro.

Executable Examples

-   [Dynpros, Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
-   [Dynpros, Tabstrips with Scrolling in AS instance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)


### abendynp_splitter_control_spcl.htm

---
title: "Hints"
description: |
  -   A splitter control can only be created in the alphanumeric Screen Painter by using Edit → Create Element → Splitter Control. For this reason, it should only be used in cases when the functions offered are required on classic dynpros. SAPUI5(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm"
abapFile: "abendynp_splitter_control_spcl.htm"
keywords: ["do", "while", "if", "case", "try", "method", "class", "abendynp", "splitter", "control", "spcl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Splitter Controls

A splitter control is a screen element that divides the area it covers either horizontally into two adjacent [subscreen areas](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry") or vertically one above each other. The division is made by a sash. The horizontal or vertical position of the sash is specified statically in the definition of the splitter control. It can be set to PBO in the ABAP program and changed by the user while the screen layout is displayed.

[Subscreen dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") are included in both subscreen areas in exactly the same way as [direct inclusion](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement in the dynpro flow logic. Any subscreens can be included, particularly those that contain splitter controls again.

In ABAP programs, the position of the sash of a splitter controls is controlled using an instance of the CL\_DYNPRO\_SPLITTER class. If, before sending this screen layout, an object of this class is created and its constructor is given the name of a splitter control, this is bound to the splitter control and its methods can be used to set and read the position of the sash. The sash position is specified as a percentage and refers to the width or height of the splitter control. In the object, the position is represented by a private attribute. Important methods of the class are:

-   GET\_GUISASH
    
    At PAI sets the sash position of the object to the current value of the bound splitter control.
    
-   SET\_SASH
    
    If no value is passed to the POSITION parameter, the method sets the sash position of the bound splitter control at PBO to the value of the object. If a value is passed to the POSITION parameter, the method sets the attribute of the object and the sash position of the bound splitter control at PBO to this value. At PAI, only the attribute of the object is set.
    
-   GET\_SASH
    
    Returns the sash position of the bound splitter control at PBO and PAI.
    

A splitter control can have a [function code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunction_code_glosry.htm "Glossary Entry") assigned to it, which can be used to react to changes to the sash position made by the user in ABAP programs.

Hints

-   A splitter control can only be created in the alphanumeric Screen Painter by using Edit → Create Element → Splitter Control. For this reason, it should only be used in cases when the functions offered are required on classic dynpros. [SAPUI5](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensapui5_glosry.htm "Glossary Entry") or [Web Dynpro ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenweb_dynpro_glosry.htm "Glossary Entry") should be used for new developments instead of classic dynpros.
-   Splitter controls offer certain advantages over the corresponding [CFW](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencfw_glosry.htm "Glossary Entry") containers. One advantage is that they allow all screen elements of a classic dynpro to be displayed directly in a flexible frame. Another is that they have better performance than CFW controls. An example of intensive use of splitter controls is the flexible interface of the ABAP Debugger.

Executable Example

[Dynpros, Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


### dynpcall.htm

---
title: "Syntax"
description: |
  CALL SUBSCREEN sub_area INCLUDING prog dynnr. Variants: 1. CALL SUBSCREEN sub_area INCLUDING prog dynnr.(#!ABAP_VARIANT_1@1@) 2. CALL SUBSCREEN sub_area.(#!ABAP_VARIANT_2@2@) Effect Includes a subscreen(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_glosr
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm"
abapFile: "dynpcall.htm"
keywords: ["loop", "do", "if", "try", "catch", "data", "dynpcall"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - CALL SUBSCREEN

Syntax

CALL SUBSCREEN sub\_area *\[*INCLUDING prog dynnr*\]*.

Variants:

[1\. CALL SUBSCREEN sub\_area INCLUDING prog dynnr.](#!ABAP_VARIANT_1@1@)
[2\. CALL SUBSCREEN sub\_area.](#!ABAP_VARIANT_2@2@)

Effect

Includes a [subscreen](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_glosry.htm "Glossary Entry") in the [dynpro flow logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_flow_logic_glosry.htm "Glossary Entry"). There is one variant for the event [PBO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm "Glossary Entry") and one variant for the event [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry"). The statement CALL SUBSCREEN cannot be used between the statements LOOP and ENDLOOP or CHAIN and ENDCHAIN.

Hints

-   The statement CALL SUBSCREEN is required to [include](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) subscreens directly and to include them using [tabstrips](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm) or [splitter controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm).
-   An obsolete variant of this statement is [CALL CUSTOMER SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall_customer_subscreen.htm).

Variant 1   

CALL SUBSCREEN sub\_area INCLUDING prog dynnr.

Effect

PBO

This statement is used to include the [subscreen dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") of the program defined in prog and the dynpro number defined in dynnr in the [subscreen area](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry") sub\_area of the current dynpro, and processes its PBO flow logic at this point. After PBO processing of the subscreen dynpro, the flow logic of the current dynpro is continued after the CALL statement.

The area sub\_area must be specified directly. prog expects either a two-character data object from the current ABAP program or a text field literal. dynnr expects a data object of the type n and length 4 from the current ABAP program or a text field literal. An uncatchable exception is raised if the specified subscreen dynpro cannot be found. If no subscreen dynpro is included for PBO in a subscreen area, the area remains empty.

If the specified subscreen dynpro is not defined in the current ABAP program, the specified program is loaded into the [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry") and [LOAD-OF-PROGRAM](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapload-of-program.htm) is raised. If the object is a [function pool](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunction_pool_glosry.htm "Glossary Entry"), a new [additional program group](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadditional_prog_group_glosry.htm "Glossary Entry") is created. If the object is an [executable program](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexecutable_program_glosry.htm "Glossary Entry") or a [module pool](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodul_pool_glosry.htm "Glossary Entry"), the program is loaded to the [program group](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_group_glosry.htm "Glossary Entry") of the current program.

The flow logic of the subscreen dynpro calls the dialog modules of its own ABAP program and the global fields of its own program are transported to the subscreen dynpro. When a subscreen is being processed, sy-dynnr contains the dynpro number of the subscreen.

The GUI status and the current next dynpro cannot be changed in the dialog modules of the subscreen, and the statements SET *{* TITLEBAR *|* PF-STATUS *}* and *{* LEAVE *|* SET *}* SCREEN raise an uncatchable exception there.

Variant 2   

CALL SUBSCREEN sub\_area.

Effect

PAI

The statement calls the PAI flow logic of the [subscreen dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") included in the sub\_area [subscreen area](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry"). The subscreen dynpro must be included in the subscreen area for PBO (see variant 1). The same applies to the dialog modules called by the PAI flow logic as to the modules called by PBO. The data transport between the subscreen dynpro and its ABAP program is performed at the call, or is delayed when [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) statements are executed in the PAI flow logic of the subscreen logic.

Hints

-   If the use of subscreens means that the names of the displayed screen elements are not unique, multiple dynpro fields can be assigned to a global data object of the ABAP program, and, accordingly, multiple transports can be performed for PBO and PAI.
-   Since function codes from the subscreen dynpro are moved to the OK field of the including dynpro, it is advisable to give these function codes unique names.
-   Since the dynpro fields of subscreen dynpros are transported to the global data objects of the program in which the subscreen dynpros are defined, it must be ensured that the calling program is provided with this data when called externally. If reusable subscreen dynpros are to be defined, it is advisable to encapsulate them in function pools and to use function modules to enable the caller to set and use the global data.

Example

If a tabstrip control with untyped tabstrips and a subscreen area called SUB is defined on a dynpro, the associated dynpro flow logic can appear as follows. The statement CALL SUBSCREEN includes the subscreen dynpro of the same ABAP program whose number is in the ABAP data object dynnr in the subscreen area SUB. The associated programming section of the ABAP program is in the example for [CONTROLS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcontrols_tabstrip.htm).

PROCESS BEFORE OUTPUT.
  MODULE prepare\_tabstrip.
  CALL SUBSCREEN sub INCLUDING sy-repid dynnr.
PROCESS AFTER INPUT.
  CALL SUBSCREEN sub.
  MODULE handle\_user\_command.


### abentab_strip_control_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Subscreens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm) !Example(exa.gif 'Example') dynpro - Tabstrips with Scrolling in SAP GUI(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm"
abapFile: "abentab_strip_control_abexas.htm"
keywords: ["do", "if", "abentab", "strip", "control", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls

Continue
![Example](exa.gif "Example") [dynpro - Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling on the ABAP Server](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)
![Example](exa.gif "Example") [dynpro - Splitter Control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


### abendynpro_subscreen_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_subscreens. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. DATA: number1(4) TYPE n VALUE '0110', number2(4) TYPE n VALUE '0130', field(10) TYPE c, field1(10) TYPE c, field2(10) TYPE c. CALL SCREEN 100. MODULE status_100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MOD
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm"
abapFile: "abendynpro_subscreen_abexa.htm"
keywords: ["do", "if", "case", "try", "data", "abendynpro", "subscreen", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Subscreens

This example demonstrates how to include subscreens.

Source Code

REPORT demo\_dynpro\_subscreens.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
DATA: number1(4) TYPE n VALUE '0110',
      number2(4) TYPE n VALUE '0130',
      field(10) TYPE c, field1(10) TYPE c, field2(10) TYPE c.
CALL SCREEN 100.
MODULE status\_100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE fill\_0110 OUTPUT.
  field = 'Entry 1'(001).
ENDMODULE.
MODULE fill\_0120 OUTPUT.
  field = field1.
ENDMODULE.
MODULE fill\_0130 OUTPUT.
  field = 'Entry 2'(002).
ENDMODULE.
MODULE fill\_0140 OUTPUT.
  field = field2.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE save\_ok INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
ENDMODULE.
MODULE user\_command\_0110 INPUT.
  IF save\_ok = 'OK1'.
    number1 = '0120'.
    field1 = field.
    CLEAR field.
  ENDIF.
ENDMODULE.
MODULE user\_command\_0130 INPUT.
  IF save\_ok = 'OK2'.
    number2 = '0140'.
    field2 = field.
    CLEAR field.
  ENDIF.
ENDMODULE.
MODULE user\_command\_100 INPUT.
  CASE save\_ok.
    WHEN 'SUB1'.
      number1 = '0110'.
    WHEN 'SUB2'.
      number1 = '0120'.
      CLEAR field1.
    WHEN 'SUB3'.
      number2 = '0130'.
    WHEN 'SUB4'.
      number2 = '0140'.
      CLEAR field2.
  ENDCASE.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. Four pushbuttons with function codes "SUB1" to "SUB4" and two identically sized subscreen areas area1 and area2 have been created. In the same ABAP program, four subscreen dynpros 110 to 140 are defined. The input/output field of all four subscreen dynpro has the name field. The function codes of the pushbuttons on the subscreen dynpros 110 and 130 are OK1 and OK2. The dynpro flow logic for dynpro 100 is as follows:

PROCESS BEFORE OUTPUT.
  MODULE status\_100.
  CALL SUBSCREEN: area1 INCLUDING sy-repid number1,
                  area2 INCLUDING sy-repid number2.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE save\_ok.
  CALL SUBSCREEN: area1,
                  area2.
  MODULE user\_command\_100.

The dynpro flow logic of subscreen dynpros 110 and 130 is:

PROCESS BEFORE OUTPUT.
  MODULE fill\_0110*|*0130.
PROCESS AFTER INPUT.
  MODULE user\_command\_0110*|*0130.

The dynpro flow logic of subscreen dynpros 120 and 140 is:

PROCESS BEFORE OUTPUT.
  MODULE fill\_0120*|*0150.
PROCESS AFTER INPUT.

When the program is executed, a screen appears on which subscreens 110 and 130 are displayed. The pushbuttons on the main dynpro allow the user to choose between two subscreen dynpros for each screen area. The pushbuttons on the subscreen dynpros 110 and 130 allow data to be passed to the subscreen dynpros 120 and 140.

Since all subscreen dynpros use the same field name field, the identically named ABAP field is transported more than once at each PBO and PAI of the main dynpro. For this reason, the values must be stored in the auxiliary fields field1 and field2 in the ABAP program.

The function code of the pushbuttons of the subscreen dynpros is different and regular handling in an ABAP field is enough. If the function codes had the same names, it would be necessary to use multiple helper fields here as well.


### abentab_strip_control1_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_tabstrip_local. CONTROLS mytabstrip TYPE TABSTRIP. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. mytabstrip-activetab = 'PUSH2'. CALL SCREEN 100. MODULE status_0100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE cancel INPUT. LEAVE PROGRAM. ENDMODULE. MODULE us
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm"
abapFile: "abentab_strip_control1_abexa.htm"
keywords: ["do", "if", "data", "abentab", "strip", "control1", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Tabstrips with Scrolling in SAP GUI

This example demonstrates the use of tabstrip controls with local scrolling.

Source Code

REPORT demo\_dynpro\_tabstrip\_local.
CONTROLS mytabstrip TYPE TABSTRIP.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
mytabstrip-activetab = 'PUSH2'.
CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'OK'.
    MESSAGE i888(sabapdemos) WITH 'MYTABSTRIP-ACTIVETAB ='
                                  mytabstrip-activetab.
  ENDIF.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. It is a tabstrip page called mytabstrip created with three tabs, PUSH1, PUSH2, PUSH3 and identically named function codes of type p. One of the subscreen areas sub1 to sub3 is assigned to each tab title. The push button is called BUTTON and has the function code OK. Three subscreen dynpros 110 to 130 are also defined that fit into the above mentioned subscreen areas. The dynpro flow logic of subscreens 110 to 130 does not contain any module calls.

When the program is executed, the user sees a screen, the second tab page of which is active because before dynpro 100 is called, the component activetab of the structure mytabstrip is set to PUSH2. The user can scroll between the tab pages without raising the event PAI. One of the three subscreen dynpros is included on each tab page.

When the user chooses Continue, the PAI event is raised, and an information message displays the function code of the tab title of the page that is currently active.


### abentab_strip_control2_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_tabstrip_server. CONTROLS mytabstrip TYPE TABSTRIP. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. DATA  number TYPE sy-dynnr. mytabstrip-activetab = 'PUSH2'. number = '0120'. CALL SCREEN 100. MODULE status_0100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE can
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm"
abapFile: "abentab_strip_control2_abexa.htm"
keywords: ["do", "if", "case", "data", "abentab", "strip", "control2", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Tabstrips with Scrolling on the ABAP Server

This example demonstrates the use of tabstrip controls with centralized scrolling.

Source Code

REPORT demo\_dynpro\_tabstrip\_server.
CONTROLS mytabstrip TYPE TABSTRIP.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
DATA  number TYPE sy-dynnr.
mytabstrip-activetab = 'PUSH2'.
number = '0120'.
CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'OK'.
    MESSAGE i888(sabapdemos) WITH 'MYTABSTRIP-ACTIVETAB ='
                                  mytabstrip-activetab.
  ELSE.
    mytabstrip-activetab = save\_ok.
    CASE save\_ok.
      WHEN 'PUSH1'.
        number = '0110'.
      WHEN 'PUSH2'.
        number = '0120'.
      WHEN 'PUSH3'.
        number = '0130'.
    ENDCASE.
  ENDIF.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The layout of dynpro 100 and the subscreen dynpros 110 to 130 is the same as in the [executable example](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm) with local scrolling. The function codes of the three tab titles are not typed and a common subscreen area sub is assigned to all tab titles.

The dynpro flow logic of dynpro 100 makes a dynamic binding to PBO, a subscreen dynpro in the subscreen area sub. The dynpro flow logic of subscreen dynpros 110 to 130 does not contain any module calls.

This example works in exactly the same way as the [example with local scrolling](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm) except that scrolling between the tabstrip pages is programmed in the ABAP program. Each time the user chooses a tab title, the function code from the OK field is assigned to the activetab component of structure mytabstrip. At the same time, the variable number is given the dynpro number of the subscreen dynpro to be displayed in the subscreen area SUB of the tabstrip.


### abendynpro_splitter_control_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_splitter_control. DATA splitter TYPE REF TO cl_dynpro_splitter. START-OF-SELECTION. CREATE OBJECT splitter EXPORTING splitter_name = 'SPLITTER'. CALL SCREEN 100. MODULE set_status OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE set_sash OUTPUT. splitter->set_sash(
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm"
abapFile: "abendynpro_splitter_control_abexa.htm"
keywords: ["select", "do", "try", "data", "abendynpro", "splitter", "control", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Splitter Control

This example demonstrates a [splitter control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensplitter_control_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_dynpro\_splitter\_control.
DATA splitter TYPE REF TO cl\_dynpro\_splitter.
START-OF-SELECTION.
  CREATE OBJECT splitter
    EXPORTING
      splitter\_name = 'SPLITTER'.
  CALL SCREEN 100.
MODULE set\_status OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE set\_sash OUTPUT.
  splitter->set\_sash( ).
ENDMODULE.
MODULE cancel.
  LEAVE PROGRAM.
ENDMODULE.
MODULE get\_sash INPUT.
  splitter->get\_guisash( ).
ENDMODULE.

Description

A subscreen is assigned to both parts of the splitter control. The subscreens are called in the dynpro flow logic.


### abentab_strip_control_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Subscreens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm) !Example(exa.gif 'Example') dynpro - Tabstrips with Scrolling in SAP GUI(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm"
abapFile: "abentab_strip_control_abexas.htm"
keywords: ["do", "if", "abentab", "strip", "control", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls

Continue
![Example](exa.gif "Example") [dynpro - Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling on the ABAP Server](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)
![Example](exa.gif "Example") [dynpro - Splitter Control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Statements in the Dynpro Flow Logic / dynpro - FIELD

**Files**: 7 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Statements in the Dynpro Flow Logic / dynpro - Subscreens, Tabstrips, and Splitter Controls

Included pages: 11


### abendynp_subscreens.htm

---
title: "Continue"
description: |
  dynpro - Including Subscreens Directly(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) dynpro - Tabstrip Controls(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm) dynpro - Splitter Controls(https://help.sap.com/doc/abapdocu_75
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm"
abapFile: "abendynp_subscreens.htm"
keywords: ["do", "try", "abendynp", "subscreens"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) → 

dynpro - Subscreens, Tabstrips, and Splitter Controls

Subscreens are screen layouts of special subscreen dynpros that can be included in other dynpros. Subscreens are either included directly, or using special [controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontrol_glosry.htm "Glossary Entry").

-   [Including Subscreens Directly](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm)
-   [Tabstrip Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm)
-   [Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm)

Continue
[dynpro - Including Subscreens Directly](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm)
[dynpro - Tabstrip Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm)
[dynpro - Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm)
[dynpro - CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm)
[dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm)


### abendynp_subscreen.htm

---
title: "Hint"
description: |
  Subscreens dynpros are defined like regular dynpros in the Screen Painter(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_painter_glosry.htm 'Glossary Entry') and are flagged there as regular dynpros. Selection screens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm"
abapFile: "abendynp_subscreen.htm"
keywords: ["select", "do", "if", "try", "abendynp", "subscreen"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Including Subscreens Directly

The statement [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) can be used to include other screen layouts directly in the [screen layout](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_glosry.htm "Glossary Entry") of a [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") in the form of subscreens. Here, subscreen areas must first be defined in the screen layout of the current dynpro. Every subscreen area has a unique name and can be configured to support changes in screen size. If the latter is defined, each size change in the current GUI window raises the [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry") event.

Subscreens are the screen layouts of special [subscreen dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry"). When a subscreen is included, the flow logic of the subscreen dynpro is also included. Subscreens can also include other subscreens. Subscreens cannot have their own OK field. Instead, user actions on subscreens pass the function codes to the OK field of the including dynpro. In the PAI event block of a subscreen dynpro, a [MODULE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpmodule.htm) statement is never executed with the AT EXIT-COMMAND addition.

Hint

Subscreens dynpros are defined like regular dynpros in the [Screen Painter](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_painter_glosry.htm "Glossary Entry") and are flagged there as regular dynpros. [Selection screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_subscreen.htm) can also be defined as subscreens.

Executable Example

[Dynpros, Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)


### abendynp_tabstrip.htm

---
title: "Hint"
description: |
  If a tab title is selected when browsing in the SAP GUI, input checks are not made, and data is not transported to the ABAP program. The entries are all checked and the data of all subscreens transported only if a user action raises the PAI event. When browsing in the ABAP program, the input is chec
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm"
abapFile: "abendynp_tabstrip.htm"
keywords: ["select", "do", "if", "try", "data", "abendynp", "tabstrip"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Tabstrip Controls

A tabstrip control is a screen element that consists of multiple tab pages. Every tab page contains a single-line [tab title](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_title_glosry.htm "Glossary Entry") linked with a function code and which can be used to select the tab page by clicking it once. Under the tab title, a tab page consists of a subscreen area. Each tab title must have a subscreen area assigned to it, in which any subscreens can be displayed. There are two ways to do this:

-   Browsing in SAP GUI
    
    A separate subscreen area is assigned to each tab title and the function codes of the tab titles are defined with the function type "P". If the user selects a tab title, the event PAI is not raised. The associated subscreens are included once in each individual subscreen area by using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement of the flow logic. If the user selects a tab title, the SAP GUI browses to the associated tab page and displays its subscreen.
    
-   Browsing in ABAP Programs
    
    The same subscreen area is assigned to each tab title, and the function codes of the tab titles are defined without [typing](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentyping_glosry.htm "Glossary Entry"). If the user selects a tab title, the event PAI is raised. The associated subscreen is included dynamically using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement of the flow logic in the subscreen area each time the user browses. In the ABAP program, the associated tab page must be activated using [CONTROLS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcontrols.htm) and the correct subscreen dynpro for the subscreen area must be specified.
    

Hint

If a tab title is selected when browsing in the SAP GUI, input checks are not made, and data is not transported to the ABAP program. The entries are all checked and the data of all subscreens transported only if a user action raises the PAI event. When browsing in the ABAP program, the input is checked each time a tab title is selected, and the current tab page data is transported to the ABAP program of the subscreen dynpro.

Executable Examples

-   [Dynpros, Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
-   [Dynpros, Tabstrips with Scrolling in AS instance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)


### abendynp_splitter_control_spcl.htm

---
title: "Hints"
description: |
  -   A splitter control can only be created in the alphanumeric Screen Painter by using Edit → Create Element → Splitter Control. For this reason, it should only be used in cases when the functions offered are required on classic dynpros. SAPUI5(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm"
abapFile: "abendynp_splitter_control_spcl.htm"
keywords: ["do", "while", "if", "case", "try", "method", "class", "abendynp", "splitter", "control", "spcl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Splitter Controls

A splitter control is a screen element that divides the area it covers either horizontally into two adjacent [subscreen areas](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry") or vertically one above each other. The division is made by a sash. The horizontal or vertical position of the sash is specified statically in the definition of the splitter control. It can be set to PBO in the ABAP program and changed by the user while the screen layout is displayed.

[Subscreen dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") are included in both subscreen areas in exactly the same way as [direct inclusion](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement in the dynpro flow logic. Any subscreens can be included, particularly those that contain splitter controls again.

In ABAP programs, the position of the sash of a splitter controls is controlled using an instance of the CL\_DYNPRO\_SPLITTER class. If, before sending this screen layout, an object of this class is created and its constructor is given the name of a splitter control, this is bound to the splitter control and its methods can be used to set and read the position of the sash. The sash position is specified as a percentage and refers to the width or height of the splitter control. In the object, the position is represented by a private attribute. Important methods of the class are:

-   GET\_GUISASH
    
    At PAI sets the sash position of the object to the current value of the bound splitter control.
    
-   SET\_SASH
    
    If no value is passed to the POSITION parameter, the method sets the sash position of the bound splitter control at PBO to the value of the object. If a value is passed to the POSITION parameter, the method sets the attribute of the object and the sash position of the bound splitter control at PBO to this value. At PAI, only the attribute of the object is set.
    
-   GET\_SASH
    
    Returns the sash position of the bound splitter control at PBO and PAI.
    

A splitter control can have a [function code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunction_code_glosry.htm "Glossary Entry") assigned to it, which can be used to react to changes to the sash position made by the user in ABAP programs.

Hints

-   A splitter control can only be created in the alphanumeric Screen Painter by using Edit → Create Element → Splitter Control. For this reason, it should only be used in cases when the functions offered are required on classic dynpros. [SAPUI5](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensapui5_glosry.htm "Glossary Entry") or [Web Dynpro ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenweb_dynpro_glosry.htm "Glossary Entry") should be used for new developments instead of classic dynpros.
-   Splitter controls offer certain advantages over the corresponding [CFW](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencfw_glosry.htm "Glossary Entry") containers. One advantage is that they allow all screen elements of a classic dynpro to be displayed directly in a flexible frame. Another is that they have better performance than CFW controls. An example of intensive use of splitter controls is the flexible interface of the ABAP Debugger.

Executable Example

[Dynpros, Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


### dynpcall.htm

---
title: "Syntax"
description: |
  CALL SUBSCREEN sub_area INCLUDING prog dynnr. Variants: 1. CALL SUBSCREEN sub_area INCLUDING prog dynnr.(#!ABAP_VARIANT_1@1@) 2. CALL SUBSCREEN sub_area.(#!ABAP_VARIANT_2@2@) Effect Includes a subscreen(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_glosr
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm"
abapFile: "dynpcall.htm"
keywords: ["loop", "do", "if", "try", "catch", "data", "dynpcall"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - CALL SUBSCREEN

Syntax

CALL SUBSCREEN sub\_area *\[*INCLUDING prog dynnr*\]*.

Variants:

[1\. CALL SUBSCREEN sub\_area INCLUDING prog dynnr.](#!ABAP_VARIANT_1@1@)
[2\. CALL SUBSCREEN sub\_area.](#!ABAP_VARIANT_2@2@)

Effect

Includes a [subscreen](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_glosry.htm "Glossary Entry") in the [dynpro flow logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_flow_logic_glosry.htm "Glossary Entry"). There is one variant for the event [PBO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm "Glossary Entry") and one variant for the event [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry"). The statement CALL SUBSCREEN cannot be used between the statements LOOP and ENDLOOP or CHAIN and ENDCHAIN.

Hints

-   The statement CALL SUBSCREEN is required to [include](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) subscreens directly and to include them using [tabstrips](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm) or [splitter controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm).
-   An obsolete variant of this statement is [CALL CUSTOMER SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall_customer_subscreen.htm).

Variant 1   

CALL SUBSCREEN sub\_area INCLUDING prog dynnr.

Effect

PBO

This statement is used to include the [subscreen dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") of the program defined in prog and the dynpro number defined in dynnr in the [subscreen area](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry") sub\_area of the current dynpro, and processes its PBO flow logic at this point. After PBO processing of the subscreen dynpro, the flow logic of the current dynpro is continued after the CALL statement.

The area sub\_area must be specified directly. prog expects either a two-character data object from the current ABAP program or a text field literal. dynnr expects a data object of the type n and length 4 from the current ABAP program or a text field literal. An uncatchable exception is raised if the specified subscreen dynpro cannot be found. If no subscreen dynpro is included for PBO in a subscreen area, the area remains empty.

If the specified subscreen dynpro is not defined in the current ABAP program, the specified program is loaded into the [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry") and [LOAD-OF-PROGRAM](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapload-of-program.htm) is raised. If the object is a [function pool](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunction_pool_glosry.htm "Glossary Entry"), a new [additional program group](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadditional_prog_group_glosry.htm "Glossary Entry") is created. If the object is an [executable program](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexecutable_program_glosry.htm "Glossary Entry") or a [module pool](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodul_pool_glosry.htm "Glossary Entry"), the program is loaded to the [program group](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_group_glosry.htm "Glossary Entry") of the current program.

The flow logic of the subscreen dynpro calls the dialog modules of its own ABAP program and the global fields of its own program are transported to the subscreen dynpro. When a subscreen is being processed, sy-dynnr contains the dynpro number of the subscreen.

The GUI status and the current next dynpro cannot be changed in the dialog modules of the subscreen, and the statements SET *{* TITLEBAR *|* PF-STATUS *}* and *{* LEAVE *|* SET *}* SCREEN raise an uncatchable exception there.

Variant 2   

CALL SUBSCREEN sub\_area.

Effect

PAI

The statement calls the PAI flow logic of the [subscreen dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") included in the sub\_area [subscreen area](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry"). The subscreen dynpro must be included in the subscreen area for PBO (see variant 1). The same applies to the dialog modules called by the PAI flow logic as to the modules called by PBO. The data transport between the subscreen dynpro and its ABAP program is performed at the call, or is delayed when [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) statements are executed in the PAI flow logic of the subscreen logic.

Hints

-   If the use of subscreens means that the names of the displayed screen elements are not unique, multiple dynpro fields can be assigned to a global data object of the ABAP program, and, accordingly, multiple transports can be performed for PBO and PAI.
-   Since function codes from the subscreen dynpro are moved to the OK field of the including dynpro, it is advisable to give these function codes unique names.
-   Since the dynpro fields of subscreen dynpros are transported to the global data objects of the program in which the subscreen dynpros are defined, it must be ensured that the calling program is provided with this data when called externally. If reusable subscreen dynpros are to be defined, it is advisable to encapsulate them in function pools and to use function modules to enable the caller to set and use the global data.

Example

If a tabstrip control with untyped tabstrips and a subscreen area called SUB is defined on a dynpro, the associated dynpro flow logic can appear as follows. The statement CALL SUBSCREEN includes the subscreen dynpro of the same ABAP program whose number is in the ABAP data object dynnr in the subscreen area SUB. The associated programming section of the ABAP program is in the example for [CONTROLS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcontrols_tabstrip.htm).

PROCESS BEFORE OUTPUT.
  MODULE prepare\_tabstrip.
  CALL SUBSCREEN sub INCLUDING sy-repid dynnr.
PROCESS AFTER INPUT.
  CALL SUBSCREEN sub.
  MODULE handle\_user\_command.


### abentab_strip_control_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Subscreens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm) !Example(exa.gif 'Example') dynpro - Tabstrips with Scrolling in SAP GUI(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm"
abapFile: "abentab_strip_control_abexas.htm"
keywords: ["do", "if", "abentab", "strip", "control", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls

Continue
![Example](exa.gif "Example") [dynpro - Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling on the ABAP Server](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)
![Example](exa.gif "Example") [dynpro - Splitter Control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


### abendynpro_subscreen_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_subscreens. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. DATA: number1(4) TYPE n VALUE '0110', number2(4) TYPE n VALUE '0130', field(10) TYPE c, field1(10) TYPE c, field2(10) TYPE c. CALL SCREEN 100. MODULE status_100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MOD
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm"
abapFile: "abendynpro_subscreen_abexa.htm"
keywords: ["do", "if", "case", "try", "data", "abendynpro", "subscreen", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Subscreens

This example demonstrates how to include subscreens.

Source Code

REPORT demo\_dynpro\_subscreens.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
DATA: number1(4) TYPE n VALUE '0110',
      number2(4) TYPE n VALUE '0130',
      field(10) TYPE c, field1(10) TYPE c, field2(10) TYPE c.
CALL SCREEN 100.
MODULE status\_100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE fill\_0110 OUTPUT.
  field = 'Entry 1'(001).
ENDMODULE.
MODULE fill\_0120 OUTPUT.
  field = field1.
ENDMODULE.
MODULE fill\_0130 OUTPUT.
  field = 'Entry 2'(002).
ENDMODULE.
MODULE fill\_0140 OUTPUT.
  field = field2.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE save\_ok INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
ENDMODULE.
MODULE user\_command\_0110 INPUT.
  IF save\_ok = 'OK1'.
    number1 = '0120'.
    field1 = field.
    CLEAR field.
  ENDIF.
ENDMODULE.
MODULE user\_command\_0130 INPUT.
  IF save\_ok = 'OK2'.
    number2 = '0140'.
    field2 = field.
    CLEAR field.
  ENDIF.
ENDMODULE.
MODULE user\_command\_100 INPUT.
  CASE save\_ok.
    WHEN 'SUB1'.
      number1 = '0110'.
    WHEN 'SUB2'.
      number1 = '0120'.
      CLEAR field1.
    WHEN 'SUB3'.
      number2 = '0130'.
    WHEN 'SUB4'.
      number2 = '0140'.
      CLEAR field2.
  ENDCASE.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. Four pushbuttons with function codes "SUB1" to "SUB4" and two identically sized subscreen areas area1 and area2 have been created. In the same ABAP program, four subscreen dynpros 110 to 140 are defined. The input/output field of all four subscreen dynpro has the name field. The function codes of the pushbuttons on the subscreen dynpros 110 and 130 are OK1 and OK2. The dynpro flow logic for dynpro 100 is as follows:

PROCESS BEFORE OUTPUT.
  MODULE status\_100.
  CALL SUBSCREEN: area1 INCLUDING sy-repid number1,
                  area2 INCLUDING sy-repid number2.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE save\_ok.
  CALL SUBSCREEN: area1,
                  area2.
  MODULE user\_command\_100.

The dynpro flow logic of subscreen dynpros 110 and 130 is:

PROCESS BEFORE OUTPUT.
  MODULE fill\_0110*|*0130.
PROCESS AFTER INPUT.
  MODULE user\_command\_0110*|*0130.

The dynpro flow logic of subscreen dynpros 120 and 140 is:

PROCESS BEFORE OUTPUT.
  MODULE fill\_0120*|*0150.
PROCESS AFTER INPUT.

When the program is executed, a screen appears on which subscreens 110 and 130 are displayed. The pushbuttons on the main dynpro allow the user to choose between two subscreen dynpros for each screen area. The pushbuttons on the subscreen dynpros 110 and 130 allow data to be passed to the subscreen dynpros 120 and 140.

Since all subscreen dynpros use the same field name field, the identically named ABAP field is transported more than once at each PBO and PAI of the main dynpro. For this reason, the values must be stored in the auxiliary fields field1 and field2 in the ABAP program.

The function code of the pushbuttons of the subscreen dynpros is different and regular handling in an ABAP field is enough. If the function codes had the same names, it would be necessary to use multiple helper fields here as well.


### abentab_strip_control1_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_tabstrip_local. CONTROLS mytabstrip TYPE TABSTRIP. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. mytabstrip-activetab = 'PUSH2'. CALL SCREEN 100. MODULE status_0100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE cancel INPUT. LEAVE PROGRAM. ENDMODULE. MODULE us
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm"
abapFile: "abentab_strip_control1_abexa.htm"
keywords: ["do", "if", "data", "abentab", "strip", "control1", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Tabstrips with Scrolling in SAP GUI

This example demonstrates the use of tabstrip controls with local scrolling.

Source Code

REPORT demo\_dynpro\_tabstrip\_local.
CONTROLS mytabstrip TYPE TABSTRIP.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
mytabstrip-activetab = 'PUSH2'.
CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'OK'.
    MESSAGE i888(sabapdemos) WITH 'MYTABSTRIP-ACTIVETAB ='
                                  mytabstrip-activetab.
  ENDIF.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. It is a tabstrip page called mytabstrip created with three tabs, PUSH1, PUSH2, PUSH3 and identically named function codes of type p. One of the subscreen areas sub1 to sub3 is assigned to each tab title. The push button is called BUTTON and has the function code OK. Three subscreen dynpros 110 to 130 are also defined that fit into the above mentioned subscreen areas. The dynpro flow logic of subscreens 110 to 130 does not contain any module calls.

When the program is executed, the user sees a screen, the second tab page of which is active because before dynpro 100 is called, the component activetab of the structure mytabstrip is set to PUSH2. The user can scroll between the tab pages without raising the event PAI. One of the three subscreen dynpros is included on each tab page.

When the user chooses Continue, the PAI event is raised, and an information message displays the function code of the tab title of the page that is currently active.


### abentab_strip_control2_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_tabstrip_server. CONTROLS mytabstrip TYPE TABSTRIP. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. DATA  number TYPE sy-dynnr. mytabstrip-activetab = 'PUSH2'. number = '0120'. CALL SCREEN 100. MODULE status_0100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE can
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm"
abapFile: "abentab_strip_control2_abexa.htm"
keywords: ["do", "if", "case", "data", "abentab", "strip", "control2", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Tabstrips with Scrolling on the ABAP Server

This example demonstrates the use of tabstrip controls with centralized scrolling.

Source Code

REPORT demo\_dynpro\_tabstrip\_server.
CONTROLS mytabstrip TYPE TABSTRIP.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
DATA  number TYPE sy-dynnr.
mytabstrip-activetab = 'PUSH2'.
number = '0120'.
CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'OK'.
    MESSAGE i888(sabapdemos) WITH 'MYTABSTRIP-ACTIVETAB ='
                                  mytabstrip-activetab.
  ELSE.
    mytabstrip-activetab = save\_ok.
    CASE save\_ok.
      WHEN 'PUSH1'.
        number = '0110'.
      WHEN 'PUSH2'.
        number = '0120'.
      WHEN 'PUSH3'.
        number = '0130'.
    ENDCASE.
  ENDIF.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The layout of dynpro 100 and the subscreen dynpros 110 to 130 is the same as in the [executable example](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm) with local scrolling. The function codes of the three tab titles are not typed and a common subscreen area sub is assigned to all tab titles.

The dynpro flow logic of dynpro 100 makes a dynamic binding to PBO, a subscreen dynpro in the subscreen area sub. The dynpro flow logic of subscreen dynpros 110 to 130 does not contain any module calls.

This example works in exactly the same way as the [example with local scrolling](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm) except that scrolling between the tabstrip pages is programmed in the ABAP program. Each time the user chooses a tab title, the function code from the OK field is assigned to the activetab component of structure mytabstrip. At the same time, the variable number is given the dynpro number of the subscreen dynpro to be displayed in the subscreen area SUB of the tabstrip.


### abendynpro_splitter_control_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_splitter_control. DATA splitter TYPE REF TO cl_dynpro_splitter. START-OF-SELECTION. CREATE OBJECT splitter EXPORTING splitter_name = 'SPLITTER'. CALL SCREEN 100. MODULE set_status OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE set_sash OUTPUT. splitter->set_sash(
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm"
abapFile: "abendynpro_splitter_control_abexa.htm"
keywords: ["select", "do", "try", "data", "abendynpro", "splitter", "control", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Splitter Control

This example demonstrates a [splitter control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensplitter_control_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_dynpro\_splitter\_control.
DATA splitter TYPE REF TO cl\_dynpro\_splitter.
START-OF-SELECTION.
  CREATE OBJECT splitter
    EXPORTING
      splitter\_name = 'SPLITTER'.
  CALL SCREEN 100.
MODULE set\_status OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE set\_sash OUTPUT.
  splitter->set\_sash( ).
ENDMODULE.
MODULE cancel.
  LEAVE PROGRAM.
ENDMODULE.
MODULE get\_sash INPUT.
  splitter->get\_guisash( ).
ENDMODULE.

Description

A subscreen is assigned to both parts of the splitter control. The subscreens are called in the dynpro flow logic.


### abentab_strip_control_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Subscreens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm) !Example(exa.gif 'Example') dynpro - Tabstrips with Scrolling in SAP GUI(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm"
abapFile: "abentab_strip_control_abexas.htm"
keywords: ["do", "if", "abentab", "strip", "control", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls

Continue
![Example](exa.gif "Example") [dynpro - Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling on the ABAP Server](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)
![Example](exa.gif "Example") [dynpro - Splitter Control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Statements in the Dynpro Flow Logic / dynpro - CHAIN

**Files**: 2 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Statements in the Dynpro Flow Logic / dynpro - Subscreens, Tabstrips, and Splitter Controls

Included pages: 11


### abendynp_subscreens.htm

---
title: "Continue"
description: |
  dynpro - Including Subscreens Directly(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) dynpro - Tabstrip Controls(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm) dynpro - Splitter Controls(https://help.sap.com/doc/abapdocu_75
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm"
abapFile: "abendynp_subscreens.htm"
keywords: ["do", "try", "abendynp", "subscreens"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) → 

dynpro - Subscreens, Tabstrips, and Splitter Controls

Subscreens are screen layouts of special subscreen dynpros that can be included in other dynpros. Subscreens are either included directly, or using special [controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontrol_glosry.htm "Glossary Entry").

-   [Including Subscreens Directly](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm)
-   [Tabstrip Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm)
-   [Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm)

Continue
[dynpro - Including Subscreens Directly](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm)
[dynpro - Tabstrip Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm)
[dynpro - Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm)
[dynpro - CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm)
[dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm)


### abendynp_subscreen.htm

---
title: "Hint"
description: |
  Subscreens dynpros are defined like regular dynpros in the Screen Painter(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_painter_glosry.htm 'Glossary Entry') and are flagged there as regular dynpros. Selection screens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm"
abapFile: "abendynp_subscreen.htm"
keywords: ["select", "do", "if", "try", "abendynp", "subscreen"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Including Subscreens Directly

The statement [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) can be used to include other screen layouts directly in the [screen layout](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_glosry.htm "Glossary Entry") of a [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") in the form of subscreens. Here, subscreen areas must first be defined in the screen layout of the current dynpro. Every subscreen area has a unique name and can be configured to support changes in screen size. If the latter is defined, each size change in the current GUI window raises the [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry") event.

Subscreens are the screen layouts of special [subscreen dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry"). When a subscreen is included, the flow logic of the subscreen dynpro is also included. Subscreens can also include other subscreens. Subscreens cannot have their own OK field. Instead, user actions on subscreens pass the function codes to the OK field of the including dynpro. In the PAI event block of a subscreen dynpro, a [MODULE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpmodule.htm) statement is never executed with the AT EXIT-COMMAND addition.

Hint

Subscreens dynpros are defined like regular dynpros in the [Screen Painter](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_painter_glosry.htm "Glossary Entry") and are flagged there as regular dynpros. [Selection screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_subscreen.htm) can also be defined as subscreens.

Executable Example

[Dynpros, Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)


### abendynp_tabstrip.htm

---
title: "Hint"
description: |
  If a tab title is selected when browsing in the SAP GUI, input checks are not made, and data is not transported to the ABAP program. The entries are all checked and the data of all subscreens transported only if a user action raises the PAI event. When browsing in the ABAP program, the input is chec
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm"
abapFile: "abendynp_tabstrip.htm"
keywords: ["select", "do", "if", "try", "data", "abendynp", "tabstrip"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Tabstrip Controls

A tabstrip control is a screen element that consists of multiple tab pages. Every tab page contains a single-line [tab title](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_title_glosry.htm "Glossary Entry") linked with a function code and which can be used to select the tab page by clicking it once. Under the tab title, a tab page consists of a subscreen area. Each tab title must have a subscreen area assigned to it, in which any subscreens can be displayed. There are two ways to do this:

-   Browsing in SAP GUI
    
    A separate subscreen area is assigned to each tab title and the function codes of the tab titles are defined with the function type "P". If the user selects a tab title, the event PAI is not raised. The associated subscreens are included once in each individual subscreen area by using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement of the flow logic. If the user selects a tab title, the SAP GUI browses to the associated tab page and displays its subscreen.
    
-   Browsing in ABAP Programs
    
    The same subscreen area is assigned to each tab title, and the function codes of the tab titles are defined without [typing](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentyping_glosry.htm "Glossary Entry"). If the user selects a tab title, the event PAI is raised. The associated subscreen is included dynamically using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement of the flow logic in the subscreen area each time the user browses. In the ABAP program, the associated tab page must be activated using [CONTROLS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcontrols.htm) and the correct subscreen dynpro for the subscreen area must be specified.
    

Hint

If a tab title is selected when browsing in the SAP GUI, input checks are not made, and data is not transported to the ABAP program. The entries are all checked and the data of all subscreens transported only if a user action raises the PAI event. When browsing in the ABAP program, the input is checked each time a tab title is selected, and the current tab page data is transported to the ABAP program of the subscreen dynpro.

Executable Examples

-   [Dynpros, Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
-   [Dynpros, Tabstrips with Scrolling in AS instance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)


### abendynp_splitter_control_spcl.htm

---
title: "Hints"
description: |
  -   A splitter control can only be created in the alphanumeric Screen Painter by using Edit → Create Element → Splitter Control. For this reason, it should only be used in cases when the functions offered are required on classic dynpros. SAPUI5(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm"
abapFile: "abendynp_splitter_control_spcl.htm"
keywords: ["do", "while", "if", "case", "try", "method", "class", "abendynp", "splitter", "control", "spcl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Splitter Controls

A splitter control is a screen element that divides the area it covers either horizontally into two adjacent [subscreen areas](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry") or vertically one above each other. The division is made by a sash. The horizontal or vertical position of the sash is specified statically in the definition of the splitter control. It can be set to PBO in the ABAP program and changed by the user while the screen layout is displayed.

[Subscreen dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") are included in both subscreen areas in exactly the same way as [direct inclusion](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement in the dynpro flow logic. Any subscreens can be included, particularly those that contain splitter controls again.

In ABAP programs, the position of the sash of a splitter controls is controlled using an instance of the CL\_DYNPRO\_SPLITTER class. If, before sending this screen layout, an object of this class is created and its constructor is given the name of a splitter control, this is bound to the splitter control and its methods can be used to set and read the position of the sash. The sash position is specified as a percentage and refers to the width or height of the splitter control. In the object, the position is represented by a private attribute. Important methods of the class are:

-   GET\_GUISASH
    
    At PAI sets the sash position of the object to the current value of the bound splitter control.
    
-   SET\_SASH
    
    If no value is passed to the POSITION parameter, the method sets the sash position of the bound splitter control at PBO to the value of the object. If a value is passed to the POSITION parameter, the method sets the attribute of the object and the sash position of the bound splitter control at PBO to this value. At PAI, only the attribute of the object is set.
    
-   GET\_SASH
    
    Returns the sash position of the bound splitter control at PBO and PAI.
    

A splitter control can have a [function code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunction_code_glosry.htm "Glossary Entry") assigned to it, which can be used to react to changes to the sash position made by the user in ABAP programs.

Hints

-   A splitter control can only be created in the alphanumeric Screen Painter by using Edit → Create Element → Splitter Control. For this reason, it should only be used in cases when the functions offered are required on classic dynpros. [SAPUI5](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensapui5_glosry.htm "Glossary Entry") or [Web Dynpro ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenweb_dynpro_glosry.htm "Glossary Entry") should be used for new developments instead of classic dynpros.
-   Splitter controls offer certain advantages over the corresponding [CFW](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencfw_glosry.htm "Glossary Entry") containers. One advantage is that they allow all screen elements of a classic dynpro to be displayed directly in a flexible frame. Another is that they have better performance than CFW controls. An example of intensive use of splitter controls is the flexible interface of the ABAP Debugger.

Executable Example

[Dynpros, Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


### dynpcall.htm

---
title: "Syntax"
description: |
  CALL SUBSCREEN sub_area INCLUDING prog dynnr. Variants: 1. CALL SUBSCREEN sub_area INCLUDING prog dynnr.(#!ABAP_VARIANT_1@1@) 2. CALL SUBSCREEN sub_area.(#!ABAP_VARIANT_2@2@) Effect Includes a subscreen(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_glosr
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm"
abapFile: "dynpcall.htm"
keywords: ["loop", "do", "if", "try", "catch", "data", "dynpcall"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - CALL SUBSCREEN

Syntax

CALL SUBSCREEN sub\_area *\[*INCLUDING prog dynnr*\]*.

Variants:

[1\. CALL SUBSCREEN sub\_area INCLUDING prog dynnr.](#!ABAP_VARIANT_1@1@)
[2\. CALL SUBSCREEN sub\_area.](#!ABAP_VARIANT_2@2@)

Effect

Includes a [subscreen](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_glosry.htm "Glossary Entry") in the [dynpro flow logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_flow_logic_glosry.htm "Glossary Entry"). There is one variant for the event [PBO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm "Glossary Entry") and one variant for the event [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry"). The statement CALL SUBSCREEN cannot be used between the statements LOOP and ENDLOOP or CHAIN and ENDCHAIN.

Hints

-   The statement CALL SUBSCREEN is required to [include](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) subscreens directly and to include them using [tabstrips](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm) or [splitter controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm).
-   An obsolete variant of this statement is [CALL CUSTOMER SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall_customer_subscreen.htm).

Variant 1   

CALL SUBSCREEN sub\_area INCLUDING prog dynnr.

Effect

PBO

This statement is used to include the [subscreen dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") of the program defined in prog and the dynpro number defined in dynnr in the [subscreen area](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry") sub\_area of the current dynpro, and processes its PBO flow logic at this point. After PBO processing of the subscreen dynpro, the flow logic of the current dynpro is continued after the CALL statement.

The area sub\_area must be specified directly. prog expects either a two-character data object from the current ABAP program or a text field literal. dynnr expects a data object of the type n and length 4 from the current ABAP program or a text field literal. An uncatchable exception is raised if the specified subscreen dynpro cannot be found. If no subscreen dynpro is included for PBO in a subscreen area, the area remains empty.

If the specified subscreen dynpro is not defined in the current ABAP program, the specified program is loaded into the [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry") and [LOAD-OF-PROGRAM](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapload-of-program.htm) is raised. If the object is a [function pool](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunction_pool_glosry.htm "Glossary Entry"), a new [additional program group](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadditional_prog_group_glosry.htm "Glossary Entry") is created. If the object is an [executable program](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexecutable_program_glosry.htm "Glossary Entry") or a [module pool](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodul_pool_glosry.htm "Glossary Entry"), the program is loaded to the [program group](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_group_glosry.htm "Glossary Entry") of the current program.

The flow logic of the subscreen dynpro calls the dialog modules of its own ABAP program and the global fields of its own program are transported to the subscreen dynpro. When a subscreen is being processed, sy-dynnr contains the dynpro number of the subscreen.

The GUI status and the current next dynpro cannot be changed in the dialog modules of the subscreen, and the statements SET *{* TITLEBAR *|* PF-STATUS *}* and *{* LEAVE *|* SET *}* SCREEN raise an uncatchable exception there.

Variant 2   

CALL SUBSCREEN sub\_area.

Effect

PAI

The statement calls the PAI flow logic of the [subscreen dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") included in the sub\_area [subscreen area](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry"). The subscreen dynpro must be included in the subscreen area for PBO (see variant 1). The same applies to the dialog modules called by the PAI flow logic as to the modules called by PBO. The data transport between the subscreen dynpro and its ABAP program is performed at the call, or is delayed when [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) statements are executed in the PAI flow logic of the subscreen logic.

Hints

-   If the use of subscreens means that the names of the displayed screen elements are not unique, multiple dynpro fields can be assigned to a global data object of the ABAP program, and, accordingly, multiple transports can be performed for PBO and PAI.
-   Since function codes from the subscreen dynpro are moved to the OK field of the including dynpro, it is advisable to give these function codes unique names.
-   Since the dynpro fields of subscreen dynpros are transported to the global data objects of the program in which the subscreen dynpros are defined, it must be ensured that the calling program is provided with this data when called externally. If reusable subscreen dynpros are to be defined, it is advisable to encapsulate them in function pools and to use function modules to enable the caller to set and use the global data.

Example

If a tabstrip control with untyped tabstrips and a subscreen area called SUB is defined on a dynpro, the associated dynpro flow logic can appear as follows. The statement CALL SUBSCREEN includes the subscreen dynpro of the same ABAP program whose number is in the ABAP data object dynnr in the subscreen area SUB. The associated programming section of the ABAP program is in the example for [CONTROLS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcontrols_tabstrip.htm).

PROCESS BEFORE OUTPUT.
  MODULE prepare\_tabstrip.
  CALL SUBSCREEN sub INCLUDING sy-repid dynnr.
PROCESS AFTER INPUT.
  CALL SUBSCREEN sub.
  MODULE handle\_user\_command.


### abentab_strip_control_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Subscreens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm) !Example(exa.gif 'Example') dynpro - Tabstrips with Scrolling in SAP GUI(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm"
abapFile: "abentab_strip_control_abexas.htm"
keywords: ["do", "if", "abentab", "strip", "control", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls

Continue
![Example](exa.gif "Example") [dynpro - Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling on the ABAP Server](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)
![Example](exa.gif "Example") [dynpro - Splitter Control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


### abendynpro_subscreen_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_subscreens. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. DATA: number1(4) TYPE n VALUE '0110', number2(4) TYPE n VALUE '0130', field(10) TYPE c, field1(10) TYPE c, field2(10) TYPE c. CALL SCREEN 100. MODULE status_100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MOD
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm"
abapFile: "abendynpro_subscreen_abexa.htm"
keywords: ["do", "if", "case", "try", "data", "abendynpro", "subscreen", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Subscreens

This example demonstrates how to include subscreens.

Source Code

REPORT demo\_dynpro\_subscreens.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
DATA: number1(4) TYPE n VALUE '0110',
      number2(4) TYPE n VALUE '0130',
      field(10) TYPE c, field1(10) TYPE c, field2(10) TYPE c.
CALL SCREEN 100.
MODULE status\_100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE fill\_0110 OUTPUT.
  field = 'Entry 1'(001).
ENDMODULE.
MODULE fill\_0120 OUTPUT.
  field = field1.
ENDMODULE.
MODULE fill\_0130 OUTPUT.
  field = 'Entry 2'(002).
ENDMODULE.
MODULE fill\_0140 OUTPUT.
  field = field2.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE save\_ok INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
ENDMODULE.
MODULE user\_command\_0110 INPUT.
  IF save\_ok = 'OK1'.
    number1 = '0120'.
    field1 = field.
    CLEAR field.
  ENDIF.
ENDMODULE.
MODULE user\_command\_0130 INPUT.
  IF save\_ok = 'OK2'.
    number2 = '0140'.
    field2 = field.
    CLEAR field.
  ENDIF.
ENDMODULE.
MODULE user\_command\_100 INPUT.
  CASE save\_ok.
    WHEN 'SUB1'.
      number1 = '0110'.
    WHEN 'SUB2'.
      number1 = '0120'.
      CLEAR field1.
    WHEN 'SUB3'.
      number2 = '0130'.
    WHEN 'SUB4'.
      number2 = '0140'.
      CLEAR field2.
  ENDCASE.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. Four pushbuttons with function codes "SUB1" to "SUB4" and two identically sized subscreen areas area1 and area2 have been created. In the same ABAP program, four subscreen dynpros 110 to 140 are defined. The input/output field of all four subscreen dynpro has the name field. The function codes of the pushbuttons on the subscreen dynpros 110 and 130 are OK1 and OK2. The dynpro flow logic for dynpro 100 is as follows:

PROCESS BEFORE OUTPUT.
  MODULE status\_100.
  CALL SUBSCREEN: area1 INCLUDING sy-repid number1,
                  area2 INCLUDING sy-repid number2.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE save\_ok.
  CALL SUBSCREEN: area1,
                  area2.
  MODULE user\_command\_100.

The dynpro flow logic of subscreen dynpros 110 and 130 is:

PROCESS BEFORE OUTPUT.
  MODULE fill\_0110*|*0130.
PROCESS AFTER INPUT.
  MODULE user\_command\_0110*|*0130.

The dynpro flow logic of subscreen dynpros 120 and 140 is:

PROCESS BEFORE OUTPUT.
  MODULE fill\_0120*|*0150.
PROCESS AFTER INPUT.

When the program is executed, a screen appears on which subscreens 110 and 130 are displayed. The pushbuttons on the main dynpro allow the user to choose between two subscreen dynpros for each screen area. The pushbuttons on the subscreen dynpros 110 and 130 allow data to be passed to the subscreen dynpros 120 and 140.

Since all subscreen dynpros use the same field name field, the identically named ABAP field is transported more than once at each PBO and PAI of the main dynpro. For this reason, the values must be stored in the auxiliary fields field1 and field2 in the ABAP program.

The function code of the pushbuttons of the subscreen dynpros is different and regular handling in an ABAP field is enough. If the function codes had the same names, it would be necessary to use multiple helper fields here as well.


### abentab_strip_control1_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_tabstrip_local. CONTROLS mytabstrip TYPE TABSTRIP. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. mytabstrip-activetab = 'PUSH2'. CALL SCREEN 100. MODULE status_0100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE cancel INPUT. LEAVE PROGRAM. ENDMODULE. MODULE us
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm"
abapFile: "abentab_strip_control1_abexa.htm"
keywords: ["do", "if", "data", "abentab", "strip", "control1", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Tabstrips with Scrolling in SAP GUI

This example demonstrates the use of tabstrip controls with local scrolling.

Source Code

REPORT demo\_dynpro\_tabstrip\_local.
CONTROLS mytabstrip TYPE TABSTRIP.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
mytabstrip-activetab = 'PUSH2'.
CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'OK'.
    MESSAGE i888(sabapdemos) WITH 'MYTABSTRIP-ACTIVETAB ='
                                  mytabstrip-activetab.
  ENDIF.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. It is a tabstrip page called mytabstrip created with three tabs, PUSH1, PUSH2, PUSH3 and identically named function codes of type p. One of the subscreen areas sub1 to sub3 is assigned to each tab title. The push button is called BUTTON and has the function code OK. Three subscreen dynpros 110 to 130 are also defined that fit into the above mentioned subscreen areas. The dynpro flow logic of subscreens 110 to 130 does not contain any module calls.

When the program is executed, the user sees a screen, the second tab page of which is active because before dynpro 100 is called, the component activetab of the structure mytabstrip is set to PUSH2. The user can scroll between the tab pages without raising the event PAI. One of the three subscreen dynpros is included on each tab page.

When the user chooses Continue, the PAI event is raised, and an information message displays the function code of the tab title of the page that is currently active.


### abentab_strip_control2_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_tabstrip_server. CONTROLS mytabstrip TYPE TABSTRIP. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. DATA  number TYPE sy-dynnr. mytabstrip-activetab = 'PUSH2'. number = '0120'. CALL SCREEN 100. MODULE status_0100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE can
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm"
abapFile: "abentab_strip_control2_abexa.htm"
keywords: ["do", "if", "case", "data", "abentab", "strip", "control2", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Tabstrips with Scrolling on the ABAP Server

This example demonstrates the use of tabstrip controls with centralized scrolling.

Source Code

REPORT demo\_dynpro\_tabstrip\_server.
CONTROLS mytabstrip TYPE TABSTRIP.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
DATA  number TYPE sy-dynnr.
mytabstrip-activetab = 'PUSH2'.
number = '0120'.
CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'OK'.
    MESSAGE i888(sabapdemos) WITH 'MYTABSTRIP-ACTIVETAB ='
                                  mytabstrip-activetab.
  ELSE.
    mytabstrip-activetab = save\_ok.
    CASE save\_ok.
      WHEN 'PUSH1'.
        number = '0110'.
      WHEN 'PUSH2'.
        number = '0120'.
      WHEN 'PUSH3'.
        number = '0130'.
    ENDCASE.
  ENDIF.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The layout of dynpro 100 and the subscreen dynpros 110 to 130 is the same as in the [executable example](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm) with local scrolling. The function codes of the three tab titles are not typed and a common subscreen area sub is assigned to all tab titles.

The dynpro flow logic of dynpro 100 makes a dynamic binding to PBO, a subscreen dynpro in the subscreen area sub. The dynpro flow logic of subscreen dynpros 110 to 130 does not contain any module calls.

This example works in exactly the same way as the [example with local scrolling](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm) except that scrolling between the tabstrip pages is programmed in the ABAP program. Each time the user chooses a tab title, the function code from the OK field is assigned to the activetab component of structure mytabstrip. At the same time, the variable number is given the dynpro number of the subscreen dynpro to be displayed in the subscreen area SUB of the tabstrip.


### abendynpro_splitter_control_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_splitter_control. DATA splitter TYPE REF TO cl_dynpro_splitter. START-OF-SELECTION. CREATE OBJECT splitter EXPORTING splitter_name = 'SPLITTER'. CALL SCREEN 100. MODULE set_status OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE set_sash OUTPUT. splitter->set_sash(
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm"
abapFile: "abendynpro_splitter_control_abexa.htm"
keywords: ["select", "do", "try", "data", "abendynpro", "splitter", "control", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Splitter Control

This example demonstrates a [splitter control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensplitter_control_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_dynpro\_splitter\_control.
DATA splitter TYPE REF TO cl\_dynpro\_splitter.
START-OF-SELECTION.
  CREATE OBJECT splitter
    EXPORTING
      splitter\_name = 'SPLITTER'.
  CALL SCREEN 100.
MODULE set\_status OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE set\_sash OUTPUT.
  splitter->set\_sash( ).
ENDMODULE.
MODULE cancel.
  LEAVE PROGRAM.
ENDMODULE.
MODULE get\_sash INPUT.
  splitter->get\_guisash( ).
ENDMODULE.

Description

A subscreen is assigned to both parts of the splitter control. The subscreens are called in the dynpro flow logic.


### abentab_strip_control_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Subscreens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm) !Example(exa.gif 'Example') dynpro - Tabstrips with Scrolling in SAP GUI(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm"
abapFile: "abentab_strip_control_abexas.htm"
keywords: ["do", "if", "abentab", "strip", "control", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls

Continue
![Example](exa.gif "Example") [dynpro - Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling on the ABAP Server](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)
![Example](exa.gif "Example") [dynpro - Splitter Control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Statements in the Dynpro Flow Logic / dynpro - Subscreens, Tabstrips, and Splitter Controls

**Files**: 11 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - Statements in the Dynpro Flow Logic / dynpro - Subscreens, Tabstrips, and Splitter Controls

Included pages: 11


### abendynp_subscreens.htm

---
title: "Continue"
description: |
  dynpro - Including Subscreens Directly(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) dynpro - Tabstrip Controls(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm) dynpro - Splitter Controls(https://help.sap.com/doc/abapdocu_75
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm"
abapFile: "abendynp_subscreens.htm"
keywords: ["do", "try", "abendynp", "subscreens"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) → 

dynpro - Subscreens, Tabstrips, and Splitter Controls

Subscreens are screen layouts of special subscreen dynpros that can be included in other dynpros. Subscreens are either included directly, or using special [controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontrol_glosry.htm "Glossary Entry").

-   [Including Subscreens Directly](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm)
-   [Tabstrip Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm)
-   [Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm)

Continue
[dynpro - Including Subscreens Directly](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm)
[dynpro - Tabstrip Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm)
[dynpro - Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm)
[dynpro - CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm)
[dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm)


### abendynp_subscreen.htm

---
title: "Hint"
description: |
  Subscreens dynpros are defined like regular dynpros in the Screen Painter(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_painter_glosry.htm 'Glossary Entry') and are flagged there as regular dynpros. Selection screens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm"
abapFile: "abendynp_subscreen.htm"
keywords: ["select", "do", "if", "try", "abendynp", "subscreen"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Including Subscreens Directly

The statement [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) can be used to include other screen layouts directly in the [screen layout](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_glosry.htm "Glossary Entry") of a [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") in the form of subscreens. Here, subscreen areas must first be defined in the screen layout of the current dynpro. Every subscreen area has a unique name and can be configured to support changes in screen size. If the latter is defined, each size change in the current GUI window raises the [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry") event.

Subscreens are the screen layouts of special [subscreen dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry"). When a subscreen is included, the flow logic of the subscreen dynpro is also included. Subscreens can also include other subscreens. Subscreens cannot have their own OK field. Instead, user actions on subscreens pass the function codes to the OK field of the including dynpro. In the PAI event block of a subscreen dynpro, a [MODULE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpmodule.htm) statement is never executed with the AT EXIT-COMMAND addition.

Hint

Subscreens dynpros are defined like regular dynpros in the [Screen Painter](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_painter_glosry.htm "Glossary Entry") and are flagged there as regular dynpros. [Selection screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_subscreen.htm) can also be defined as subscreens.

Executable Example

[Dynpros, Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)


### abendynp_tabstrip.htm

---
title: "Hint"
description: |
  If a tab title is selected when browsing in the SAP GUI, input checks are not made, and data is not transported to the ABAP program. The entries are all checked and the data of all subscreens transported only if a user action raises the PAI event. When browsing in the ABAP program, the input is chec
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm"
abapFile: "abendynp_tabstrip.htm"
keywords: ["select", "do", "if", "try", "data", "abendynp", "tabstrip"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Tabstrip Controls

A tabstrip control is a screen element that consists of multiple tab pages. Every tab page contains a single-line [tab title](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_title_glosry.htm "Glossary Entry") linked with a function code and which can be used to select the tab page by clicking it once. Under the tab title, a tab page consists of a subscreen area. Each tab title must have a subscreen area assigned to it, in which any subscreens can be displayed. There are two ways to do this:

-   Browsing in SAP GUI
    
    A separate subscreen area is assigned to each tab title and the function codes of the tab titles are defined with the function type "P". If the user selects a tab title, the event PAI is not raised. The associated subscreens are included once in each individual subscreen area by using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement of the flow logic. If the user selects a tab title, the SAP GUI browses to the associated tab page and displays its subscreen.
    
-   Browsing in ABAP Programs
    
    The same subscreen area is assigned to each tab title, and the function codes of the tab titles are defined without [typing](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentyping_glosry.htm "Glossary Entry"). If the user selects a tab title, the event PAI is raised. The associated subscreen is included dynamically using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement of the flow logic in the subscreen area each time the user browses. In the ABAP program, the associated tab page must be activated using [CONTROLS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcontrols.htm) and the correct subscreen dynpro for the subscreen area must be specified.
    

Hint

If a tab title is selected when browsing in the SAP GUI, input checks are not made, and data is not transported to the ABAP program. The entries are all checked and the data of all subscreens transported only if a user action raises the PAI event. When browsing in the ABAP program, the input is checked each time a tab title is selected, and the current tab page data is transported to the ABAP program of the subscreen dynpro.

Executable Examples

-   [Dynpros, Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
-   [Dynpros, Tabstrips with Scrolling in AS instance](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)


### abendynp_splitter_control_spcl.htm

---
title: "Hints"
description: |
  -   A splitter control can only be created in the alphanumeric Screen Painter by using Edit → Create Element → Splitter Control. For this reason, it should only be used in cases when the functions offered are required on classic dynpros. SAPUI5(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm"
abapFile: "abendynp_splitter_control_spcl.htm"
keywords: ["do", "while", "if", "case", "try", "method", "class", "abendynp", "splitter", "control", "spcl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Splitter Controls

A splitter control is a screen element that divides the area it covers either horizontally into two adjacent [subscreen areas](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry") or vertically one above each other. The division is made by a sash. The horizontal or vertical position of the sash is specified statically in the definition of the splitter control. It can be set to PBO in the ABAP program and changed by the user while the screen layout is displayed.

[Subscreen dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") are included in both subscreen areas in exactly the same way as [direct inclusion](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) using the [CALL SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm) statement in the dynpro flow logic. Any subscreens can be included, particularly those that contain splitter controls again.

In ABAP programs, the position of the sash of a splitter controls is controlled using an instance of the CL\_DYNPRO\_SPLITTER class. If, before sending this screen layout, an object of this class is created and its constructor is given the name of a splitter control, this is bound to the splitter control and its methods can be used to set and read the position of the sash. The sash position is specified as a percentage and refers to the width or height of the splitter control. In the object, the position is represented by a private attribute. Important methods of the class are:

-   GET\_GUISASH
    
    At PAI sets the sash position of the object to the current value of the bound splitter control.
    
-   SET\_SASH
    
    If no value is passed to the POSITION parameter, the method sets the sash position of the bound splitter control at PBO to the value of the object. If a value is passed to the POSITION parameter, the method sets the attribute of the object and the sash position of the bound splitter control at PBO to this value. At PAI, only the attribute of the object is set.
    
-   GET\_SASH
    
    Returns the sash position of the bound splitter control at PBO and PAI.
    

A splitter control can have a [function code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunction_code_glosry.htm "Glossary Entry") assigned to it, which can be used to react to changes to the sash position made by the user in ABAP programs.

Hints

-   A splitter control can only be created in the alphanumeric Screen Painter by using Edit → Create Element → Splitter Control. For this reason, it should only be used in cases when the functions offered are required on classic dynpros. [SAPUI5](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensapui5_glosry.htm "Glossary Entry") or [Web Dynpro ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenweb_dynpro_glosry.htm "Glossary Entry") should be used for new developments instead of classic dynpros.
-   Splitter controls offer certain advantages over the corresponding [CFW](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencfw_glosry.htm "Glossary Entry") containers. One advantage is that they allow all screen elements of a classic dynpro to be displayed directly in a flexible frame. Another is that they have better performance than CFW controls. An example of intensive use of splitter controls is the flexible interface of the ABAP Debugger.

Executable Example

[Dynpros, Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


### dynpcall.htm

---
title: "Syntax"
description: |
  CALL SUBSCREEN sub_area INCLUDING prog dynnr. Variants: 1. CALL SUBSCREEN sub_area INCLUDING prog dynnr.(#!ABAP_VARIANT_1@1@) 2. CALL SUBSCREEN sub_area.(#!ABAP_VARIANT_2@2@) Effect Includes a subscreen(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_glosr
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall.htm"
abapFile: "dynpcall.htm"
keywords: ["loop", "do", "if", "try", "catch", "data", "dynpcall"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - CALL SUBSCREEN

Syntax

CALL SUBSCREEN sub\_area *\[*INCLUDING prog dynnr*\]*.

Variants:

[1\. CALL SUBSCREEN sub\_area INCLUDING prog dynnr.](#!ABAP_VARIANT_1@1@)
[2\. CALL SUBSCREEN sub\_area.](#!ABAP_VARIANT_2@2@)

Effect

Includes a [subscreen](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_glosry.htm "Glossary Entry") in the [dynpro flow logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_flow_logic_glosry.htm "Glossary Entry"). There is one variant for the event [PBO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm "Glossary Entry") and one variant for the event [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry"). The statement CALL SUBSCREEN cannot be used between the statements LOOP and ENDLOOP or CHAIN and ENDCHAIN.

Hints

-   The statement CALL SUBSCREEN is required to [include](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreen.htm) subscreens directly and to include them using [tabstrips](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_tabstrip.htm) or [splitter controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_splitter_control_spcl.htm).
-   An obsolete variant of this statement is [CALL CUSTOMER SUBSCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpcall_customer_subscreen.htm).

Variant 1   

CALL SUBSCREEN sub\_area INCLUDING prog dynnr.

Effect

PBO

This statement is used to include the [subscreen dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") of the program defined in prog and the dynpro number defined in dynnr in the [subscreen area](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry") sub\_area of the current dynpro, and processes its PBO flow logic at this point. After PBO processing of the subscreen dynpro, the flow logic of the current dynpro is continued after the CALL statement.

The area sub\_area must be specified directly. prog expects either a two-character data object from the current ABAP program or a text field literal. dynnr expects a data object of the type n and length 4 from the current ABAP program or a text field literal. An uncatchable exception is raised if the specified subscreen dynpro cannot be found. If no subscreen dynpro is included for PBO in a subscreen area, the area remains empty.

If the specified subscreen dynpro is not defined in the current ABAP program, the specified program is loaded into the [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry") and [LOAD-OF-PROGRAM](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapload-of-program.htm) is raised. If the object is a [function pool](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunction_pool_glosry.htm "Glossary Entry"), a new [additional program group](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadditional_prog_group_glosry.htm "Glossary Entry") is created. If the object is an [executable program](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexecutable_program_glosry.htm "Glossary Entry") or a [module pool](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodul_pool_glosry.htm "Glossary Entry"), the program is loaded to the [program group](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_group_glosry.htm "Glossary Entry") of the current program.

The flow logic of the subscreen dynpro calls the dialog modules of its own ABAP program and the global fields of its own program are transported to the subscreen dynpro. When a subscreen is being processed, sy-dynnr contains the dynpro number of the subscreen.

The GUI status and the current next dynpro cannot be changed in the dialog modules of the subscreen, and the statements SET *{* TITLEBAR *|* PF-STATUS *}* and *{* LEAVE *|* SET *}* SCREEN raise an uncatchable exception there.

Variant 2   

CALL SUBSCREEN sub\_area.

Effect

PAI

The statement calls the PAI flow logic of the [subscreen dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_dynpro_glosry.htm "Glossary Entry") included in the sub\_area [subscreen area](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensubscreen_arrea_glosry.htm "Glossary Entry"). The subscreen dynpro must be included in the subscreen area for PBO (see variant 1). The same applies to the dialog modules called by the PAI flow logic as to the modules called by PBO. The data transport between the subscreen dynpro and its ABAP program is performed at the call, or is delayed when [FIELD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/dynpfield.htm) statements are executed in the PAI flow logic of the subscreen logic.

Hints

-   If the use of subscreens means that the names of the displayed screen elements are not unique, multiple dynpro fields can be assigned to a global data object of the ABAP program, and, accordingly, multiple transports can be performed for PBO and PAI.
-   Since function codes from the subscreen dynpro are moved to the OK field of the including dynpro, it is advisable to give these function codes unique names.
-   Since the dynpro fields of subscreen dynpros are transported to the global data objects of the program in which the subscreen dynpros are defined, it must be ensured that the calling program is provided with this data when called externally. If reusable subscreen dynpros are to be defined, it is advisable to encapsulate them in function pools and to use function modules to enable the caller to set and use the global data.

Example

If a tabstrip control with untyped tabstrips and a subscreen area called SUB is defined on a dynpro, the associated dynpro flow logic can appear as follows. The statement CALL SUBSCREEN includes the subscreen dynpro of the same ABAP program whose number is in the ABAP data object dynnr in the subscreen area SUB. The associated programming section of the ABAP program is in the example for [CONTROLS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcontrols_tabstrip.htm).

PROCESS BEFORE OUTPUT.
  MODULE prepare\_tabstrip.
  CALL SUBSCREEN sub INCLUDING sy-repid dynnr.
PROCESS AFTER INPUT.
  CALL SUBSCREEN sub.
  MODULE handle\_user\_command.


### abentab_strip_control_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Subscreens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm) !Example(exa.gif 'Example') dynpro - Tabstrips with Scrolling in SAP GUI(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm"
abapFile: "abentab_strip_control_abexas.htm"
keywords: ["do", "if", "abentab", "strip", "control", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls

Continue
![Example](exa.gif "Example") [dynpro - Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling on the ABAP Server](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)
![Example](exa.gif "Example") [dynpro - Splitter Control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


### abendynpro_subscreen_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_subscreens. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. DATA: number1(4) TYPE n VALUE '0110', number2(4) TYPE n VALUE '0130', field(10) TYPE c, field1(10) TYPE c, field2(10) TYPE c. CALL SCREEN 100. MODULE status_100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MOD
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm"
abapFile: "abendynpro_subscreen_abexa.htm"
keywords: ["do", "if", "case", "try", "data", "abendynpro", "subscreen", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Subscreens

This example demonstrates how to include subscreens.

Source Code

REPORT demo\_dynpro\_subscreens.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
DATA: number1(4) TYPE n VALUE '0110',
      number2(4) TYPE n VALUE '0130',
      field(10) TYPE c, field1(10) TYPE c, field2(10) TYPE c.
CALL SCREEN 100.
MODULE status\_100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE fill\_0110 OUTPUT.
  field = 'Entry 1'(001).
ENDMODULE.
MODULE fill\_0120 OUTPUT.
  field = field1.
ENDMODULE.
MODULE fill\_0130 OUTPUT.
  field = 'Entry 2'(002).
ENDMODULE.
MODULE fill\_0140 OUTPUT.
  field = field2.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE save\_ok INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
ENDMODULE.
MODULE user\_command\_0110 INPUT.
  IF save\_ok = 'OK1'.
    number1 = '0120'.
    field1 = field.
    CLEAR field.
  ENDIF.
ENDMODULE.
MODULE user\_command\_0130 INPUT.
  IF save\_ok = 'OK2'.
    number2 = '0140'.
    field2 = field.
    CLEAR field.
  ENDIF.
ENDMODULE.
MODULE user\_command\_100 INPUT.
  CASE save\_ok.
    WHEN 'SUB1'.
      number1 = '0110'.
    WHEN 'SUB2'.
      number1 = '0120'.
      CLEAR field1.
    WHEN 'SUB3'.
      number2 = '0130'.
    WHEN 'SUB4'.
      number2 = '0140'.
      CLEAR field2.
  ENDCASE.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. Four pushbuttons with function codes "SUB1" to "SUB4" and two identically sized subscreen areas area1 and area2 have been created. In the same ABAP program, four subscreen dynpros 110 to 140 are defined. The input/output field of all four subscreen dynpro has the name field. The function codes of the pushbuttons on the subscreen dynpros 110 and 130 are OK1 and OK2. The dynpro flow logic for dynpro 100 is as follows:

PROCESS BEFORE OUTPUT.
  MODULE status\_100.
  CALL SUBSCREEN: area1 INCLUDING sy-repid number1,
                  area2 INCLUDING sy-repid number2.
PROCESS AFTER INPUT.
  MODULE cancel AT EXIT-COMMAND.
  MODULE save\_ok.
  CALL SUBSCREEN: area1,
                  area2.
  MODULE user\_command\_100.

The dynpro flow logic of subscreen dynpros 110 and 130 is:

PROCESS BEFORE OUTPUT.
  MODULE fill\_0110*|*0130.
PROCESS AFTER INPUT.
  MODULE user\_command\_0110*|*0130.

The dynpro flow logic of subscreen dynpros 120 and 140 is:

PROCESS BEFORE OUTPUT.
  MODULE fill\_0120*|*0150.
PROCESS AFTER INPUT.

When the program is executed, a screen appears on which subscreens 110 and 130 are displayed. The pushbuttons on the main dynpro allow the user to choose between two subscreen dynpros for each screen area. The pushbuttons on the subscreen dynpros 110 and 130 allow data to be passed to the subscreen dynpros 120 and 140.

Since all subscreen dynpros use the same field name field, the identically named ABAP field is transported more than once at each PBO and PAI of the main dynpro. For this reason, the values must be stored in the auxiliary fields field1 and field2 in the ABAP program.

The function code of the pushbuttons of the subscreen dynpros is different and regular handling in an ABAP field is enough. If the function codes had the same names, it would be necessary to use multiple helper fields here as well.


### abentab_strip_control1_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_tabstrip_local. CONTROLS mytabstrip TYPE TABSTRIP. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. mytabstrip-activetab = 'PUSH2'. CALL SCREEN 100. MODULE status_0100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE cancel INPUT. LEAVE PROGRAM. ENDMODULE. MODULE us
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm"
abapFile: "abentab_strip_control1_abexa.htm"
keywords: ["do", "if", "data", "abentab", "strip", "control1", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Tabstrips with Scrolling in SAP GUI

This example demonstrates the use of tabstrip controls with local scrolling.

Source Code

REPORT demo\_dynpro\_tabstrip\_local.
CONTROLS mytabstrip TYPE TABSTRIP.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
mytabstrip-activetab = 'PUSH2'.
CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'OK'.
    MESSAGE i888(sabapdemos) WITH 'MYTABSTRIP-ACTIVETAB ='
                                  mytabstrip-activetab.
  ENDIF.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. It is a tabstrip page called mytabstrip created with three tabs, PUSH1, PUSH2, PUSH3 and identically named function codes of type p. One of the subscreen areas sub1 to sub3 is assigned to each tab title. The push button is called BUTTON and has the function code OK. Three subscreen dynpros 110 to 130 are also defined that fit into the above mentioned subscreen areas. The dynpro flow logic of subscreens 110 to 130 does not contain any module calls.

When the program is executed, the user sees a screen, the second tab page of which is active because before dynpro 100 is called, the component activetab of the structure mytabstrip is set to PUSH2. The user can scroll between the tab pages without raising the event PAI. One of the three subscreen dynpros is included on each tab page.

When the user chooses Continue, the PAI event is raised, and an information message displays the function code of the tab title of the page that is currently active.


### abentab_strip_control2_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_tabstrip_server. CONTROLS mytabstrip TYPE TABSTRIP. DATA: ok_code TYPE sy-ucomm, save_ok TYPE sy-ucomm. DATA  number TYPE sy-dynnr. mytabstrip-activetab = 'PUSH2'. number = '0120'. CALL SCREEN 100. MODULE status_0100 OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE can
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm"
abapFile: "abentab_strip_control2_abexa.htm"
keywords: ["do", "if", "case", "data", "abentab", "strip", "control2", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Tabstrips with Scrolling on the ABAP Server

This example demonstrates the use of tabstrip controls with centralized scrolling.

Source Code

REPORT demo\_dynpro\_tabstrip\_server.
CONTROLS mytabstrip TYPE TABSTRIP.
DATA: ok\_code TYPE sy-ucomm,
      save\_ok TYPE sy-ucomm.
DATA  number TYPE sy-dynnr.
mytabstrip-activetab = 'PUSH2'.
number = '0120'.
CALL SCREEN 100.
MODULE status\_0100 OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE cancel INPUT.
  LEAVE PROGRAM.
ENDMODULE.
MODULE user\_command INPUT.
  save\_ok = ok\_code.
  CLEAR ok\_code.
  IF save\_ok = 'OK'.
    MESSAGE i888(sabapdemos) WITH 'MYTABSTRIP-ACTIVETAB ='
                                  mytabstrip-activetab.
  ELSE.
    mytabstrip-activetab = save\_ok.
    CASE save\_ok.
      WHEN 'PUSH1'.
        number = '0110'.
      WHEN 'PUSH2'.
        number = '0120'.
      WHEN 'PUSH3'.
        number = '0130'.
    ENDCASE.
  ENDIF.
ENDMODULE.

Description

The static next dynpro number of dynpro 100 is 100. The layout of dynpro 100 and the subscreen dynpros 110 to 130 is the same as in the [executable example](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm) with local scrolling. The function codes of the three tab titles are not typed and a common subscreen area sub is assigned to all tab titles.

The dynpro flow logic of dynpro 100 makes a dynamic binding to PBO, a subscreen dynpro in the subscreen area sub. The dynpro flow logic of subscreen dynpros 110 to 130 does not contain any module calls.

This example works in exactly the same way as the [example with local scrolling](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm) except that scrolling between the tabstrip pages is programmed in the ABAP program. Each time the user chooses a tab title, the function code from the OK field is assigned to the activetab component of structure mytabstrip. At the same time, the variable number is given the dynpro number of the subscreen dynpro to be displayed in the subscreen area SUB of the tabstrip.


### abendynpro_splitter_control_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_splitter_control. DATA splitter TYPE REF TO cl_dynpro_splitter. START-OF-SELECTION. CREATE OBJECT splitter EXPORTING splitter_name = 'SPLITTER'. CALL SCREEN 100. MODULE set_status OUTPUT. SET PF-STATUS 'SCREEN_100'. ENDMODULE. MODULE set_sash OUTPUT. splitter->set_sash(
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm"
abapFile: "abendynpro_splitter_control_abexa.htm"
keywords: ["select", "do", "try", "data", "abendynpro", "splitter", "control", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) →  [dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm) → 

dynpro - Splitter Control

This example demonstrates a [splitter control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensplitter_control_glosry.htm "Glossary Entry").

Source Code

REPORT demo\_dynpro\_splitter\_control.
DATA splitter TYPE REF TO cl\_dynpro\_splitter.
START-OF-SELECTION.
  CREATE OBJECT splitter
    EXPORTING
      splitter\_name = 'SPLITTER'.
  CALL SCREEN 100.
MODULE set\_status OUTPUT.
  SET PF-STATUS 'SCREEN\_100'.
ENDMODULE.
MODULE set\_sash OUTPUT.
  splitter->set\_sash( ).
ENDMODULE.
MODULE cancel.
  LEAVE PROGRAM.
ENDMODULE.
MODULE get\_sash INPUT.
  splitter->get\_guisash( ).
ENDMODULE.

Description

A subscreen is assigned to both parts of the splitter control. The subscreens are called in the dynpro flow logic.


### abentab_strip_control_abexas.htm

---
title: "Continue"
description: |
  !Example(exa.gif 'Example') dynpro - Subscreens(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm) !Example(exa.gif 'Example') dynpro - Tabstrips with Scrolling in SAP GUI(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control_abexas.htm"
abapFile: "abentab_strip_control_abexas.htm"
keywords: ["do", "if", "abentab", "strip", "control", "abexas"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - Statements in the Dynpro Flow Logic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_dynpro_statements.htm) →  [dynpro - Subscreens, Tabstrips, and Splitter Controls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynp_subscreens.htm) → 

dynpro - Examples of Subscreens, Tabstrips, and Splitter Controls

Continue
![Example](exa.gif "Example") [dynpro - Subscreens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_subscreen_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling in SAP GUI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control1_abexa.htm)
![Example](exa.gif "Example") [dynpro - Tabstrips with Scrolling on the ABAP Server](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentab_strip_control2_abexa.htm)
![Example](exa.gif "Example") [dynpro - Splitter Control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_splitter_control_abexa.htm)


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - ABAP Statements / LOOP AT SCREEN

**Files**: 4 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - ABAP Statements / SET HOLD DATA

Included pages: 2


### abapset_hold_data.htm

---
title: "SET HOLD DATA"
description: |
  Short Reference(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data_shortref.htm) Syntax SET HOLD DATA ONOFF. Effect During PBO(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm 'Glossary Entry') processing, this statement makes the f
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data.htm"
abapFile: "abapset_hold_data.htm"
keywords: ["select", "delete", "do", "if", "try", "data", "abapset", "hold"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - ABAP Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_abap_statements.htm) → 

SET HOLD DATA

[Short Reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data_shortref.htm)

Syntax

SET HOLD DATA *{*ON*|*OFF*}*.

Effect

During [PBO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm "Glossary Entry") processing, this statement makes the following standard menu items in the GUI status of the [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") either effective using the addition ON or ineffective using the addition OFF:

-   System → User Profile → Hold Data
    
    This function saves the entries made by the user in the input fields of the dynpro for the duration of the current user session. Each time the [screen layout](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_glosry.htm "Glossary Entry") of the dynpro is displayed, these values are passed to the corresponding input fields as default values. This overwrites the values transported from the ABAP program.
    
-   System → User Profile → Set Data
    
    This function works like the 'Hold Data' function except that here, the corresponding input fields are no longer ready for input for all subsequent calls of the dynpro.
    
-   System → User Profile → Delete Data
    
    This function deletes all saved data and makes the input fields that were locked using 'Set Data' ready for input again for all subsequent calls of the dynpro.
    

Each time PBO processing starts, the setting made in the static properties of the dynpro under Hold Data is set so that execution of SET HOLD DATA during [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry") processing does not have an effect on the display of the subsequent screen layout.

Hint

The menu items above can be selected in every GUI status but only take effect when they are activated in the static properties of the dynpro using Hold Data or the statement SET HOLD DATA.

Continue
![Example](exa.gif "Example") [dynpro - Holding Data](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_hold_data_abexa.htm)


### abendynpro_hold_data_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_set_hold_data. DATA field(10) TYPE c. CALL SCREEN 100. field = 'XXXXXXXXXX'. CALL SCREEN 100. MODULE hold_data OUTPUT. SET HOLD DATA ON. ENDMODULE. Description The static next dynpro of dynpro 100 is 0. It contains a single input/output field field. The dynpro flow logic is:
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_hold_data_abexa.htm"
abapFile: "abendynpro_hold_data_abexa.htm"
keywords: ["delete", "do", "if", "try", "data", "abendynpro", "hold", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - ABAP Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_abap_statements.htm) →  [SET HOLD DATA](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data.htm) → 

dynpro - Holding Data

This example demonstrates how to hold input data across transactions.

Source Code

REPORT demo\_dynpro\_set\_hold\_data.
DATA field(10) TYPE c.
CALL SCREEN 100.
field = 'XXXXXXXXXX'.
CALL SCREEN 100.
MODULE hold\_data OUTPUT.
  SET HOLD DATA ON.
ENDMODULE.

Description

The static next dynpro of dynpro 100 is 0. It contains a single input/output field field. The dynpro flow logic is:

PROCESS BEFORE OUTPUT.
  MODULE hold\_data.
PROCESS AFTER INPUT.

In the PBO event of the dynpro, the Hold Data attribute is activated regardless of the static default. If, after entering a value, the user chooses System → User Profile → Hold Data or Set Data, the value is displayed again when the dynpro is called a second time and whenever the program is subsequently called (in the same [ABAP session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_session_glosry.htm "Glossary Entry")) unless the user chooses Delete Data. This overwrites any value assigned to the field field in the ABAP program.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - ABAP Statements / SET CURSOR, Dynpro

**Files**: 2 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - ABAP Statements / SET HOLD DATA

Included pages: 2


### abapset_hold_data.htm

---
title: "SET HOLD DATA"
description: |
  Short Reference(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data_shortref.htm) Syntax SET HOLD DATA ONOFF. Effect During PBO(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm 'Glossary Entry') processing, this statement makes the f
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data.htm"
abapFile: "abapset_hold_data.htm"
keywords: ["select", "delete", "do", "if", "try", "data", "abapset", "hold"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - ABAP Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_abap_statements.htm) → 

SET HOLD DATA

[Short Reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data_shortref.htm)

Syntax

SET HOLD DATA *{*ON*|*OFF*}*.

Effect

During [PBO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm "Glossary Entry") processing, this statement makes the following standard menu items in the GUI status of the [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") either effective using the addition ON or ineffective using the addition OFF:

-   System → User Profile → Hold Data
    
    This function saves the entries made by the user in the input fields of the dynpro for the duration of the current user session. Each time the [screen layout](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_glosry.htm "Glossary Entry") of the dynpro is displayed, these values are passed to the corresponding input fields as default values. This overwrites the values transported from the ABAP program.
    
-   System → User Profile → Set Data
    
    This function works like the 'Hold Data' function except that here, the corresponding input fields are no longer ready for input for all subsequent calls of the dynpro.
    
-   System → User Profile → Delete Data
    
    This function deletes all saved data and makes the input fields that were locked using 'Set Data' ready for input again for all subsequent calls of the dynpro.
    

Each time PBO processing starts, the setting made in the static properties of the dynpro under Hold Data is set so that execution of SET HOLD DATA during [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry") processing does not have an effect on the display of the subsequent screen layout.

Hint

The menu items above can be selected in every GUI status but only take effect when they are activated in the static properties of the dynpro using Hold Data or the statement SET HOLD DATA.

Continue
![Example](exa.gif "Example") [dynpro - Holding Data](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_hold_data_abexa.htm)


### abendynpro_hold_data_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_set_hold_data. DATA field(10) TYPE c. CALL SCREEN 100. field = 'XXXXXXXXXX'. CALL SCREEN 100. MODULE hold_data OUTPUT. SET HOLD DATA ON. ENDMODULE. Description The static next dynpro of dynpro 100 is 0. It contains a single input/output field field. The dynpro flow logic is:
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_hold_data_abexa.htm"
abapFile: "abendynpro_hold_data_abexa.htm"
keywords: ["delete", "do", "if", "try", "data", "abendynpro", "hold", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - ABAP Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_abap_statements.htm) →  [SET HOLD DATA](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data.htm) → 

dynpro - Holding Data

This example demonstrates how to hold input data across transactions.

Source Code

REPORT demo\_dynpro\_set\_hold\_data.
DATA field(10) TYPE c.
CALL SCREEN 100.
field = 'XXXXXXXXXX'.
CALL SCREEN 100.
MODULE hold\_data OUTPUT.
  SET HOLD DATA ON.
ENDMODULE.

Description

The static next dynpro of dynpro 100 is 0. It contains a single input/output field field. The dynpro flow logic is:

PROCESS BEFORE OUTPUT.
  MODULE hold\_data.
PROCESS AFTER INPUT.

In the PBO event of the dynpro, the Hold Data attribute is activated regardless of the static default. If, after entering a value, the user chooses System → User Profile → Hold Data or Set Data, the value is displayed again when the dynpro is called a second time and whenever the program is subsequently called (in the same [ABAP session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_session_glosry.htm "Glossary Entry")) unless the user chooses Delete Data. This overwrites any value assigned to the field field in the ABAP program.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - ABAP Statements / GET CURSOR, Dynpro

**Files**: 3 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - ABAP Statements / SET HOLD DATA

Included pages: 2


### abapset_hold_data.htm

---
title: "SET HOLD DATA"
description: |
  Short Reference(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data_shortref.htm) Syntax SET HOLD DATA ONOFF. Effect During PBO(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm 'Glossary Entry') processing, this statement makes the f
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data.htm"
abapFile: "abapset_hold_data.htm"
keywords: ["select", "delete", "do", "if", "try", "data", "abapset", "hold"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - ABAP Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_abap_statements.htm) → 

SET HOLD DATA

[Short Reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data_shortref.htm)

Syntax

SET HOLD DATA *{*ON*|*OFF*}*.

Effect

During [PBO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm "Glossary Entry") processing, this statement makes the following standard menu items in the GUI status of the [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") either effective using the addition ON or ineffective using the addition OFF:

-   System → User Profile → Hold Data
    
    This function saves the entries made by the user in the input fields of the dynpro for the duration of the current user session. Each time the [screen layout](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_glosry.htm "Glossary Entry") of the dynpro is displayed, these values are passed to the corresponding input fields as default values. This overwrites the values transported from the ABAP program.
    
-   System → User Profile → Set Data
    
    This function works like the 'Hold Data' function except that here, the corresponding input fields are no longer ready for input for all subsequent calls of the dynpro.
    
-   System → User Profile → Delete Data
    
    This function deletes all saved data and makes the input fields that were locked using 'Set Data' ready for input again for all subsequent calls of the dynpro.
    

Each time PBO processing starts, the setting made in the static properties of the dynpro under Hold Data is set so that execution of SET HOLD DATA during [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry") processing does not have an effect on the display of the subsequent screen layout.

Hint

The menu items above can be selected in every GUI status but only take effect when they are activated in the static properties of the dynpro using Hold Data or the statement SET HOLD DATA.

Continue
![Example](exa.gif "Example") [dynpro - Holding Data](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_hold_data_abexa.htm)


### abendynpro_hold_data_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_set_hold_data. DATA field(10) TYPE c. CALL SCREEN 100. field = 'XXXXXXXXXX'. CALL SCREEN 100. MODULE hold_data OUTPUT. SET HOLD DATA ON. ENDMODULE. Description The static next dynpro of dynpro 100 is 0. It contains a single input/output field field. The dynpro flow logic is:
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_hold_data_abexa.htm"
abapFile: "abendynpro_hold_data_abexa.htm"
keywords: ["delete", "do", "if", "try", "data", "abendynpro", "hold", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - ABAP Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_abap_statements.htm) →  [SET HOLD DATA](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data.htm) → 

dynpro - Holding Data

This example demonstrates how to hold input data across transactions.

Source Code

REPORT demo\_dynpro\_set\_hold\_data.
DATA field(10) TYPE c.
CALL SCREEN 100.
field = 'XXXXXXXXXX'.
CALL SCREEN 100.
MODULE hold\_data OUTPUT.
  SET HOLD DATA ON.
ENDMODULE.

Description

The static next dynpro of dynpro 100 is 0. It contains a single input/output field field. The dynpro flow logic is:

PROCESS BEFORE OUTPUT.
  MODULE hold\_data.
PROCESS AFTER INPUT.

In the PBO event of the dynpro, the Hold Data attribute is activated regardless of the static default. If, after entering a value, the user chooses System → User Profile → Hold Data or Set Data, the value is displayed again when the dynpro is called a second time and whenever the program is subsequently called (in the same [ABAP session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_session_glosry.htm "Glossary Entry")) unless the user chooses Delete Data. This overwrites any value assigned to the field field in the ABAP program.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - ABAP Statements / CONTROLS

**Files**: 3 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - ABAP Statements / SET HOLD DATA

Included pages: 2


### abapset_hold_data.htm

---
title: "SET HOLD DATA"
description: |
  Short Reference(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data_shortref.htm) Syntax SET HOLD DATA ONOFF. Effect During PBO(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm 'Glossary Entry') processing, this statement makes the f
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data.htm"
abapFile: "abapset_hold_data.htm"
keywords: ["select", "delete", "do", "if", "try", "data", "abapset", "hold"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - ABAP Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_abap_statements.htm) → 

SET HOLD DATA

[Short Reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data_shortref.htm)

Syntax

SET HOLD DATA *{*ON*|*OFF*}*.

Effect

During [PBO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm "Glossary Entry") processing, this statement makes the following standard menu items in the GUI status of the [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") either effective using the addition ON or ineffective using the addition OFF:

-   System → User Profile → Hold Data
    
    This function saves the entries made by the user in the input fields of the dynpro for the duration of the current user session. Each time the [screen layout](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_glosry.htm "Glossary Entry") of the dynpro is displayed, these values are passed to the corresponding input fields as default values. This overwrites the values transported from the ABAP program.
    
-   System → User Profile → Set Data
    
    This function works like the 'Hold Data' function except that here, the corresponding input fields are no longer ready for input for all subsequent calls of the dynpro.
    
-   System → User Profile → Delete Data
    
    This function deletes all saved data and makes the input fields that were locked using 'Set Data' ready for input again for all subsequent calls of the dynpro.
    

Each time PBO processing starts, the setting made in the static properties of the dynpro under Hold Data is set so that execution of SET HOLD DATA during [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry") processing does not have an effect on the display of the subsequent screen layout.

Hint

The menu items above can be selected in every GUI status but only take effect when they are activated in the static properties of the dynpro using Hold Data or the statement SET HOLD DATA.

Continue
![Example](exa.gif "Example") [dynpro - Holding Data](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_hold_data_abexa.htm)


### abendynpro_hold_data_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_set_hold_data. DATA field(10) TYPE c. CALL SCREEN 100. field = 'XXXXXXXXXX'. CALL SCREEN 100. MODULE hold_data OUTPUT. SET HOLD DATA ON. ENDMODULE. Description The static next dynpro of dynpro 100 is 0. It contains a single input/output field field. The dynpro flow logic is:
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_hold_data_abexa.htm"
abapFile: "abendynpro_hold_data_abexa.htm"
keywords: ["delete", "do", "if", "try", "data", "abendynpro", "hold", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - ABAP Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_abap_statements.htm) →  [SET HOLD DATA](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data.htm) → 

dynpro - Holding Data

This example demonstrates how to hold input data across transactions.

Source Code

REPORT demo\_dynpro\_set\_hold\_data.
DATA field(10) TYPE c.
CALL SCREEN 100.
field = 'XXXXXXXXXX'.
CALL SCREEN 100.
MODULE hold\_data OUTPUT.
  SET HOLD DATA ON.
ENDMODULE.

Description

The static next dynpro of dynpro 100 is 0. It contains a single input/output field field. The dynpro flow logic is:

PROCESS BEFORE OUTPUT.
  MODULE hold\_data.
PROCESS AFTER INPUT.

In the PBO event of the dynpro, the Hold Data attribute is activated regardless of the static default. If, after entering a value, the user chooses System → User Profile → Hold Data or Set Data, the value is displayed again when the dynpro is called a second time and whenever the program is subsequently called (in the same [ABAP session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_session_glosry.htm "Glossary Entry")) unless the user chooses Delete Data. This overwrites any value assigned to the field field in the ABAP program.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - ABAP Statements / SET HOLD DATA

**Files**: 2 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / General Dynpros / dynpro - ABAP Statements / SET HOLD DATA

Included pages: 2


### abapset_hold_data.htm

---
title: "SET HOLD DATA"
description: |
  Short Reference(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data_shortref.htm) Syntax SET HOLD DATA ONOFF. Effect During PBO(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm 'Glossary Entry') processing, this statement makes the f
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data.htm"
abapFile: "abapset_hold_data.htm"
keywords: ["select", "delete", "do", "if", "try", "data", "abapset", "hold"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - ABAP Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_abap_statements.htm) → 

SET HOLD DATA

[Short Reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data_shortref.htm)

Syntax

SET HOLD DATA *{*ON*|*OFF*}*.

Effect

During [PBO](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpbo_glosry.htm "Glossary Entry") processing, this statement makes the following standard menu items in the GUI status of the [dynpro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_glosry.htm "Glossary Entry") either effective using the addition ON or ineffective using the addition OFF:

-   System → User Profile → Hold Data
    
    This function saves the entries made by the user in the input fields of the dynpro for the duration of the current user session. Each time the [screen layout](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenscreen_glosry.htm "Glossary Entry") of the dynpro is displayed, these values are passed to the corresponding input fields as default values. This overwrites the values transported from the ABAP program.
    
-   System → User Profile → Set Data
    
    This function works like the 'Hold Data' function except that here, the corresponding input fields are no longer ready for input for all subsequent calls of the dynpro.
    
-   System → User Profile → Delete Data
    
    This function deletes all saved data and makes the input fields that were locked using 'Set Data' ready for input again for all subsequent calls of the dynpro.
    

Each time PBO processing starts, the setting made in the static properties of the dynpro under Hold Data is set so that execution of SET HOLD DATA during [PAI](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpai_glosry.htm "Glossary Entry") processing does not have an effect on the display of the subsequent screen layout.

Hint

The menu items above can be selected in every GUI status but only take effect when they are activated in the static properties of the dynpro using Hold Data or the statement SET HOLD DATA.

Continue
![Example](exa.gif "Example") [dynpro - Holding Data](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_hold_data_abexa.htm)


### abendynpro_hold_data_abexa.htm

---
title: "Source Code"
description: |
  REPORT demo_dynpro_set_hold_data. DATA field(10) TYPE c. CALL SCREEN 100. field = 'XXXXXXXXXX'. CALL SCREEN 100. MODULE hold_data OUTPUT. SET HOLD DATA ON. ENDMODULE. Description The static next dynpro of dynpro 100 is 0. It contains a single input/output field field. The dynpro flow logic is:
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynpro_hold_data_abexa.htm"
abapFile: "abendynpro_hold_data_abexa.htm"
keywords: ["delete", "do", "if", "try", "data", "abendynpro", "hold", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [General Dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros.htm) →  [dynpro - ABAP Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dynpros_abap_statements.htm) →  [SET HOLD DATA](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_hold_data.htm) → 

dynpro - Holding Data

This example demonstrates how to hold input data across transactions.

Source Code

REPORT demo\_dynpro\_set\_hold\_data.
DATA field(10) TYPE c.
CALL SCREEN 100.
field = 'XXXXXXXXXX'.
CALL SCREEN 100.
MODULE hold\_data OUTPUT.
  SET HOLD DATA ON.
ENDMODULE.

Description

The static next dynpro of dynpro 100 is 0. It contains a single input/output field field. The dynpro flow logic is:

PROCESS BEFORE OUTPUT.
  MODULE hold\_data.
PROCESS AFTER INPUT.

In the PBO event of the dynpro, the Hold Data attribute is activated regardless of the static default. If, after entering a value, the user chooses System → User Profile → Hold Data or Set Data, the value is displayed again when the dynpro is called a second time and whenever the program is subsequently called (in the same [ABAP session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_session_glosry.htm "Glossary Entry")) unless the user chooses Delete Data. This overwrites any value assigned to the field field in the ABAP program.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Overview

**Files**: 2 | **Difficulty**: beginner

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Create / SELECTION-SCREEN / SELECTION-SCREEN, BEGIN OF

**Files**: 7 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Create / SELECTION-SCREEN / SELECTION-SCREEN, screen_elements / SELECTION-SCREEN, PUSHBUTTON

**Files**: 2 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Create / SELECTION-SCREEN / SELECTION-SCREEN, screen_elements / SELECTION-SCREEN, TABBED BLOCK

**Files**: 3 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Create / SELECTION-SCREEN / SELECTION-SCREEN, screen_elements / SELECTION-SCREEN, FUNCTION KEY

**Files**: 2 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Create / SELECTION-SCREEN / SELECTION-SCREEN INCLUDE

**Files**: 6 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Create / PARAMETERS / PARAMETERS, type_options

**Files**: 2 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Create / PARAMETERS / PARAMETERS, screen_options

**Files**: 2 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Create / PARAMETERS / PARAMETERS, value_options

**Files**: 2 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Create / SELECT-OPTIONS

**Files**: 8 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Calls

**Files**: 4 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Processing

**Files**: 8 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

**Files**: 2 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / SAP GUI User Dialogs / Selection Screens / Selection Screens - Free Selections

Included pages: 2


### abenfree_selections.htm

---
title: "Selection Screens - Free Selections"
description: |
  A dynamic selection is a ranges condition(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm 'Glossary Entry') that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm"
abapFile: "abenfree_selections.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenfree", "selections"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) → 

Selection Screens - Free Selections

A dynamic selection is a [ranges condition](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_condition_glosry.htm "Glossary Entry") that can be entered on a dynamically created selection screen. The associated selection screens are created, displayed, and processed by the system function modules FREE\_SELECTIONS\_... of the function pool SSEL. The selection screens can be displayed as standalone selection screens, or integrated into the screen layouts of other dynpros or selection screens as a subscreen. Dynamic selections can be included in a logical database or used in any programs.

-   [Dynamic Selections in Logical Databases](#abenfree-selections-1-------dynamic-selections-in-all-programs---@ITOC@@ABENFREE_SELECTIONS_2)

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm). See [Security Risks Caused by Input from Outside](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_programming_scrty.htm).

Dynamic Selections in Logical Databases

[Logical databases](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogical_data_base_glosry.htm "Glossary Entry") can provide dynamic selections on their selection screen to specify further dynamic ranges conditions for individual nodes of the logical database, in addition to the parameters and selection criteria already defined statically in the database. These dynamic conditions can then be evaluated in the database program of the logical database. Dynamic selections of a logical database can be declared simply using the addition [DYNAMIC SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen_ldb_dynamic.htm) of the statement [SELECTION-SCREEN](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselection-screen.htm) in the database.

The ABAP runtime framework is responsible for calling function modules to create, display, and handle dynamic selections. The selections entered by the user are passed directly to data objects of the database program and can be evaluated there. For more information, see [Logical Databases - Dynamic Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenldb_free_selections.htm).

Hint

The special addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm) is used to pass parameters to selection screens of logical databases that provide dynamic selections. If this addition is used, the function modules mentioned above are generally also implemented.

Dynamic Selections in All Programs

In ABAP programs that work with classic dynpros, dynamic selections can be provided by using the following two function modules directly:

-   FREE\_SELECTIONS\_INIT
-   FREE\_SELECTIONS\_DIALOG

The function module FREE\_SELECTIONS\_INIT is used to determine the entities for which dynamic selections are to be made. This could be, for example, database tables from the ABAP Dictionary or any fields specified freely. The result of the function module is a selection ID, which must be passed to the function module FREE\_SELECTIONS\_DIALOG.

The function module FREE\_SELECTIONS\_DIALOG can display differently configured selection screens in different formats. Users can enter dynamic selections on these selection screens for the fields provided there and, if required, can also select fields for which they want to perform dynamic selections. If Save is chosen, the function module returns the specified selections to the caller in three different formats, which the caller can take from the following EXPORTING parameters:

-   WHERE\_CLAUSES
    
    This parameter passes an internal table with the relative expressions [rel\_exp](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_stmt_logexp.htm) generated according to the dynamic selections for [dynamic specification](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_dynamic.htm) in the [WHERE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapwhere.htm) clause of [SELECT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect.htm) statements.
    
-   FIELD\_RANGES
    
    This parameter passes an internal table with the [ranges tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenranges_table_glosry.htm "Glossary Entry") generated according to the dynamic selections and that can be evaluated using the predicate [comparison operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomp_operator_glosry.htm "Glossary Entry") IN in corresponding [WHERE conditions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwhere_logexp_seltab.htm) or [comparison expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogexp_select_option.htm).
    
-   EXPRESSIONS
    
    This parameter passes an internal table with conditions generated according to the dynamic selections in an internal format (Reverse Polish Notation). This format can then be passed to the function module FREE\_SELECTIONS\_INIT to prepare a selection screen that is predefined with these selections. This format is also required for passes made to called programs using the addition [WITH FREE SELECTIONS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit_selscreen_parameters.htm) of the statement [SUBMIT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsubmit.htm).
    

For more information, see the documentation about function modules and their parameter interface.

Executable Example

[Dynamic selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)

Continue
![Example](exa.gif "Example") [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm)


### abenfree_selection_abexa.htm

---
title: "Selection Screens - Free Selections"
description: |
  This example demonstrates how a free selection is used in a program. Source Code REPORT demo_free_selections. PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'. CLASS demo DEFINITION. PUBLIC SECTION. CLASS-METHODS main. PRIVATE SECTION. CLASS-METHODS check_existence_and_authority RETURNING VALUE(ch
version: "7.56"
category: "ui"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selection_abexa.htm"
abapFile: "abenfree_selection_abexa.htm"
keywords: ["select", "do", "if", "try", "catch", "method", "class", "data", "abenfree", "selection", "abexa"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [SAP GUI User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_screens.htm) →  [Selection Screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselection_screen.htm) →  [Selection Screens - Free Selections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) → 

Selection Screens - Free Selections

This example demonstrates how a free selection is used in a program.

Source Code

REPORT demo\_free\_selections.
PARAMETERS dbtab TYPE tabname DEFAULT 'SPFLI'.
CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
  PRIVATE SECTION.
    CLASS-METHODS check\_existence\_and\_authority
      RETURNING VALUE(checked\_dbtab) TYPE tabname.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    DATA selid         TYPE  rsdynsel-selid.
    DATA field\_tab     TYPE TABLE OF rsdsfields.
    DATA table\_tab     TYPE TABLE OF rsdstabs.
    DATA cond\_tab      TYPE rsds\_twhere.
    DATA dref          TYPE REF TO data.
    FIELD-SYMBOLS <table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <cond>  LIKE LINE OF cond\_tab.
    DATA(checked\_dbtab) = demo=>check\_existence\_and\_authority( ).
    table\_tab = VALUE #( ( prim\_tab = checked\_dbtab ) ).
    CALL FUNCTION 'FREE\_SELECTIONS\_INIT'
      EXPORTING
        kind         = 'T'
      IMPORTING
        selection\_id = selid
      TABLES
        tables\_tab   = table\_tab
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc <> 0.
      MESSAGE 'Error in initialization' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CALL FUNCTION 'FREE\_SELECTIONS\_DIALOG'
      EXPORTING
        selection\_id  = selid
        title         = 'Free Selection'
        as\_window     = ' '
      IMPORTING
        where\_clauses = cond\_tab
      TABLES
        fields\_tab    = field\_tab
      EXCEPTIONS
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE 'No free selection created' TYPE 'I'.
      LEAVE PROGRAM.
    ENDIF.
    ASSIGN cond\_tab\[ tablename = checked\_dbtab \] TO <cond>.
    IF sy-subrc <> 0.
      MESSAGE 'Error in condition' TYPE 'I' DISPLAY LIKE 'E'.
      LEAVE PROGRAM.
    ENDIF.
    CREATE DATA dref TYPE TABLE OF (checked\_dbtab).
    ASSIGN dref->\* TO <table>.
    TRY.
        SELECT \*
               FROM (checked\_dbtab)
               WHERE (<cond>-where\_tab)
               INTO TABLE @<table>.
      CATCH cx\_sy\_dynamic\_osql\_error.
        MESSAGE 'Error in dynamic ABAP SQL' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
    TRY.
        cl\_salv\_table=>factory(
          IMPORTING r\_salv\_table = DATA(alv)
          CHANGING  t\_table      = <table> ).
        alv->display( ).
      CATCH cx\_salv\_msg.
        MESSAGE 'Error in ALV display' TYPE 'I' DISPLAY LIKE 'E'.
    ENDTRY.  ENDMETHOD.
  METHOD check\_existence\_and\_authority.
    TRY.
        checked\_dbtab = cl\_abap\_dyn\_prg=>check\_table\_name\_str(
                        val = dbtab
                        packages = 'SAPBC\_DATAMODEL' ).
      CATCH cx\_abap\_not\_a\_table.
        MESSAGE 'Database table not found' TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
      CATCH cx\_abap\_not\_in\_package.
        MESSAGE 'Only tables from the flight data model are allowed'
                 TYPE 'I' DISPLAY LIKE 'E'.
        LEAVE PROGRAM.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.
START-OF-SELECTION.
  demo=>main( ).

Description

This example shows the simplest way to use a [dynamic selection](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfree_selections.htm) in a program. When the value "T" of the parameter KIND is passed, the function module FREE\_SELECTIONS\_INIT is set to prepare dynamic selections for database tables in the ABAP Dictionary. The names of the database tables (here only one freely selectable table) are passed to the table parameter TABLES\_TAB.

The result of FREE\_SELECTIONS\_INIT is passed to the function module FREE\_SELECTIONS\_DIALOG, which displays a selection screen for entering dynamic selections for the database table. The user can select which database fields are used for free selections and can then make these selections.

Once the user confirms the selected dynamic selections by choosing Save, the program inherits them as a dynamic WHERE clause and then uses this clause in a dynamic SELECT statement to read the data accordingly. The result is displayed in an ALV list.

The method CHECK\_TABLE\_NAME\_STR of the class CL\_ABAP\_DYN\_PRG is used to check whether the database table specified exists and can be used.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / Obsolete Language Elements / Obsolete User Dialogs / dynpro - Obsolete Statements in Dynpro Flow Logic

**Files**: 11 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / Obsolete Language Elements / Obsolete User Dialogs / Obsolete Editor Calls

Included pages: 3


### abentexteditor.htm

---
title: "Obsolete Editor Calls"
description: |
  The following statements trigger calls of editors integrated into GUI windows(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_window_glosry.htm 'Glossary Entry'). -   EDITOR-CALL FOR itab.(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm)
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentexteditor.htm"
abapFile: "abentexteditor.htm"
keywords: ["do", "try", "abentexteditor"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obsolete.htm) →  [Obsolete User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_obsolete.htm) → 

Obsolete Editor Calls

The following statements trigger calls of editors integrated into [GUI windows](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_window_glosry.htm "Glossary Entry").

-   [EDITOR-CALL FOR itab.](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm)
-   [EDITOR-CALL FOR REPORT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_report.htm)

Continue
[EDITOR-CALL FOR itab](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm)
[EDITOR-CALL FOR REPORT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_report.htm)


### abapeditor-call_for_itab.htm

---
title: "EDITOR-CALL FOR itab"
description: |
  Short Reference(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm) Obsolete Syntax EDITOR-CALL FOR itab TITLE title DISPLAY-MODEBACKUP INTO jtab. Additions: 1. ... TITLE title(#!ABAP_ADDITION_1@1@) 2. ... DISPLAY-MODE(#!ABA
version: "7.56"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm"
abapFile: "abapeditor-call_for_itab.htm"
keywords: ["delete", "do", "if", "try", "class", "data", "types", "internal-table", "abapeditor", "call", "for", "itab"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obsolete.htm) →  [Obsolete User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_obsolete.htm) →  [Obsolete Editor Calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentexteditor.htm) → 

EDITOR-CALL FOR itab

[Short Reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm)

Obsolete Syntax

EDITOR-CALL FOR itab *\[*TITLE title*\]*
                     *\[**{*DISPLAY-MODE*}**|**{*BACKUP INTO jtab*}**\]*.

Additions:

[1\. ... TITLE title](#!ABAP_ADDITION_1@1@)
[2\. ... DISPLAY-MODE](#!ABAP_ADDITION_2@2@)
[3\. ... BACKUP INTO jtab](#!ABAP_ADDITION_3@3@)

Effect

This statement passes the content of the internal table itab to a text editor and starts this text editor. The internal table must be a [standard table](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_table_glosry.htm "Glossary Entry") without [secondary table keys](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensecondary_table_key_glosry.htm "Glossary Entry") with a character-like line type.

The text editor is based on a GUI control displayed in the current GUI window and has its own GUI status, part of which matches that of the ABAP Editor. The text editor has, depending its settings, a line width of 255 or 72 characters. This setting can be made in the GUI status and also applies to the ABAP Editor.

The content of the table lines is converted line by line in accordance with the [conversion rules for elementary data types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_elementary.htm) into a field of the type c with length 255 or 72 and passed to the text editor. If the text editor is exited using the function Save, the previous content of the table is deleted and the content of each line of the editor is appended to the internal table from top to bottom. If necessary, this process involves a conversion of the type c of length 255 or 72 to the line type of the internal table.

Return Code

sy-subrc

Meaning

0

The text editor was exited using the Save function after the content was modified.

2

The text editor was exited using the Save function and no content was modified.

4

The text editor was not exited using the Save function.

Hint

This statement is replaced by using the [Control Framework](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontrol_framework_glosry.htm "Glossary Entry"). Here, the class CL\_GUI\_TEXTEDIT wraps the corresponding [GUI control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_control_glosry.htm "Glossary Entry").

Addition 1   

... TITLE title

Effect

A character-like data object title can be specified after the addition TITLE. The first 50 characters of title are displayed in the header of the text editor.

Addition 2   

... DISPLAY-MODE

Effect

If the addition DISPLAY-MODE is specified, the text editor is started in display mode.

Hint

The text editor is started in display mode but can be switched to change mode using a key combination.

Addition 3   

... BACKUP INTO jtab

Effect

If the addition BACKUP INTO is specified, the content of the internal table itab is assigned to an internal table jtab before the text editor is called. jtab can have any table category. The line types must be [compatible](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencompatible_glosry.htm "Glossary Entry") or [convertible](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconvertible_glosry.htm "Glossary Entry").

Example

Calls a text editor for a table with text lines. The processing in the IF control structure is only executed if the content of the table was actually modified. sy-subrc = 0 does not necessarily indicate this.

TYPES text TYPE c LENGTH 255.
DATA: text\_tab TYPE TABLE OF text,
      back\_tab LIKE text\_tab.
EDITOR-CALL FOR text\_tab BACKUP INTO back\_tab.
IF sy-subrc = 0 AND
   text\_tab <> back\_tab.
  ...
ENDIF.


### abapeditor-call_for_report.htm

---
title: "EDITOR-CALL FOR REPORT"
description: |
  Short Reference(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm) Obsolete Syntax EDITOR-CALL FOR REPORT prog DISPLAY-MODE. Addition: ... DISPLAY-MODE(#!ABAP_ONE_ADD@1@) Effect This statement starts the ABAP Editor for the source code of the program
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_report.htm"
abapFile: "abapeditor-call_for_report.htm"
keywords: ["do", "if", "case", "try", "method", "class", "data", "abapeditor", "call", "for", "report"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obsolete.htm) →  [Obsolete User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_obsolete.htm) →  [Obsolete Editor Calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentexteditor.htm) → 

EDITOR-CALL FOR REPORT

[Short Reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm)

Obsolete Syntax

EDITOR-CALL FOR REPORT prog *\[*DISPLAY-MODE*\]*.

Addition:

[... DISPLAY-MODE](#!ABAP_ONE_ADD@1@)

Effect

This statement starts the ABAP Editor for the source code of the program specified in prog. prog must be a character-like data object, which contains the name of a program in uppercase letters that exists in the [repository](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrepository_glosry.htm "Glossary Entry"). If not, a corresponding message is displayed in the status line.

Once ABAP Editor is started, it offers the full range of functions, as when called in the ABAP Workbench or the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadt_glosry.htm "Glossary Entry"). Forward navigation to branch to other tools is also possible. After returning from the ABAP Editor, the current program continues after the statement EDITOR-CALL.

Hints

-   If an inactive version of the program exists, then this version is loaded.
-   This statement bypasses the authorization checks that are performed when the ABAP Editor is called using a transaction code, however the editor still checks the development authorization of the current user.
-   The statement EDITOR-CALL FOR REPORT calls the function module EDITOR\_PROGRAM internally for the specified program prog, which starts the editor in the current environment (SAP GUI or Eclipse) and performs the required authorization checks.
-   This method of calling the ABAP Editor should no longer be used. Instead, official ABAP Workbench interfaces, such as the function module RS\_TOOL\_ACCESS should be used. If only the properties of the editor control are needed, the GUI class CL\_GUI\_SOURCEEDIT or its subclass CL\_GUI\_ABAPEDIT is used.

Addition   

... DISPLAY-MODE

Effect

The ABAP Editor is started in change mode by default. The addition DISPLAY-MODE causes the ABAP Editor to be started in display mode.

Hint

The ABAP Editor is started in display mode but can be switched to change mode.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / Obsolete Language Elements / Obsolete User Dialogs / dynpro - Obsolete ABAP Statements

**Files**: 3 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / Obsolete Language Elements / Obsolete User Dialogs / Obsolete Editor Calls

Included pages: 3


### abentexteditor.htm

---
title: "Obsolete Editor Calls"
description: |
  The following statements trigger calls of editors integrated into GUI windows(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_window_glosry.htm 'Glossary Entry'). -   EDITOR-CALL FOR itab.(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm)
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentexteditor.htm"
abapFile: "abentexteditor.htm"
keywords: ["do", "try", "abentexteditor"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obsolete.htm) →  [Obsolete User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_obsolete.htm) → 

Obsolete Editor Calls

The following statements trigger calls of editors integrated into [GUI windows](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_window_glosry.htm "Glossary Entry").

-   [EDITOR-CALL FOR itab.](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm)
-   [EDITOR-CALL FOR REPORT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_report.htm)

Continue
[EDITOR-CALL FOR itab](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm)
[EDITOR-CALL FOR REPORT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_report.htm)


### abapeditor-call_for_itab.htm

---
title: "EDITOR-CALL FOR itab"
description: |
  Short Reference(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm) Obsolete Syntax EDITOR-CALL FOR itab TITLE title DISPLAY-MODEBACKUP INTO jtab. Additions: 1. ... TITLE title(#!ABAP_ADDITION_1@1@) 2. ... DISPLAY-MODE(#!ABA
version: "7.56"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm"
abapFile: "abapeditor-call_for_itab.htm"
keywords: ["delete", "do", "if", "try", "class", "data", "types", "internal-table", "abapeditor", "call", "for", "itab"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obsolete.htm) →  [Obsolete User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_obsolete.htm) →  [Obsolete Editor Calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentexteditor.htm) → 

EDITOR-CALL FOR itab

[Short Reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm)

Obsolete Syntax

EDITOR-CALL FOR itab *\[*TITLE title*\]*
                     *\[**{*DISPLAY-MODE*}**|**{*BACKUP INTO jtab*}**\]*.

Additions:

[1\. ... TITLE title](#!ABAP_ADDITION_1@1@)
[2\. ... DISPLAY-MODE](#!ABAP_ADDITION_2@2@)
[3\. ... BACKUP INTO jtab](#!ABAP_ADDITION_3@3@)

Effect

This statement passes the content of the internal table itab to a text editor and starts this text editor. The internal table must be a [standard table](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_table_glosry.htm "Glossary Entry") without [secondary table keys](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensecondary_table_key_glosry.htm "Glossary Entry") with a character-like line type.

The text editor is based on a GUI control displayed in the current GUI window and has its own GUI status, part of which matches that of the ABAP Editor. The text editor has, depending its settings, a line width of 255 or 72 characters. This setting can be made in the GUI status and also applies to the ABAP Editor.

The content of the table lines is converted line by line in accordance with the [conversion rules for elementary data types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_elementary.htm) into a field of the type c with length 255 or 72 and passed to the text editor. If the text editor is exited using the function Save, the previous content of the table is deleted and the content of each line of the editor is appended to the internal table from top to bottom. If necessary, this process involves a conversion of the type c of length 255 or 72 to the line type of the internal table.

Return Code

sy-subrc

Meaning

0

The text editor was exited using the Save function after the content was modified.

2

The text editor was exited using the Save function and no content was modified.

4

The text editor was not exited using the Save function.

Hint

This statement is replaced by using the [Control Framework](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontrol_framework_glosry.htm "Glossary Entry"). Here, the class CL\_GUI\_TEXTEDIT wraps the corresponding [GUI control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_control_glosry.htm "Glossary Entry").

Addition 1   

... TITLE title

Effect

A character-like data object title can be specified after the addition TITLE. The first 50 characters of title are displayed in the header of the text editor.

Addition 2   

... DISPLAY-MODE

Effect

If the addition DISPLAY-MODE is specified, the text editor is started in display mode.

Hint

The text editor is started in display mode but can be switched to change mode using a key combination.

Addition 3   

... BACKUP INTO jtab

Effect

If the addition BACKUP INTO is specified, the content of the internal table itab is assigned to an internal table jtab before the text editor is called. jtab can have any table category. The line types must be [compatible](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencompatible_glosry.htm "Glossary Entry") or [convertible](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconvertible_glosry.htm "Glossary Entry").

Example

Calls a text editor for a table with text lines. The processing in the IF control structure is only executed if the content of the table was actually modified. sy-subrc = 0 does not necessarily indicate this.

TYPES text TYPE c LENGTH 255.
DATA: text\_tab TYPE TABLE OF text,
      back\_tab LIKE text\_tab.
EDITOR-CALL FOR text\_tab BACKUP INTO back\_tab.
IF sy-subrc = 0 AND
   text\_tab <> back\_tab.
  ...
ENDIF.


### abapeditor-call_for_report.htm

---
title: "EDITOR-CALL FOR REPORT"
description: |
  Short Reference(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm) Obsolete Syntax EDITOR-CALL FOR REPORT prog DISPLAY-MODE. Addition: ... DISPLAY-MODE(#!ABAP_ONE_ADD@1@) Effect This statement starts the ABAP Editor for the source code of the program
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_report.htm"
abapFile: "abapeditor-call_for_report.htm"
keywords: ["do", "if", "case", "try", "method", "class", "data", "abapeditor", "call", "for", "report"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obsolete.htm) →  [Obsolete User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_obsolete.htm) →  [Obsolete Editor Calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentexteditor.htm) → 

EDITOR-CALL FOR REPORT

[Short Reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm)

Obsolete Syntax

EDITOR-CALL FOR REPORT prog *\[*DISPLAY-MODE*\]*.

Addition:

[... DISPLAY-MODE](#!ABAP_ONE_ADD@1@)

Effect

This statement starts the ABAP Editor for the source code of the program specified in prog. prog must be a character-like data object, which contains the name of a program in uppercase letters that exists in the [repository](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrepository_glosry.htm "Glossary Entry"). If not, a corresponding message is displayed in the status line.

Once ABAP Editor is started, it offers the full range of functions, as when called in the ABAP Workbench or the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadt_glosry.htm "Glossary Entry"). Forward navigation to branch to other tools is also possible. After returning from the ABAP Editor, the current program continues after the statement EDITOR-CALL.

Hints

-   If an inactive version of the program exists, then this version is loaded.
-   This statement bypasses the authorization checks that are performed when the ABAP Editor is called using a transaction code, however the editor still checks the development authorization of the current user.
-   The statement EDITOR-CALL FOR REPORT calls the function module EDITOR\_PROGRAM internally for the specified program prog, which starts the editor in the current environment (SAP GUI or Eclipse) and performs the required authorization checks.
-   This method of calling the ABAP Editor should no longer be used. Instead, official ABAP Workbench interfaces, such as the function module RS\_TOOL\_ACCESS should be used. If only the properties of the editor control are needed, the GUI class CL\_GUI\_SOURCEEDIT or its subclass CL\_GUI\_ABAPEDIT is used.

Addition   

... DISPLAY-MODE

Effect

The ABAP Editor is started in change mode by default. The addition DISPLAY-MODE causes the ABAP Editor to be started in display mode.

Hint

The ABAP Editor is started in display mode but can be switched to change mode.


---


## ABAP - Keyword Documentation / ABAP - Programming Language / Obsolete Language Elements / Obsolete User Dialogs / Obsolete Statements for Selection Screens

**Files**: 2 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Language / Obsolete Language Elements / Obsolete User Dialogs / Obsolete Editor Calls

Included pages: 3


### abentexteditor.htm

---
title: "Obsolete Editor Calls"
description: |
  The following statements trigger calls of editors integrated into GUI windows(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_window_glosry.htm 'Glossary Entry'). -   EDITOR-CALL FOR itab.(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm)
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentexteditor.htm"
abapFile: "abentexteditor.htm"
keywords: ["do", "try", "abentexteditor"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obsolete.htm) →  [Obsolete User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_obsolete.htm) → 

Obsolete Editor Calls

The following statements trigger calls of editors integrated into [GUI windows](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_window_glosry.htm "Glossary Entry").

-   [EDITOR-CALL FOR itab.](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm)
-   [EDITOR-CALL FOR REPORT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_report.htm)

Continue
[EDITOR-CALL FOR itab](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm)
[EDITOR-CALL FOR REPORT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_report.htm)


### abapeditor-call_for_itab.htm

---
title: "EDITOR-CALL FOR itab"
description: |
  Short Reference(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm) Obsolete Syntax EDITOR-CALL FOR itab TITLE title DISPLAY-MODEBACKUP INTO jtab. Additions: 1. ... TITLE title(#!ABAP_ADDITION_1@1@) 2. ... DISPLAY-MODE(#!ABA
version: "7.56"
category: "data-structures"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_itab.htm"
abapFile: "abapeditor-call_for_itab.htm"
keywords: ["delete", "do", "if", "try", "class", "data", "types", "internal-table", "abapeditor", "call", "for", "itab"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obsolete.htm) →  [Obsolete User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_obsolete.htm) →  [Obsolete Editor Calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentexteditor.htm) → 

EDITOR-CALL FOR itab

[Short Reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm)

Obsolete Syntax

EDITOR-CALL FOR itab *\[*TITLE title*\]*
                     *\[**{*DISPLAY-MODE*}**|**{*BACKUP INTO jtab*}**\]*.

Additions:

[1\. ... TITLE title](#!ABAP_ADDITION_1@1@)
[2\. ... DISPLAY-MODE](#!ABAP_ADDITION_2@2@)
[3\. ... BACKUP INTO jtab](#!ABAP_ADDITION_3@3@)

Effect

This statement passes the content of the internal table itab to a text editor and starts this text editor. The internal table must be a [standard table](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_table_glosry.htm "Glossary Entry") without [secondary table keys](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensecondary_table_key_glosry.htm "Glossary Entry") with a character-like line type.

The text editor is based on a GUI control displayed in the current GUI window and has its own GUI status, part of which matches that of the ABAP Editor. The text editor has, depending its settings, a line width of 255 or 72 characters. This setting can be made in the GUI status and also applies to the ABAP Editor.

The content of the table lines is converted line by line in accordance with the [conversion rules for elementary data types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_elementary.htm) into a field of the type c with length 255 or 72 and passed to the text editor. If the text editor is exited using the function Save, the previous content of the table is deleted and the content of each line of the editor is appended to the internal table from top to bottom. If necessary, this process involves a conversion of the type c of length 255 or 72 to the line type of the internal table.

Return Code

sy-subrc

Meaning

0

The text editor was exited using the Save function after the content was modified.

2

The text editor was exited using the Save function and no content was modified.

4

The text editor was not exited using the Save function.

Hint

This statement is replaced by using the [Control Framework](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontrol_framework_glosry.htm "Glossary Entry"). Here, the class CL\_GUI\_TEXTEDIT wraps the corresponding [GUI control](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_control_glosry.htm "Glossary Entry").

Addition 1   

... TITLE title

Effect

A character-like data object title can be specified after the addition TITLE. The first 50 characters of title are displayed in the header of the text editor.

Addition 2   

... DISPLAY-MODE

Effect

If the addition DISPLAY-MODE is specified, the text editor is started in display mode.

Hint

The text editor is started in display mode but can be switched to change mode using a key combination.

Addition 3   

... BACKUP INTO jtab

Effect

If the addition BACKUP INTO is specified, the content of the internal table itab is assigned to an internal table jtab before the text editor is called. jtab can have any table category. The line types must be [compatible](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencompatible_glosry.htm "Glossary Entry") or [convertible](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconvertible_glosry.htm "Glossary Entry").

Example

Calls a text editor for a table with text lines. The processing in the IF control structure is only executed if the content of the table was actually modified. sy-subrc = 0 does not necessarily indicate this.

TYPES text TYPE c LENGTH 255.
DATA: text\_tab TYPE TABLE OF text,
      back\_tab LIKE text\_tab.
EDITOR-CALL FOR text\_tab BACKUP INTO back\_tab.
IF sy-subrc = 0 AND
   text\_tab <> back\_tab.
  ...
ENDIF.


### abapeditor-call_for_report.htm

---
title: "EDITOR-CALL FOR REPORT"
description: |
  Short Reference(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm) Obsolete Syntax EDITOR-CALL FOR REPORT prog DISPLAY-MODE. Addition: ... DISPLAY-MODE(#!ABAP_ONE_ADD@1@) Effect This statement starts the ABAP Editor for the source code of the program
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_for_report.htm"
abapFile: "abapeditor-call_for_report.htm"
keywords: ["do", "if", "case", "try", "method", "class", "data", "abapeditor", "call", "for", "report"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_reference.htm) →  [Obsolete Language Elements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obsolete.htm) →  [Obsolete User Dialogs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengui_obsolete.htm) →  [Obsolete Editor Calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentexteditor.htm) → 

EDITOR-CALL FOR REPORT

[Short Reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapeditor-call_shortref.htm)

Obsolete Syntax

EDITOR-CALL FOR REPORT prog *\[*DISPLAY-MODE*\]*.

Addition:

[... DISPLAY-MODE](#!ABAP_ONE_ADD@1@)

Effect

This statement starts the ABAP Editor for the source code of the program specified in prog. prog must be a character-like data object, which contains the name of a program in uppercase letters that exists in the [repository](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrepository_glosry.htm "Glossary Entry"). If not, a corresponding message is displayed in the status line.

Once ABAP Editor is started, it offers the full range of functions, as when called in the ABAP Workbench or the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadt_glosry.htm "Glossary Entry"). Forward navigation to branch to other tools is also possible. After returning from the ABAP Editor, the current program continues after the statement EDITOR-CALL.

Hints

-   If an inactive version of the program exists, then this version is loaded.
-   This statement bypasses the authorization checks that are performed when the ABAP Editor is called using a transaction code, however the editor still checks the development authorization of the current user.
-   The statement EDITOR-CALL FOR REPORT calls the function module EDITOR\_PROGRAM internally for the specified program prog, which starts the editor in the current environment (SAP GUI or Eclipse) and performs the required authorization checks.
-   This method of calling the ABAP Editor should no longer be used. Instead, official ABAP Workbench interfaces, such as the function module RS\_TOOL\_ACCESS should be used. If only the properties of the editor control are needed, the GUI class CL\_GUI\_SOURCEEDIT or its subclass CL\_GUI\_ABAPEDIT is used.

Addition   

... DISPLAY-MODE

Effect

The ABAP Editor is started in change mode by default. The addition DISPLAY-MODE causes the ABAP Editor to be started in display mode.

Hint

The ABAP Editor is started in display mode but can be switched to change mode.


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / General Rules

**Files**: 4 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / General Rules

Included pages: 4


### abengeneral_rules_gdl.htm

---
title: "General Rules"
description: |
  The following rules do not apply specifically to ABAP, even if they are demonstrated here in the context of ABAP programming, but apply equally well to all types of business application programming. Many of the rules described in this section are either derived from the general rules or support thes
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneral_rules_gdl.htm"
abapFile: "abengeneral_rules_gdl.htm"
keywords: ["do", "if", "types", "abengeneral", "rules", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) → 

General Rules

The following rules do not apply specifically to ABAP, even if they are demonstrated here in the context of ABAP programming, but apply equally well to all types of business application programming. Many of the rules described in this section are either derived from the general rules or support these rules.

-   [Separation of Concerns](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenseperation_concerns_guidl.htm "Guideline")
-   [KISS Principle](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenkiss_principle_guidl.htm "Guideline")
-   [Correctness and Quality](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm "Guideline")

Continue
[Separation of Concerns](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenseperation_concerns_guidl.htm)
[KISS Principle](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenkiss_principle_guidl.htm)
[Correctness and Quality](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm)


### abenseperation_concerns_guidl.htm

---
title: "Separation of Concerns"
description: |
  Background The term 'separation of concerns' (SoC) was coined in Edsger W. Dijkstra's article On the role of scientific thought from 1974: '... But nothing is gained --on the contrary!-- by tackling these various aspects simultaneously. It is what I sometimes have called 'the separation of concerns'
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenseperation_concerns_guidl.htm"
abapFile: "abenseperation_concerns_guidl.htm"
keywords: ["select", "do", "if", "case", "try", "catch", "method", "class", "data", "types", "abenseperation", "concerns", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [General Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneral_rules_gdl.htm) → 

Separation of Concerns

Background

The term 'separation of concerns' (SoC) was coined in Edsger W. Dijkstra's article On the role of scientific thought from 1974:

"... But nothing is gained --on the contrary!-- by tackling these various aspects simultaneously. It is what I sometimes have called 'the separation of concerns', which, even if not perfectly possible, is yet the only available technique for effective ordering of one's thoughts, that I know of. This is what I mean by 'focusing one's attention upon some aspect': it does not mean ignoring the other aspects, it is just doing justice to the fact that from this aspect's point of view, the other is irrelevant." (Springer-Verlag, 1982)

Separation of concerns is a principle used in programming to separate an application into units, with minimal overlapping between the functions of the individual units. The separation of concerns is achieved using modularization, encapsulation and arrangement in software layers.

Although the classic three-layer architecture of Application Server ABAP (AS ABAP) is ideal for ABAP programming based on the SoC principle, this possibility was never explored. Application programs (in other words, dialog programs in module pools or reports in executable programs) were usually displayed as monolithic blocks, in which the system simultaneously reacted to user actions of the presentation layer, completed the application logic and executed accesses to data on the persistency layer. This type of programming is no longer relevant in today's programming world, where concepts like service-oriented architecture (SOA) set the trend.

Rule

Follow the SoC principle

Follow the separation of concerns principle. Model your applications strictly as service-oriented applications. It is especially important that you separate the logic of the application from the logic of the presentation logic, persistency, and the logic for communication with external systems. Encapsulate the repository objects of the individual concerns in separate packages.

Details

The SoC principle identifies the parts of an application with a specific purpose and encapsulates these parts in closed units. These units only communicate with each other using specified interfaces. Thanks to this principle, the software - which would have otherwise been overcomplicated - is divided up into manageable components. As a result, the software is:

-   more stable
-   easier to understand
-   easier to reuse
-   easier to transport
-   easier to maintain
-   easier to test

Regarding the last point, it would even be true to say that following the SoC principle is a prerequisite for executing isolated, automated [unit tests](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm "Guideline").

Bad Example

The following figure shows two examples of an ABAP application that do not follow the SoC principle.

![Figure](bdoc_soc_bad.jpg)

In fact, the two bad examples here are the programmer models for reporting and dialog programming that were propagated by SAP for a considerable length of time! To be more precise, the example is not bad due to the reporting or programming of transactions itself, but due to the way in which these applications are usually implemented. The mini report in the following source code is a typical example of how different concerns are mixed together in a single program unit. Both the data declarations and the implementation of the functions are mixed together. Access to persistent data, data processing, data presentation and the associated declarations all occur in one single unit.

REPORT z\_non\_soc\_report.

PARAMETERS p\_carrid TYPE spfli-carrid.

DATA: spfli\_tab TYPE STANDARD TABLE OF spfli,
      alv     TYPE REF TO cl\_salv\_table,
      alv\_exc TYPE REF TO cx\_salv\_msg.

SELECT \*
       FROM spfli
       WHERE carrid = @p\_carrid
       INTO TABLE @spfli\_tab.

IF sy-subrc = 0.
  SORT spfli\_tab BY cityfrom cityto.
  TRY.
      cl\_salv\_table=>factory(
        IMPORTING r\_salv\_table = alv
        CHANGING t\_table = spfli\_tab ).
      alv->display( ).
    CATCH cx\_salv\_msg INTO alv\_exc.
      MESSAGE alv\_exc TYPE 'I' DISPLAY LIKE 'E'.
  ENDTRY.
ENDIF.

Of course, it would be too much to insist that concerns should be completely separated even in short programs like in the source code above. However, real applications are usually very long ABAP programs (executable programs, module pools), in which all concerns are handled at the same time. If modularization was performed, it was usually restricted to reusing functional units and was rarely focused on the actual available layers. In addition, large volumes of global data were usually created that were used in different procedures and layers. As a result, all the parts of the program were inherently dependent on each other and could not be tested individually. We are convinced that the quality of these programs can be improved not only by following naming conventions, but also by changing the paradigm for the procedure used for programming tasks.

The following source codes proves that you can implement the SoC principle using classic ABAP procedural methods (in this case, subroutines). This source code works in the same way as the source code above. However, all the concerns are implemented in separate procedures that are assigned to layers. As we have already mentioned, this type of implementation would be too much for a simple program. However, if you needed to test the concerns in the above source code individually and independently of each other by using unit tests, the only possibility would be to adapt the source code as shown below. The program of the following source code can now be easily assigned test methods in ABAP unit test classes, which test the individual procedures.

REPORT z\_soc\_report.

SELECTION-SCREEN BEGIN OF SCREEN 100.
PARAMETERS p\_carrid TYPE spfli-carrid.
SELECTION-SCREEN END OF SCREEN 100.

TYPES spfli\_tab TYPE STANDARD TABLE OF spfli.

DATA: carrid TYPE spfli-carrid,
      table  TYPE spfli\_tab,
      arc     TYPE sy-subrc.

START-OF-SELECTION.
  PERFORM get\_carrid CHANGING carrid.
  PERFORM get\_table  USING    carrid
                     CHANGING table
                              arc.

IF arc = 0
  PERFORM sort\_table    CHANGING table.
  PERFORM display\_table USING    table.
ENDIF.

\* Presentation layer

FORM get\_carrid
     CHANGING value(carrid) TYPE spfli-carrid.
  CALL SELECTION-SCREEN 100.
  IF sy-subrc = 0.
    carrid = p\_carrid.
  ENDIF.
ENDFORM.

FORM display\_table
     USING table TYPE spfli\_tab.
  DATA: alv TYPE      REF TO cl\_salv\_table,
        alv\_exc TYPE REF TO cx\_salv\_msg.
  TRY.
     cl\_salv\_table=>factory(
       IMPORTING r\_salv\_table = alv
       CHANGING t\_table = table ).
     alv->display( ).
   CATCH cx\_salv\_msg INTO alv\_exc.
     MESSAGE alv\_exc TYPE 'I' DISPLAY LIKE 'E'.
  ENDTRY.
ENDFORM.

\* Application layer

FORM sort\_table
     CHANGING table TYPE spfli\_tab.
     SORT table BY cityfrom cityto.
ENDFORM.

\* Persistency layer

FORM get\_table
     USING     carrid TYPE spfli-carrid
     CHANGING table   TYPE spfli\_tab
              arc     TYPE sy-subrc.
  SELECT \*
         FROM spfli
         WHERE carrid = @carrid
         INTO TABLE @table.
  arc = sy-subrc.
ENDFORM.

However, this separation of concerns using subroutines shown above does not create a good impression. The following source code shows how the separation of concerns should be implemented instead using methods in concern-specific classes.

Good Example

The following figure shows how an ABAP application should look that follows the separation of concerns.

![Figure](bdoc_soc_good.jpg)

After the concerns have been identified, they are implemented in ABAP object classes. The concerns shown in the figure are the main tasks that are usually performed in ABAP application programming:

-   Communication with a user interface (UI) using UI services
-   Actual application logic
-   Access to persistent data using persistency services
-   Communication with external systems using proxy services

These main rules can be subdivided further, which is often necessary.

The boxes for the individual concerns in the figure represent packages. All the repository objects (classes, data types) belonging to a concern should be located in corresponding packages. The package concept (encapsulated packages) supports this separation of concerns. In encapsulated packages, repository objects in one package can only access the objects of another package using package interfaces, which is checked by the syntax check. A package can restrict the usability of its repository objects even more by using access control lists. Subdividing the separation of concerns in a package is a concept supported by subpackages.

For example, encapsulating all database tables of an application in a package for persistency services prevents any program, that does not belong to this package, from accessing these database tables. The reverse is also true. For example, programs in the persistency layer cannot communicate directly with components in the presentation layer, such as a Web Dynpro ABAP application. You should prepare the package encapsulation (by choosing Package Check as Server) in the package properties. These packages have package interfaces, A package check is performed during the extended program check.

The following source code shows how to adapt the separation of concerns from the above source code for classes local to the program.

REPORT z\_soc\_class\_report.
SELECTION-SCREEN BEGIN OF SCREEN 100.
PARAMETERS p\_carrid TYPE spfli-carrid.
SELECTION-SCREEN END OF SCREEN 100.

TYPES spfli\_tab TYPE STANDARD TABLE OF spfli.

CLASS presentation\_server DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      get\_carrid RETURNING VALUE(carrid) TYPE spfli-carrid,
      display\_table IMPORTING VALUE(table) TYPE spfli\_tab.
ENDCLASS.

CLASS presentation\_server IMPLEMENTATION.
  METHOD get\_carrid.
    CALL SELECTION-SCREEN 100.
    IF sy-subrc = 0.
      carrid = p\_carrid.
    ENDIF.
  ENDMETHOD.
  METHOD display\_table.
    DATA: alv     TYPE REF TO cl\_salv\_table,
          alv\_exc TYPE REF TO cx\_salv\_msg.
    TRY.
       cl\_salv\_table=>factory(
         IMPORTING r\_salv\_table = alv
         CHANGING t\_table = table ).
        alv->display( ).
      CATCH cx\_salv\_msg INTO alv\_exc.
        MESSAGE alv\_exc TYPE 'I' DISPLAY LIKE 'E'.
     ENDTRY.
   ENDMETHOD.
ENDCLASS.

CLASS application\_server DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS
       sort\_table CHANGING table TYPE spfli\_tab.
    ENDCLASS.

CLASS application\_server IMPLEMENTATION.
  METHOD sort\_table.
    SORT table BY cityfrom cityto.
  ENDMETHOD.
ENDCLASS.

CLASS persistency\_server DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS
       get\_table IMPORTING carrid TYPE spfli-carrid
                 EXPORTING table  TYPE spfli\_tab
                           arc     TYPE sy-subrc.
ENDCLASS.

CLASS persistency\_server IMPLEMENTATION.
  METHOD get\_table.
   SELECT \*
          FROM spfli
          WHERE carrid = @carrid
          INTO TABLE @table.
    arc = sy-subrc.
  ENDMETHOD.
ENDCLASS.

CLASS report DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main.
ENDCLASS.

CLASS report IMPLEMENTATION.
  METHOD main.
    DATA: carrid TYPE spfli-carrid,
          table  TYPE spfli\_tab,
          arc     TYPE sy-subrc.
    carrid = presentation\_server=>get\_carrid( ).
    persistency\_server=>get\_table( EXPORTING carrid = carrid
                                   IMPORTING table  = table
                                             arc     = arc ).
    IF arc = 0.
      application\_server=>sort\_table(
        CHANGING table = table ).
      presentation\_server=>display\_table( table ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
report=>main( ).

At first glance, the above source code appears to be very excessive compared to the first source code. But only on the first glance. A real application program usually only consists of 25 lines. The larger and more realistic the application program, the smaller the proportion of the overhead that is incurred by wrapping the concerns in classes. If the reuse options for [ABAP Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") are used appropriately, it is even possible to reduce the amount of source code.

In addition, the individual steps are now wrapped in classes, in other words, real program units (unlike in the second source code). In practice, wrapping is not performed in one single program, but in global classes that are assigned to different packages, depending on the layer. These packages are connected to each other using package interfaces. It is only by using these interfaces that you can achieve the other benefits of separating the concerns (in addition to the testing capability achieved in the second source code).


### abenkiss_principle_guidl.htm

---
title: "KISS Principle"
description: |
  Background The KISS principle says that you should always choose the simplest solution for a problem. KISS is an acronym and can have any of the following meanings (the list is not exhaustive): -   Keep it simple, stupid. -   Keep it small and simple. -   Keep it sweet and simple. -   Keep it simple
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenkiss_principle_guidl.htm"
abapFile: "abenkiss_principle_guidl.htm"
keywords: ["do", "while", "if", "try", "method", "abenkiss", "principle", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [General Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneral_rules_gdl.htm) → 

KISS Principle

Background

The KISS principle says that you should always choose the simplest solution for a problem. KISS is an acronym and can have any of the following meanings (the list is not exhaustive):

-   Keep it simple, stupid.
-   Keep it small and simple.
-   Keep it sweet and simple.
-   Keep it simple and straightforward.
-   Keep it short and simple.
-   Keep it simple and smart.
-   Keep it strictly simple.

The basic statement of the KISS principle is similar to Occam's razor, which says that in science the preferred theory is the one that makes fewest assumptions to explain observations (see Wikipedia entry on the KISS principle).

Rule

Follow the KISS principle

Follow the KISS principle, and limit the complexity of your programs as far as possible.

Details

The best solution to a problem is usually the one that is as simple, minimalist, and easy to understand as possible, while ensuring stability, understandability, and maintainability in addition to functional correctness.

There are plenty of bad examples of the KISS principle. Why is this?

-   Programs are too complex right from the start. This can be due to poor design or simply a rash, undisciplined programming style.
-   Programs are maintained for lengthy periods. Instead of creating new implementations for old and new functions together, new functions are simply added (usually using IF control structures) to old functions. Programs that were initially simple thus become ever more complex, although this is not justified by the complexity of the task at hand.

To develop according to the KISS principle, you should ensure right from the start that the complexity of the program remains manageable. Rules that support this approach relate to the [structure and style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) of programs, in particular [comments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomments_gdl.htm) and [complexity](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomplexity_gdl.htm).

Hint

If existing programs do not follow the KISS principle, and these programs need to be further developed, we recommend refactoring as appropriate. Refactoring refers to the process of manually or automatically improving the structure of programs while retaining the observable program behavior. It improves legibility, understandability, maintainability, and extensibility, as well as considerably reducing the related effort for troubleshooting and functional enhancements (see Wikipedia entry on refactoring). The (incremental) refactoring of an existing program is not only useful for following the above rule, but also for all following rules.

The refactoring of existing code is supported by the required coverage by [unit tests](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm "Guideline"). Comprehensive unit tests can ensure that a program behaves in the same way after the refactoring process.

Example

The figure below shows the structure of a method that does not follow the KISS principle. The method consists of approximately 160 statements and reaches a [nesting depth](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennesting_depth_guidl.htm "Guideline") of 12 levels. The method, which is only illustrated schematically, is a real example from a live ABAP program, which reached the state shown on the left after continuous additional developments. The method had become so complex that it was practically impossible to make another necessary change, and the developer was forced to refactor in line with the KISS principle.

![Figure](bdoc_kiss.jpg)

The result is illustrated on the right of the figure. By splitting the method M into three methods, each with less than 100 statements and a maximum nesting depth of 5 levels, manageable modularization units were created, which follow the rules for [complexity](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomplexity_gdl.htm), and allow the required modification to be made. Ideally, however, the state shown on the left side of the figure should never occur.


### abencorrectness_quality_guidl.htm

---
title: "Correctness and Quality"
description: |
  Background Most organizations that develop professional software have product standards that must be adhered to. These product standards define what is meant by correctness and quality of a program. SAP has many such standards, which development departments have to comply with. The current product s
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm"
abapFile: "abencorrectness_quality_guidl.htm"
keywords: ["do", "if", "case", "try", "method", "class", "data", "abencorrectness", "quality", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [General Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneral_rules_gdl.htm) → 

Correctness and Quality

Background

Most organizations that develop professional software have product standards that must be adhered to. These product standards define what is meant by correctness and quality of a program. SAP has many such standards, which development departments have to comply with. The current product standards that are most important to developers are listed below:

-   Accessibility
    
    In the information technology environment, the term accessibility relates to the requirement that anyone, including and especially those with impairments, can access and use information technology products. To make products such as software or websites accessible to all consumers, they must be created and designed so that they can still be used if users have a particular impairment (for example, visual impairment, color blindness) and must be compatible with technologies such as screen readers and screen magnifiers.
    
-   Documentation
    
    As a rule, a product standard for documentation defines which documents have to be shipped to the consumer with the product and ensures that the documentation supplied is consistent, correct, and up to date across all product areas.
    
-   Functional Correctness
    
    The functional correctness of software is generally seen as its most important quality. Software that is not functionally correct is usually unusable. As a rule, a product standard for functional correctness requires software to be error-free, and defines the stability of interfaces and program behavior during upgrades. To reach these goals, thorough testing of the software may be made compulsory.
    
-   Globalization
    
    If software is to be used worldwide, a product standard for globalization is usually necessary. This covers the aspects of internationalization and localization.
    
    -   Internationalization
        
        Internationalization comprises the technical aspects of globalization such as Unicode compatibility, text processing, screen display, printing, data exchange, time zones, translatability, and so on, and thus sets out the technical prerequisites for localization. The translation of user interfaces and other texts is also, of course, an important aspect of internationalization.
        
    -   Localization
        
        Localization is necessary if software for global use has to be adapted to local (usually country-specific) conditions, such as legal requirements or particular business procedures.
        
-   Performance
    
    Even if a program is functionally correct, it is of little or no use to a user if it cannot be executed in a reasonable time. A performance product standard ensures that this aspect is not neglected. It can include, for example, rules for efficient database access and scalability of application logic.
    
-   Security
    
    Where security is critical to software, and this is generally the case for any type of business software, a product standard for security sets out all security-relevant aspects of a product, by pointing out any potential security gaps or legal requirements, for example, and also contains instructions for meeting the standard.
    
-   Usability
    
    The term usability refers to the adaptation of user interfaces to the requirements of human end users and their tasks. A usability product standard should ensure that end users can perform their tasks efficiently and effectively. Key aspects of usability include consistency of user interfaces, ease of use, intuitive task-friendly and role-friendly interfaces, individual adaptability, error tolerance, and so on.
    

Although these standards are, in part, legal requirements, they essentially arise from the fundamental aim to guarantee the correctness and quality of the software that is shipped to consumers. Programming guidelines are very important in this respect. Many of the guidelines listed here support, directly or indirectly, one of the standards mentioned or are derived from them. They support and ensure compliance with such standards, resulting in correct, high-quality programs. The programming guidelines themselves could even be said to be on a par with binding product standards.

However, since not all possible product standards can be covered by the programming guidelines, for example all rules of a performance or security standard, we set out the following basic rule.

Rule

Comply with or check compliance with existing product standards

Adhere to the product standards that exist in your organization, and ensure the correctness and quality of your programs by testing them during development and after completion with all the test tools at your disposal.

Details

It is obvious that you must comply with product standards; this needs no further explanation. However, it is often forgotten that the static and dynamic analysis tools that are available in the ABAP environment can provide invaluable help for compliance with important product standards, particularly standards for functional correctness and performance. Therefore, as part of this basic rule we recommend that you use all available tools that help to ensure the correctness and quality of ABAP programs.

-   Perform the [extended program check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm "Guideline") (transaction SLIN) on a regular basis and correct all messages.
-   Use the [Code Inspector](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencode_inspector_guidl.htm "Guideline") tool (transaction SCI) on a regular basis using the standard check variant, and correct all messages.
-   Check the usability and accessibility of your interface elements by using the appropriate tools (integrated into the workbench tools and [ABAP Test Cockpit](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap-testcockpit_guidl.htm "Guideline")).
-   Cover all functions of your procedural units by using units tests with ABAP Unit (integrated into ABAP Workbench, Code Inspector, and ABAP Test Cockpit).
-   Cover all functions of your applications by using scenario tests with eCATT (transaction SECATT).
-   Check the memory consumption of your programs by using ABAP Memory Inspector (transaction S\_MEMORY\_INSPECTOR and the memory analysis function integrated into ABAP Debugger).
-   Check the runtime behavior and the performance. In SAP GUI use the ABAP runtime analysis (transaction SAT) and in the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadt_glosry.htm "Glossary Entry") use the ABAP Profiler.
-   Check the test coverage by using Coverage Analyzer (transaction SCOV and integrated into ABAP Unit Browser of ABAP Workbench).
-   Follow the [ABAP - Security Notes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_security.htm) to protect your programs and data from attacks from outside.
-   Document your programs and services using all available means: Starting with [comments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomments_gdl.htm), this ranges from simple data element documentation for context-sensitive input help, to class and method documentation for documenting APIs, to explanations of concepts and tutorials in other repositories such as SAP Knowledge Warehouse, or on the Internet, for example in the SAP Community (https://community.sap.com/).

[ABAP Test Cockpit](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencts_glosry.htm "Glossary Entry") (ATC) integrated into ABAP Workbench and the [Change and Transport System (CTS)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencts_glosry.htm "Glossary Entry") supports the execution and evaluation of the most important tests. Some of these tests also check compliance with some of the rules of the ABAP programming guidelines discussed later.

Hint

Where in doubt, product standards take precedence over the guidelines and recommendations of this documentation. If, for example, performance or security aspects prohibit any of the programming practices presented here, compliance with the standard takes priority.

Good Example

Executing unit tests for classes of the package SABAP\_DEMOS\_CAR\_RENTAL\_APPL and displaying the results in ABAP Unit Browser of Object Navigator gives a test coverage of 100%. This package is shipped as a subpackage for the application part of a small example application, which, in addition to unit tests, also demonstrates strict adherence to the [separation of concerns](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenseperation_concerns_guidl.htm "Guideline").


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / ABAP-Specific Rules / Program Type and Program Attributes

**Files**: 4 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / ABAP-Specific Rules / Program Type and Program Attributes

Included pages: 4


### abenprogr_type_features_gdl.htm

---
title: "Program Type and Program Attributes"
description: |
  As soon as an ABAP program is created, important decisions must be made about its robustness and maintainability by selecting its program type and attributes. Among other things, the program type and program attributes determine how strict the syntax check is. Another important property of a program
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogr_type_features_gdl.htm"
abapFile: "abenprogr_type_features_gdl.htm"
keywords: ["select", "do", "if", "abenprogr", "type", "features", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [ABAP-Specific Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_specific_rules_gdl.htm) → 

Program Type and Program Attributes

As soon as an ABAP program is created, important decisions must be made about its robustness and maintainability by selecting its program type and attributes. Among other things, the program type and program attributes determine how strict the syntax check is. Another important property of a program (as well as all other development objects) is its original language.

-   [Program Type](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_type_guidl.htm "Guideline")
-   [Program Attributes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_attribute_guidl.htm "Guideline")
-   [Original Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenoriginal_langu_guidl.htm "Guideline")

Continue
[Program Type](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_type_guidl.htm)
[Program Attributes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_attribute_guidl.htm)
[Original Language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenoriginal_langu_guidl.htm)


### abenprogram_type_guidl.htm

---
title: "Program Type"
description: |
  Background Each ABAP program has a program type that specifies which declarations and processing blocks a program can contain, and how it can be executed using the ABAP runtime framework. These are the possible program types in ABAP: -   Executable program An executable program can contain all possi
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_type_guidl.htm"
abapFile: "abenprogram_type_guidl.htm"
keywords: ["select", "update", "do", "if", "case", "method", "class", "types", "internal-table", "abenprogram", "type", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [ABAP-Specific Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_specific_rules_gdl.htm) →  [Program Type and Program Attributes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogr_type_features_gdl.htm) → 

Program Type

Background

Each ABAP program has a program type that specifies which declarations and processing blocks a program can contain, and how it can be executed using the ABAP runtime framework. These are the possible program types in ABAP:

-   Executable program
    
    An executable program can contain all possible declarative statements. All processing blocks are possible except for function modules. The program supports classic dynpros and selection screens. It can be executed using the statement SUBMIT or using transaction codes. Executable programs are created in ABAP Editor.
    
-   Class pool
    
    A class pool always contains declarative statements for a global class. It can also include declarative statements for local types, interfaces, and classes. Only methods can be used as processing blocks. The pool does not support classic dynpros or selection screens. Global class methods can be called externally (depending on visibility) and public methods of the global class can be executed using transaction codes. Class pools are created using Class Builder.
    
-   Interface pool
    
    An interface pool can only contain the declarative statements for a global interface. Processing blocks, classic dynpros, and selection screens are not possible. Interface pools cannot be called or executed and are created using Class Builder.
    
-   Function pool (function group)
    
    A function pool can contain all types of declarative statements. All processing blocks are supported except for the reporting event blocks. Classic dynpros and selection screens are supported. The associated function modules can be called, but it is also possible to access dynpro processing of the function pool by using transaction codes. Function pools are created using the Function Builder.
    
-   Module pool
    
    A module pool can contain all possible declarative statements. All processing blocks are supported except for reporting event blocks and function modules. The module pool supports classic dynpros and selection screens. It can be executed using transaction codes. Module pools are created using ABAP Editor.
    
-   Subroutine pool
    
    A subroutine pool can contain all possible declarative statements. The LOAD-OF-PROGRAM event block, subroutines and methods can be used as processing blocks. The pool does not support classic dynpros or selection screens. The subroutines can be called, but it is also possible to execute methods using transaction codes. Subroutine pools are created using ABAP Editor.
    
-   Type pool (type group)
    
    A type pool can contain the declarative statements, TYPES and CONSTANTS. Processing blocks, classic dynpros, and selection screens are not possible. Type pools cannot be called or executed. Type pools are created using ABAP Dictionary.
    

In addition to these compilation units (programs that can be compiled independently), include programs can also be used for [source code organization](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensource_code_orga_gdl.htm).

In ABAP, a program execution means that the system loads a program into the memory and executes one or more of its processing blocks. A distinction is made between standalone and called program execution:

-   Standalone program execution
    
    When programs are executed as standalone programs, the program is started using a transaction code (statements CALL TRANSACTION and LEAVE TO TRANSACTION) or using the statement SUBMIT for an executable program. The statement SUBMIT also allows execution in a background process.
    
-   Called program execution
    
    In called program executions, a running program calls a procedure (method, function module, or subroutine) of another program. If necessary, this other program is loaded into the [internal session of the calling program](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenintern_extern_proc_call_guidl.htm "Guideline").
    
-   The program flow for standalone program execution depends on the selected program type and the type of program call:
-   If the program is called using a transaction, a distinction is made between object-oriented (OO) transactions and dialog transactions. For object-oriented transactions, the transaction code is connected to a method of a local or global class. This method defines the program flow. Dialog transactions, however, are linked with a classic dynpro of the program. In this case, the program flow is defined by the associated dynpro flow logic.
-   The program flow of an executable program that was started using SUBMIT is defined by the reporting process of the ABAP runtime framework. The runtime framework calls the different reporting event blocks (START-OF-SELECTION, GET and END-OF-SELECTION) of the program.
-   The program type must be selected based on the technical program attributes described here and the requirements for program execution. Not all the program types mention here are appropriate for new developments.

Rule

Select the appropriate program type

To select the program type, proceed as follows:

-   The program type "class pool" or "interface pool" is automatically set for global classes and interfaces.
-   To implement completed functions that should not be part of the class library, use the program type "subroutine pool" for the implementation of local classes.
-   If required, the program type "function pool" is set automatically for function modules. In addition, function pools must be used to wrap classic dynpros or selection screens.
-   If the programs needs to be executed within the scope of background processing, the executable program type is automatically set.
-   New module pools or type pools should no longer be created.

Details

The above hierarchy for selecting the program type is derived from the basic [rule](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") described, which defines the use of ABAP Objects. The following list describes specific aspects in detail:

-   If ABAP Objects functions need to be provided across the whole package or system, this is done using global classes or interfaces that have the program type "class pool" or "interface pool" implicitly. The call is performed using a method call or an OO transaction (if a standalone program execution is required).
-   The "subroutine pool" program type can be used to implement completed functions called using a transaction code (not using a method call), and which do not require passed parameters and do not have a user interface. Only local classes are used for implementation. The program is called using an OO transaction. Subroutine pools - as the name suggests - were originally intended for subroutines that were called from other programs. Subroutines (and calling subroutines externally in particular) are declared as obsolete, according to the existing programming guidelines. Subroutine pools no longer have this purpose. Instead, subroutine pools are suggested as independent containers for local classes. This is because they are otherwise barely affected by implicit processes of the ABAP runtime framework.
-   Remote-enabled function modules (RFM) (which provide functions using the RFC interface across servers or across systems or are used for parallelization) can only be created in a function pool. The implementation of the actual functions, however, is carried out in a class, for example in a local class within the [function pool](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline").
-   The same applies to update function modules (which are called for the update using CALL FUNCTION IN UPDATE TASK) as to RFMs.
-   Programs with a [classic dynpro interface or selection screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenencap_class_interf_guidl.htm "Guideline") (if still required) should also be created as a function pool. The function pool only implements the UI but does not contain its own application logic (based on the [SoC principle](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenseperation_concerns_guidl.htm "Guideline")). This program type is suitable because it can contain both classic dynpros and an external functional interface in the form of function modules. The dialog modules of the function pool called by the dynpro flow logic should only contain method calls, for instance, for methods of local classes.
-   An executable program includes multiple event blocks that are executed when the various reporting events occur. This form of event control is largely obsolete and should no longer be used. Executable programs should only be used where they are technically required, thus mainly for background processing. In this case, the actual implementation should also be carried out in methods, for example, methods of a local class within the executable program. The event block of the initial event, START-OF-SELECTION, should only contain a [method call](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendial_mod_event_block_guidl.htm "Guideline"). No other event blocks should be included anymore.
-   The module pool used to be the program type traditionally used for classic dialog programming with dynpros. The [Separation of Concerns](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenseperation_concerns_guidl.htm "Guideline") concept is not sufficiently supported by module pools. This is why no more new module pools should be created. Instead, any classic dynpros that are still required should be wrapped in function pools.
-   The type pool program type was initially implemented as a temporary solution. This was because it was not always possible to define types for internal tables in ABAP Dictionary. The same applied to the global storage of constants. Both gaps have now been closed. In ABAP Dictionary, any types can be defined. In global classes and interfaces, types and constants can be created for package-wide or system-wide use. Therefore, the "type pool" program type is obsolete, and no new [type pools](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendeclaration_dtypes_const_guidl.htm "Guideline") should be created.

Note

In cases where program types other than class and interface pools are still used, the check Obsolete Statements (OO Context) should be activated in the [extended program check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm "Guideline"). This enables same stringent syntax check to be implemented for program components not implemented in local classes as for within classes.


### abenprogram_attribute_guidl.htm

---
title: "Program Attributes"
description: |
  Background Alongside various, less important properties, each ABAP program has a set of program attributes that control specific aspects of the program behavior and syntax check severity: -   ABAP language version for configuring the ABAP language version(https://help.sap.com/doc/abapdocu_756_inde
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_attribute_guidl.htm"
abapFile: "abenprogram_attribute_guidl.htm"
keywords: ["select", "do", "while", "if", "try", "method", "class", "data", "types", "abenprogram", "attribute", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [ABAP-Specific Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_specific_rules_gdl.htm) →  [Program Type and Program Attributes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogr_type_features_gdl.htm) → 

Program Attributes

Background

Alongside various, less important properties, each ABAP program has a set of program attributes that control specific aspects of the program behavior and syntax check severity:

-   ABAP language version
    
    for configuring the [ABAP language version](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_version_glosry.htm "Glossary Entry")
    
-   Fixed point arithmetic
    
    For respecting the decimal separator for operations with packed numbers.
    
-   Logical database
    
    For connecting an executable program with a logical database.
    

The program attributes are defined when a program is created the relevant tool (Class Builder, Function Builder, ABAP Editor). It is possible to change them later.

Rule

Use the default settings for program attributes

Set the program attributes for new programs as follows:

-   ABAP language version is [Standard ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_abap_glosry.htm "Glossary Entry") or higher
-   Fixed Point Arithmetic activated
-   No assignment to a logical database

When a new program is created, these settings are the same as the default values. This means that they can be applied without making any changes. Once the program attributes are set they should no longer be modified.

Details

Different behaviors or check severities are only provided for compatibility reasons, to ensure that existing programs can still be compiled and executed. New programs should definitely not use obsolete settings.

-   When a new program is created, the ABAP Language Version attribute is already set to [Standard ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_abap_glosry.htm "Glossary Entry") by default. This attribute must never be set to [Non-Unicode ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennon_unicode_abap_glosry.htm "Glossary Entry"). Only Unicode systems are supported in the current release, which means such programs can no longer be used. Higher [ABAP language versions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_version_glosry.htm "Glossary Entry") are possible because they cover the Unicode checks.
-   When a new program is created, the Fixed Point Arithmetic attribute is already set by default. This attribute must never be reset. If fixed point arithmetic is disabled, the position of the decimal separator of packed numbers (type p) is only respected for output in a classic dynpro, in assignments to fields of the types c and string, or for formatting using WRITE TO. The position is not respected for calculations. Today, this behavior only rarely meets the expectations of developers. If the calculation is to be carried out with packed numbers without any decimal places, this must be specified using the DECIMALS 0 addition for the declaration.
-   When a new executable program is created, the Logical Database attribute is empty. This attribute assigns executable programs to a logical database. This enables the selection screen and flow of the program to be combined with the selection screen and flow of the logical database. A logical database is a special development object that is maintained in Logical Database Builder and which provides other ABAP programs with data from the nodes of a hierarchical tree structure. A logical database has a hierarchical structure, an ABAP database program and a separate standard selection screen. Logical databases should no longer be used. This is because they are based on cross-program usage of global data, implicit subroutine calls and reporting event control, and therefore do not comply with modern concepts. The function module LDB\_PROCESS can be used to access existing logical databases. This function module can be called from a method. No new logical databases should be created. Instead a relevant service should be made available using a global class.

Because any later changes to the program attributes potentially involve extra work, the correct attributes should be configured right from the start and not changed later.

The following sections assume that fixed point arithmetic is always activated and that logical databases are not used.

Hint

From Release 740, SP05, the [strict modes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_strict_modes.htm) in the ABAP SQL syntax check require programs with the ABAP language version [Standard ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_abap_glosry.htm "Glossary Entry") in which the program attribute [fixed point arithmetic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfixed_point_arithmetic_glosry.htm "Glossary Entry") is switched on.

Example

In the following source code performs a substring write across two numeric components of a structure.

METHOD ...
  DATA:
    BEGIN OF struct,
      comp1 TYPE i,
      comp2 TYPE i,
    END OF struct.
  struct+2(4) = 'XXXX'.
ENDMETHOD.

This was only possible for programs in the obsolete ABAP language version [Non-Unicode ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennon_unicode_abap_glosry.htm "Glossary Entry"). Here an implicit [casting](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencasting_guidl.htm "Guideline") of the subarea is performed for type c. The result in the components depends on the alignment gaps, the internal presentation of numeric values (byte order), and the code page used. Therefore, the result is extremely platform-dependent. A live program must never contain this type of code. This type of code often produces data with errors or runtime errors that are difficult to trace.

The above code produces a syntax error when used in an ABAP program defined as [Standard ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_abap_glosry.htm "Glossary Entry") or higher in the program attributes (in accordance with the above rule). Unwanted substring accesses are prohibited, just like any other unwanted accesses to structures or other parts of the working memory. If these accesses cannot be identified by the syntax check, a runtime error occurs with a descriptive short dump while the program is running.


### abenoriginal_langu_guidl.htm

---
title: "Original Language"
description: |
  Background When a new repository object is created, such as a program, class, or database table in ABAP Dictionary, its original language must be specified. This is specified implicitly by the current logon language. All translatable texts created as part of a development object in a development pro
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenoriginal_langu_guidl.htm"
abapFile: "abenoriginal_langu_guidl.htm"
keywords: ["do", "if", "case", "class", "data", "types", "abenoriginal", "langu", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [ABAP-Specific Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_specific_rules_gdl.htm) →  [Program Type and Program Attributes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogr_type_features_gdl.htm) → 

Original Language

Background

When a new repository object is created, such as a program, class, or database table in ABAP Dictionary, its original language must be specified. This is specified implicitly by the current logon language. All translatable texts created as part of a development object in a development project (including descriptive short texts and long texts, the text elements of a program, and the documentation of data types or interfaces) are assigned the specified original language. The texts are created in other languages in a translation process (triggered by development) from the original language into the target languages.

Once specified, there is currently no technical support for replacing an original language with another language across an entire project.

Rule

Define the original language at project level

Consider carefully at the beginning which original language you want to use for your repository objects at project level. Developers may only create their development objects in the original language defined for this project (or subproject).

Details

Proceed as follows when defining the original language:

-   If all development groups involved in a project share a single native language, define this language as the original language of all development objects (this is known as monolingual development).
-   If the development groups are multilingual,
    -   the original language of all development objects is either a language understood by all developers involved (usually English, also called monolingual development)
    -   or the original language in parts of the project is the native language of the majority of developers working in them (multilingual development).

Monolingual development groups are a best-case scenario, but are not always possible nowadays. The two possible scenarios for multilingual development groups, either monolingual or multilingual development, meet two different and contradictory requirements:

-   When you log on to a system in a language other than the original language, there is no effective way of working with development objects (either new or being developed) until a translation of the relevant texts has been created in the appropriate target language. Translation usually takes place in a follow-on translation system and has to be transported back to the development system. This means that an efficient development process is only possible if a single original language is defined at the beginning for the entire project, particularly in international development groups (often working in more than one location). All people involved in the development and validation process can then use the product, even if only for test purposes. If monolingual development is implemented in multilingual development groups, therefore, some (if not all) developers in a project need to create texts in a language other than their native language.
-   There are usually no tools or processes available for linguistic and stylistic checks on UI texts and documentation written by developers in a language other than their native language. Ideally, developers working on user dialogs and documentation should create texts in their native language and these texts should then be translated by trained translators into their own native language, using predefined terminology.

This second point is the reason why English is not required to be the one and only original language for all development projects, and why monolingual development groups should be free to work in their native language, with follow-on translation if required.

If a development group is multilingual, the original language of each development object must be decided case by case. Generally, the approach with single understood development language is used, since international development teams require monolingual development to be able to use their development resources most effectively for a particular project. In some cases, for example where subprojects require large volumes of text to be created, it might be preferable to define the native language of the developers as the original language. This is particularly relevant in SAP's in-house development teams, which still have a high proportion of German-speaking workers.

In multilingual projects, it is best develop associated business functions in a single language (at least at package level). Table contents should also be created in a single language.

Hints

-   When a repository object is created, its original language is the logon language. A conscious decision must be made for the logon language when creating or maintaining repository objects.
-   Regardless of whether a development project is monolingual or multilingual, consistent terminology must be defined for all texts created in the project and used across the board. In multilingual development projects, the translation of the terminology into the relevant languages should be completed before development start if possible, so that the terms can be used by the developers. The existing [standards](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm "Guideline") for UI texts and documents must also be followed.


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / ABAP-Specific Rules / Checks for Correctness

**Files**: 5 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / ABAP-Specific Rules / Checks for Correctness

Included pages: 5


### abencheck_correctness_gdl.htm

---
title: "Checks for Correctness"
description: |
  This section enhances the section Correctness and Quality(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm 'Guideline') by providing more information about static checks on ABAP programs. -   Syntax Check(https://help.sap.com/doc/abapdocu_756_index_htm
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencheck_correctness_gdl.htm"
abapFile: "abencheck_correctness_gdl.htm"
keywords: ["do", "if", "abencheck", "correctness", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [ABAP-Specific Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_specific_rules_gdl.htm) → 

Checks for Correctness

This section enhances the section [Correctness and Quality](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm "Guideline") by providing more information about static checks on ABAP programs.

-   [Syntax Check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensyntax_check_guidl.htm "Guideline")
-   [Extended Program Check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm "Guideline")
-   [Code Inspector](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencode_inspector_guidl.htm "Guideline")
-   [ABAP Test Cockpit](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap-testcockpit_guidl.htm "Guideline")

Continue
[Syntax Check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensyntax_check_guidl.htm)
[Extended Program Check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm)
[Code Inspector](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencode_inspector_guidl.htm)
[ABAP Test Cockpit](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap-testcockpit_guidl.htm)


### abensyntax_check_guidl.htm

---
title: "Syntax Check"
description: |
  Background The syntax check provides syntax errors and syntax warnings: -   As soon as a syntax error occurs, the system stops the check and displays the relevant error message. In many cases, the system suggests a correction that can be applied. Programs with syntax errors can be activated, but the
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensyntax_check_guidl.htm"
abapFile: "abensyntax_check_guidl.htm"
keywords: ["select", "do", "if", "case", "class", "data", "internal-table", "abensyntax", "check", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [ABAP-Specific Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_specific_rules_gdl.htm) →  [Checks for Correctness](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencheck_correctness_gdl.htm) → 

Syntax Check

Background

The syntax check provides syntax errors and syntax warnings:

-   As soon as a syntax error occurs, the system stops the check and displays the relevant error message. In many cases, the system suggests a correction that can be applied. Programs with syntax errors can be activated, but they cannot be generated and executed. In the extended program check, the syntax errors are reported as fatal errors. Syntax errors must be corrected at all costs.
-   If a syntax warning occurs, the syntax check is not terminated. The program can still be executed. The syntax warnings are displayed in ABAP Editor after the syntax check and the [extended program check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm "Guideline"). Of course, testing tools that include the checks of the extended program check (such as Code Inspector and ABAP Test Cockpit) also display syntax warnings. When a program is activated, the system only displays syntax warnings if syntax errors have occurred at the same time. The warnings reported by the syntax check are subdivided into three priorities that are only displayed by the extended program check:
    -   Priority 1
        
        Errors that could cause program termination if the ABAP program is executed. This priority also includes all constructs that should not be used at all, because they indicate program errors and are very likely to make the program behave incorrectly.
        
    -   Priority 2
        
        This priority refers to all constructs that do not necessarily cause incorrect behavior, but are obsolete, for example, and should be replaced by current constructs. Priority 2 errors can become priority 1 errors or syntax errors in future releases.
        
    -   Priority 3
        
        Includes all errors where correction would be beneficial, but not necessarily essential, for the current release. However, the possibility of raising the priority in future releases is not ruled out.
        

The [severity of the ABAP syntax check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogr_type_features_gdl.htm) is determined by the decisions that were made when the program was created. As a result, program constructs that only cause syntax warnings outside of classes can actually indicate real syntax errors within classes. Selected syntax warnings can be suppressed by using pragmas. A pragma is a program directive that affects specific checks but does not affect the program flow.

Rule

Take notice of syntax warnings

Take all warnings of the ABAP syntax check seriously. Syntax warnings are not allowed in completed programs.

Details

The causes of syntax warnings must always be corrected because they generally produce unpredictable errors. These warnings are often reclassified as errors by SAP in subsequent AS ABAP releases. In this case, a program that initially only includes syntax warnings has incorrect syntax and can no longer be used after an upgrade.

Selected syntax check warnings can be hidden using pragmas. With respect to the package check, selecting Package Check as Server in Package Builder is the first step to achieving real encapsulation.. It enables consumers of development objects to modify their where-used positions before hard syntax errors occur. For this reason, all package check warnings must be corrected to ensure that the program's syntax remains correct, even after increased encapsulation of the packages used.

Bad Example

The following source code causes a syntax warning. An internal table is accessed using a freely specified key, even though a secondary key with the same components exists. This access performs a linear search.

FIELD-SYMBOLS <fs> TYPE spfli.
DATA itab TYPE HASHED TABLE OF spfli
          WITH UNIQUE KEY carrid connid
          WITH NON-UNIQUE SORTED KEY cities COMPONENTS cityto cityfrom.
...
READ TABLE itab WITH KEY cityfrom = '...' cityto = '...'
                ASSIGNING <fs>.

Good Example

The following source code corrects the above example. Here, the secondary key is used to access the table. The access performs a binary search. Hiding the syntax warning using the associated program primkey is not recommended here.

FIELD-SYMBOLS <fs> TYPE spfli.
DATA itab TYPE HASHED TABLE OF spfli
          WITH UNIQUE KEY carrid connid
          WITH NON-UNIQUE SORTED KEY cities COMPONENTS cityto cityfrom.
...
ASSIGN itab\[ KEY cities
             COMPONENTS cityfrom = '...' cityto = '...' \] TO <fs>.


### abenextended_program_check_guidl.htm

---
title: "Extended Program Check"
description: |
  Background You can call the extended program check for activated programs either from ABAP Workbench or by using transaction SLIN. It performs static checks that are too complex for the regular syntax check. Both individual and multiple subtests can be performed, or an ATC-relevant check that includ
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm"
abapFile: "abenextended_program_check_guidl.htm"
keywords: ["select", "do", "if", "case", "try", "class", "abenextended", "program", "check", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [ABAP-Specific Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_specific_rules_gdl.htm) →  [Checks for Correctness](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencheck_correctness_gdl.htm) → 

Extended Program Check

Background

You can call the extended program check for activated programs either from ABAP Workbench or by using transaction SLIN. It performs static checks that are too complex for the regular syntax check. Both individual and multiple subtests can be performed, or an ATC-relevant check that includes important subtests.

The extended program check reports errors, warnings and messages. The ATC-relevant check reports errors and warnings that are particularly critical. These checks are also performed in program checks in [ABAP Test Cockpit (ATC)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_test_cockpit_glosry.htm "Glossary Entry"). The classification of individual results (error, warning or message) depends on whether an ATC-relevant check is performed or explicitly selected individual checks. The extended program check also reports the errors and warnings of the syntax check.

In the initial screen of the extended program check, a programming guidelines check can also be selected. This checks whether certain rules presented in this book (that can be verified statically) have been adhered to.

The messages from the extended program check, which are inapplicable in some special cases, can be hidden using pragmas. Before the introduction of pragmas, it was not possible to hide messages raised by a regular syntax check.

Hint

The extended program check also covers security checks used to test ABAP programs for all potential [security risks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_security.htm). In customer systems, these checks are subject to a special licensing procedure.

Rule

Use the extended program check

Use the extended program check and take the results seriously. Message are not allowed to appear when the ATC-relevant checks are performed for a completed program.

Details

The errors, warnings and messages output by the extended program check are just as important as the syntax errors and syntax warnings from the [syntax check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensyntax_check_guidl.htm "Guideline"). For example, an error reported by the extended program check can indicate that a program will definitely lead to a runtime error when it is executed. Warnings and messages usually indicate a questionable use of language elements, which is likely to cause unexpected program behavior.

In rare cases, when a result reported by the extended program check is not justified, this must be documented using an appropriate pragma (the relevant pragma is indicated in the message). This means that the system suppresses the message of the extended program check. Ideally, in less obvious situations, an additional comment should be used to describe why the message is not applicable.

Hint

The extended program check provides useful help for writing ABAP programs in the correct way. Using unspecific pseudo comments or pragmas can undo the positive effect of the extended program check. In particular, the following statement should never be used:

SET EXTENDED CHECK OFF.

This statement suppresses all messages of the extended program check for an entire source code section.

If the ABAP program is submitted to a code review, the results of the extended program check should be used to evaluate the quality.

Bad Example

If the following source code is checked using the extended program check, a warning appears. It indicates a particularly questionable query of the content of the [return code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenreturn_code_guidl.htm "Guideline") sy-subrc.

ASSIGN field TO <fs>.
IF sy-subrc <> 0.
  ...
ENDIF.

The program section shows a typical error in a program with correct syntax. The developer wrongly assumes that the static form of the ASSIGN statement sets the sy-subrc system field, which is not the case. The developer wrongly believes that the program is secured. An incorrect program behavior occurs if sy-subrc has a value that is not zero, due to previous statements. Therefore, the main advantage of the extended program check is that the system does not just examine individual statements for correct syntax, but it also examines entire program sections for semantic errors.

Good Example

The following source code shows the corrected version of the above example. The predicate expression IS ASSIGNED is used (as recommended in the documentation) instead of sy-subrc. The message from the extended program check could also be hidden using a pragma (##subrc\_read), but this is not recommended in this case because the extended program check indicates a real problem.

ASSIGN field TO <fs>.
IF <fs> IS ASSIGNED.
  ...
ENDIF.


### abencode_inspector_guidl.htm

---
title: "Code Inspector"
description: |
  Background The Code Inspector tool performs a static check of repository objects regarding performance, security, syntax, and adherence to naming conventions. Transaction SCI can be called to use the full range of functions of Code Inspector to perform complex static checks and regular mass tests fo
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencode_inspector_guidl.htm"
abapFile: "abencode_inspector_guidl.htm"
keywords: ["select", "loop", "do", "if", "case", "method", "class", "data", "types", "internal-table", "abencode", "inspector", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [ABAP-Specific Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_specific_rules_gdl.htm) →  [Checks for Correctness](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencheck_correctness_gdl.htm) → 

Code Inspector

Background

The Code Inspector tool performs a static check of repository objects regarding performance, security, syntax, and adherence to naming conventions. Transaction SCI can be called to use the full range of functions of Code Inspector to perform complex static checks and regular mass tests for large numbers of development objects.

Code Inspector can also be called from ABAP Workbench to perform a standard set of checks for the current object, for example by choosing Program → Check → Code Inspector in ABAP Editor. The standard check variant used here contains most of the checks from the [extended program check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm "Guideline"), as well as a few additional security and performance checks. Code Inspector can also be integrated into the release of transports.

As in the extended program check, the results of Code Inspector are divided into three categories (errors, warnings, and simple messages), which you can hide using special pseudo comments.

Rule

Use the standard check variant of Code Inspector

Perform the standard check variant of Code Inspector before releasing a program, and correct all error messages.

Details

If the [extended program check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm "Guideline") is used, the standard check variant of Code Inspector only reports messages and checks that are not covered by the extended program check. These are mainly messages relating to potential performance or security risks in programs. Examples are messages about unfavorable WHERE conditions in a SELECT, a pass by value instead of a pass by reference for parameters, or non-secure program calls.

Compared with the messages of the extended program check, it is not always so easy to correct these problems at their source, perhaps because there is no other option for a selection, or because the transparency or robustness of a construct is seen as more important than a small potential loss of performance.

In such cases, the messages can be suppressed using the appropriate pseudo comments. A pseudo comment is a clear indication to the reader of a program that the program author has performed the relevant checks and has explicitly suppressed the message for a good reason. If necessary, pseudo comments can be substantiated by additional regular [comments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomments_gdl.htm).

Bad Example

A standard Code Inspector run for the example class below issues warnings because an internal table is returned by pass by value and an inner join for database tables with activated table buffering is used in the SELECT statement.

CLASS class DEFINITION FINAL.
  PUBLIC SECTION.
    TYPES: BEGIN OF docu\_wa,
             object   TYPE dokil-object,
             dokldate TYPE dokhl-dokldate,
             dokltime TYPE dokhl-dokltime,
           END OF docu\_wa,
           docu\_tab TYPE SORTED TABLE OF docu\_wa
                    WITH NON-UNIQUE KEY object.
    METHODS get\_docu
              IMPORTING VALUE(langu)     TYPE sy-langu
              EXPORTING VALUE(documents) TYPE docu\_tab.
ENDCLASS.
CLASS class IMPLEMENTATION.
  METHOD get\_docu.
    SELECT d~object, h~dokldate, h~dokltime
           FROM dokil AS d
           INNER JOIN dokhl AS h
             ON h~id         = d~id     AND
                h~object     = d~object AND
                h~typ        = d~typ    AND
                h~langu      = d~langu  AND
                h~dokversion = d~version
           WHERE d~id     = 'SD'     AND
                 d~object LIKE 'AB%' AND
                 d~typ    = 'E'      AND
                 d~langu  = @langu
           INTO CORRESPONDING FIELDS OF TABLE @documents.
  ENDMETHOD.
ENDCLASS.

Good Example

The source code below shows the corrected version of the above class, for which Code Inspector no longer issues any messages.

The pass by value of the internal table is replaced by a pass by reference. When passing the elementary parameter langu, the pass by value is left unchanged to ensure robustness. In the standard check used, it would not have triggered a warning in any case. If Code Inspector displays a warning in a case such as this, it can be hidden by using the pseudo comment "#EC CI\_VALPAR.

The inner join of the SELECT statement bypasses table buffering, which would cause performance problems if the method was called frequently. However let us assume (for purpose of this example) that the method is part of a larger application, where shared objects ensure that the selected data is buffered. In this case, the inner join should be used instead of other constructs with poor performance, such as a nested SELECT loop. As a result, the warning from Code Inspector is hidden using the pseudo comment #EC CI\_BUFFJOIN. The reasons for this are described in a regular comment.

CLASS class DEFINITION FINAL.
  PUBLIC SECTION.
    TYPES: BEGIN OF docu\_wa,
             object   TYPE dokil-object,
             dokldate TYPE dokhl-dokldate,
             dokltime TYPE dokhl-dokltime,
           END OF docu\_wa,
           docu\_tab TYPE SORTED TABLE OF docu\_wa
                    WITH NON-UNIQUE KEY object.
    METHODS get\_docu
            IMPORTING VALUE(langu)         TYPE sy-langu "#EC CI\_VALPAR
            EXPORTING REFERENCE(documents) TYPE docu\_tab.
ENDCLASS.
CLASS class IMPLEMENTATION.
  METHOD get\_docu.
    SELECT d~object, h~dokldate, h~dokltime  "#EC CI\_BUFFJOIN
           FROM dokil AS d
           INNER JOIN dokhl AS h             "Buffering is done
             ON h~id         = d~id     AND  "by application
                h~object     = d~object AND  "with Shared Objects
                h~typ        = d~typ    AND
                h~langu      = d~langu  AND
                h~dokversion = d~version
           WHERE d~id     = 'SD'     AND
                 d~object LIKE 'AB%' AND
                 d~typ    = 'E'      AND
                 d~langu  = @langu
           INTO CORRESPONDING FIELDS OF TABLE @documents.
  ENDMETHOD.
ENDCLASS.


### abenabap-testcockpit_guidl.htm

---
title: "ABAP Test Cockpit"
description: |
  Background ABAP Test Cockpit (ATC) is a framework that is integrated into ABAP Workbench and the ABAP Development Tools (ADT)(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadt_glosry.htm 'Glossary Entry'); it simplifies considerably the handling of the tests required during develo
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap-testcockpit_guidl.htm"
abapFile: "abenabap-testcockpit_guidl.htm"
keywords: ["do", "if", "try", "abenabap", "testcockpit", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [ABAP-Specific Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_specific_rules_gdl.htm) →  [Checks for Correctness](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencheck_correctness_gdl.htm) → 

ABAP Test Cockpit

Background

ABAP Test Cockpit (ATC) is a framework that is integrated into ABAP Workbench and the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadt_glosry.htm "Glossary Entry"); it simplifies considerably the handling of the tests required during development. ATC makes it possible to execute and display results for various tests on development objects, for example:

-   Extended program checks
-   Static performance tests
-   Unit tests with ABAP Unit
-   Static usability tests
-   Package checks
-   Security checks

Whereas Code Inspector is only integrated into the [ABAP development environment](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dev_envir_glosry.htm "Glossary Entry") by way of the [standard check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencode_inspector_guidl.htm "Guideline") and can otherwise only be used by calling a separate transaction, ATC is completely integrated into Object Navigator and Transport Organizer, and is available there for tests during development. ATC allows quality managers to perform mass tests. In the [ABAP Development Tools (ADT)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadt_glosry.htm "Glossary Entry"), some tests are provided only from ATC.

Rule

Configure and use ABAP Test Cockpit correctly

If ABAP Test Cockpit is available in your system, make sure that an ATC run is performed on all involved development objects and that no messages are displayed before you release the objects for transport. The ATC check should be integrated directly into the transport release.

Details

ATC is a tool that can be used both by SAP developers and as part of central quality assurance management. For example, if a developer checks all development objects of a package in the development system using the same ATC configuration used by a quality manager as part of a mass run in a consolidation system, all messages can be taken care of without having to wait for feedback from the quality manager.

If ATC is configured correctly, the above rule includes the previous rules for [syntax warnings](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensyntax_check_guidl.htm "Guideline"), [extended program checks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm "Guideline"), and [Code Inspector](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencode_inspector_guidl.htm "Guideline").

Hints

-   More specifically, the security checks in the [extended program check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_glosry.htm "Glossary Entry") can be executed and managed from ATC, which makes their integration into the transport release possible.
-   Outside of SAP, ATC is available from the following releases:
    -   AS ABAP 7.0, EhP2, Support Package 12
    -   AS ABAP 7.0, EhP3, Support Package 05
    -   AS ABAP 7.3, EhP1, Support Package 05
    -   AS ABAP 7.4, Support Package 02


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Formatting the Source Code

**Files**: 5 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Formatting the Source Code

Included pages: 5


### abenformatting_code_gdl.htm

---
title: "Formatting the Source Code"
description: |
  The readability of source code is dependent to a great extent on formatting that highlights its logical structure. The following methods help to format source code in a clear way. -   Case(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlower_upper_case_guidl.htm 'Guideline') -   S
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenformatting_code_gdl.htm"
abapFile: "abenformatting_code_gdl.htm"
keywords: ["do", "case", "method", "abenformatting", "code", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) → 

Formatting the Source Code

The readability of source code is dependent to a great extent on formatting that highlights its logical structure. The following methods help to format source code in a clear way.

-   [Case](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlower_upper_case_guidl.htm "Guideline")
-   [Statements per Program Line](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstatement_guidl.htm "Guideline")
-   [Using Pretty Printer](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_pretty_printer_guidl.htm "Guideline")
-   [Line Width](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenline_width_guidl.htm "Guideline")

Continue
[Case](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlower_upper_case_guidl.htm)
[Statements per Program Line](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstatement_guidl.htm)
[Using Pretty Printer](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_pretty_printer_guidl.htm)
[Line Width](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenline_width_guidl.htm)


### abenlower_upper_case_guidl.htm

---
title: "Case"
description: |
  Background In contrast to many other modern programming languages, ABAP is not case-sensitive for ABAP words (tokens of an ABAP statement that express its semantics; either ABAP keywords or additions) nor for operators and names of operands. The only exception is dynamic programming(https://help.s
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlower_upper_case_guidl.htm"
abapFile: "abenlower_upper_case_guidl.htm"
keywords: ["do", "if", "case", "try", "class", "data", "types", "abenlower", "upper", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Formatting the Source Code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenformatting_code_gdl.htm) → 

Case

Background

In contrast to many other modern programming languages, ABAP is not case-sensitive for ABAP words (tokens of an ABAP statement that express its semantics; either ABAP keywords or additions) nor for operators and names of operands. The only exception is [dynamic programming](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_types_objects_guidl.htm "Guideline"), where the names of operands usually have to be specified in uppercase.

Rule

Do not mix uppercase and lowercase in names

Use only lowercase or uppercase in an individual token. Use uppercase for keywords and lowercase for operands.

Details

The usage of uppercase or lowercase for tokens, that is ABAP words and names, used to be a very important aspect for the formatting of the source code. Uniform case-sensitivity made it easier for the reader to distinguish keywords from names. Due to the source code coloring in the syntax in ABAP Editor, this aspect has become less important; however, the above rule is still valid because of the following reasons:

-   Source code coloring in the syntax is generally not visible when source code is printed. Therefore, uniform case-sensitivity is useful here for emphasizing the difference between keywords and names.
-   Since case-sensitivity in ABAP source code is not significant in the syntax outside of character literals (that is, text field literals in single quotes ('), string literals in backquotes (\`), and string templates in vertical bars (|)), the [ABAP development environment](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dev_envir_glosry.htm "Glossary Entry") is not designed to maintain it permanently outside the mentioned constructs. Pretty Printer only offers the alternatives to use only lowercase or only uppercase, or to use either uppercase or lowercase for keywords and lowercase or uppercase respectively for names in operand positions.

Because of the second point, it does not make sense in ABAP to use uppercase and lowercase as a self-defined means of style. In other words, the names should not be written in mixed case style (also referred to as camel case style; see the following example), as is very popular in languages that are case-sensitive. A consistent notation cannot be ensured due to the missing relevance in the syntax. A mixed notation will be lost sooner or later when Pretty Printer is used, even if this is unintentional. Moreover, it possibly prevents other developers from using Pretty Printer after changes have been made to the source code. Use of [Pretty Printer](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_pretty_printer_guidl.htm "Guideline") is explicitly recommended.

Hint

The built-in string functions, to\_mixed and from\_mixed, allow conversions between names in ABAP style with underscores and names in mixed case style or camel case style, which can be helpful for data exchange with external systems.

Example

When the program PGL\_UPPER\_LOWER\_CASE is executed, source code is displayed in ABAP Editor; the upper part shows the declaration of a class with names in mixed case style or camel case style. Here, uppercase marks the beginnings of words within a combined name.

The code provided here as a bad example approximately follows the Java convention, and in the eyes of many beholders it might look better than the following good example. However, its appearance is less important than the technical restrictions mentioned, which do not currently allow naming like this. Executing Pretty Printer would irreversibly spoil the code's appearance because the names would then be illegible.

The lower part of the source code shows the declaration of a class in ABAP style, where which words within combined names are separated by underscores (\_). These separations cannot get lost when Pretty Printer is used.

Once the program has been called, the example is formatted according to the proposed Pretty Printer [setting](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_pretty_printer_guidl.htm "Guideline"), with ABAP words in uppercase and operands in lowercase. Regardless of its configuration, the separation of the words in the names would be preserved after each execution of Pretty Printer.


### abenstatement_guidl.htm

---
title: "Statements per Program Line"
description: |
  Background An ABAP statement (declaration or executable statement) is closed with a period. This statement can be followed by further statements in the same line. Statements can also span multiple lines. Rule Maximum of one statement per program line Write a maximum of one statement in every source
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstatement_guidl.htm"
abapFile: "abenstatement_guidl.htm"
keywords: ["select", "loop", "do", "if", "try", "method", "class", "data", "abenstatement", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Formatting the Source Code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenformatting_code_gdl.htm) → 

Statements per Program Line

Background

An ABAP statement (declaration or executable statement) is closed with a period. This statement can be followed by further statements in the same line. Statements can also span multiple lines.

Rule

Maximum of one statement per program line

Write a maximum of one statement in every source code line. Long statements can and should be split at suitable places. This means the statements can be divided up across consecutive lines.

Details

Using multiple statements in one line makes the source code harder to read. If a line contains an entire control structure, the lack of indentations makes it especially difficult to identify the logical structure. Therefore you should try to avoid using more than one statement in a program line.

Besides reduced readability, using multiple statements in one line can also make the code more difficult to debug. Even in single steps, ABAP Debugger stops a maximum of once per executable program line. This makes it impractical for the debugging process if there is more than one statement in a line.

If a statement spans [multiple lines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenline_width_guidl.htm "Guideline") (which occurs frequently due to the potential length of complex ABAP statements), there should be no empty lines between the parts of the statement. The breaks in the statement should occur at semantically suitable places so that groups with a similar semantic meaning are next to each other, if possible. Indentations should be used to ensure that the statement is as well structured and readable as possible.

Bad Example

The following source code shows a program section with correct syntax but that is poorly laid out and difficult to understand. Even the [Pretty Printer](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_pretty_printer_guidl.htm "Guideline") can barely improve the layout of the pattern shown here.

CLASS class DEFINITION.
  PUBLIC SECTION. METHODS meth. ENDCLASS.

CLASS class IMPLEMENTATION. METHOD meth.
  DATA: itab TYPE TABLE OF dbtab, wa TYPE dbtab.
  SELECT \* FROM dbtab WHERE column = ' ' INTO TABLE @itab.
  IF sy-subrc <> 0. RETURN. ENDIF.
  LOOP AT itab INTO wa. ... ENDLOOP.
  ENDMETHOD. ENDCLASS.

Good Example

The following source code shows the same code as above but with the recommended limit of one statement per line. The complex SELECT statement contains numerous clauses and hence spans multiple consecutive lines.

CLASS class DEFINITION.
  PUBLIC SECTION.
    METHODS meth.
ENDCLASS.

CLASS class IMPLEMENTATION.
  METHOD meth.
    DATA: itab TYPE TABLE OF dbtab,
          wa   TYPE dbtab.
    SELECT \*
           FROM dbtab
           WHERE column = ' '
           INTO TABLE @itab.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    LOOP AT itab INTO wa.
       ...
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.


### abenuse_pretty_printer_guidl.htm

---
title: "Using Pretty Printer"
description: |
  Background The alignment of ABAP statements in the source code is not defined in the syntax. There should be a maximum of one statement per line(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstatement_guidl.htm 'Guideline'), which can be technically indented and wrapped as require
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_pretty_printer_guidl.htm"
abapFile: "abenuse_pretty_printer_guidl.htm"
keywords: ["select", "insert", "loop", "do", "if", "case", "method", "class", "data", "abenuse", "pretty", "printer", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Formatting the Source Code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenformatting_code_gdl.htm) → 

Using Pretty Printer

Background

The alignment of ABAP statements in the source code is not defined in the syntax. There should be a [maximum of one statement per line](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstatement_guidl.htm "Guideline"), which can be technically indented and wrapped as required. This makes control structures visible. By inserting blank lines, related source code sections can be grouped, which makes the code easier to read. Note that, in ABAP statements, blanks cannot be added or left out at random. For example, tokens must be separated by at least one blank (especially with operands and operators). In a method call, no blanks are allowed between the name of the method and the opening parenthesis.

Languages with a C-like syntax (where statement blocks within control structures are delimited by curly brackets) provide an inexhaustible source for discussions on how to best make indentations. However, for ABAP the solution is obvious: Every initiating statement (such as IF) has an associated concluding statement (in this case, ENDIF). Event blocks for ABAP runtime framework events are the only exception here. They are introduced by a statement (such as START-OF-SELECTION) but are not concluded with the associated concluding statement. Instead, they are concluded with the next event block. However, [event blocks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") should only be used in exceptional cases. Initiating and concluding statements are aligned at the same level; the block content is indented.

Pretty Printer can modify the indentation of control structures and the capitalization of keywords and names in the source code at any time (even in display mode).

Rule

Use Pretty Printer consistently and universally

Use Pretty Printer to format source code consistently. If Pretty Printer cannot format the code as required, manual changes are necessary.

Details

We recommend that the use of Pretty Printer to make indentations required to make the source code easy to read. This guarantees that the indentations are consistently based on the logical control structure and that the indentation depth is identical for each program. Implementing this type of formatting by hand is prone to errors and not recommended.

Even though Pretty Printer can be used to adapt the source code to any other style (using the available settings), a consistent and universal style should be selected. The reason for this is that version management and the correction workbench are not designed to ignore purely stylistic differences between source code versions. Therefore, the following Pretty Printer settings are recommended for consistent source code formatting. These settings cover the expectations and working habits of most ABAP developers:

-   Indent statements
    
    Absolutely essential for a logical program structure that is clearly visible. A [maximum of one statement per program line](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstatement_guidl.htm "Guideline") is allowed.
    
-   Do not insert standard comments
    
    The standard comment only contains redundant information and it is not adapted, if the source code is changed.
    
-   Uppercase keywords
    
    Makes it easier to [understand the source code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlower_upper_case_guidl.htm "Guideline") in printed form. In this case, syntax color-coding is usually not visible.
    

The code needs to be edited manually, to ensure the correct use of blank lines between related source code blocks. Syntax units, such as classes, methods, control blocks, or semantic units of a program, should be separated from one another with one or two blank lines (depending on their size and meaning). However, there should not be more than two blank lines in succession.

Note

We recommend that the use of the Keyword Lowercase setting in Pretty Printer, for reasons of visual clarity. This is because repository object names and data objects names in the ABAP Debugger are displayed in uppercase, in all tools required for ABAP development. With the Keyword Lowercase setting, the source code format matches this display format. For example, reading COLUMN columns form a DBTAB database table:

select COLUMN1 COLUMN2 ...
       from DBTAB
       into corresponding fields of ITAB
       where COLUMN = FIELD.

Names in uppercase are also more suitable because many dynamic operand positions in ABAP still require uppercase. A good example is an almost static call of function modules. Using the Keyword Lowercase setting, the call of a function module FUNCTION\_MODULE would be as follows:

call function 'FUNCTION\_MODULE' exporting PARAMETER = FIELD.

However, the Keyword Lowercase setting was added to Pretty Printer relatively late and could not compete against the more common setting Keyword Uppercase. In addition, the ABAP syntax diagrams and sample programs in ABAP documentation, as well as all relevant publications, are formatted with the Keyword Uppercase setting. If we recommended the use of the Keyword Lowercase setting, this would lead to confusion and would not help the programming guidelines to be universally accepted.

Bad Example

The following source code shows the above example, but without indentations and only with lowercase. The highlighted ABAP words (shown in bold here and in color in the ABAP Editor) might not appear in a program printout. This would make the program even less legible.

class class definition.
public section.
methods meth.
endclass.
class class implementation.
method meth.
data: itab type table of dbtab,
wa type dbtab.
select \*
from dbtab
into table itab
where column = ' '.
if sy-subrc <> 0.
return.
endif.
loop at itab into wa.
...
endloop.
endmethod.
endclass.


### abenline_width_guidl.htm

---
title: "Line Width"
description: |
  Background The maximum line width of an ABAP program is restricted to 255 characters. Rule Do not use full line width Limit the width of a line in the source code to a reasonable size. As a rule of thumb, you should be able to print a program on common paper formats without truncation or line breaks
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenline_width_guidl.htm"
abapFile: "abenline_width_guidl.htm"
keywords: ["do", "method", "abenline", "width", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Formatting the Source Code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenformatting_code_gdl.htm) → 

Line Width

Background

The maximum line width of an ABAP program is restricted to 255 characters.

Rule

Do not use full line width

Limit the width of a line in the source code to a reasonable size. As a rule of thumb, you should be able to print a program on common paper formats without truncation or line breaks.

Details

Whereas the old restriction to 72 characters was too strict, the full utilization of the 255 characters that are now available would not make a program any more legible. Although very large monitors are now available, it can still be necessary, for example, for code inspections or reviews, to print a program or program section. It is therefore advisable to break long [statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstatement_guidl.htm "Guideline") at suitable positions and to distribute long literals across multiple lines using the literal operator (&) or the concatenation operator (&&).

Note

The example programs in the documentation are restricted in width in a natural way, which makes them legible at the same time. Unfortunately this sometimes means using shorter [names](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentelling_names_guidl.htm "Guideline") than would actually be possible.

Example

In the first method of the program PGL\_PROGRAM\_LINE\_WIDTH, a very long literal is assigned to the return value. The literal is not displayed completely even on very wide screens, and in the printout it will be broken up or even truncated.

The second method uses a literal whose content is identical to the one of the previous method; here, however, it is composed of multiple shorter literals using the literal operator &. The literal is split at appropriate positions, and the method becomes more legible both on the screen and the printout.


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Comments

**Files**: 4 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Comments

Included pages: 4


### abencomments_gdl.htm

---
title: "Comments"
description: |
  Comments do not affect how a program is executed and are ignored by the computer. People who work with the source code, however, benefit greatly from comments, since they make the code easier to understand. There are two categories of comments in ABAP: -   Comment lines A comment line contains a com
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomments_gdl.htm"
abapFile: "abencomments_gdl.htm"
keywords: ["do", "abencomments", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) → 

Comments

Comments do not affect how a program is executed and are ignored by the computer. People who work with the source code, however, benefit greatly from comments, since they make the code easier to understand.

There are two categories of comments in ABAP:

-   Comment lines
    
    A comment line contains a comment and nothing else. It can be defined either by the \* character at the start of the program line, or by the " character at any point of a program line blank to its left.
    
-   End of line comments
    
    An end of line comment is a comment added using the " character and located on the right of an ABAP statement or part of an ABAP statement.
    

A comment line or end of line comment can have any content and this content is ignored when the program is generated using ABAP Compiler.

-   [Language of Comments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomment_langu_guidl.htm "Guideline")
-   [Content](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontent_guidl.htm "Guideline")
-   [Arrangement in the Source Code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarrange_guidl.htm "Guideline")

Continue
[Language of Comments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomment_langu_guidl.htm)
[Content](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontent_guidl.htm)
[Arrangement in the Source Code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarrange_guidl.htm)


### abencomment_langu_guidl.htm

---
title: "Language of Comments"
description: |
  Background The natural language that has established itself worldwide for computer programming is English. This is because the language elements in all significant programming languages have been taken from English and their syntax based on English grammar. ABAP is no exception. In fact, efforts hav
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomment_langu_guidl.htm"
abapFile: "abencomment_langu_guidl.htm"
keywords: ["do", "while", "if", "case", "try", "abencomment", "langu", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Comments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomments_gdl.htm) → 

Language of Comments

Background

The natural language that has established itself worldwide for computer programming is English. This is because the language elements in all significant programming languages have been taken from English and their syntax based on English grammar. ABAP is no exception. In fact, efforts have been made to guarantee correct English by giving additions of related statements different names, even if they have the same meaning. Well-known examples include the (now obsolete) additions VARYING and VARY of the statements DO and WHILE. Here, ABAP can even be viewed as a subset of the English language.

Rule

Write program comments in English

Write all comments in ABAP programs in English only, so that as many readers as possible can understand them and benefit from them.

Details

English comments are a basic prerequisite for distributed development at an international level. There are other good reasons for using English as the comment language:

-   If names are in [English](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenname_langu_guidl.htm "Guideline"), the statements of an ABAP program can be considered (with a little good will) to be English sentences. For the reader, English comments are best suited for the source code. If comments in another language were used, this would result in a continuous switching between the languages, which would be exhausting even for readers who can speak the languages used.
-   Frequently, the unwanted [retelling comments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontent_guidl.htm "Guideline") are very similar to the described ABAP statements if they are written in English. This way, the author quickly realizes that his comment is superfluous.

Exception

Technical terms that originate from country-specific legislation (such as "Abgeltungssteuer" in German) or specific abbreviations (such as DÜVO) cannot be translated meaningfully or would no longer be recognizable after translation. Such terms should be placed in quotation marks and not be translated into English. In this case, it should be noted that [country-specific characters](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencharacter_set_guidl.htm "Guideline") can be replaced with 7-bit ASCII characters. The goal of the above rule is to enable as many users a possible to follow the program flow. This is still possible if non-IT terms are worded in another language.

Note

This rule applies regardless of the [original language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenoriginal_langu_guidl.htm "Guideline") chosen.

Bad Example

The following source code shows a typical example of German comments, mixed with English terms, which usually do not even follow the required notation or terminology.

"Horizontales Splittercontrol im Hilfecontainer
CREATE OBJECT splitter\_h
  EXPORTING
    parent = help\_container
    rows = 1
    columns = 2.

"Vertikales Splittercontrol im linken Container
CREATE OBJECT splitter\_v
  EXPORTING
    parent = container\_left
    rows = 2
    columns = 1.

Good Example

The following source code shows the above source code with English comments, as set out in the above rule.

  "Horizontal splitter control in help container
CREATE OBJECT splitter\_h
  EXPORTING
    parent = help\_container
    rows = 1
    columns = 2.

  "Vertical splitter control in left container
CREATE OBJECT splitter\_v
  EXPORTING
    parent = container\_left
    rows = 2
    columns = 1.

The goal of this example is to show the difference between German and English comments. If more meaningful [names](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentelling_names_guidl.htm "Guideline") had been chosen, that is splitter\_horizontal instead of splitter\_h, and so on, comments could be dispensed with altogether, thus complying with the following [rule](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontent_guidl.htm "Guideline").


### abencontent_guidl.htm

---
title: "Content"
description: |
  Background It is usually sufficient to examine the ABAP statements to find out what happens in an implementation. However, it much more difficult to find out why something happens. This is often only possible in a much wider context and requires a great deal of effort. Rule Make meaningful comments
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontent_guidl.htm"
abapFile: "abencontent_guidl.htm"
keywords: ["select", "do", "if", "case", "method", "class", "abencontent", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Comments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomments_gdl.htm) → 

Content

Background

It is usually sufficient to examine the ABAP statements to find out what happens in an implementation. However, it much more difficult to find out why something happens. This is often only possible in a much wider context and requires a great deal of effort.

Rule

Make meaningful comments

Write comments for your implementations that describe why something is done and not how.

Details

The best case scenario is where meaningful [identifiers](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennaming_gdl.htm) are used in the source code; the source code effectively documents itself. This is the best way to document the concept of "what happens in this program section". In this case, any additional comments that only describe obvious behavior are superfluous and do not make the code easier to understand. There is also the risk that when changes are made to the program logic, the associated comments are not adapted and are therefore no longer correct. In summary, these comments are not only useless but can even be misleading and should be avoided from the start.

Conversely, developers often tend to assume that their source code is sufficiently self-documenting and leave out descriptive comments. However, this assumption is often incorrect. This becomes apparent when a third party tries to understand the source code (either when attempting to enhance the source code or identify a problem). Even the authors of the code can often face this problem, if they are confronted with source code that they wrote a long time ago and have not seen the source code since.

Even if the identifier names allow readers to easily follow what happens in the code, the question "why" often remains unanswered. Therefore, this information must be provided as comments in the source code. This also includes a description of the algorithms used or at least a list of their names.

Hint

This section mainly deals with commenting the implementation of functions.. Header comments play a different role. Such comments, usually in the form of line comments that start with an asterisk (\*), subdivide large source codes into meaningful sections and can contain administrative entries. Here the rule also applies that these comments should not repeat what is already clearly described in the source code or described by any other means. For example, the person who last changed the program or the change date is indicated in the program attributes. A header comment with the name of a class or method directly above the class or method is also redundant information. However, it makes more sense to differentiate between logical program parts, which cannot be indicated in the code. For example, you can subdivide the program into a global declaration part and an implementation part. Usually, this is only required if the program is not subdivided by [include programs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensource_code_modular_guidl.htm "Guideline").

Bad Example

The meaning of the comments in the following source code is actually already perfectly obvious due to the commented statements.

"Select udat, stime from trdir
"into change\_date, change\_time
SELECT SINGLE udat, stime
       FROM trdir
       WHERE name = @prog\_name
       INTO (@change\_date, @change\_time).

"Set version\_date, version\_time to change\_date, change\_time
IF sy-subrc = 0.
   IF change\_date > version\_date.
      version\_date = change\_date.
      version\_time = change\_time.
   ELSEIF change\_date = version\_date AND
          change\_time > version\_time.
   version\_time = change\_time.
  ENDIF.
ENDIF.

Good Example

In the following source code, the comments in the above example have been replaced with a description of why something happens.

"If a newer program exists, version time stamp must
"be adjusted to program time stamp
SELECT SINGLE udat, stime
       FROM trdir
       WHERE name = @prog\_name
       INTO (@change\_date, @change\_time).

IF sy-subrc = 0.
   IF change\_date > version\_date.
      version\_date = change\_date.
      version\_time = change\_time.
   ELSEIF change\_date = version\_date AND
          change\_time > version\_time.
   version\_time = change\_time.
  ENDIF.
ENDIF.


### abenarrange_guidl.htm

---
title: "Arrangement in the Source Code"
description: |
  Background The arrangement of comments plays an important role (in addition to comment language and comment content) in making programs easy to read. Rule Arrange comments correctly Place comments in front of the statements that they describe. The horizontal arrangement of comments should follow the
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarrange_guidl.htm"
abapFile: "abenarrange_guidl.htm"
keywords: ["loop", "do", "while", "if", "case", "method", "class", "data", "abenarrange", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Comments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomments_gdl.htm) → 

Arrangement in the Source Code

Background

The arrangement of comments plays an important role (in addition to comment language and comment content) in making programs easy to read.

Rule

Arrange comments correctly

Place comments in front of the statements that they describe. The horizontal arrangement of comments should follow the indentations of the source code. End of line comments should only be placed after declarative or concluding statements.

Details

Vertical positioning
In general, when users read source code, they prefer to view the comment first and then the described statements. This arrangement means that the correlation between the comment and the associated source code passage is intuitively clear.

For control structures, this means that comment lines directly before a control statement (such as IF or WHILE) refer to the associated condition and comment lines after the control statement refer to the associated statement block. Comment lines directly before an ELSE or WHEN OTHERS statement have obviously been put in the wrong place.

End of line comments
End of line comments are problematic in conjunction with executable statements. Individual executable program lines are usually not complex enough to justify a separate comment for each one. If you add end of line comments, they will often be [unwanted](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontent_guidl.htm "Guideline") repetitions of what the statements clearly indicate already. In addition, these comments tend to be cryptic and unclear, because the ends of lines does not provide enough space for meaningful comments in most cases. A uniform alignment for end of line comments can only be achieved with a high degree of effort.

Therefore, you should make comments for entire statement blocks. Use self-contained comment lines to do this. This is because it is difficult to describe a reference to more than one statement line if you use end of line comments.

End of line comments are suitable for the following situations:

-   To comment on declarative statements
-   To indicate block ends (separate from indentations) in larger control structures
-   To justify pseudo comments (at the relevant places) for hiding messages from the extended program check or [Code Inspector](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencode_inspector_guidl.htm "Guideline").

The pseudo comments for hiding warnings of the extended program check and [Code Inspector](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencode_inspector_guidl.htm "Guideline") play a special role. They are not comments in the usual sense of the word. They are program directives that must be appear in the same lines as the commented statements to take full effect. These pseudo comments were replaced by pragmas for the extended program check.

Indentations
Formatting source code using indentations is essential. Otherwise the human reader cannot understand the logical structure. This formatting is required by the rule for using the [pretty printer](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_pretty_printer_guidl.htm "Guideline"). However, if comments are added in the source code that do not follow this formatting, they hide the logical structure and make the code difficult to read. Therefore, comment lines must have the same indentation as the statement lines that they relate to.

These indentations can only be achieved using comments that start with a quotation mark ("), because this character can be in any position. A comment line that starts with an asterisk (\*) must always be in the first position. It is therefore strongly recommended that you start all comments used in procedures ([methods](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_operand_position_guidl.htm "Guideline")) with a quotation mark and the correct indentation. Comment lines that start with a quotation mark must not be confused with end of line comments, which are appear after different code.

Comment lines that start with an asterisk should only be used for head comments of classes and procedures. Here they help to [subdivide](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencontent_guidl.htm "Guideline") source code into logical sections. In addition, they are useful for temporarily disabling statements by commenting them out. The commented-out code can be clearly distinguished from actually indented comments.

Bad Example

The following source code shows the implementation part of a class. The positioning of the comments does not follow the above rule.

CLASS application IMPLEMENTATION. "Application class
  METHOD main. "Main Method

\* Item data
  DATA items  TYPE STANDARD TABLE
              OF REF TO item.
DATA item\_ref LIKE LINE OF items.

\* Amount data
  DATA amount TYPE i.
  DATA total\_amount TYPE i.
  ...

\* Loop over all items to compute total amount
    LOOP AT items INTO item\_ref. "Loop over all items
      IF item\_ref IS BOUND AND
         item\_ref->is\_valid( ) = abap\_true. "Check validity
         amount = item\_ref->get\_amount( ). "Get amount
         ADD amount TO total\_amount. "Add amount to totals
          ...                                          "...
       ELSE.
          ...
      ENDIF.
    ENDLOOP.
    ...
  ENDMETHOD.
ENDCLASS.

Good Example

The following source code shows the same implementation part as above. However, the comments are positioned as recommended. Comment lines that start with an asterisk (\*) are used as header comments in the program structure. End of line comments only appear after declarations and block ends. All other comments appear in comment lines before the described statements and are indented accordingly.

\*----------------------------------------------------------\*
\* Class implementations
\*
\*----------------------------------------------------------\*

CLASS application IMPLEMENTATION.

\*----------------------------------------------------------\*
  METHOD main.
     DATA: items    TYPE STANDARD TABLE
                    OF REF TO item,     "Item table
           item\_ref LIKE LINE OF items. "Item reference
     DATA: amount TYPE i, "Amount per item
           total\_amount TYPE i. "Total amount of items
...

"Loop over all items to compute total amount
LOOP AT items INTO item\_ref.
  IF item\_ref IS BOUND AND
     item\_ref->is\_valid( ) = abap\_true.
     "Compute total amount for valid items
     amount = item\_ref->get\_amount( ).
     ADD amount TO total\_amount.
     ...
  ELSE.
  ENDIF. "item\_ref IS BOUND AND...
ENDLOOP.
...
ENDMETHOD. "main
\*----------------------------------------------------------\*
ENDCLASS. "application


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Program Structure and Procedure Structure

**Files**: 3 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Program Structure and Procedure Structure

Included pages: 3


### abenprogr_proc_structure_gdl.htm

---
title: "Program Structure and Procedure Structure"
description: |
  ABAP offers you a great deal of freedom when structuring your programs and procedures. Remember, however, that the finished product needs to be easy to maintain. -   Global Declarations of a Program(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenglobal_declar_guidl.htm 'Guideline')
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogr_proc_structure_gdl.htm"
abapFile: "abenprogr_proc_structure_gdl.htm"
keywords: ["do", "abenprogr", "proc", "structure", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) → 

Program Structure and Procedure Structure

ABAP offers you a great deal of freedom when structuring your programs and procedures. Remember, however, that the finished product needs to be easy to maintain.

-   [Global Declarations of a Program](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenglobal_declar_guidl.htm "Guideline")
-   [Local Declarations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlocal_declar_guidl.htm "Guideline")

Continue
[Global Declarations of a Program](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenglobal_declar_guidl.htm)
[Local Declarations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlocal_declar_guidl.htm)


### abenglobal_declar_guidl.htm

---
title: "Global Declarations of a Program"
description: |
  Background Each ABAP program has a global declaration part where data types, interfaces, classes, and data objects that are visible throughout the program can be declared. From a technical viewpoint, the global declaration part consists of all declarations that cannot be assigned to a more local con
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenglobal_declar_guidl.htm"
abapFile: "abenglobal_declar_guidl.htm"
keywords: ["select", "do", "if", "case", "try", "class", "data", "types", "abenglobal", "declar", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Program Structure and Procedure Structure](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogr_proc_structure_gdl.htm) → 

Global Declarations of a Program

Background

Each ABAP program has a global declaration part where data types, interfaces, classes, and data objects that are visible throughout the program can be declared.

From a technical viewpoint, the global declaration part consists of all declarations that cannot be assigned to a more local context (class, procedure). All declarations implemented in processing blocks without their own contexts (in event blocks and dialog modules) and declarations declared between completed processing blocks are assigned to the global context. Event blocks of GET and AT SELECTION-SCREEN events are exceptions. Variables declared here are only valid in the event block.

In an ABAP statement, it is only ever possible to refer to the previous declarations of the currently visible contexts.

Rule

Implement global declarations centrally

Place the global declaration part of a program at a central, context-related point at the beginning of the program.

Details

The global declaration part should only ever be the area between the program-initiating statement and the first implementation. This the only place where global declarations should be made in a meaningful order. This ensures that the declarations intended for global use can really be used in all subsequent implementations.

There should not be any declarative statements in contexts that do not support local data (provided that they are [still used](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline")). Otherwise, a false impression of local validity is created when the program is read, which may lead to the program not being correctly understood.

This rule is only of explicit relevance when working with program types other than class or interface pools. Class Builder implicitly specifies which declarations occur and where. These are the declarations of the global class or global interface itself as well as optional local data types, classes, and interfaces in [class pools](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlocal_type_glob_class_guidl.htm "Guideline"). The developer cannot directly access the master program of a class pool or interface pool. This is still the case even if the source code-based Class Builder is introduced, because it only shows the declaration and implementation of the global class.

For other [program types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_type_guidl.htm "Guideline") (subroutine pools, function pools, and executable programs), the developer can access the entire master program. If these program types are used, adherence to the rule is the developer's responsibility. The top include is helpful here. It is especially suited to all programs that are [organized](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensource_code_orga_gdl.htm) using include programs. The [top include](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentop_include_glosry.htm "Glossary Entry") is specially designed for the global declaration part and is therefore supported by ABAP Workbench and ABAP Compiler. ABAP Workbench creates and includes the top include automatically. The compiler incorporates the relevant top include into the syntax check for an individual include program. This enables meaningful syntax checks to be made on individual include programs.

If the top include is available, it should always be the first include program that a master program includes. The top include can also contain additional INCLUDE statements. The top include, and any include programs included in the top include, can only contain declarations and not implementations.

If [ABAP Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") are the main focus, the global declaration part or the top include should only contain declarations of local classes and interfaces, if the above rule is strictly adhered to. Data types should only be [declared](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendeclaration_dtypes_const_guidl.htm "Guideline") for classes and interfaces or in ABAP Dictionary. Global data objects are only required for communication with classical dynpros. Therefore they should only be used in the top include for function pools that encapsulate classic [dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenencap_class_interf_guidl.htm "Guideline").

Exception

The above rule can be mainly justified due to the visibility within the program and the validity of declarations. Strictly speaking therefore, it only applies to program types other than class pools. In class pools, the visibility outside of the class pool and the resulting [dependencies](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlocal_type_glob_class_guidl.htm "Guideline") are also important.

A further exception applies in the following situation: the local classes of a program are relatively independent units and their implementations do not refer to the declarations of other local classes. In this case, their declaration and implementation parts can be specified one after the other to improve readability.

Bad Example

The following source code shows a function pool for encapsulating a classic dynpro, after the include programs have been resolved. The two dialog modules contain data declarations that look like local declarations but have global validity. Static access to this type of data object is only possible below the declaration, which means the function module has no access to g\_input\_field, and the PBO module has no access to g\_ok\_code.

FUNCTION-POOL z\_screen.

DATA g\_start\_value TYPE c LENGTH 20.

FUNCTION z\_handle\_screen.
\*"------------------------------------------------------
\*"\*"Local Interface:
\*" IMPORTING
\*" REFERENCE(i\_start\_value) TYPE csequence OPTIONAL
\*"------------------------------------------------------
  g\_start\_value = i\_start\_value.
  CALL SCREEN 100.
ENDFUNCTION.

MODULE status\_0100 OUTPUT.
  DATA g\_input\_field TYPE c LENGTH 20.
  g\_input\_field = g\_start\_value.
ENDMODULE.

MODULE user\_command\_0100 INPUT.
  DATA g\_ok\_code TYPE sy-ucomm.
  CASE g\_ok\_code.
    WHEN '...'.
       ...
  ENDCASE.
ENDMODULE.

Good Example

The following source code shows the function pool from the above example, after the global declarations have been moved to a coherent global declaration part that follows the program-initiating statement. The additional global data object g\_start\_value is no longer required, and g\_ok\_code can be accessed in the PBO module.

FUNCTION-POOL z\_screen.

DATA: g\_input\_field TYPE c LENGTH 20,
      g\_ok\_code TYPE sy-ucomm.

FUNCTION z\_handle\_screen.
\*"------------------------------------------------------
\*"\*"Local Interface:
\*" IMPORTING
\*" REFERENCE(i\_start\_value) TYPE csequence OPTIONAL
\*"------------------------------------------------------
  g\_input\_field = i\_start\_value.
  CALL SCREEN 100.
ENDFUNCTION.

MODULE status\_0100 OUTPUT.
  CLEAR g\_ok\_code.
ENDMODULE.

MODULE user\_command\_0100 INPUT.
  CASE g\_ok\_code.
    WHEN '...'.
      ...
  ENDCASE.
ENDMODULE.


### abenlocal_declar_guidl.htm

---
title: "Local Declarations"
description: |
  Background Local declarations can be made in a procedure ( method(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm 'Guideline')). These are data types, data objects, and field symbols that are valid in the context of the procedure only. Therefore, th
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlocal_declar_guidl.htm"
abapFile: "abenlocal_declar_guidl.htm"
keywords: ["select", "loop", "do", "if", "method", "data", "types", "field-symbol", "abenlocal", "declar", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Program Structure and Procedure Structure](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogr_proc_structure_gdl.htm) → 

Local Declarations

Background

Local declarations can be made in a procedure ( [method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")). These are data types, data objects, and field symbols that are valid in the context of the procedure only. Therefore, they can only be addressed in the code of the procedure and are only available during the execution of the procedure (the data objects declared with STATICS are an exception).

Procedure-local declarations can be specified in any position of a procedure. However, the position of the declaration does not affect the validity area of the declared object (which always comprises the entire procedure), but only the static visibility.

Rule

Implement local declarations at the beginning of the procedure

Position the local declarations of a procedure ( [method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline") coherently and at the beginning of a procedure. The local declarations must not be distributed across the implementation of the procedure.

Details

Local declarations within a procedure ( [method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) are statically visible starting from the point of the program where they are positioned to the end of the procedure. However, because they are valid in the entire procedure, the declared entities can be accessed dynamically throughout the entire procedure. The following program example illustrates the different behavior:

METHOD demo\_method.
  FIELD-SYMBOLS <field\_symbol> TYPE any.
  ...
\* ASSIGN dobj TO <field\_symbol>. "Syntax error ...
  ASSIGN ('DOBJ') TO <field\_symbol>. "No error
  ASSERT <field\_symbol> IS ASSIGNED.
  ...
  DATA dobj TYPE i.
ENDMETHOD.

Because the different behavior of the [dynamic](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm) and the static variant of the ASSIGN statement is rather unexpected, all declarations are supposed to be carried out at the beginning of the procedure, that is, between the initiating and the first executable statement. Then, the static and the dynamic visibility sections match.

This rule contradicts the common recommendations for other programming languages. They recommend declaring local variables as close to their use as possible to tightly restrict their validity area. In ABAP, however, there is no block-local validity of local variables. Positioning a declaration within the statement block of a loop, for example, does not make it possible to restrict the validity of this declaration to this statement block. Rather, the variable is valid within the entire procedure. So a declaration at the position where it is used can be misleading to developers or readers of a program who are not aware of this.

According to the rule, [the size of a procedure](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenproc_volume_guidl.htm "Guideline") should be selected in such a way that the procedure remains clear for the reader, which means there is no good reason why all variables should not be declared as a whole at the beginning of a procedure.

Note

Within processing blocks that do not support any local data (dialog modules and event blocks), declarative statements must be [omitted completely](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenglobal_declar_guidl.htm "Guideline").

In [function modules and subroutines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline"), there should be no local data, only a method call.

Exception

[Inline declarations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendeclaration_inline_guidl.htm "Guideline") in procedures generally represent an exception. If used correctly, they can make a program easier to understand.

Bad Example

The following source code shows a local data declaration in a loop. Readers who are familiar with another programming language or even the developer of the program himself would probably expect the number variable to be set to value 10 for each loop pass. Indeed, number is set to 10 exactly once when the method starts because the variable is created only once for the context of the method and provided with a start value.

METHOD main.
  ...
  DO 10 TIMES.
    DATA number TYPE i VALUE 10.
    ...
    "number = 11, 13, 16, 20, ...
    number = number + sy-index.
    ...
  ENDDO.
  ...
ENDMETHOD.

Good Example

The following source code shows the corrected version of the above example, which behaves as the above example is expected to behave (if deeper ABAP knowledge is not involved). There is no block-local validity of data in ABAP, so proceed as shown below.

METHOD main.
  DATA number TYPE i.
  ...
  DO 10 TIMES.
    number = 10.
    ...
    "number = 11, 12, 13, 14, ...
    number = number + sy-index.
    ...
  ENDDO.
  ...
ENDMETHOD.


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Source Code Organization

**Files**: 3 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Source Code Organization

Included pages: 3


### abensource_code_orga_gdl.htm

---
title: "Source Code Organization"
description: |
  ABAP source code is saved in the ABAP Repository in the standard database(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_db_glosry.htm 'Glossary Entry') of an AS ABAP, and not in source code files like in most other programming environments. Source codes can be split into
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensource_code_orga_gdl.htm"
abapFile: "abensource_code_orga_gdl.htm"
keywords: ["do", "try", "data", "abensource", "code", "orga", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) → 

Source Code Organization

ABAP source code is saved in the ABAP Repository in the [standard database](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_db_glosry.htm "Glossary Entry") of an AS ABAP, and not in source code files like in most other programming environments. Source codes can be split into individual units by using include programs. There are also [macros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmacros_guidl.htm "Guideline") that are handled for callable modularization units in the context of these guidelines.

-   [Source code modularization](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensource_code_modular_guidl.htm "Guideline")
-   [Multiple use of include programs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmultiple_use_include_guidl.htm "Guideline")

Continue
[Source Code Modularization](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensource_code_modular_guidl.htm)
[Multiple Use of Include Programs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmultiple_use_include_guidl.htm)


### abensource_code_modular_guidl.htm

---
title: "Source Code Modularization"
description: |
  Background The unit in ABAP that corresponds to a source code file capable of being inserted into another program is known as an include program. Include programs are used for source code modularization and are inserted into compilation units for this purpose. Include programs are not compilation un
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensource_code_modular_guidl.htm"
abapFile: "abensource_code_modular_guidl.htm"
keywords: ["insert", "do", "if", "try", "method", "class", "abensource", "code", "modular", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Source Code Organization](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensource_code_orga_gdl.htm) → 

Source Code Modularization

Background

The unit in ABAP that corresponds to a source code file capable of being inserted into another program is known as an include program. Include programs are used for source code modularization and are inserted into compilation units for this purpose. Include programs are not compilation units (which means they cannot be compiled as standalone programs), but can be activated and transported separately. The [compilation units](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_type_guidl.htm "Guideline") of include programs (such as class pools, interface pools, function pools, subroutine pools, or executable programs) are compilation units in which, when compiled, an INCLUDE statement is replaced by the content of the specified include program.

Rule

Use include programs to modularize source code.

Distribute the source code of large ABAP programs across several include programs, remembering to choose a granularity for the modules that suits the structure of the program's structure.

Details

A suitable level of source code modularization using include programs makes it easier to develop and modify larger programs in several ways:

-   The lock management of ABAP Editor works at the level of include programs. In this way, several developers can make changes to a large program at the same time, as long as the source code sections in question are in different include programs.
-   Include programs are activated separately. This means that corrections or new developments in a compilation unit can be activated independently of each other, as long as they are in separate include programs.
-   Include programs can be transported separately. In this way, specific corrections can be distributed across a system landscape without the need to transport the entire compilation unit. This minimizes the potential for conflicts between correction levels.

The [ABAP development environment](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_dev_envir_glosry.htm "Glossary Entry") already provides modularization templates using includes for many compilation units. For example, the visibility sections and methods of global classes or function modules of a function pool are saved in separate include programs. The source code-based Class Builder displays the resolved include programs as a single programs, but saves each part separately. The top include for global declarations is also supported by ABAP Workbench and ABAP Compiler.

As well as this, you can perform manual modularization using include programs, if required. Here, you can perform some of the extra modularizations on the include programs defined by ABAP Workbench. Or you can create include programs for compilation units that are not modularized automatically (such as subroutine pools and executable programs).

Include programs that you create manually must contain a logically related section of the source code and this section must represent an independently maintainable and transportable unit. Logically related units such as individual procedures ([methods](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) or the declaration parts of local classes should not be distributed across multiple include programs, however. (The declaration parts of global classes are distributed automatically across multiple include programs, as specified by ABAP Compiler. There is no reason why ABAP developers should distribute local classes in the same way.)

Include programs you create manually should be named in accordance with the naming conventions of ABAP Workbench for automatically generated include programs. These conventions emphasize the relationship between the include program and the compilation unit and prevent include programs [from being used more than once](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmultiple_use_include_guidl.htm "Guideline").


### abenmultiple_use_include_guidl.htm

---
title: "Multiple Use of Include Programs"
description: |
  Background From a technical point of view, it is possible to use an include program multiple times by including it more than once into a compilation unit or different compilation units. Rule Do not use include programs more than once Use an include program for the modularization of exactly one compi
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmultiple_use_include_guidl.htm"
abapFile: "abenmultiple_use_include_guidl.htm"
keywords: ["select", "do", "if", "method", "class", "data", "types", "abenmultiple", "use", "include", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Source Code Organization](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensource_code_orga_gdl.htm) → 

Multiple Use of Include Programs

Background

From a technical point of view, it is possible to use an include program multiple times by including it more than once into a compilation unit or different compilation units.

Rule

Do not use include programs more than once

Use an include program for the modularization of exactly one compilation It must not be included into multiple different compilation units. Also, an include program should only be included once within a compilation unit.

Details

The multiple use of include programs is highly problematic conceptually. This particularly concerns the use of include programs for the reuse of:

-   Type definitions
-   Data declarations
-   Local classes
-   Procedure implementations

We strongly recommended using only suitable means for reuse, such as global classes or interfaces, for the reasons specified in the following sections.

Restricted maintainability
The inclusion of an include program into multiple compilation units dramatically restricts the maintainability both of the include program itself and of the compilation units using it. Changes to an include program like this can be unproblematic in the context of selected master programs, but can make other compilation units syntactically incorrect at the same time. This is particularly critical for compilation units that include such include programs that were developed in other systems.

Increased resource consumption
If compilation units that use shared include programs are executed at the same time, these include programs must be loaded multiple times by the ABAP runtime framework, which increases memory consumption. In the past, include programs were used multiple times for the central definition of constants, for example. Today, you should use a global interface or global class for this purpose. Because it is loaded only once, the memory consumption does not increase with every new use as it does with any multiple use of include programs.

The memory consumption also increases if an include program is used multiple times within one compilation unit (for example, through inclusion into the source code of multiple function modules of a function pool or into the source code of multiple methods of a class) because this expands the compilation unit unnecessarily. When using centrally defined, [standalone types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbound_independent_dtype_guidl.htm "Guideline") and storing required constants in suitable classes or interfaces, there remains no conceivable scenario where it would be useful to use include programs multiple times within a compilation unit.

Missing semantic context
Like source code files in other programming environments, include programs are included into a compilation unit as pure text and without any semantics. The semantics only emerge in the context of the compilation unit and the position where the include program is included. Consequently, especially class definitions that are included into different compilation units by using an include program result in different technical classes whose objects have different reference types and cannot be exchanged between the compilation units.

Bad Example

The following source code shows an include program that contains declarations of constants intended for use in multiple programs. According to the above rule, procedures of this type are no longer allowed.

\*&---------------------------------------------\*
\*& Include Z\_ORDERS\_OF\_MAGNITUDE
\*&---------------------------------------------\*
CONSTANTS:
  mega TYPE  p DECIMALS 6 VALUE '1000000.0',
  kilo TYPE  p DECIMALS 6 VALUE '1000.0',
  milli TYPE p DECIMALS 6 VALUE '0.001',
  micro TYPE p DECIMALS 6 VALUE '0.000001'.

Good Example

The following source code shows the same declarations of constants as in the above example, but this time in a global class suitable for reuse. Here, a corresponding ABAP Unit test method would even be possible that checks the consistency of the constants.

CLASS zcl\_orders\_of\_magnitude DEFINITION PUBLIC .
  PUBLIC SECTION.
    CONSTANTS:
      mega TYPE  p DECIMALS 6 VALUE '1000000.0',
      kilo TYPE  p DECIMALS 6 VALUE '1000.0',
      milli TYPE p DECIMALS 6 VALUE '0.001',
      micro TYPE p DECIMALS 6 VALUE '0.000001'.
ENDCLASS.


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Alternative Spellings

**Files**: 6 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Alternative Spellings

Included pages: 6


### abenalternative_spelling_gdl.htm

---
title: "Alternative Spellings"
description: |
  Some ABAP statements can be written with different spellings, but interpreted by the compiler in the same way. To make programming easier to understand, however, spellings should be kept the same, with alternative spelling used only in special situations. -   Alternative Language Constructs(https:
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenalternative_spelling_gdl.htm"
abapFile: "abenalternative_spelling_gdl.htm"
keywords: ["do", "if", "method", "abenalternative", "spelling", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) → 

Alternative Spellings

Some ABAP statements can be written with different spellings, but interpreted by the compiler in the same way. To make programming easier to understand, however, spellings should be kept the same, with alternative spelling used only in special situations.

-   [Alternative Language Constructs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenalternative_langu_guidl.htm "Guideline")
-   [Chained Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenchained_statements_guidl.htm "Guideline")
-   [Method Calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmethod_call_guidl.htm "Guideline")
-   [Assignments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassign_calc_guidl.htm "Guideline")
-   [Calculations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencalc_expresssion_guidl.htm "Guideline")

Continue
[Alternative Language Constructs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenalternative_langu_guidl.htm)
[Chained Statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenchained_statements_guidl.htm)
[Method Calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmethod_call_guidl.htm)
[Assignments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassign_calc_guidl.htm)
[Calculations](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencalc_expresssion_guidl.htm)


### abenalternative_langu_guidl.htm

---
title: "Alternative Language Constructs"
description: |
  Background Alternative language constructs are parts of statements that can be written in different ways. One reason for this are the constant new developments in the language. Often, new spellings are introduced and the old spellings retained for reasons of downward-compatibility. Rule Use consiste
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenalternative_langu_guidl.htm"
abapFile: "abenalternative_langu_guidl.htm"
keywords: ["do", "while", "if", "try", "method", "data", "types", "abenalternative", "langu", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Alternative Spellings](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenalternative_spelling_gdl.htm) → 

Alternative Language Constructs

Background

Alternative language constructs are parts of statements that can be written in different ways. One reason for this are the constant new developments in the language. Often, new spellings are introduced and the old spellings retained for reasons of downward-compatibility.

Rule

Use consistent spelling

If there is more than one spelling for a statement, choose one of these spellings and use it consistently throughout your development work. It is best to choose the spelling that most accurately reflects the semantics of the statement.

Details

To make your programming easier to understand, always choose the spelling that is most accurate and easiest to read, and which (where applicable) matches the spelling used in other statements. The following list contains some examples:

-   If you can choose from a range of comparison operators (\= or EQ, \> or GT, < or LT, \>= or GE, <= or LE) we recommend that you pick a type of operator and stick to it within the context of a program. The variant with the characters =, <, and > is seen as more modern, but also overloads these characters. The comparison operators that consist of two letters are better matched to other comparison operators such as CO, CN, and so on, which have no alternative forms.
-   The addition NOT of the [comparison operators](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrel_operator_glosry.htm "Glossary Entry") BETWEEN, IN, IS ASSIGNED, IS BOUND, IS INSTANCE OF, IS INITIAL, and IS SUPPLIED is a better option than the identical Boolean operator NOT, for improved readability. For example, the expression a IS NOT INITIAL is easier than the logically identical expression NOT a IS INITIAL. This corresponds to the definition of comparison expressions, where a <> b is more intuitive than NOT a = b.
-   The addition LENGTH len of the declarative statements DATA and TYPES is preferable to the length specified in parentheses (len). This then matches the spelling used in CREATE DATA ... LENGTH. In addition to this, it is easy to mistake the parenthesized form for [dynamic tokens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm). Only dynamic tokens should use this form.
-   The optional addition SUBSTRING of the statements FIND and REPLACE can be used to make a clearer distinction from the alternative addition PCRE*|*REGEX.
-   In ABAP SQL, comma-separated lists are preferable to lists without commas. Using commas as separators is the prerequisite for using expressions in lists. [Host variables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenhost_variable_glosry.htm "Glossary Entry") should always be indicated by the escape character @.
-   Within the parameter list of the statements EXPORT and IMPORT, use the equal sign (=) instead of the additions FROM or TO. The spelling then matches the spelling used in parameter lists in other calls, such as methods, functions modules, and transformations.
-   Always use the semantically identical addition ACTUAL LENGTH instead of the addition LENGTH of the statement READ DATASET. This makes the distinction from the similar addition MAXIMUM LENGTH clearer. The last two examples are typical of the way new additions are added to the language, while retaining the old spelling as a kind of short form for reasons of downward compatibility.

Bad Example

The following piece of source code shows how the statement FIND is used inconsistently within a program. The first and third FIND statements are alternative spellings with the same meaning.

DATA text TYPE string.
...
FIND '...' IN text.
...
FIND PCRE '...' IN text.
...
FIND SUBSTRING '...' IN text.
...

Good Example

The following piece of source code shows the same statements as in the example above, but with consistent spelling. This expresses the semantic distinction between searching for a substring and searching for a regular expression in clear syntax.

DATA text TYPE string.
...
FIND SUBSTRING '...' IN text.
...
FIND PCRE '...' IN text.
...
FIND SUBSTRING '...' IN text.
...


### abenchained_statements_guidl.htm

---
title: "Chained Statements"
description: |
  Background Successive ABAP statements that have the same starting part can be expressed in a chained statement. A chained statement consists of the identical starting part that is specified once and that is concluded by a colon (:). Behind this colon, the remaining parts are separated by commas (,).
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenchained_statements_guidl.htm"
abapFile: "abenchained_statements_guidl.htm"
keywords: ["select", "update", "do", "if", "case", "try", "catch", "method", "data", "types", "exception-handling", "abenchained", "statements", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Alternative Spellings](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenalternative_spelling_gdl.htm) → 

Chained Statements

Background

Successive ABAP statements that have the same starting part can be expressed in a chained statement. A chained statement consists of the identical starting part that is specified once and that is concluded by a colon (:). Behind this colon, the remaining parts are separated by commas (,). Only the last part is concluded with a period (.). During the syntax check and the compilation, a chained statement is handled like the respective sequence of individual ABAP statements, where the shared starting part is put in front of each remaining part. The identical starting parts are not restricted to the keyword.

Rule

Only use chained statements where appropriate

Use chained statements mainly for declarations. They should always be used for related declarations of type TYPES BEGIN OF ... TYPES END OF ....

Details

The main motivation for using chained statements is to increase the readability of programs. Using chained statements correctly in declarations achieves this goal. In other statements, chained statements can actually decrease the readability or, in the worst case, result in incorrect program behavior. When using chained statements, only [one statement at most should be specified per program line](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstatement_guidl.htm "Guideline"). Never span [expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexpression_glosry.htm "Glossary Entry") or functional calls across multiple parts of chained statements.

Declarations

In complex declarations, chained statements can be used to improve readability. (However, if local declarations are too complex, this suggests an [insufficient separation of tasks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenproc_volume_guidl.htm "Guideline"), and should not occur.) In particular, multiple chained statements can be used to group related declarations:

DATA:
   airplane            TYPE REF TO cl\_airplane,
   airplane\_attributes TYPE cl\_airplane=>airplane\_attributes.
DATA:
   airport            TYPE REF TO cl\_airport,
   airport\_attributes TYPE cl\_airport=>airport\_attributes.
...

The grouping of declarative statements that semantically represent a composite statement is even more important. For example, the declaration of structured types and data objects in ABAP is done using individual statements, whose close relationship should be expressed by a chained statement:

TYPES:
   BEGIN OF file,
     name TYPE string,
     owner TYPE sy-uname,
     creation\_date TYPE timestamp,
   END OF file.

For structures that copy components of another structure using the statements INCLUDE TYPE or INCLUDE STRUCTURE, this procedure cannot be used consistently because the beginning of the statement is different and therefore the chained statement must be interrupted. In any case, we [no longer recommend](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenincluding_structures_guidl.htm "Guideline") using the statement INCLUDE.

Operational Statements

For operational statements, however, chained statements are not recommended because they do not usually result in better readability. Example:

CALL METHOD meth EXPORTING para = : '1', '2', '3'.

Here, the exploitation of the fact that the same starting parts in front of the colon are not limited to the keyword was a little overdone. The following chained statement would be easier to read:

CALL METHOD:
meth EXPORTING para = '1',
meth EXPORTING para = '2',
meth EXPORTING para = '3'.

However, in this case the best [notation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmethod_call_guidl.htm "Guideline") can manage without a chained statement anyway:

meth( '1' ).
meth( '2' ).
meth( '3' ).

Unexpected Behavior

If chained statements are not understood correctly, this can easily produce statements with correct syntax but unexpected behavior. Prominent examples are initiating statements within control structures. Here, the use of chained statements does not usually lead to the intended result.

Let us look at the following TRY control structure, in which the CATCH statements are implemented using a chained statement:

TRY.
     ...
  CATCH: cx\_1, cx\_2, cx\_3.
     "exception handling
      ...
ENDTRY.

A reader and probably even a developer would assume that this is a CATCH block that handles three exceptions. In fact, the complete syntax is as follows:

TRY.
     ...
  CATCH cx\_1.
  CATCH cx\_2.
  CATCH cx\_3.
    "exception handling
     ...
ENDTRY.

The cx\_1 and cx\_2 exceptions are indeed caught, but the corresponding CATCH blocks are empty. Only the third exception cx\_3 has a CATCH block that is not empty. The syntax that the developer presumably intended is as follows:

TRY.
    ...
  CATCH cx\_1 cx\_2 cx\_3.
    "exception handling
    ...
ENDTRY.

For the WHEN blocks within a CASE control structure, the following applies:

WHEN: a, b, c.

is not equivalent to the more probable

WHEN a OR b OR c.

The [extended program check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm "Guideline") warns of empty statement blocks after CATCH and WHEN. In this way, the extended program check can be used to uncover where chained statements have been misused within TRY and CASE control structures.

Another example in which the use of chained statements can cause problems are ABAP SQL statements. Here are two examples:

-   The following chained statement consists of two SELECT statements that both supply a work area with values, and of which only the second one has a WHERE condition.
    
    SELECT SINGLE carrid, connid
           FROM spfli
           WHERE @carrid = '...'
           INTO: @carrid\_wa, @connid\_wa.
    

The following INTO clause was undoubtedly meant here:

INTO (@carrid\_wa, @connid\_wa).

-   In the following example, the seemingly single statement does not update the discount and the telephone number of the customer with the customer ID 00017777. Instead, these are in fact two statements, of which the first changes the discount for all customers and the second changes the telephone number of the customer with the customer ID 00017777.
    
    UPDATE scustom SET: discount = '003',
                        telephone = '0621/444444'
                   WHERE id = '00017777'.
    

Even if the previous examples of the chained statements would show the semantic that is expected by the developer, such use is not recommended in any case because each reader would probably expect a different program behavior, and the readability and maintainability of the source code would be impaired considerably.

Expressions and Function Calls

Unfortunately, ABAP statements can be spanned across the colon in chained statements, even within expressions or function calls. The following example with correct syntax shows what can happen here, even in the simplest of cases. This example cannot be understood and nor does it produce the expected result.

DATA: itab TYPE TABLE OF i,
      num  TYPE i.
itab = VALUE #(: ( 1 ) ), ( 2 ) ), ( 3 ) ), ( 4 ) ).
num  = itab\[: 1 \], 2 \], 3 \], 4 \].
cl\_demo\_output=>new(
  )->write\_data(: \`Text1\` ), \`Text2\` ), num
  )->display( ).


### abenmethod_call_guidl.htm

---
title: "Method Calls"
description: |
  Background Static calls of methods can be formulated in two different ways. The obsolete long form(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcall_method_static.htm) CALL METHOD meth EXPORTING ... is based on the notation of the function module call. Alternatively, a short for
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmethod_call_guidl.htm"
abapFile: "abenmethod_call_guidl.htm"
keywords: ["insert", "do", "if", "method", "class", "abenmethod", "call", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Alternative Spellings](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenalternative_spelling_gdl.htm) → 

Method Calls

Background

Static calls of methods can be formulated in two different ways. The [obsolete long form](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcall_method_static.htm)

CALL METHOD meth EXPORTING ...

is based on the notation of the function module call. Alternatively, a [short form](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcall_method_static_short.htm) can be used:

meth( ... ).

This form uses a parenthesis notation instead of the initiating ABAP words [CALL METHOD](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcall_method_static.htm). A combination of CALL METHOD and parentheses is also possible.

Rule

Formulate static method calls without CALL METHOD

Use the long form of the method call using CALL METHOD only for dynamic method calls.

Details

The short form of the static method call is clearer. The redundant ABAP words CALL METHOD provide no additional information to the reader. Using the short form, self-contained method calls have the same appearance as functional method calls on operand positions. For dynamic method calls, the long form with CALL METHOD is required by the syntax. If it is only used there, the different notations provide the reader with another distinguishing feature between the static and dynamic method call.

Bad Example

The following source code shows the long form of a static method call using CALL METHOD, which is no longer recommended.

...
CALL METHOD cl\_class=>do\_something
  EXPORTING
    some\_input = value1
  IMPORTING
    some\_output = value2
  CHANGING
    some\_change = value3.
...

The following source code shows the same static method call as above, but with parentheses inserted. In this form, which also has correct syntax, either CALL METHOD or the parentheses are superfluous.

...
CALL METHOD cl\_class=>do\_something(
  EXPORTING
    some\_input = value1
  IMPORTING
    some\_output = value2
  CHANGING
    some\_change = value3 ).
...

Good Example

The following source code shows the same method call as above, but as recommended, without CALL METHOD. If a method has only importing parameters, IMPORTING and CHANGING can be omitted, and also the EXPORTING addition. If it is a single importing parameter, its name can also be omitted.

...
cl\_class=>do\_something(
  EXPORTING
    some\_input = value1
  IMPORTING
    some\_output = value2
  CHANGING
    some\_change = value3 ).
...


### abenassign_calc_guidl.htm

---
title: "Assignments"
description: |
  Background For explicit assignments in which the value of a source is assigned to a target, ABAP contains the general assignment operator =(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenequals_operator.htm) and the special casting operator ?=(https://help.sap.com/doc/abapdocu_7
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassign_calc_guidl.htm"
abapFile: "abenassign_calc_guidl.htm"
keywords: ["do", "if", "try", "method", "data", "abenassign", "calc", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Alternative Spellings](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenalternative_spelling_gdl.htm) → 

Assignments

Background

For explicit assignments in which the value of a source is assigned to a target, ABAP contains the general assignment operator [\=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenequals_operator.htm) and the special casting operator [?=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapmove_cast.htm). Statements with these operators

lhs =*|*?= rhs.

enable assignments of

-   data objects,
-   return values or results of functional methods, built-in functions or construction expressions, table expressions and
-   results of calculation expressions (arithmetic expressions, bit expressions, and string expressions)

to be made to variables that can also be declared inline and to [writable expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenwritable_expression_glosry.htm "Glossary Entry").

Alongside the assignment operators, two obsolete statements exist for historical reasons that can also perform assignments:

-   The statement
    
    [MOVE source TO*|*?TO destination.](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapmove_obs.htm)
    
    assigns a source source to a target destination. It covers some of the operators performed by the assignment operators [\=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenequals_operator.htm) and [?=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapmove_cast.htm).
    
-   The statement
    
    [COMPUTE lhs =*|*?= rhs.](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcompute.htm)
    
    has the same semantics as lhs =*|*?= rhs. The keyword COMPUTE can be written in front of each assignment with the assignment operators [\=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenequals_operator.htm) and [?=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapmove_cast.htm) where the left side is not an inline declaration, but is ignored.
    

Rule

Assignments with the assignment operators \= and ?= only

Use the assignment operators instead of the statement MOVE. Do not use the keyword COMPUTE in front of assignments.

Details

Assignments with the assignment operators [\=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenequals_operator.htm) and [?=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapmove_cast.htm) implement the most global concept. The right side is a [general expression position](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneral_expr_position_glosry.htm "Glossary Entry") and the left side is a [declaration position](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendeclaration_position_glosry.htm "Glossary Entry") (except in down casts).

The statements MOVE and COMPUTE have the following drawbacks:

-   The statement MOVE cannot be used globally. The only sources allowed are data objects, function methods, and certain built-in functions whose arguments must be single data objects. The only targets allowed are variables; inline declarations are not possible. Any future enhancements to operand positions will not be applied to MOVE.
-   The keyword COMPUTE is both confusing and surplus to requirements. If an arithmetic expression or other calculation expression is on the right side, the keyword COMPUTE has the correct meaning, but is redundant. If a data object, a function method, a built-in function, or a constructor expression is on the right side, the keyword COMPUTE has the wrong meaning, since a return value is assigned instead of an expression being calculated.

The statements MOVE and COMPUTE were created at a time when assignments were only made between individual data objects and calculations were exclusively arithmetic. Neither of these statements is appropriate in a modern, expression-oriented ABAP program that exploits all options on the left and right sides of an assignments.

Hint

The optional addition EXACT of the statements [MOVE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapmove_obs.htm) and [COMPUTE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcompute.htm), which produces lossless assignments and lossless calculations, has been replaced in full by the lossless operator [EXACT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconstructor_expression_exact.htm).

Bad Example

The following source code shows a simple assignment using MOVE and the assignment of an arithmetic expression after COMPUTE.

DATA text1 TYPE string.
DATA text2 TYPE string.
...
MOVE text1 TO text2.
DATA result TYPE decfloat34.
DATA number1 TYPE i.
DATA number2 TYPE i.
...
COMPUTE result = number1 \* number2.

Good Example

The following source code shows the same example as above but without specifying the keywords MOVE and COMPUTE. This makes inline declarations possible on the left side.

DATA text1 TYPE string.
...
DATA(text2) = text1.
DATA number1 TYPE i.
DATA number2 TYPE i.
...
DATA(result) = CONV decfloat34( number1 \* number2 ).


### abencalc_expresssion_guidl.htm

---
title: "Calculations"
description: |
  Background In ABAP, the arithmetic operators(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarithmetic_operator_glosry.htm 'Glossary Entry') in arithmetic expressions(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarithmetic_expression_glosry.htm 'Glossary Entry')
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencalc_expresssion_guidl.htm"
abapFile: "abencalc_expresssion_guidl.htm"
keywords: ["do", "if", "try", "abencalc", "expresssion", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Alternative Spellings](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenalternative_spelling_gdl.htm) → 

Calculations

Background

In ABAP, the [arithmetic operators](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarithmetic_operator_glosry.htm "Glossary Entry") in [arithmetic expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarithmetic_expression_glosry.htm "Glossary Entry") are used for numeric calculations. [Calculation assignments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencalculation_assignment_glosry.htm "Glossary Entry") with the operators [+=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencalculation_assignments.htm), [\-=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencalculation_assignments.htm), [\*=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencalculation_assignments.htm), and [/=](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencalculation_assignments.htm) are available for the basic arithmetic operations. These operator formats are accompanied by the dedicated ABAP keywords ADD, SUBTRACT, MULTIPLY, and DIVIDE.

Rule

Use the operator format

For calculations, use the operator format with the operators (+=, \-=, \*=, or /=) instead of the ABAP keyword format.

Details

Calculations with the statements ADD, SUBTRACT, MULTIPLY, and DIVIDE do not allow expressions in the operand positions and are often more difficult to read than the corresponding operator format.

Bad Example

The following source code shows a multiplication using the statement MULTIPLY.

MULTIPLY n1 by n2.

Good Example

The following source code shows the same example as above, but in the more compact operator format.

n1 \*=  n2.


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Complexity

**Files**: 6 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Structure and Style / Complexity

Included pages: 6


### abencomplexity_gdl.htm

---
title: "Complexity"
description: |
  The aim of program complexity is to keep the source code as clear and readable as possible for the human reader. The computer has no problems with compiling or executing highly complex programs. Unformatted source code does also not constitute any problems. The human reader, however, is usually over
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomplexity_gdl.htm"
abapFile: "abencomplexity_gdl.htm"
keywords: ["do", "if", "case", "method", "class", "abencomplexity", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) → 

Complexity

The aim of program complexity is to keep the source code as clear and readable as possible for the human reader. The computer has no problems with compiling or executing highly complex programs. Unformatted source code does also not constitute any problems. The human reader, however, is usually overwhelmed by the program complexity.

High complexity in this context means, for example, voluminous procedures ([methods](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) and control structures with a very deep nesting or unclear classes without clearly defined tasks. The program complexity must not be confused with the complexity of the task that is handled by the program. Even if task complexity is very high, it is always possible to keep the program complexity manageable for individual procedures and classes by clearly [separating the tasks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenseperation_concerns_guidl.htm "Guideline").

To understand a program, the reader must be able to mentally trace the flow, and keep an eye on the different paths through the program that result from the control structure, under different external conditions. This is very difficult when dealing with voluminous procedures or deep nesting. In these situations, the program author may have been overwhelmed and consequently the program might contain errors. These situations increase the time required for corrections or further developments and the risk of errors. What makes the situation even more difficult is that testing complex procedures requires a great deal of time and effort, due to the high number of possible execution paths. Formulating a test case for every single execution path is often impossible due to the high number of paths.

-   [Expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexpression_guidl.htm "Guideline")
-   [Nesting Depth](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennesting_depth_guidl.htm "Guideline")
-   [Procedure Volume](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenproc_volume_guidl.htm "Guideline")
-   [Class Size](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenclass_size_guidl.htm "Guideline")
-   [Dead Code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendead_code_guidl.htm "Guideline")

Continue
[Expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexpression_guidl.htm)
[Nesting Depth](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennesting_depth_guidl.htm)
[Procedure Volume](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenproc_volume_guidl.htm)
[Class Size](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenclass_size_guidl.htm)
[Dead Code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendead_code_guidl.htm)


### abenexpression_guidl.htm

---
title: "Expressions"
description: |
  Background An expression is part of an ABAP statement that returns a result. An expression consists of one or more operands in combination with operators or special ABAP words. Expressions can be logical expressions constructed from relational expressions and also calculation expressions. The latter
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexpression_guidl.htm"
abapFile: "abenexpression_guidl.htm"
keywords: ["loop", "do", "if", "method", "data", "abenexpression", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Complexity](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomplexity_gdl.htm) → 

Expressions

Background

An expression is part of an ABAP statement that returns a result. An expression consists of one or more operands in combination with operators or special ABAP words. Expressions can be logical expressions constructed from relational expressions and also calculation expressions. The latter type is subdivided into arithmetic expressions, bit expressions, and string expressions. Data objects, other suitable expressions, and calls of built-in functions and functional methods can all be used as expression operands. In character string processing, regular expressions for searches and pattern comparisons are also used.

These expressions can be nested and combined in many different ways. Nested and chained calls are possible for functional methods. The maximum nesting depth of expressions is restricted to 32 by ABAP Compiler.

Rule

Limit the complexity of expressions

Use expressions at operand positions in a way that means the program remains legible and understandable.

Details

The diverse options for expressions mean that the use of helper variables is superfluous in many places. The use of expressions and functional calls at operand positions is useful under the following prerequisites:

-   The result of an expression or a calculation is required only once. If an intermediate result is required multiple times, it should only be calculated once and saved in a helper variable. (ABAP Compiler does not implicitly handle this task at the moment)
-   The data type of the result matches the operand position, or the conversion rules for an expression or call used at an operand position are suitable for the task to be implemented. If special type conversions must be performed, for example, for date or time fields, helper variables of an appropriate type might be required.

Programs should always be kept clear and legible.. Do not be too ambitious and combine everything into one single expression. If an expression becomes too complex, it should be split at suitable points, and the intermediate results should be saved in helper variables. This particularly applies to character string processing with string templates and to regular expressions. These are very powerful but they can also make programs difficult to read very quickly. [Comments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomments_gdl.htm) can also help to describe the way a complex expression works.

Bad Example

The following source code shows an arithmetic expression in a relational expression in a loop. The same total must be recalculated for each loop pass.

LOOP AT itab ASSIGNING <wa>.
  IF oref->meth( <wa> ) < sy-tabix \* ( offset + length ).
    ...
  ENDIF.
ENDLOOP.

Good Example

The following source code has the same function as the example above. However, the total is only calculated once before the loop.

limit = offset + length.
LOOP AT itab ASSIGNING <wa>.
  IF oref->meth( <wa> ) < sy-tabix \* limit.
    ...
  ENDIF.
ENDLOOP.


### abennesting_depth_guidl.htm

---
title: "Nesting Depth"
description: |
  Background The nesting depth is the number of statement blocks that are nested due to the use of control structures (branches, loops). We will discuss the nesting depth at the level of a procedure (method(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennesting_depth_guidl.htm"
abapFile: "abennesting_depth_guidl.htm"
keywords: ["loop", "do", "while", "if", "case", "method", "abennesting", "depth", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Complexity](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomplexity_gdl.htm) → 

Nesting Depth

Background

The nesting depth is the number of statement blocks that are nested due to the use of control structures (branches, loops). We will discuss the nesting depth at the level of a procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")). [Implementations must not](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendial_mod_event_block_guidl.htm "Guideline") occur at other points.

The maximum nesting depth is restricted to 256 by ABAP Compiler.

Rule

Restrict the nesting depth of control structures

Restrict the maximum nesting depth within a procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) to five levels.

Details

In addition to the [number of executable statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenproc_volume_guidl.htm "Guideline"), the control structures of a procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) are also important for their clarity and traceability. Each new nesting level makes nested branches and loops (such as in the statements IF, CASE, DO, WHILE, and LOOP) increasingly complicated and difficult to interpret. For this reason, the nesting depth must be restricted within a procedure, for example by moving functions to other procedures.

A maximum nesting depth of five levels is considered tolerable. A deeper nesting requires a great deal of effort to trace the program flow based on the source code. This would considerably constrain maintenance and further development.

Note

The use of modern language elements can help to restrict the maximum nesting depth. This is the case if a statement or a built-in function replaces an entire control structure, for instance, for REPLACE with the addition ALL OCCURRENCES or for the numeric extremum functions, nmax( ) and nmin( ), to determine the maximum or minimum value. The former replaces a loop, the latter an IF control structure.

Example

The transition from the bad to the good example in the rule for [modern ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodern_abap_guidl.htm "Guideline") shows how you can reduce the nesting depth by using modern language elements.


### abenproc_volume_guidl.htm

---
title: "Procedure Volume"
description: |
  Background The procedure volume is the number of executable ABAP statements in a procedure (method(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm 'Guideline')). In theory, this number has no upper limit and is only limited by the maximum program si
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenproc_volume_guidl.htm"
abapFile: "abenproc_volume_guidl.htm"
keywords: ["do", "if", "case", "method", "data", "abenproc", "volume", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Complexity](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomplexity_gdl.htm) → 

Procedure Volume

Background

The procedure volume is the number of executable ABAP statements in a procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")). In theory, this number has no upper limit and is only limited by the maximum program size that fits into the current session memory.

Rule

Restrict the number of statements in procedures

Restrict the number of executable ABAP statements in a procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) to a manageable size. A maximum of 150 executable statements per procedure is the recommended guideline.

Details

Procedures with large volumes ([methods](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) generally have a complex decision structure, a lot of procedure parameters and work with a multitude of local data. These procedures, which often do not perform a clearly defined single task, are difficult to understand and therefore particularly prone to errors. You should use multiple small procedures with narrow interfaces and closely defined tasks. The ideal parameter interface has a small number of input parameters and only one [return value](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_formal_param_proc_guidl.htm "Guideline").

The number of executable statements is a simple measure of the complexity of a procedure. All statements that are not declarations and do not define processing blocks can be regarded as executable statements. This is very similar to statements at which program execution can be stopped in the debugger. Procedure-concluding statements, such as ENDMETHOD, at which you can stop in the debugger are exceptions. However, these are not regarded as executable statements.

Note

The recommendation not to write procedures that are too large should not lead to the other extreme (too many procedures that are very small). Procedures should be of a reasonable size that is consistent with the ABAP programming language ([modularize instead of atomize](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_guidl.htm "Guideline")).

Exception

Strict linear code (for example, programmatic filling of a table with single values) cannot be subdivided into multiple procedures. In these cases, a restriction on the number of statements does not make sense.

Example

See the [KISS Principle](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenkiss_principle_guidl.htm "Guideline") figure.


### abenclass_size_guidl.htm

---
title: "Class Size"
description: |
  Background The class size is the number of components (attributes, methods, events) of a class. ABAP Compiler predefines a maximum number of 65,536 components. The total memory consumption by static attributes, instance attributes, and constants is restricted to 500KB in each case. With respect to d
version: "7.56"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenclass_size_guidl.htm"
abapFile: "abenclass_size_guidl.htm"
keywords: ["do", "if", "case", "method", "class", "data", "abenclass", "size", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Complexity](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomplexity_gdl.htm) → 

Class Size

Background

The class size is the number of components (attributes, methods, events) of a class. ABAP Compiler predefines a maximum number of 65,536 components. The total memory consumption by static attributes, instance attributes, and constants is restricted to 500KB in each case. With respect to deep data objects (tables, strings, and data references), only the fixed size of the reference is important and not the variable size of the referenced data object.

Rule

Maintain reasonable class sizes

Ensure that classes and interfaces do not contain an excessively high number of attributes, methods and events. The components contained must be class-specific and should not handle tasks that are extremely different from each other. The same applies to function pools.

Details

Complexity is not only important on the level of procedure implementations. The number of procedures to be considered and the data processed by these procedures are also very important when it comes to understanding the source code.

A class, interface or function pool should not be mistaken as a container that can be used for any functions. Function pools play the same role here as abstract final classes for which no instances can be created. The function modules correspond to static public methods, and the global data corresponds to private static attributes. The situation should be viewed more as an abstraction of a certain subject or an object from real life. This modularization of a complex problem in objects of a manageable size makes it easier to understand the code. Therefore, the classes and interfaces must be designed appropriately and each class or interface must cover a manageable function that is easy to understand.

This is obviously not the case, if a class or an interface contains a large number of attributes and methods. The same applies to the number of function modules of a function pool (with respect to the use of [function pools](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline")). Large classes, interfaces, and function pools either provide functions that are too heterogeneous or, conversely, are highly specialized, which restricts their reusability.

Besides the high degree of complexity, which makes it more difficult to maintain voluminous classes and function pools, you must consider another technical aspect: Even if you use just a few of the provided functions, the entire class or function pool is loaded into the session memory, which negatively impacts the memory usage.

Note

It is [preferable](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenproc_volume_guidl.htm "Guideline") to use multiple procedures, which are not too large and have clearly defined tasks, instead of a small number of large procedures. On the other hand, classes should not contain too many methods. However, these two rules are not contradictory, provided that the procedures do not become too small and are appropriately grouped into different classes with a clearly defined task field. In this process, very specialized classes can be created that do not require global visibility.

Functionality that is only required in a global class, function pool or any other program should therefore be encapsulated in local classes. (All functions of function pools, subroutine pools, and executable programs [should](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") be implemented in local classes anyway). An example of such self-contained functionality is the display logic for [classic dynpros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenencap_class_interf_guidl.htm "Guideline") within a function pool. A meaningful reuse of classes that call the dynpros of the function pool is not possible outside the function pool. Therefore, local classes are the preferred elements for this task.

This type of procedure is also useful for global classes. By moving highly specialized functions to smaller, local classes, you reduce the number of methods of the global class, which results in a clearer overview and makes the class easier to maintain. When you use local classes within global classes, make sure you position them appropriately to [avoid](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlocal_type_glob_class_guidl.htm "Guideline") unnecessary dependencies.


### abendead_code_guidl.htm

---
title: "Dead Code"
description: |
  Background Dead code is program parts that are never executed because they are no longer required or were never actually required at any time. This code can accumulate during the development (rejected prototypes) or maintenance (changeover to new code without deleting the old code) of programs. Rule
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendead_code_guidl.htm"
abapFile: "abendead_code_guidl.htm"
keywords: ["do", "if", "case", "method", "class", "types", "abendead", "code", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Structure and Style](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstructure_style_gdl.htm) →  [Complexity](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomplexity_gdl.htm) → 

Dead Code

Background

Dead code is program parts that are never executed because they are no longer required or were never actually required at any time. This code can accumulate during the development (rejected prototypes) or maintenance (changeover to new code without deleting the old code) of programs.

Rule

Remove dead code

Completely remove any unused or inaccessible program parts from live programs.

Details

Although dead code does not affect the executed program parts directly, it still has a negative impact on the product. Program parts that cannot be accessed during program execution do not provide any benefit. Instead they cause increased costs in the course of a program lifecycle because they must be identified as unused for maintenance and further development purposes. The worst case scenario is that if these program parts are not immediately recognized as unused, they will be reused or modified during further developments or refactoring measures. A lot of time and effort is wasted making changes to unused code. In addition, these program parts increase the space required in the program buffer during program execution.

Dead code also interferes with the aim of maximum [test coverage](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm "Guideline") by unit tests using ABAP Unit or scenario tests using eCATT. Code not used in the live system is either tested, which is very time-consuming, or is not tested, which results in poor test coverage. Unused and inaccessible program parts must therefore be identified and removed as quickly as possible.

Note

[Check tools](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencheck_correctness_gdl.htm) indicate dead code if it can be identified. Examples:

-   The syntax check warns you about unused private methods of local classes.
-   The extended program check warns you about unused declarations or statement blocks in control structures that can never be accessed.

However, these static checks can never be complete because not every use of a program part has to be known statically. Therefore, Coverage Analyzer is another important tool for isolating potential dead code.


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Architecture / Data Storage

**Files**: 6 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Architecture / Data Storage

Included pages: 6


### abendata_storage_gdl.htm

---
title: "Data Storage"
description: |
  ABAP programs generally work with data imported from persistent memory media to the internal session(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm 'Glossary Entry') of the current program execution. This data is then available to the program as transien
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendata_storage_gdl.htm"
abapFile: "abendata_storage_gdl.htm"
keywords: ["do", "try", "data", "abendata", "storage", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarchitecture_gdl.htm) → 

Data Storage

ABAP programs generally work with data imported from persistent memory media to the [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry") of the current program execution. This data is then available to the program as transient data. For performance reasons, data can also be stored in the shared memory of the current AS instance. This shared memory is available to all programs of an AS instance. Access to data in the shared memory is faster than accessing data in persistent memory media by some magnitude.

-   [Persistent Data Storage](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpersistent_data_storage_guidl.htm "Guideline")
-   [Database Accesses](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendatabase_access_guidl.htm "Guideline")
-   [Client Handling](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenclient_handling_guidl.htm "Guideline")
-   [Using the Shared Memory](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_shared_memory_guidl.htm "Guideline")
-   [Using Shared Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_shared_objects_guidl.htm "Guideline")

Continue
[Persistent Data Storage](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpersistent_data_storage_guidl.htm)
[Database Accesses](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendatabase_access_guidl.htm)
[Client Handling](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenclient_handling_guidl.htm)
[Using the Shared Memory](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_shared_memory_guidl.htm)
[Using Shared Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_shared_objects_guidl.htm)


### abenpersistent_data_storage_guidl.htm

---
title: "Persistent Data Storage"
description: |
  Background ABAP programs can have both read and write access to data in the following persistent storage media: -   Relational database tables in databases -   Data clusters in special database tables -   Binary files or text files on the host computer(https://help.sap.com/doc/abapdocu_756_index_h
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenpersistent_data_storage_guidl.htm"
abapFile: "abenpersistent_data_storage_guidl.htm"
keywords: ["select", "do", "if", "try", "class", "data", "internal-table", "abenpersistent", "storage", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarchitecture_gdl.htm) →  [Data Storage](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendata_storage_gdl.htm) → 

Persistent Data Storage

Background

ABAP programs can have both read and write access to data in the following persistent storage media:

-   Relational database tables in databases
-   Data clusters in special database tables
-   Binary files or text files on the [host computer](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenhost_computer_glosry.htm "Glossary Entry") of the current AS instance
-   Binary files or text files on the front-end computer when SAP GUI is used

According to the [SoC principle](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenseperation_concerns_guidl.htm "Guideline"), such accesses are wrapped in service classes of the persistency layer of an application.

Rule

Plan persistent data storage carefully

Select with care the persistent storage media that are used by the application as well as the possible data transport routes between these media. Here is a general rule of thumb:

-   Database tables for the general storage of raw data
-   Data clusters for the storage of formatted data
-   Files for data exchange with external systems

Details

When you plan persistent data storage, you should follow these steps:

1.  On an AS ABAP, storing in relational database tables is always the first choice. ABAP supports this with the ABAP SQL that is integrated into the language. An object-oriented access is possible using Object Services. The majority of the data is stored in the [standard database](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_db_glosry.htm "Glossary Entry") of AS ABAP. [Secondary connections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensecondary_db_connection_glosry.htm "Glossary Entry") (managed using [DBA Cockpit](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendba_cockpit_glosry.htm "Glossary Entry")) can be used to access further databases.
2.  The following data can be stored in data clusters when using the EXPORT and IMPORT statements:
    
    \- Formatted data as the result of comprehensive analyses
    
    \- Data that is not suitable for relational databases because it does not exist in the first normal form (such as nested internal tables)
    
    \- Object networks after a serialization to XML
    
3.  The persistent storage of data in files of the [host computer](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenhost_computer_glosry.htm "Glossary Entry") of a AS instance or of the presentation server is usually the least suitable for AS ABAP application programs because it is generally platform-dependent (code pages, byte order). In addition, data like this is then only available in specific AS instances, which can cause problems in load distribution scenarios with automated server selection. Such files may be required for the data exchange with external systems, however.

Under no circumstances should you use existing database tables (or files) to store data that are not provided for this purpose. Follow the convention of restricting reads and writes to database tables to specific packages. A database table must always be considered a semantic entity that is only allowed to contain the corresponding data. This even applies if a table with the required structure already exists. If in doubt, you should create a specific database table.

You must also be careful when using seemingly cross-system resources, such as the predefined INDX database table, to store data clusters. Such a resource must only be used to store temporary data for the short term, if at all. You should create specific database tables, for example, [export/import tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexport_import_table_glosry.htm "Glossary Entry"), for application-specific and longer-lasting data.


### abendatabase_access_guidl.htm

---
title: "Database Accesses"
description: |
  Background In ABAP, data in database tables can be accessed in the following ways: -   ABAP SQL Implemented by ABAP statements, ABAP SQL(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql.htm) is a subset of the Structured Query Language (SQL) comprising the DML (Data Manipula
version: "7.56"
category: "database"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendatabase_access_guidl.htm"
abapFile: "abendatabase_access_guidl.htm"
keywords: ["update", "do", "while", "if", "case", "try", "method", "class", "data", "types", "internal-table", "abendatabase", "access", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarchitecture_gdl.htm) →  [Data Storage](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendata_storage_gdl.htm) → 

Database Accesses

Background

In ABAP, data in database tables can be accessed in the following ways:

-   ABAP SQL
    
    Implemented by ABAP statements, [ABAP SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql.htm) is a subset of the Structured Query Language (SQL) comprising the DML (Data Manipulation Language) part. The ABAP SQL statements use the ABAP SQL interface for platform-independent access to those database tables in the [standard AS ABAP database](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_db_glosry.htm "Glossary Entry") defined in ABAP Dictionary and having instances created in the [ABAP database schema](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_db_schema_glosry.htm "Glossary Entry").
    
-   AMDP
    
    The [AMDP framework](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenamdp.htm) is used to manage and call ABAP Managed Database Procedures. These are database procedures or database procedures implemented as AMDP procedures in an AMDP method or an AMDP class and replicated to the database system from here.
    
-   Native SQL
    
    Database-specific SQL statements that include both DML and DDL (Data Definition Language) statements and which can be passed to the Native SQL interface of the database as follows:
    
    -   The methods of [ADBC](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadbc.htm) make it possible to execute dynamic SQL statements on a database system and process the results. ADBC (ABAP Database Connectivity), a class-based API that enables object-oriented access to the Native SQL interface.
    -   Native SQL statements can be specified in ABAP programs between the statements [EXEC SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapexec.htm) and [ENDEXEC](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapendexec.htm). Static Native SQL statements of this kind are not checked completely by the syntax check and are forwarded almost unchanged from the Native SQL interface to the database of an AS ABAP.

Alongside access to the ABAP database schema of the standard AS ABAP database, all access types (except for AMDP) also allow access to other databases and other database schemas using additional [database connections](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendatabase_connection_glosry.htm "Glossary Entry").

Rule

Using ABAP SQL

Use ABAP SQL for general database accesses where possible. Only use AMDP and Native SQL for tasks where ABAP SQL is not suitable.

Details

Only ABAP SQL is guaranteed to be independent of the database platform used. For this reason, ABAP SQL does not contain the set of all possible SQL statements in a specific database, but only a subset of the DML scope of all database systems supported by AS ABAP. The database tables that can be processed using ABAP SQL can be used in ABAP directly as structured types for the declaration of suitable work areas. Only ABAP SQL supports [table buffering](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentable_buffering_glosry.htm "Glossary Entry") of table content in the [shared memory](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_shared_memory_guidl.htm "Guideline").

AMDP and Native SQL should only be used if the task really cannot be solved using ABAP SQL. Services that work with AMDP and Native SQL are generally dependent on the database system used, so that they cannot be executed in all AS ABAP systems. For platform-independent services, implementations should be provided for all supported databases.

If the database is accessed using the Native SQL interface instead of the ABAP SQL interface, [AMDP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadbc_glosry.htm "Glossary Entry") or [ADBC](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadbc_glosry.htm "Glossary Entry") should be used.

-   AMDP, currently only available for a SAP HANA database as the standard AS ABAP database, is recommended for all tasks that swap out code from ABAP programs to this SAP HANA database for performance reasons.
-   ADBC is a modern object-oriented API that is better suited to modern ABAP programming than [EXEC SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapexec.htm). Enhancements to the Native SQL interface, such as bulk access using internal tables, are now only provided using ADBC. ADBC also enables [dynamic access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm); Native SQL on the other hand is just static. Newer SQL statements, such as WITH for common table expressions (CTEs), are not supported in full by EXEC SQL.

Hints

-   The rule dictating that ABAP SQL is to be used for as long as possible applies in particular to [AMDP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenamdp.htm) too. It is not a good idea to swap out SQL statements to database procedures if these could be implemented using ABAP SQL or [ABAP CDS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencds_glosry.htm "Glossary Entry") too. In this case, no performance gains can be expected since the ABAP SQL statements are updated to Native SQL by the database interface in exactly the same way as they would be written in the database procedure. Using AMDP is a good idea only if HANA-specific properties can be exploited by procedure calls or if repeated transports of large amounts of data between the database and the AS ABAP can be bypassed.
-   It is [not advisable](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendatabase_access_recomm.htm) to access ABAP-managed database objects if the access does not take place in ABAP programs.

Bad Example

See the executable example [AMDP, Comparison with ABAP SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenamdp_vs_abap_sql_abexa.htm). Database access not programmed well using ABAP SQL can often be optimized by improved use of ABAP SQL, making it unnecessary to use AMDP in these cases.

Bad Example

See the executable example [Currency Conversion with SQLScript](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_script_curr_conv_abexa.htm). In this case, a specific built-in function of HANA SQL is used that was not generally available in ABAP SQL. Meanwhile, the function [currency\_conversion](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensql_curr_unit_conv_func.htm) is available in ABAP SQL and can replace the usage of AMDP.


### abenclient_handling_guidl.htm

---
title: "Client Handling"
description: |
  Background A client indicates a data area in an AS ABAP database that contains independent application data. The application data of different clients use the same database tables, but are flagged with a three-figure client ID within these tables. When logging on to AS ABAP, this client ID must be e
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenclient_handling_guidl.htm"
abapFile: "abenclient_handling_guidl.htm"
keywords: ["select", "do", "if", "try", "data", "abenclient", "handling", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarchitecture_gdl.htm) →  [Data Storage](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendata_storage_gdl.htm) → 

Client Handling

Background

A client indicates a data area in an AS ABAP database that contains independent application data. The application data of different clients use the same database tables, but are flagged with a three-figure client ID within these tables.

When logging on to AS ABAP, this client ID must be entered. This selects the client whose data is processed by the user session. The current client is entered in the system field sy-mandt.

-   [ABAP SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_glosry.htm "Glossary Entry") statements work with implicit client handling, where the data of the current client is accessed by default. This is specified by passing an implicit condition for the current client to WHERE conditions, and ignoring clients specified in modifying statements in work areas. Implicit client handling in ABAP SQL can be switched to one more different clients by using the addition [USING](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect_client.htm) in queries or the additions [USING](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapiumd_client.htm) or [CLIENT SPECIFIED](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapiumd_client.htm) in write statements.
-   [Native SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennative_sql_glosry.htm "Glossary Entry") and [ADBC](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenamdp_glosry.htm "Glossary Entry") do not apply implicit client handling. The client in question does not need to be selected explicitly when Native SQL or AMDP is used to access client-dependent database tables or views.

Rule

Do not access the data of other clients

In the persistency services of business applications, access the data of the current client only.

Details

Each client within the AS ABAP is to be viewed as a self-contained unit. The additions USING CLIENT and CLIENT SPECIFIED should not be used in ABAP SQL statements of business applications. When Native SQL or AMDP is used, only the current client should be selected.

The system field sy-mandt does not generally need to be evaluated, unless Native SQL or AMDP is used to access client-dependent database tables or views. The client ID is then needed to select the data of the current client explicitly.

Hints

-   Client-independent database tables (tables without client ID) are usually system tables. This means that client-independent access to these tables is also reserved for system programs.
-   The addition CLIENT SPECIFIED is fully [obsolete](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapselect_client_obsolete.htm) in queries and partially [obsolete](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapud_client_obsolete.htm) in write statements.

Bad Example

The following source code demonstrates ABAP SQL access on application data where implicit client handling is switched to a different client.

SELECT SINGLE ...
       FROM scarr USING '...'
       WHERE ...             ...
       INTO ...

Good Example

The following source code demonstrates the recommended use of ABAP SQL where implicit client handling accesses the current client by default.

SELECT SINGLE ...
       FROM scarr
       WHERE ...
       INTO ...


### abenuse_shared_memory_guidl.htm

---
title: "Using the Shared Memory"
description: |
  Background The shared memory of an AS instance is an highly important medium for buffering data with the goal of high-performance access. For this purpose, the shared memory can be used as follows: -   To buffer data from database tables implicitly using table buffering(https://help.sap.com/doc/ab
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_shared_memory_guidl.htm"
abapFile: "abenuse_shared_memory_guidl.htm"
keywords: ["do", "if", "try", "method", "class", "data", "internal-table", "exception-handling", "abenuse", "shared", "memory", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarchitecture_gdl.htm) →  [Data Storage](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendata_storage_gdl.htm) → 

Using the Shared Memory

Background

The shared memory of an AS instance is an highly important medium for buffering data with the goal of high-performance access. For this purpose, the shared memory can be used as follows:

-   To buffer data from database tables implicitly using [table buffering](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentable_buffering_glosry.htm "Glossary Entry"), which can be determined when defining the tables in ABAP Dictionary
-   To explicitly store data clusters in the cross-transaction application buffer using the statements EXPORT TO SHARED MEMORY or EXPORT TO SHARED BUFFER
-   To explicitly handle (data) objects stored there using shared objects, which are created using the addition AREA HANDLE of the statements CREATE OBJECT or CREATE DATA

Rule

Implement the explicit buffering in the shared memory using shared objects

Work with shared objects to explicitly use the shared memory for cross-program data buffering. The appropriate application scenarios are shared buffer and exclusive buffer. The access to shared objects should be wrapped in loader and broker classes.

Details

For explicit access to the shared memory, shared objects (CREATE AREA HANDLE) provide the following advantages compared to the cross-transaction application buffer (SHARED MEMORY, SHARED BUFFER):

-   Any number of (data) objects can be saved, including their mutual interdependencies.
-   (Data) objects can be used in the shared objects memory just like objects in the [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry"). Technically, the shared objects memory can be considered an extension of the internal session during the time the memory is bound to it.
-   Multiple programs can access the same memory area simultaneously without having to copy data to their own internal session.

Scenarios in which shared objects can be used efficiently include the following:

-   Usage as a shared buffer
    
    A shared buffer contains a large data set on which many consumers can perform reads but which is changed rarely and is usually provided by a single program.
    
-   Usage as an exclusive buffer
    
    An exclusive buffer contains data that are accessed by only one program but that is maintained for various programs across transaction boundaries.
    

The shared memory should not be used for different purposes, if, for example this results in many modifying accesses of parallel consumers, since the current locking concept does not support this.

Access to the shared memory should be encapsulated in specific classes, and application programs should access the shared memory using these classes only. Normally, there are two classes, which can also be combined into one class:

-   A loader for creating and changing area instances
-   A broker for reads on area instances

Such wrapping ensures the following:

-   Central management of the connection of the internal session to the shared objects memory and the associated locks
-   Central exception handling and respective fallback strategies (for example, if the shared objects memory overflows, it is possible to ensure that objects in the internal session are used without the using program having to be notified of this).
-   Potential authorization checks

This makes the application program more legible, more robust, and easier to maintain.

Bad Example

The following source code shows how an internal table index\_table, which has been formatted elsewhere and buffered in the cross-transaction application buffer, is imported to a program. To store it locally, a local data object is required. Tasks like these can be performed more efficiently by using shared objects.

"Get index page from data cluster
IMPORT index\_html = index\_html
       FROM SHARED MEMORY docutables(...) ID ...
ASSERT sy-subrc = 0.

Good Example

The following source code shows how an internal table index\_table, which has been formatted elsewhere and buffered in the shared objects memory, can be accessed within program. By calling a get method, the corresponding broker ensures that its root attribute refers to a shared object that contains the table. A local data object is then not required to access the internal table in the program.

"Get index page from shared memory
cl\_docu\_tables\_broker=>get\_index\_table( ).
ASSERT cl\_docu\_tables\_broker=>root->index\_html
       IS NOT INITIAL.


### abenuse_shared_objects_guidl.htm

---
title: "Using Shared Objects"
description: |
  Background Access to shared objects(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_shared_objects.htm) is regulated by lock mechanisms. The individual locks are stored as administrative information with the area instances in the shared memory and are set and evaluated when the
version: "7.56"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_shared_objects_guidl.htm"
abapFile: "abenuse_shared_objects_guidl.htm"
keywords: ["do", "if", "case", "method", "class", "data", "abenuse", "shared", "objects", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Architecture](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarchitecture_gdl.htm) →  [Data Storage](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendata_storage_gdl.htm) → 

Using Shared Objects

Background

Access to [shared objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_shared_objects.htm) is regulated by lock mechanisms. The individual locks are stored as administrative information with the area instances in the shared memory and are set and evaluated when they are accessed using area handles.

Rule

Shared buffer and exclusive buffer are suitable application scenarios for shared objects.

The access to shared objects should be wrapped in loader and broker classes.

Details

How locks work depends on how shared objects are used as follows:

-   Scenario 1 - Use as a shared buffer
    
    A shared buffer is a data store that is rarely changed (once a day up to a maximum of once an hour), usually by a single consumer only. The amount of data can be very large. In general, many consumers can perform reads on a shared buffer at the same time. A typical use of a shared buffer is to store a catalog.
    
-   Scenario 2 - Use as an exclusive buffer
    
    An exclusive buffer is a data store where only one consumer performs reads or writes or, in rare cases, where one consumer performs writes and another performs reads. The data stored in an exclusive buffer should be available as long term data, that is longer than the lifetime of a program. A typical use of an exclusive buffer is to store a shopping basket that is filled initially by the shopper and then read by the salesperson later.
    

General shared memory programming is not possible. The current lock logic does not enable you to set specific locks for the following requirements:

-   Many parallel reads and writes
-   Frequent writes
-   Split into modifiable and non-modifiable areas

Although the lock logic makes the first two points technically possible, they are not practical because most accesses would be rejected.

Wrapping

It is recommended that application programs do not access the shared objects memory directly. Instead reads on the shared objects should be wrapped in a wrapping class, whose methods are accessed by the individual programs. The [area constructor class](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenshm_area_constructor_class.htm) can be used as the wrapping class, for example.

Wrapping has the following advantages:

-   Central administration of an area in the shared memory
-   An application program does not need to worry about area handles and locks.
-   Central administration of locks
-   Option to implement central authorization checks


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Robust ABAP / Assignments, Calculations, and Other Types of Data Access

**Files**: 13 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Robust ABAP / Assignments, Calculations, and Other Types of Data Access

Included pages: 13


### abenassignment_access_gdl.htm

---
title: "Assignments, Calculations, and Other Types of Data Access"
description: |
  An assignment passes the content of a data object, a return value, or a result of a calculation expression to a data object. If the data types are compatible, the content is copied unchanged. If the data types are incompatible and there is a suitable conversion rule, the content is converted. An ass
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm"
abapFile: "abenassignment_access_gdl.htm"
keywords: ["select", "do", "if", "data", "types", "abenassignment", "access", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) → 

Assignments, Calculations, and Other Types of Data Access

An assignment passes the content of a data object, a return value, or a result of a calculation expression to a data object. If the data types are compatible, the content is copied unchanged. If the data types are incompatible and there is a suitable conversion rule, the content is converted. An assignment is usually performed with the [assignment operator (\=)](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenequals_operator.htm).

A calculation is executed in a calculation expression, which can be specified in an operand position, in particular on the right side of the assignment operator \=. If necessary, the result of a calculation expression is converted to the data type of the operand position or of the result of the assignment. In arithmetic expressions, the calculation is executed in a calculation type based on the data types of all operands including the result.

-   [Assignments Between Different Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignemnt_diff_types_guidl.htm "Guideline")
-   [Avoiding Invalid Values](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenavoiding_invalid_values_guidl.htm "Guideline")
-   [Using Conversion Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_conversion_rules_guidl.htm "Guideline")
-   [Trailing Blanks in Character Literals](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentrailing_blanks_literals_guidl.htm "Guideline")
-   [Specifying Numbers](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennumbers_guidl.htm "Guideline")
-   [Selecting the Numeric Type](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselect_numeric_type_guidl.htm "Guideline")
-   [Rounding Errors](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrounding_error_guidl.htm "Guideline")
-   [Dividing by Zero](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendivision_zero_guidl.htm "Guideline")
-   [Casting](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencasting_guidl.htm "Guideline")
-   [Runtime Errors When Accessing Data Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenruntime_error_data_obj_guidl.htm "Guideline")
-   [Anonymous Containers](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenunknown_container_guidl.htm "Guideline")
-   [Pass by Reference of Global Data](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_transf_global_data_guidl.htm "Guideline")

Continue
[Assignments Between Different Types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignemnt_diff_types_guidl.htm)
[Avoiding Invalid Values](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenavoiding_invalid_values_guidl.htm)
[Using Conversion Rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_conversion_rules_guidl.htm)
[Trailing Blanks in Character Literals](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentrailing_blanks_literals_guidl.htm)
[Specifying Numbers](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennumbers_guidl.htm)
[Selecting the Numeric Type](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselect_numeric_type_guidl.htm)
[Rounding Errors](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrounding_error_guidl.htm)
[Division by Zero](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendivision_zero_guidl.htm)
[Casting](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencasting_guidl.htm)
[Runtime Errors When Accessing Data Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenruntime_error_data_obj_guidl.htm)
[Anonymous Containers](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenunknown_container_guidl.htm)
[Pass by Reference of Global Data](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_transf_global_data_guidl.htm)


### abenassignemnt_diff_types_guidl.htm

---
title: "Assignments Between Different Types"
description: |
  Background ABAP allows a direct assignment between data objects with different data types. There must be a suitable conversion rule and the content of the source field must be a meaningful value for the data type of the target field. If a suitable conversion rule is not found or the content of the s
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignemnt_diff_types_guidl.htm"
abapFile: "abenassignemnt_diff_types_guidl.htm"
keywords: ["do", "if", "data", "types", "abenassignemnt", "diff", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Assignments Between Different Types

Background

ABAP allows a direct assignment between data objects with different data types. There must be a suitable conversion rule and the content of the source field must be a meaningful value for the data type of the target field. If a suitable conversion rule is not found or the content of the source field is not suitable, an exception is raised.

Such conversions take place not only in direct assignments, but also in many operand positions and in particular in arithmetic calculations, if the specified operand does not have the data type expected at the position.

Rule

Avoid conversions

Where possible, assignments should be performed between compatible data objects with the same data type.

Details

Type conversions incur additional runtime and may not always have the result intended by the developer. Therefore, conversions should only be performed between data objects with different data types if there is no other choice. In particular, conversions should be avoided where the [conversion rules](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_conversion_rules_guidl.htm "Guideline") produce unexpected results.

Bad Example

The following source code shows an arithmetic calculation involving two unnecessary conversions. First the text field literal '1' has to be converted to the calculation type i, then the result of the calculation has to be converted from type i to data type n. Such conversions produce significant increases in runtime.

DATA index TYPE n LENGTH 4.
...
DO ... TIMES.
  index = sy-index - '1'.
  ...
ENDDO.

Good Example

The following source code shows how code can be improved compared to the previous example, so that no conversions are necessary.

DATA index TYPE i.
...
DO ... TIMES.
  index = sy-index - 1.
  ...
ENDDO.


### abenavoiding_invalid_values_guidl.htm

---
title: "Avoiding Invalid Values"
description: |
  Background For performance reasons, the ABAP runtime framework does not check whether the target field contains a valid value after each and every assignment. Particularly for target fields of the character-like data type n and the date/time types d and t, the conversion rules allow any alphanumeric
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenavoiding_invalid_values_guidl.htm"
abapFile: "abenavoiding_invalid_values_guidl.htm"
keywords: ["do", "if", "case", "try", "catch", "data", "types", "abenavoiding", "invalid", "values", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Avoiding Invalid Values

Background

For performance reasons, the ABAP runtime framework does not check whether the target field contains a valid value after each and every assignment. Particularly for target fields of the character-like data type n and the date/time types d and t, the conversion rules allow any alphanumeric values as the result of an assignment. However, only the following values are valid:

-   For type n: digits only
-   For type d: a calendar date in the format "YYYYMMDD"
-   For type t: a time in the format "HHMMSS"

For a detailed description of the validity of date fields and time fields, see also the [relevant section](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenchar_date_time_fields_validity.htm) of the documentation.

A [lossless assignment](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlossless_assignment_glosry.htm "Glossary Entry") can be used to force checks on valid values.

Rule

Only assign valid values

In assignments and calculations, data objects are filled with data types n, d, and t with valid values only.

Details

Statements that work with variables with types n, d, or t can only be guaranteed to behave correctly if values are valid. If date and time fields are required, it is important to be aware of their special characteristics. Since the initial value for variables of type d is itself not a valid value, a suitable start value must always be specified by using the addition VALUE. Note that in arithmetic calculations with date fields, if an assignment to a target field with data type d has 0 as a result value, this is an invalid initial value and may require special handling.

If the responsibility for filling data objects of the critical data types lies elsewhere, [it is best to](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_conversion_rules_guidl.htm "Guideline") always check the validity of their content before use. [Lossless assignments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlossless_assignment_glosry.htm "Glossary Entry") with the operator [EXACT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconstructor_expression_exact.htm) can be used to do this. Note that the initial value of a date field of type d is interpreted as valid for a lossless assignment, but the value "00010101" is considered to be a valid date only in [ABAP SQL](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_sql_glosry.htm "Glossary Entry").

Bad Example

The following source code shows a case where the conversion rules in ABAP can lead to problems if not used properly in combination with date fields. The literals can be transferred to the date fields, without raising an exception, to give the values 07092009 and 16092009. Unfortunately, these are interpreted as 09.20.0709 and 09.20.1609, which are invalid dates. During the calculation, they are both converted to the value 0 and the result is 0. Looking at the dates, you would expect the result to be 9.

DATA: date1  TYPE d,
      date2  TYPE d,
      result TYPE i.
date1 = '07092009'.
date2 = '16092009'.
result = date2 - date1.

Good Example

The following source code shows a date calculation that does give the expected result of 9, thanks to valid values in the date fields. The validity of the literal values is guaranteed by the use of the operator EXACT.

TRY.
    DATA(result) = EXACT d( '20090916' ) - EXACT d( '20090907' ).
  CATCH cx\_sy\_conversion\_no\_date.
    ...
ENDTRY.

The following source code shows how you can check whether the date fields are valid in the calculation, if they are not filled in the same program. Since the EXACT operator does not perform a check for compatible types, the data fields are first converted to temporary text strings, and these are checked.

TRY.
    result = EXACT d( CONV string( date2 ) ) -
             EXACT d( CONV string( date1 ) ).
  CATCH cx\_sy\_conversion\_no\_date.
    ...
ENDTRY.


### abenuse_conversion_rules_guidl.htm

---
title: "Using Conversion Rules"
description: |
  Background ABAP contains numerous conversion rules for assignments between data objects of different data types. These rules relate to assignments between: -   Elementary data objects(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_elementary.htm) -   Elementary data obj
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_conversion_rules_guidl.htm"
abapFile: "abenuse_conversion_rules_guidl.htm"
keywords: ["do", "if", "case", "try", "catch", "data", "types", "internal-table", "abenuse", "conversion", "rules", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Using Conversion Rules

Background

ABAP contains numerous conversion rules for assignments between data objects of different data types. These rules relate to assignments between:

-   [Elementary data objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_elementary.htm)
-   [Elementary data objects and structures](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_flat_elementary.htm)
-   [Structures](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_struc.htm)
-   [Internal tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_itab.htm)
-   [Reference variables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_references.htm)

Assignments between data objects of nearly every different data type are possible. The only prohibited assignments are for data types for data and time specifications. Almost all allowed assignments have a corresponding conversion rule. It is especially important to have rules for assignments between data objects of the same data type, if different technical attributes (such as length or number of decimal places) are allowed. [Lossless assignments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlossless_assignment_glosry.htm "Glossary Entry") allow only conversions that produce valid values and where no values are lost.

Rule

Avoid unexpected conversion results

Only assign data objects to each other if the content corresponds to the data type of the target field and produces an expected result. Do not exploit every ABAP conversion rule to its full extent. Consider using [lossless assignments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlossless_assignment_glosry.htm "Glossary Entry").

Details

The ABAP conversion rules are based on the philosophy that assignments should be allowed between as many combinations of values as possible, without raising exceptions. In this situation, ABAP behaves quite differently from other programming languages. In other languages, assignments between different data types are usually handled much more strictly and special conversion routines or explicit casting for specific requested conversions are used.

Although it is convenient to be able to readily assign all possible data objects to each other, there are also disadvantages, such as the [creation of invalid values](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenavoiding_invalid_values_guidl.htm "Guideline"). Another example is [implicit casting](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencasting_guidl.htm "Guideline"), which occurs when assignments are made between elementary data objects and structures, or between incompatible structures.

Even if no invalid values are created, problems still can occur. If valid target values are created from invalid source values, this does not necessarily meet the expectations of the reader and it can make program maintenance considerably difficult. One example of this is the handling of invalid content in the source field in assignments from a character-like type to a byte-like type. Instead of exiting the assignment with an exception, hexadecimal zeros are passed from the first invalid character.

The only solution here are [lossless assignments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlossless_assignment_glosry.htm "Glossary Entry") with the operator [EXACT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconstructor_expression_exact.htm), which produce an exception in these cases. Even though this is a bit late in the day, the behavior of an assignment with the operator EXACT could be regarded as the normal, expected behavior. Other unexpected behaviors represent an implementation of special rules, which is actually the standard behavior in ABAP.

Bad Example

Anyone who is familiar with all the details of the ABAP conversion rules would probably expect an exception when the text in the following source code is assigned to the numeric text. However, only the digits of the text are respected. Therefore, the target field is given the value "00000042" instead of the value "00000007", which might also be expected.

DATA text TYPE string,
num\_text TYPE n LENGTH 8.
...
text = '4 Apples + 2 Oranges'.
...
num\_text = text.

Good Example

This issue is corrected in the source code below. The [EXACT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconstructor_expression_exact.htm) operator is used, which raises an exception.

...
text = '4 Apples + 2 Oranges'.
...
TRY.
    num\_text = EXACT #( text ).
  CATCH cx\_sy\_conversion\_error.
     ...
ENDTRY.


### abentrailing_blanks_literals_guidl.htm

---
title: "Trailing Blanks in Character Literals"
description: |
  Background Trailing blanks in text field literals use memory, but are generally(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstring_processing_trail_blanks.htm) ignored in operand positions, like all data objects of the type c. In text string literals they are always relevant, as
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentrailing_blanks_literals_guidl.htm"
abapFile: "abentrailing_blanks_literals_guidl.htm"
keywords: ["do", "if", "case", "data", "types", "abentrailing", "blanks", "literals", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Trailing Blanks in Character Literals

Background

Trailing blanks in text field literals use memory, but are [generally](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstring_processing_trail_blanks.htm) ignored in operand positions, like all data objects of the type c. In text string literals they are always relevant, as is the case for all data objects of type string.

Rule

Do not use trailing blanks in text field literals

They should also not be specified in literals in any operand positions where trailing blanks are not relevant.

Details

This rule is designed mainly to make programs more readable. It makes no sense to specify literal characters in places where they are ignored, and raises expectations in users of the program that cannot be met. In particular, this also applies to the text field literal ' '.

Conversely, specifying the supposedly empty text field literal '' in places where trailing blanks are respected may be a trap.

Bad Example

The following simple example demonstrates the full scope of the rule. Any readers with little experience in ABAP would expect the result of the assignment to be a string with length six. In actual fact, the result contains only the three relevant places.

DATA text TYPE string.
text = '123   '.

Good Example

Whether the example needs to be improved depends on whether the trailing blanks are required. If the blanks are needed, use a string literal:

text = \`123   \`.

If they are not needed, leave them out:

text = '123'.

Bad Example

The following example demonstrates that the supposedly empty literal '' actually represents a blank that is not cut off after SEPARATED BY. The result is "AB AP".

DATA text TYPE string.
CONCATENATE 'AB' 'AP' INTO text SEPARATED BY ''.

Good Example

Depending on whether the blank is needed as a separator, either ' ' or \`\` must be specified after SEPARATED BY to express this clearly.


### abennumbers_guidl.htm

---
title: "Specifying Numbers"
description: |
  Background There are no special literals available for numbers with decimal places, or with mantissa plus exponent. If required, these numbers must be expressed using character literals. The following notations can be used: -   Mathematical notation A string of digits with a maximum of one period (.
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abennumbers_guidl.htm"
abapFile: "abennumbers_guidl.htm"
keywords: ["do", "if", "method", "class", "data", "types", "abennumbers", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Specifying Numbers

Background

There are no special literals available for numbers with decimal places, or with mantissa plus exponent. If required, these numbers must be expressed using character literals. The following notations can be used:

-   Mathematical notation
    
    A string of digits with a maximum of one period (.) as a decimal separator and an optional sign "+" or "-" on the left. This sign can be separated from the digits by blanks, for example: - 1234.56
    
-   Commercial notation
    
    A string of digits with a maximum of one period (.) as a decimal separator and an optional sign "+" or "-" on the right. This sign can be separated from the digits by blanks, for example: 1234.56-
    
-   Scientific notation
    
    An uninterrupted string consisting of a mantissa (an optional sign "+" or "-", digits with a maximum of one period (.) as a decimal separator), a character e or E, and an exponent (an optional sign "+" or "-" and further digits), for example: -1.23456E03
    

Rule

Use globally valid notation for numeric values

When using numbers in character strings that are intended for assignments to a numeric data object, create them so that they are accepted by all possible target types. The sign must always be on the left, and there must be no blanks.

Details

When converting a character string to a numeric variable, the type of the target variables decides which notations are accepted:

-   If the type of the target variable is decfloat16 or decfloat34, all three notations are accepted.
-   If the type of the target variable is f, all three notations are accepted. The mathematical and commercial notations are only accepted, however, if the sign is not separated from the string of digits by one or more blanks and there are blanks in front of the string of digits.
-   If the type of the target variable is p or i, only the mathematical and commercial notations are accepted.

To make sure that a program is readable, and also that numbers in character strings can be converted to as many numeric data types as possible, always use mathematical notation without blanks between the sign and the string of digits. This notation also confirms to other standards, such as the canonic representation of XML schema data types.

Bad Example

The following source code demonstrates the initialization of a generically typed parameter with commercial notation, where the sign is separated by a blank. If an actual parameter with a type other than f is passed, the assignment produces the value -1000 (as expected); if an actual parameter of the type f is passed, however, the value is +1000.

CLASS class DEFINITION.
  PUBLIC SECTION.
    METHODS calculate\_something
      EXPORTING number TYPE numeric.
ENDCLASS.
CLASS class IMPLEMENTATION.
  METHOD calculate\_something.
    number = '1000 -'.
    ...
  ENDMETHOD.
ENDCLASS.

Good Example

The following source code demonstrates an assignment using globally valid notation that is easy to read and which produces the same result, the value -1000, for all numeric data types.

METHOD calculate\_something.
number = '-1000'.
...
ENDMETHOD.


### abenselect_numeric_type_guidl.htm

---
title: "Selecting the Numeric Type"
description: |
  Background Multiple numeric types with various properties and value ranges are available in ABAP, which can be used for storing numbers and for calculations: -   Signed 4-byte integer numbers (type i) and 8-byte integer numbers (type int8) (1-byte and 2-byte-integers with the internal types b and s
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenselect_numeric_type_guidl.htm"
abapFile: "abenselect_numeric_type_guidl.htm"
keywords: ["select", "do", "if", "case", "data", "types", "abenselect", "numeric", "type", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Selecting the Numeric Type

Background

Multiple numeric types with various properties and value ranges are available in ABAP, which can be used for storing numbers and for calculations:

-   Signed 4-byte integer numbers (type i) and 8-byte integer numbers (type int8) (1-byte and 2-byte-integers with the internal types b and s are also available.) However, these data objects cannot be created based on a built-in ABAP type. Instead, the built-in ABAP Dictionary types INT1 and INT2 are required.
-   Packed numbers in BCD format (binary coded decimals, type p)
-   Binary floating point numbers (type f)
-   Decimal floating point numbers (types decfloat16, decfloat34)

The decimal floating point numbers meet the requirements for highly exact processing of decimal numbers in a large value ranges, where the data types p and f only cover a single aspect each.

Rule

Choose suitable numeric types for numbers and calculations

Choose a numeric type to suit the values to be represented to achieve the highest possible speed and accuracy. Here is a general rule of thumb:

-   i and int8 for integers
-   p for fixed point numbers
-   decfloat16 or decfloat34 for floating point numbers
-   f in exceptional cases only

Details

The calculation speed and accuracy are generally contradictory requirements and depend on the data type of the objects to be processed. Therefore, when choosing the numeric type, both these two requirements must be weighed up. These considerations must also include the value range to be represented:

-   If the values to be mapped are integers, type i or int8 must usually be used. This guarantees the highest possible calculation speed. Examples of these integers include counters, indexes, offsets and time intervals. If the values to be mapped exceed the value range of type int8 or i, you can use type p without decimal places instead. The calculation speed is slower, but decimal places are still represented accurately (except for rounding errors). If this value range is still not sufficient, a floating point type (decfloat16 and decfloat34) can be used instead.
-   If non-integer values that have a fixed number of decimal places are to be represented, the type p can be used. However, calculations with type p are executed in the ABAP kernel and not by the hardware. Examples of non-integer values include lengths, weights, or monetary amounts. If this value range is still not sufficient, a decimal floating point type (decfloat16 and decfloat34) can be used instead. The binary floating point type f is less suitable because it cannot represent all decimal fractions. This is a further impediment for calculation accuracy (in addition to the unavoidable rounding errors).
-   For non-integer values with a variable number of decimal places or a large value range, the decimal floating point types decfloat16 or decfloat34 should be used. decfloat34 has a greater number of places and a greater value range. However, this also leads to increased memory consumption.

Thanks to the hardware support available on all platforms, binary floating point type f allows fast calculations. However, it is inferior to the new decimal floating point types due to the following reasons:

-   Type f can only accurately represent fractions with the power of two in the denominator (1/2, 1/4, 1/8, etc.) and totals. Other values are rounded according to this representation. This rounding process does not correspond to the decimal rounding process (and usually does not meet the expectations of the developer or user). For example, the value 0.815 is approximated internally as 8.1499999999999995E-01. This means when the value is rounded to two decimal places, 0.81 is returned instead of the expected value 0.82.
-   Very large numbers can no longer be represented exactly (working in line with IEEE 754) if the difference between the largest and smallest exponent is greater than 52 (in the total of powers of two). For example, 1E+23 is represented as 9.9999999999999992E+22.
-   A number of type f cannot be rounded to a specific number of decimal places, if the result needs to be assigned to another number of type f.
-   Divisions by powers of 10, which often occur when converting metric units, for example, are not exact. 8.0500000000000005E-01 is returned for 805/1000, for example.
-   Simple calculations often produce unexpected results. 123456.15 - 123455 returns 1,1499999999941792, for example.
-   The conversion of binary floating point numbers to other number formats is not clearly defined in line with IEEE 754. Consequently, when data is stored in the database, the rounding behavior depends on the platform and how numbers of type f are represented in the database.
-   The decimal floating point types decfloat16 and decfloat34 do not have these problems. Both have a greater value range than type f, and decfloat34 has 34 places instead of 16 places. However, the following restrictions apply:
    -   Currently, calculations with decimal floating point types are generally even slower than calculations with the type f (the speed is comparable to calculations with the type p). Until now, only IBM's Power6 architecture provided hardware support for floating point calculations of this type in accordance with IEEE-754-2008. On other platforms, calculations with decimal floating point numbers have to be performed on the software side in the ABAP kernel, in a similar way to calculations with the type p.
    -   Decimal floating point types are not yet supported by associated data types on all database platforms. As an interim solution, ABAP Dictionary provides a set of built-in data types DF16\_..., DF34\_..., based on existing types (DEC and RAW). In most cases, the benefits of the decimal floating point types compensate for the current slow calculation speed. However, it might still be necessary to use type f if there are stringent requirements for performance and less stringent requirements for calculation accuracy. Remember that the speed advantage currently possible for calculations with f, may be outweighed by the fact that conversions from f to other numeric types are relatively slow.

Hint

For programs that are currently created with decimal floating point types, the performance is increased as soon as the processor architecture supports decimal floating point calculations and the ABAP runtime framework starts using this hardware support. Calculations with decimal floating point numbers then become faster than calculations with packed numbers.

Bad Example

The following source code shows a declaration of a binary floating point number. The start value 0.815 is assigned. The true start value, however, is 8.1499999999999995E-01.

DATA number TYPE f VALUE '0.815'.

Good Example

The following source code shows a declaration of a decimal floating point number. The start value 0.815 is assigned. The true start value is actually 8.15E-01.

DATA number TYPE decfloat34 VALUE '0.815'


### abenrounding_error_guidl.htm

---
title: "Rounding Errors"
description: |
  Background In the case of assignments between floating point numbers (types f, decfloat16, decfloat34) and fixed point numbers (types i and p), rounding errors usually occur that produce an incorrect value. Conversely, values of type p (and also decfloat16 and decfloat34) that are assigned to type f
version: "7.56"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrounding_error_guidl.htm"
abapFile: "abenrounding_error_guidl.htm"
keywords: ["do", "if", "case", "data", "types", "abenrounding", "error", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Rounding Errors

Background

In the case of assignments between floating point numbers (types f, decfloat16, decfloat34) and fixed point numbers (types i and p), rounding errors usually occur that produce an incorrect value. Conversely, values of type p (and also decfloat16 and decfloat34) that are assigned to type f are not always represented accurately.

Rule

Avoid unnecessary rounding errors

Avoid unnecessary or frequent conversions between floating point numbers and fixed numbers as this can cause rounding errors.

Details

In a program, the value of a number should always be stored for as long as possible in a data object with the numeric data type of the highest required level of accuracy. This applies especially to saving intermediate results of calculations.

The data input or output requirements (for example, formatting on the screen or in a spool list) cannot change the way numbers are saved internally. If a number is to be formatted using a specific number of decimal places, the actual value should not be converted to the corresponding packed number. Instead, a suitable format should be configured in a character-like field using the relevant constructs. These are string templates and previously the statement WRITE TO.

Bad Example

The following source code shows a calculation where results can be assigned to a numeric field intended for output. The result 55.55 is rounded to 56.00.

DATA: output     TYPE p DECIMALS 2,
      percentage TYPE decfloat34,
      value TYPE decfloat34.
percentage = '55.55'.
value      = '100.0'.
output = percentage / 100.
output = value \* output.

Good Example

The following source code corrects the above example by separating the code into data objects intended for calculations and a character-like data object for the formatted output.

DATA: result TYPE decfloat34,
      percentage TYPE decfloat34,
      value TYPE decfloat34.
DATA output TYPE c LENGTH 40.
percentage = '55.55'.
value      = '100.0'.
result = percentage / 100.
result = value \* result.
WRITE result TO output DECIMALS 2 EXPONENT 0.


### abendivision_zero_guidl.htm

---
title: "Division by Zero"
description: |
  Background Division by zero is forbidden in all recognized programming languages and raises an exception. This is also the case in ABAP, but with the difference that the exception cx_sy_zerodivide is not raised if the dividend is also zero when divided by zero. In this case, the division in ABAP p
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendivision_zero_guidl.htm"
abapFile: "abendivision_zero_guidl.htm"
keywords: ["do", "if", "case", "data", "types", "abendivision", "zero", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Division by Zero

Background

Division by zero is forbidden in all recognized programming languages and raises an exception. This is also the case in ABAP, but with the difference that the exception cx\_sy\_zerodivide is not raised if the dividend is also zero when divided by zero. In this case, the division in ABAP produces the result 0.

Rule

Prevent division by zero

Do not exploit the fact that ABAP allows division by zero if the dividend itself is zero.

Details

This ABAP behavior is arbitrary and does not produce the result expected by the user. Avoid using it if at all possible. Instead, set preconditions that avoid division by zero or specify explicitly that the correct exception is raised for the case 0/0.

Example

The following source code always raises an exception when the divisor has the value 0.

IF divisor <> 0.
   result = dividend / divisor.
ELSE.
   RAISE EXCEPTION TYPE cx\_sy\_zerodivide.
ENDIF.


### abencasting_guidl.htm

---
title: "Casting"
description: |
  Background Casting refers to the process of handling a data object by assuming a certain data type. This definition is different to the meaning of the concept in other programming languages, such as Java. Here, casting means a different concept which is referred to as 'conversion' in ABAP. Casting i
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencasting_guidl.htm"
abapFile: "abencasting_guidl.htm"
keywords: ["select", "do", "if", "try", "data", "types", "internal-table", "field-symbol", "abencasting", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Casting

Background

Casting refers to the process of handling a data object by assuming a certain data type. This definition is different to the meaning of the concept in other programming languages, such as Java. Here, casting means a different concept which is referred to as 'conversion' in ABAP. Casting in ABAP is either explicit or implicit:

-   Explicit casting is possible by using the CASTING addition with the ASSIGN statement and by using the ASSIGNING addition in statements for processing internal tables. Assignments between reference variables allow [up casts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenup_cast_glosry.htm "Glossary Entry") and [down casts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendown_cast_glosry.htm "Glossary Entry"). Obsolete explicit casting is also possible for formal parameters and field symbols, if the STRUCTURE addition is used.
-   Implicit casting is sometimes performed for special assignments or during operand handling at certain operand positions. A common example is the handling of flat structures using character-like-only components as a single field of type c.

Rule

Avoid implicit casting

Avoid implicit casting. If a cast to another data type is required, it can usually be implemented explicitly using ASSIGN ... CASTING.

Details

Implicit casting can potentially occur if structures are used as follows:

-   Assignments between incompatible structures or structures and elementary data objects
-   Comparisons between structures and elementary data objects
-   Using structures in operand positions where elementary data objects are expected
-   Reads from the database using SELECT \* ... INTO wa
-   Using the INCREMENT addition for the ASSIGN statement

The use of implicit casting is prone to errors and produces source code that is difficult to understand. If the CASTING addition is used when handling field symbols, explicit casting can be implemented, which is easier to follow and understand. The explicit casting option is a very important reason to [use field symbols](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendyn_access_data_obj_guidl.htm "Guideline").

Bad Example

The following source code shows the assignment of a text string to a structure with only character-like components. An implicit casting occurs here, which is regarded as unwanted according to the above rule. The entire structure is handled as a text field of type c and length 6.

TYPES: BEGIN OF structure,
         comp1 TYPE c LENGTH 2,
         comp2 TYPE c LENGTH 4,
       END OF structure.
DATA structure TYPE structure.
DATA text TYPE string.
...
text        = ...
structure = text.

Good Example

The following source code improves the example above, by assigning the structure to a field symbol of type c. Explicit casting occurs. Only the character-like field symbol is used to handle the structure as a character-like field.

...
FIELD-SYMBOLS <text> TYPE c.
...
ASSIGN structure TO <text> CASTING.
<text> = ...


### abenruntime_error_data_obj_guidl.htm

---
title: "Runtime Errors When Accessing Data Objects"
description: |
  Background Using data objects can cause runtime errors if the data object contains unsuitable content or the access to the data object is unsuitable. Examples: -   Assigning values outside the value range of a target variable -   Using values that cannot be converted to the required type. In other w
version: "7.56"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenruntime_error_data_obj_guidl.htm"
abapFile: "abenruntime_error_data_obj_guidl.htm"
keywords: ["do", "if", "try", "catch", "class", "data", "types", "exception-handling", "abenruntime", "error", "obj", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Runtime Errors When Accessing Data Objects

Background

Using data objects can cause runtime errors if the data object contains unsuitable content or the access to the data object is unsuitable. Examples:

-   Assigning values outside the value range of a target variable
-   Using values that cannot be converted to the required type. In other words, a conversion rule exists but the source field content is not convertible. For example, you are trying to assign a character field (with content that cannot be interpreted as a number) to a numeric field.
-   Access to parts of data objects (substring access). Either offset/length access or the use of built-in subfunctions such as substring.

Rule

Prevent runtime errors when accessing data objects

You need to prevent runtime errors that can occur when accessing data objects. Robust applications should always be programmed to avoid these errors.

Details

If it is not possible to determine whether subsequent access causes errors by filling data objects appropriately, either the relevant properties must be checked before the data is accessed or possible exceptions (subclasses of CX\_SY\_CONVERSION\_ERROR or CX\_SY\_DATA\_ACCESS\_ERROR) must be caught during data access.

Bad Example

The following source code illustrates a typical situation that can easily cause a runtime error if the subarea defined by offset and length is not defined in text.

DATA text TYPE string.
...
substring = text+offset(length).
...

Good Example

The following two pieces of source code illustrate how the above example can be changed to avoid runtime errors using prevention or exception handling.

IF strlen( text ) > offset + length.
  substring = text+offset(length).
ELSE.
  ...
ENDIF.

TRY.
  substring = text+offset(length).
CATCH cx\_sy\_range\_out\_of\_bounds.
   ...
ENDTRY.


### abenunknown_container_guidl.htm

---
title: "Anonymous Containers"
description: |
  Background Anonymous containers are character-like or byte-like data objects of type c or string type (or x/xstring type). Data objects of other types (especially structures) are assigned using casting(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencasting_guidl.htm 'Guideline') to
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenunknown_container_guidl.htm"
abapFile: "abenunknown_container_guidl.htm"
keywords: ["do", "if", "try", "class", "data", "types", "abenunknown", "container", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Anonymous Containers

Background

Anonymous containers are character-like or byte-like data objects of type c or string type (or x/xstring type). Data objects of other types (especially structures) are assigned using [casting](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencasting_guidl.htm "Guideline") to these objects, to store them persistently in these containers.

Rule

Do not use character or byte fields as containers

Do not store structured data in unstructured character-like or byte-like variables.

Details

The direct storage of structured data in unstructured character-like or byte-like data objects is problematic, particularly with data exchanges using remote function calls (RFC), input/output through the file system of the [host computer](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenhost_computer_glosry.htm "Glossary Entry") or output to a printer. Unexpected results can occur due to platform-dependent byte orders (endianness), alignment requirements and different character sets (code pages).

If, for example, a container is saved and imported from an AS instance whose [host computer](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenhost_computer_glosry.htm "Glossary Entry") has a different byte order, problems occur if the container is used for content for which the byte order is critical. In other words, the numeric fields of types i, decfloat16, decfloat34 and f. The order of the character-like data objects of bytes is also dependent on the platform in the character representation [UCS-2](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenucs2_glosry.htm "Glossary Entry") of the programming language ABAP.

Even without these technical problems, it can difficult to correctly import data that has been stored as described above. You usually have to perform another casting operation for the data type of the data stored in the container. However, as the relevant type information is not saved with the data, it might not be possible to perform type-compliant casting.

Hint

If data needs to be saved in an unstructured container, the statement EXPORT ... TO DATA BUFFER can be used. This type of data storage is robust against different platform properties. However, you cannot use EXPORT and IMPORT to directly process reference variables or instances referenced by them. As a workaround, you can serialize these variables and instances for storage by using the statement CALL TRANSFORMATION. A class must include the IF\_SERIALIZABLE\_OBJECT tag interface, so that its objects can be serialized using CALL TRANSFORMATION.


### abenref_transf_global_data_guidl.htm

---
title: "Pass by Reference of Global Data"
description: |
  Background In a local context you can normally directly access the data objects(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendata_type_obj_gdl.htm) of superordinate more global contexts. For example, it is possible in a method to perform writes on the attributes of its class and
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_transf_global_data_guidl.htm"
abapFile: "abenref_transf_global_data_guidl.htm"
keywords: ["do", "if", "method", "class", "data", "types", "abenref", "transf", "global", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Assignments, Calculations, and Other Types of Data Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassignment_access_gdl.htm) → 

Pass by Reference of Global Data

Background

In a local context you can normally directly access the [data objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendata_type_obj_gdl.htm) of superordinate more global contexts. For example, it is possible in a method to perform writes on the attributes of its class and on any global data of the current program.

Therefore, if a more global data object is passed to a procedure by reference, access is granted there both through its name and the formal parameter.

Rule

Do not pass global data to local contexts using pass by reference

Do not use global data as actual parameters for formal parameters of procedures if you can change them in the procedure in another way, and the parameter is passed by reference.

Details

If a global data object that has also been passed by reference is changed in a procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")), this also changes the formal parameter and vice versa. This behavior is not usually anticipated when writing the procedure.

Global data is only supposed to be passed to formal parameters for which [pass by value](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_transf_formal_para_guidl.htm "Guideline") is declared, or to procedures that are guaranteed not to have any unwanted consequences for this data.

Bad Example

After the do\_something method has been called in the main method in the following source code, the attr attribute contains the unexpected value 2.0, because the first assignment to the c\_value changing parameter, which has been passed by reference, also changes attr.

CLASS class DEFINITION.
   PUBLIC SECTION.
     METHODS
       main.
   PRIVATE SECTION.
     DATA
       attr TYPE p DECIMALS 2.
     METHODS
       do\_something CHANGING c\_value TYPE numeric.
ENDCLASS.
CLASS class IMPLEMENTATION.
   METHOD main.
     attr = '1.23'.
     do\_something( CHANGING c\_value = attr ).
   ENDMETHOD.
   METHOD do\_something.
     ...
     c\_value = floor( attr ).
     ...
     c\_value = c\_value + attr.
     ...
   ENDMETHOD.
ENDCLASS.

Good Example

If the pass by reference method in the method declaration of do\_something in the above example is converted into a pass by value method, as shown in the following source code, the attr attribute contains the expected value 2.23 after the method has been called.

...
     METHODS
       do\_something CHANGING VALUE(c\_value) TYPE numeric.
...


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Robust ABAP / System Fields

**Files**: 8 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Robust ABAP / System Fields

Included pages: 8


### abensystem_fields_gdl.htm

---
title: "System Fields"
description: |
  An ABAP program can request the state of the ABAP runtime framework using the system fields(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields.htm). From a technical viewpoint, these system fields are a set of built-in variables (the components of the built-in sy structur
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields_gdl.htm"
abapFile: "abensystem_fields_gdl.htm"
keywords: ["do", "case", "data", "abensystem", "fields", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) → 

System Fields

An ABAP program can request the state of the ABAP runtime framework using the [system fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields.htm). From a technical viewpoint, these system fields are a set of built-in variables (the components of the built-in sy structure with the data type SYST from ABAP Dictionary) that always exist when the program is running.

The system field sy-repid is an exception. This field indicates the name of the program currently running. In this case, we are dealing with a built-in constant and not a component of the built-in sy structure.

-   [Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensyst_field_access_guidl.htm "Guideline")
-   [Obsolete and internal system fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenobs_intern_system_field_guidl.htm "Guideline")
-   [Evaluation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenevaluation_guidl.htm "Guideline")
-   [Return code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenreturn_code_guidl.htm "Guideline")
-   [Use as actual parameter](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_actual_parameters_guidl.htm "Guideline")
-   [Using system fields on the user interface](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_ui_guidl.htm "Guideline")
-   [Use in operand positions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_operand_position_guidl.htm "Guideline")

Continue
[Access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensyst_field_access_guidl.htm)
[Obsolete and Internal System Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenobs_intern_system_field_guidl.htm)
[Evaluation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenevaluation_guidl.htm)
[Return Code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenreturn_code_guidl.htm)
[Using System Fields as Actual Parameters](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_actual_parameters_guidl.htm)
[Using System Fields on the User Interface](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_ui_guidl.htm)
[Using Elements in Operand Positions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_operand_position_guidl.htm)


### abensyst_field_access_guidl.htm

---
title: "Access"
description: |
  Background The system fields are supplied with values by the ABAP runtime framework. In a program, however, they behave like normal variables. You can assign values to these fields using the ABAP program. This is because both the ABAP kernel and the ABAP components of the ABAP runtime framework have
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensyst_field_access_guidl.htm"
abapFile: "abensyst_field_access_guidl.htm"
keywords: ["do", "if", "case", "class", "abensyst", "field", "access", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [System Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields_gdl.htm) → 

Access

Background

The system fields are supplied with values by the ABAP runtime framework. In a program, however, they behave like normal variables. You can assign values to these fields using the ABAP program. This is because both the ABAP kernel and the ABAP components of the ABAP runtime framework have can perform writes on system fields.

Rule

Do not write to system fields

In application programs, only perform reads on system fields and never perform writes.

Details

The values of system fields are usually vital for correct program execution. This means performing writes on system fields carries a lot of risk. Write operations in system fields can lead to a loss of important information, which can prevent programs from running correctly. Therefore, you cannot overwrite system fields to change the execution of the program or use the fields to replace explicitly defined variables.

In addition, you cannot misuse system fields as implicit output parameters of procedures, irrespective of whether the fields have been explicitly set within the procedure (due to an illegal write or as the result of an executed statement).

Exception

The only system fields where it was allowed to change the field content (in an application program) are part of classic list processing. This should [no longer be used](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlist_guidl.htm "Guideline").

Bad Example

The following source code shows a write performed on the system field sy-subrc, which occurs frequently. This write is not harmful but it also is not beneficial: sy-subrc is always set to zero when a function module is called and only adopts a different value by handling a classic exception. Therefore, the statement is redundant.

sy-subrc = 4.
CALL FUNCTION ...
   ...
   EXCEPTIONS ...
CASE sy-subrc.
   ...

Good Example

The source code below omits the write shown above.

CALL FUNCTION...
   ...
   EXCEPTIONS ...
CASE sy-subrc.
   ...


### abenobs_intern_system_field_guidl.htm

---
title: "Obsolete and Internal System Fields"
description: |
  Background Not all system fields are designed to be used in application programs. All available system fields are components of the structure SYST in ABAP Dictionary (or components of the structure sy in the debugger). The meaning of the components is included in the accompanying description. Any sy
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenobs_intern_system_field_guidl.htm"
abapFile: "abenobs_intern_system_field_guidl.htm"
keywords: ["do", "data", "abenobs", "intern", "system", "field", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [System Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields_gdl.htm) → 

Obsolete and Internal System Fields

Background

Not all system fields are designed to be used in application programs. All available system fields are components of the structure SYST in ABAP Dictionary (or components of the structure sy in the debugger). The meaning of the components is included in the accompanying description. Any system fields that are [obsolete](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields_obsolete.htm) or only to be [used internally](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields_internal.htm) are clearly marked.

Rule

Do not use obsolete or internal system fields

In application programs, do not use system fields flagged as obsolete or for internal use only in ABAP Dictionary or in the ABAP documentation.

Details

The behavior of obsolete and internal system fields is undefined. This means that ABAP application programs must not make any assumptions about the content of these system fields.

Bad Example

The following source code shows how the system field sy-fodec, flagged for internal use, is used illegally in the structure SYST after the statement DESCRIBE FIELD to count the number of decimal places in a data object.

DATA dobj TYPE p LENGTH 8 DECIMALS 2.
DATA type TYPE c LENGTH 1.
DATA decimal TYPE i.
DESCRIBE FIELD dobj TYPE type.
decimals = sy-fodec.

Good Example

The following source code demonstrates how decimal places can be counted correctly using the appropriate addition of the statement DESCRIBE FIELD.

DATA dobj TYPE p LENGTH 8 DECIMALS 2.
DATA type TYPE c LENGTH 1.
DATA decimals TYPE i.
DESCRIBE FIELD dobj TYPE type DECIMALS decimals.


### abenevaluation_guidl.htm

---
title: "Evaluation"
description: |
  Background System fields describe general system states or are set specifically by individual statements. The content of system fields is only defined as described in the documentation of the system fields or in the documentation of ABAP statements that set system fields. In contexts other than thos
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenevaluation_guidl.htm"
abapFile: "abenevaluation_guidl.htm"
keywords: ["loop", "do", "if", "method", "class", "abenevaluation", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [System Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields_gdl.htm) → 

Evaluation

Background

System fields describe general system states or are set specifically by individual statements. The content of system fields is only defined as described in the documentation of the system fields or in the documentation of ABAP statements that set system fields. In contexts other than those described there, the content of system fields is not defined. Particularly statements whose effects on system fields are undocumented can modify the content of specific system fields, such as the [return code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenreturn_code_guidl.htm "Guideline") sy-subrc, in an undefined way. This applies especially to statements that call ABAP code implicitly or explicitly when executed.

Rule

Evaluate system fields in the right position

Evaluate system fields only in contexts for which they are defined. If an ABAP statement sets a system field in accordance with its documentation, the field should be evaluated directly after the statement. You must not evaluate system fields after statements, however, whose effects are undocumented.

Details

If possible, a system field should be evaluated directly after the statement that set it, to prevent it from being overwritten by other statements. The bigger the gap between the ABAP statement in question and the evaluation of a system field, the higher the risk that this system field will be affected by a different statement in the meantime.

If necessary, the values of system fields should be saved in helper variables. This applies in particular to the general [return code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenreturn_code_guidl.htm "Guideline"), sy-subrc, which is set by very many different statements. Other common examples include the syindex loop counter or the sy-tabix table index.

You should never evaluate statement-related system fields after statements that do not set these fields according to their documentation. As before, a common example is the evaluation of sy-subrc. If it is not documented for a statement that it sets sy-subrc in a defined way, an evaluation after this statement is very risky. Either sy-subrc still has the previous value, or it is set in an undefined way by the statement. Both outcomes can lead to incorrect program behavior. The bad example in the [extended program check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm "Guideline") section shows an example of this.

Hint

The static methods of the class CL\_ABAP\_SYST also provide important system states. There is no possibility of a previous overwriting in the program.

Bad Example

The following source code shows an example where sy-subrc is evaluated too late. Even if it is not documented for the statements between FIND and IF that they set sy-subrc, the value can be overwritten due to possible side effects.

FIND PCRE ... IN ...
...
... "other statements
...
IF sy-subrc = 0.
   ...
ENDIF.

Good Example

The following source code corrects the above example by assigning sy-subrc to a helper variable directly after FIND. This variable is then evaluated in IF. It can also be necessary to assign sy-index or sy-tabix to a helper variable directly after DO or LOOP loop is entered.

FIND PCRE ... IN ...
find\_subrc = sy-subrc.
...
... "other statements
...
IF find\_subrc = 0.
   ...
ENDIF.


### abenreturn_code_guidl.htm

---
title: "Return Code"
description: |
  Background The most prominent system field is probably the return code(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenreturn_code_glosry.htm 'Glossary Entry') sy-subrc, which signals the successful execution of an ABAP statement or, if you are using classic exceptions(https://hel
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenreturn_code_guidl.htm"
abapFile: "abenreturn_code_guidl.htm"
keywords: ["select", "do", "if", "try", "method", "class", "data", "abenreturn", "code", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [System Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields_gdl.htm) → 

Return Code

Background

The most prominent system field is probably the [return code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenreturn_code_glosry.htm "Glossary Entry") sy-subrc, which signals the successful execution of an ABAP statement or, if you are [using classic exceptions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_exception_class_guidl.htm "Guideline"), of a procedure. A return code of 0 generally indicates successful execution.

Rule

Evaluate the return code sy-subrc

Evaluate the return code sy-subrc after every ABAP statement that sets the value according to the documentation. However, sy-subrc should never be set after statements are executed for which the setting of a return code is not documented.

Details

The system field sy-subrc indicates whether a statement was successfully executed. If the execution was not successful, the program should usually react accordingly. If this does not happen, the program's response will probably be unexpected.

This rule is a specialization of the more general rule [evaluate system fields in the correct place](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenevaluation_guidl.htm "Guideline"). It is specified here again separately due to the prominent role of the return code sy-subrc. The system field sy-subrc must always be evaluated immediately and, if necessary, assigned to a help variable. An evaluation cannot occur after statements that set sy-subrc not defined, because otherwise wrong conclusions could easily be drawn.

Hint

Special care must be taken in [functional method calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapcall_method_functional.htm). If executed successfully, each method call sets the return code sy-subrc to 0, which means that functional method calls overwrite the return code when used in statements where the setting of the return code is not documented. The same applies to the instance operator [NEW](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconstructor_expression_new.htm) when instances of classes are created.

Exception

If a handling action seems unnecessary because, in the developer's opinion, the statement is always executed successfully, the assumption should at least be saved and documented using an [assertion](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenassertions_guidl.htm "Guideline").

Bad Example

The following source code shows how further processing of data is performed using the work area of a SELECT statement, without a request from sy-subrc. However, the content of wa is usually undefined here, if a request from sy-subrc does not guarantee that database access will be successful.

SELECT ...
       INTO wa
       ...
... "work with wa

Good Example

The following source code corrects the above example. This means the successful execution of the SELECT statement is checked.

SELECT ...
       INTO wa
       ...
IF sy-subrc <> 0.
  ...
ENDIF
... "work with wa


### abenuse_actual_parameters_guidl.htm

---
title: "Using System Fields as Actual Parameters"
description: |
  Background The structure sy exists once in an internal session(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm 'Glossary Entry') and is shared by all programs in this internal session. The components of sy represent the system fields. System fields are gl
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_actual_parameters_guidl.htm"
abapFile: "abenuse_actual_parameters_guidl.htm"
keywords: ["loop", "do", "if", "try", "method", "class", "data", "abenuse", "actual", "parameters", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [System Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields_gdl.htm) → 

Using System Fields as Actual Parameters

Background

The structure sy exists once in an [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry") and is shared by all programs in this internal session. The components of sy represent the system fields. System fields are global for all programs of an internal session and their procedures.

Rule

Do not use system fields as actual parameters

Never use system fields as actual parameters - especially not for passing by reference.

Details

This rule reinforces the rule [do not pass global data to local contexts by reference](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_transf_global_data_guidl.htm "Guideline"). Since system fields are set implicitly, it is important to be even more careful. If the value of a system field changes implicitly within a procedure, the value of the parameter passed by reference, which refers to this system field, also changes. Procedures are never prepared for this behavior.

Even pass by value should be avoided for system fields. This is because a procedure might be switched to pass by reference in an enhancement process, without the consumer of the procedure being notified. The only secure method is to assign the value of a system field to a regular variable and then use this variable as the actual parameter when calling the program.

Bad Example

Looking at the method do\_something in the following source code, it could be expected that the parameter index in the loop to contain the unchanged value that was passed to the procedure. In fact, index references sy-index, which is set to the current loop counter in the DO loop.

CLASS class DEFINITION.
  PUBLIC SECTION.
    METHODS main.
  PRIVATE SECTION.
    METHODS do\_something IMPORTING index TYPE i.
ENDCLASS.
CLASS class IMPLEMENTATION.
  METHOD main.
    DO 2 TIMES.
      do\_something( sy-index ).
    ENDDO.
  ENDMETHOD.
  METHOD do\_something.
    DO 3 TIMES.
      ... index ... .
    ENDDO.
  ENDMETHOD.
ENDCLASS.

Good Example

The following source code corrects the call of the method do\_something. A helper variable is passed with the corresponding value instead of sy-index.

...
CLASS class IMPLEMENTATION.
  METHOD main.
    DATA index TYPE sy-index.
    DO 2 TIMES.
      index = sy-index.
      do\_something( index ).
    ENDDO.
  ENDMETHOD.
  ...
ENDCLASS.
...


### abenuse_ui_guidl.htm

---
title: "Using System Fields on the User Interface"
description: |
  Background As system fields are defined using the syst structure in ABAP Dictionary, you can technically use them to define input fields in dynpros or in Web Dynpro. Rule Do not use system fields on the user interface Never use system field types to define input or output fields for dynpros or selec
version: "7.56"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_ui_guidl.htm"
abapFile: "abenuse_ui_guidl.htm"
keywords: ["select", "do", "class", "data", "types", "abenuse", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [System Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields_gdl.htm) → 

Using System Fields on the User Interface

Background

As system fields are defined using the syst structure in ABAP Dictionary, you can technically use them to define input fields in dynpros or in Web Dynpro.

Rule

Do not use system fields on the user interface

Never use system field types to define input or output fields for dynpros or selection screens in application programs.

Details

This rule is derived from the [SoC](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenseperation_concerns_guidl.htm "Guideline") rule and the [use of data types rule](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenusing_types_guidl.htm "Guideline"). System fields are purely technical. Their semantic attributes, are defined in ABAP Dictionary (documentation and other texts), do not allow meaningful use in the user dialogs of application programs.

Hint

Similarly, you can apply the rule [only use semantically appropriate data types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenusing_types_guidl.htm "Guideline") to the use of SYST structure components (for typing interface parameters of procedures). The semantic meaning of a system field (expressed in the short text) does not generally match the meaning of the parameter.

Example

When the program PGL\_SYSTEM\_FIELD\_ON\_UI is executed, input fields for document output language are displayed on a classic dynpro. The first input field is declared with reference to data type syst-langu of system field sy-langu. The second input field is declared with reference to a semantically suitable ABAP Dictionary data type. The displayed F1 help clearly indicates that syst-langu is not suited for language fields in a user dialog. This is because the help only describes the behavior of the sy-langu field in a program. It does not describe the meaning of the language field in the relevant application.


### abenuse_operand_position_guidl.htm

---
title: "Using Elements in Operand Positions"
description: |
  Background Statements that modify the content of system fields generally evaluate the operands first and then set the system fields. In some complex statements, however, a system field could be set first, before all operand positions are evaluated. Rule Do not use system fields in statements that se
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_operand_position_guidl.htm"
abapFile: "abenuse_operand_position_guidl.htm"
keywords: ["loop", "do", "if", "case", "method", "abenuse", "operand", "position", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [System Fields](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_fields_gdl.htm) → 

Using Elements in Operand Positions

Background

Statements that modify the content of system fields generally evaluate the operands first and then set the system fields. In some complex statements, however, a system field could be set first, before all operand positions are evaluated.

Rule

Do not use system fields in statements that set the fields

For reasons of robustness, do not use system fields as operands of statements that themselves set these system fields.

Details

A program does not always define whether a particular system field is set in a statement before or after an operand is evaluated. This means that, to reduce risks and to make the program easier to read, the content of a system field should always be copied to a helper variable and only this copy should be used within the statement in question.

Hint

Also take note of how functional methods are used in operand positions. These methods also modify important system fields. Also be careful here when using system fields in operand positions of the same statement.

Bad Example

The following source code shows how the system field sy-tabix is used in a READ statement that sets the system field itself. The case shown here does not itself present any difficulties, however we still recommend you follow the rule above, not least to make the code more readable.

LOOP AT itab1 ... WHERE ...
   ...
   READ TABLE itab2 ... INDEX sy-tabix.
   ...
ENDLOOP.

Good Example

The following source code makes the example above more robust by assigning the value of the system field sy-tabix to a helper variable before it is used.

LOOP AT itab1 ... WHERE ...
   index = sy-tabix.
   ...
   .... itab2\[ index \] ...
   ...
ENDLOOP.


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Robust ABAP / Modularization Units

**Files**: 10 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Robust ABAP / Modularization Units

Included pages: 10


### abenmodularization_unit_gdl.htm

---
title: "Modularization Units"
description: |
  The key modularization units or callable units within an ABAP program are referred to as processing blocks. In this context, procedures on one side are distinguished from dialog modules and event blocks on the other side. While dialog modules and event blocks are called from the dynpro flow logic or
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_unit_gdl.htm"
abapFile: "abenmodularization_unit_gdl.htm"
keywords: ["do", "while", "method", "data", "abenmodularization", "unit", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) → 

Modularization Units

The key modularization units or callable units within an ABAP program are referred to as processing blocks. In this context, procedures on one side are distinguished from dialog modules and event blocks on the other side. While dialog modules and event blocks are called from the dynpro flow logic or from the event processing of the ABAP runtime framework, procedures are designed for direct calls from an ABAP program. In addition to processing blocks, macros can also be created as callable units.

Procedures can be:

-   Methods
-   Function modules
-   Subroutines

Only procedures support parameter interfaces and have a local data context.

Dialog modules and event blocks do not have parameter interfaces and generally do not have a local data context.

Macros are a kind of halfway house between callable units and source code modularization.

-   [Function Modules and Subroutines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")
-   [Type of Formal Parameters in Procedures](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_formal_param_proc_guidl.htm "Guideline")
-   [How Formal Parameters Are Passed](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_transf_formal_para_guidl.htm "Guideline")
-   [Pass By Reference for Output Parameters](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_transf_output_param_guidl.htm "Guideline")
-   [Typing of Formal Parameters](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_formal_param_guidl.htm "Guideline")
-   [Internal and External Procedure Calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenintern_extern_proc_call_guidl.htm "Guideline")
-   [Exiting Procedures](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexit_procedure_guidl.htm "Guideline")
-   [Dialog Modules and Event Blocks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendial_mod_event_block_guidl.htm "Guideline")
-   [Macros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmacros_guidl.htm "Guideline")

Continue
[Function Modules and Subroutines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm)
[Type of Formal Parameters in Procedures](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_formal_param_proc_guidl.htm)
[How Formal Parameters Are Passed](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_transf_formal_para_guidl.htm)
[Pass By Reference for Output Parameters](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_transf_output_param_guidl.htm)
[Typing of Formal Parameters](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_formal_param_guidl.htm)
[Internal and External Procedure Calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenintern_extern_proc_call_guidl.htm)
[Exiting Procedures](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexit_procedure_guidl.htm)
[Dialog Modules and Event Blocks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendial_mod_event_block_guidl.htm)
[Macros](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmacros_guidl.htm)


### abenfunct_module_subroutine_guidl.htm

---
title: "Function Modules and Subroutines"
description: |
  Background Function modules and subroutines are the procedures(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_guidl.htm 'Guideline') of the structured programming model that already existed before the introduction of ABAP Objects. -   Function modules in function poo
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm"
abapFile: "abenfunct_module_subroutine_guidl.htm"
keywords: ["select", "update", "do", "if", "case", "method", "class", "types", "abenfunct", "module", "subroutine", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Modularization Units](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_unit_gdl.htm) → 

Function Modules and Subroutines

Background

Function modules and subroutines are the [procedures](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_guidl.htm "Guideline") of the structured programming model that already existed before the introduction of ABAP Objects.

-   Function modules in function pools are independent repository objects that the structured model provides for [external calls](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenintern_extern_proc_call_guidl.htm "Guideline") or for the provision of reusable functions.
-   Before the introduction of ABAP Objects, subroutines could be created in any programs and were intended for internal calls or for the internal modularization of programs in the structured model.

The introduction of ABAP Objects means that methods now have both roles.

Rule

No implementations in function modules and subroutines

Only use function modules and subroutines if they are necessary from a technical viewpoint. In these cases, do not implement the required function. Instead, call the relevant (local) methods.

Details

This rule is directly derived from rule [Use ABAP Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline"). This rule states that only methods should be created. You are only [allowed](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") to create other types of procedures if is technically not possible to use a method:

-   Function modules for RFC, updates, and access to classic dynpros or selection screens
-   Subroutines for PERFORM ON COMMIT/ROLLBACK and GENERATE SUBROUTINE POOL

These subroutines should only be used for wrapping method calls to ensure that ABAP Objects is also used in these cases.

All the rules in these programming guidelines that relate to procedures actually refer to methods because, strictly speaking, no other procedures with nontrivial code are supposed to occur. If you strictly adhere to the above rule, is almost impossible for any of the rules that refer to implementations of procedures to be applied to function modules and subroutines, because they are only used to wrap calls. For example, function modules and subroutines should no longer contain any of the local declarations that are described in ["Defining Local Declarations at the Start of a Procedure"](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlocal_declar_guidl.htm "Guideline").

If you cannot adhere to the rule ["Use ABAP Objects"](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") and the above rule because, for example, existing legacy function modules and subroutines need to be maintained or enhanced and you cannot switch to methods, the rules in these programming guidelines that refer to procedures also apply to function modules and subroutines.


### abentype_formal_param_proc_guidl.htm

---
title: "Type of Formal Parameters in Procedures"
description: |
  Background The parameter interface of a procedure consists of formal parameters and specifies the exceptions(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenclass_exception_guidl.htm 'Guideline') possible in the procedure. The possible types of formal parameters are: -   Input param
version: "7.56"
category: "types"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_formal_param_proc_guidl.htm"
abapFile: "abentype_formal_param_proc_guidl.htm"
keywords: ["select", "do", "if", "case", "method", "class", "types", "internal-table", "abentype", "formal", "param", "proc", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Modularization Units](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_unit_gdl.htm) → 

Type of Formal Parameters in Procedures

Background

The parameter interface of a procedure consists of formal parameters and specifies the [exceptions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenclass_exception_guidl.htm "Guideline") possible in the procedure. The possible types of formal parameters are:

-   Input parameters
    
    Defined using IMPORTING in methods and function modules and using USING in subroutines.
    
-   Output parameters
    
    Defined using EXPORTING in methods and function modules.
    
-   Input/output parameters
    
    Defined using CHANGING in methods, function modules, and subroutines.
    
-   Return values
    
    Defined using RETURNING in methods.
    

The actual behavior of a formal parameter, however, is in part determined by the combination of the parameter type and the [pass by type](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_transf_formal_para_guidl.htm "Guideline").

Rule

Choose the appropriate formal parameter type

Select a formal parameter type that corresponds to the parameter semantics:

-   Input parameters for parameters that are evaluated but not changed in the procedure.
-   Output parameters or return values for parameters that are not evaluated but changed in the procedure.
-   Input/output parameters for parameters that are evaluated and changed in the procedure.

Details

For the consumer of a procedure, the parameter types provide important information about how they are used in the procedure and leads the user to expect the procedure to behave in a certain way. If an unsuitable parameter type is selected, the risk of inappropriate use increases.

-   Input-only parameters should always have the IMPORTING type (or USING for subroutines). Be aware that, when using pass by reference, writes performed on an input parameter defined using USING are possible without a syntax error being produced (as is the case with input parameters of methods or function modules defined using IMPORTING). Yet another reason to not use subroutines.
-   Output-only parameters should always be EXPORTING or RETURNING.
-   Parameters that are received and changed should always be of the CHANGING type. In particular, in a procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) the fact that an EXPORTING parameter (or a USING parameter in the case of subroutines) passed by reference [behaves](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_transf_output_param_guidl.htm "Guideline") (from a technical perspective) like a CHANGING parameter should not be exploited.

Input parameters or input/output parameters that are not necessarily required for the execution of a procedure should be defined as optional by using OPTIONAL or by specifying a DEFAULT value. Otherwise, calling programs are forced to pass unnecessary parameters and create helper variables especially for this purpose.

A narrow parameter interface in line with a [procedure with an appropriate number of statements](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenproc_volume_guidl.htm "Guideline") only requires a few input parameters and one return value. However, this cannot really be applied consistently in practice and is therefore not set out as a rule here.

Hint

Another parameter type are table parameters that can be declared for function modules and subroutines using TABLES. Basically, they have the same effects as input/output parameters for internal tables. This parameter type is obsolete and should no longer be used.

Bad Example

The following source code shows a formal parameter that is declared as an output parameter using EXPORTING, but is used in the method like an input/output parameter declared with CHANGING. This does not correspond to the semantics that a calling program expects.

CLASS class DEFINITION.
  PUBLIC SECTION.
    METHODS do\_something
      EXPORTING e\_parameter TYPE ...
ENDCLASS.

CLASS class IMPLEMENTATION.
  METHOD do\_something.
    "evaluate e\_parameter
    ...
    "set e\_parameter
    ...
  ENDMETHOD.
ENDCLASS.

Good Example

The following source code corrects the above example by declaring the parameter as an input/output parameter with CHANGING according to its use.

CLASS class DEFINITION.
  PUBLIC SECTION.
    METHODS do\_something
      CHANGING c\_parameter TYPE ...
ENDCLASS.

CLASS class IMPLEMENTATION.
  METHOD do\_something.
    "evaluate c\_parameter
    ...
    "set c\_parameter
    ...
  ENDMETHOD.
ENDCLASS.


### abentype_transf_formal_para_guidl.htm

---
title: "How Formal Parameters Are Passed"
description: |
  Background Parameters can be passed to procedures either by reference or by value. -   Pass by reference In the case of pass by reference, a reference to the actual parameter is passed to the procedure when it is called. The procedure then works with the actual parameter. No local data object is cre
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_transf_formal_para_guidl.htm"
abapFile: "abentype_transf_formal_para_guidl.htm"
keywords: ["select", "do", "while", "if", "case", "method", "data", "internal-table", "abentype", "transf", "formal", "para", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Modularization Units](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_unit_gdl.htm) → 

How Formal Parameters Are Passed

Background

Parameters can be passed to procedures either by reference or by value.

-   Pass by reference
    
    In the case of pass by reference, a reference to the actual parameter is passed to the procedure when it is called. The procedure then works with the actual parameter. No local data object is created for the actual parameter. Input parameters that are passed by reference cannot be changed in the procedure (exception: USING parameters of subroutines).
    
-   Pass by value
    
    In the case of pass by value, a type-compliant local data object is created as a copy of the actual parameter for the formal parameter. The system initializes output parameters and return values when the procedure is started. Input parameters as well as input/output parameters receive the value of the actual parameter. A changed formal parameter is only passed to the actual parameter if the procedure is completed without errors.
    

IMPORTING parameters that are passed by reference are protected from explicit changes within the procedure. This is not the case for the pass by value method. RETURNING parameters always require the pass by value method.

Rule

Choose a suitable pass-by type

When selecting the pass-by type, consider both speed and security:

-   Pass by value for small data sets for security reasons
-   Pass by reference for large data sets for performance reasons

Details

The pass by reference method generally has a higher performance than pass by value because no values need to be copied. This speed advantage can be noticed especially in the case of large parameters, such as internal tables or strings, or in mass data processing. In the case of small, flat parameters, the pass by value method usually does not lead to problems because the copy costs incurred are not high here. Furthermore, for strings and internal tables, sharing takes effect in the case of pass by value. Consequently, only references are passed here. The time-intensive copy process is skipped if the data objects involved are only to be read-accessed, such as in the case of EXPORTING parameters that are filled within a procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")), and are not modified by the calling program after the pass.

Despite the speed advantage, the pass by reference method can lead to problems due to the following aspects:

-   EXPORTING parameters that are passed by reference are not initialized automatically. Therefore, such parameters are [not supposed to be read](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_transf_output_param_guidl.htm "Guideline") until the first value has been assigned to them.
-   Writes performed on EXPORTING and CHANGING parameters with the pass by reference method work directly on the actual parameters. Their values are also modified if the procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) is left early due to an exception.
-   IMPORTING parameters that are passed by reference change if the actual parameter changes. The actual parameter can change, for example, if it is a [global variable](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_transf_global_data_guidl.htm "Guideline") or a [system field](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_actual_parameters_guidl.htm "Guideline").

If passing by value does not cause performance problems, that is, if small data sets are passed or sharing can be used, this method should be used for security reasons. If speed is an issue, pass by reference should be chosen. In this case, the potential risks of implementing the procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) must be [considered](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_transf_output_param_guidl.htm "Guideline").

Example

See the example in the section about [Code Inspector](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencode_inspector_guidl.htm "Guideline"). In this example, an internal table is passed by reference due to performance reasons, while an elementary parameter is passed by value due to robustness reasons.


### abenref_transf_output_param_guidl.htm

---
title: "Pass By Reference for Output Parameters"
description: |
  Background When parameters are passed to a procedure by reference, this procedure directly uses the data object that has been passed as a parameter. Its value is consequently determined by the calling program of the procedure. Particular notice must be made of this behavior for EXPORTING parameters,
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenref_transf_output_param_guidl.htm"
abapFile: "abenref_transf_output_param_guidl.htm"
keywords: ["insert", "delete", "do", "if", "method", "class", "data", "internal-table", "abenref", "transf", "output", "param", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Modularization Units](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_unit_gdl.htm) → 

Pass By Reference for Output Parameters

Background

When parameters are passed to a procedure by reference, this procedure directly uses the data object that has been passed as a parameter. Its value is consequently determined by the calling program of the procedure. Particular notice must be made of this behavior for EXPORTING parameters, whose value is (unlike the pass by value method) not initialized when the procedure is called. After the procedure has started, an output parameter that was passed by reference has the value of the supplied actual parameter.

Rule

Use output parameters correctly with pass by reference

Do not evaluate EXPORTING parameters that are passed by reference in a procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) until a value has been explicitly assigned.

Details

The value of an output parameter that has been passed by reference is undefined from the perspective of the procedure, since cannot be evaluated within the procedure in a useful manner. Therefore, no assumptions can be made regarding the content of the parameter until the first value has been assigned to it.

If a parameter like this is an internal table or a string, a simple write is not sufficient. First, an initialization must be implemented. For example, if new lines are to be inserted in an internal table that is supposed to be produced by reference, its current content needs to be deleted first. Pass by reference means that it cannot be guaranteed that the table is actually empty when the procedure is started. The same applies to strings that are filled using concatenation operations within the procedure.

Hint

If the described properties are to be exploited for writable parameters that have been passed by reference in a procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")), that is, a read is to be performed prior to the write or an existing dynamic data object is to be extended, the [appropriate formal parameter type](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_formal_param_proc_guidl.htm "Guideline") must be specified, that is, input/output parameter (CHANGING parameter).

Exception

Strictly speaking, optional output parameters that have been passed by reference must be initialized only if the parameter is bound to an actual parameter when called. This can be determined using the IS SUPPLIED query. The obsolete query, IS REQUESTED, in contrast, should no longer be used.

Example

The following source code shows how an internal table that, for performance reasons, is implemented by reference is returned. For this reason, it cannot be declared as a RETURNING parameter. The tabular output parameter is explicitly initialized at the beginning of the method before new lines are inserted.

CLASS class DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS get\_some\_table
      EXPORTING e\_some\_table TYPE table\_type.
ENDCLASS.
CLASS class IMPLEMENTATION.
  METHOD get\_some\_table.
    DATA new\_line LIKE LINE OF e\_some\_table.
    CLEAR e\_some\_table.
    ...
    INSERT new\_line INTO TABLE e\_some\_table.
    ...
  ENDMETHOD.
ENDCLASS.


### abentype_formal_param_guidl.htm

---
title: "Typing of Formal Parameters"
description: |
  Background The typing of formal parameters can be full or generic. Formal parameters of methods must be, and formal parameters of function modules and subroutines should be, explicitly typed using the TYPE or LIKE addition. When actual parameters are bound to formal parameters, the system checks whe
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_formal_param_guidl.htm"
abapFile: "abentype_formal_param_guidl.htm"
keywords: ["do", "while", "if", "try", "method", "class", "data", "types", "field-symbol", "abentype", "formal", "param", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Modularization Units](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_unit_gdl.htm) → 

Typing of Formal Parameters

Background

The typing of formal parameters can be full or generic. Formal parameters of methods must be, and formal parameters of function modules and subroutines should be, explicitly typed using the TYPE or LIKE addition. When actual parameters are bound to formal parameters, the system checks whether the data type of the actual parameter matches the typing of the formal parameter.

-   Full typing completely defines the data type of a formal parameter and applies to both dynamic access and static access to the formal parameter.
-   Generic typing does not define the data type of a formal parameter in full. Instead, the actual data type of the supplied actual parameter is used. The attributes of the actual parameter apply to dynamic access performed on formal parameters like this. The attributes defined by the typing apply to static access.

For generic typing, a set of built-in generic types is available in ABAP, which are only intended for the typing of formal parameters and field symbols. Using them in any other way can lead either to errors or to missing attributes being filled with default values. The generic types are: any, any table, c, clike, csequence, data, decfloat, hashed table, index table, n, numeric, object, simple, sorted table, standard table, table, x, and xsequence. Self-defined table types without fully specified table keys are also generic.

Rule

Be as specific as possible when typing formal parameters

Be only as generic as necessary when typing formal parameters. Fully generic types (any) should be the exception rather than the rule. When used, a formal parameter must be compliant with all possible fixed types.

Details

Absolute type security within a procedure can only be achieved using full typing. It should always be used when providing a generic service is not a defined goal. It is much easier to carry out [tests](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm "Guideline") for non-generic services than for generic services.

A generically typed procedure interface usually involves more implementation effort within the procedure ([method](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) to avoid [runtime errors](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenruntime_error_dyn_proc_guidl.htm "Guideline"). Therefore, use the following principle when providing generic interfaces: as little generic typing as possible and as much generic typing as necessary. You should use specific generic types, such as numeric or csequence, instead of any or data, for example, if services are involved that are supposed to process numeric values or character strings. However, already when csequence is used, you must take into account that the possible concrete types c and string behave differently with respect to trailing blanks. or that the concrete numeric types that are possible for numeric lead to different [calculation types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencalculation_type_glosry.htm "Glossary Entry") in calculations. Especially, when existing typings are generalized, it may be necessary to modify the implementation accordingly.

Generic typing can be a pitfall if you are not aware that you have used generic typing instead of full typing, because only the technical type attributes are checked when an actual parameter is connected, but no component names, for example. This can lead to different behavior than expected.

Hints

-   These statements about typing apply equally to [field symbols](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendyn_access_data_obj_guidl.htm "Guideline").
-   In typings of formal parameters with the generic type [data](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbuilt_in_types_generic.htm), it should be noted that no [numeric functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmathematical_funktion_glosry.htm "Glossary Entry"), no [description functions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendescription_function_glosry.htm "Glossary Entry"), and no [arithmetic expressions](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenarithmetic_expression_glosry.htm "Glossary Entry") can be passed to these parameters. This restriction can be bypassed by applying the [conversion operator](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconversion_operator_glosry.htm "Glossary Entry") [CONV](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconstructor_expression_conv.htm) to the actual parameter. This restriction does not apply to the generic type any, however, which means that, if required, a typing with the generic type any is recommended.

Bad Example

The following method shows different behavior when a blank is passed as a string of the type string or as a text field of the type c.

CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main IMPORTING flag TYPE csequence.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF flag = abap\_false.
      ...
    ENDIF.
  ENDMETHOD.
ENDCLASS.

Good Example

Using the built-in function [condense](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencondense_functions.htm) produces the same behavior when a blank is passed, regardless of the fixed type.

CLASS demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS main IMPORTING flag TYPE csequence.
ENDCLASS.
CLASS demo IMPLEMENTATION.
  METHOD main.
    IF condense( flag ) = abap\_false.
      ...
    ENDIF.
  ENDMETHOD.
ENDCLASS.

Bad Example

The example in the following source code shows the trap you can fall into, particularly when working with table types, if the table key is not specified in full their declaration (in a program or in ABAP Dictionary). Due to the missing key specification, the table type that is used to type the formal parameter of sort\_itab is generic. While the first static sort is successful, the second SORT statement fails and raises a runtime error. For the dynamic component specification, the attributes of the actual parameter apply to the formal parameter, and the actual parameter does not have the col2 component (this can also be tracked in the ABAP Debugger).

CLASS class DEFINITION.
  PUBLIC SECTION.
    TYPES: BEGIN OF struc,
              col1 TYPE type1,
              col2 TYPE type2,
           END OF struc,
           itab TYPE STANDARD TABLE OF struc.
    METHODS: main,
             sort\_itab CHANGING c\_itab TYPE itab.
ENDCLASS.

CLASS class IMPLEMENTATION.
  METHOD main.
    TYPES: BEGIN OF struc,
             col1 TYPE type1,
             col3 TYPE type2,
           END OF struc.
    DATA itab TYPE STANDARD TABLE OF struc
              WITH NON-UNIQUE KEY col1 col3.
              ...
     sort\_itab( CHANGING c\_itab = itab ).
  ENDMETHOD.
  METHOD sort\_itab.
     SORT c\_itab BY col1 col2.
     SORT c\_itab BY ('COL1') ('COL2'). "<- Runtime error!
  ENDMETHOD.
ENDCLASS.

Good Example

The following source code shows a very simple correction of the typing in the above example. Because the primary table key is specified in full, the type used is no longer generic, and dynamic sorts work like static sorts.

...
itab TYPE STANDARD TABLE OF struc
     WITH NON-UNIQUE KEY col1 col2.
...


### abenintern_extern_proc_call_guidl.htm

---
title: "Internal and External Procedure Calls"
description: |
  Background When a procedure is called, a distinction is made between internal and external procedure calls. An internal call calls a procedure of the same program, whereas an external call calls a procedure of a different program. The major difference between internal and external procedure calls is
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenintern_extern_proc_call_guidl.htm"
abapFile: "abenintern_extern_proc_call_guidl.htm"
keywords: ["select", "do", "if", "case", "try", "method", "class", "data", "types", "abenintern", "extern", "proc", "call", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Modularization Units](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_unit_gdl.htm) → 

Internal and External Procedure Calls

Background

When a procedure is called, a distinction is made between internal and external procedure calls. An internal call calls a procedure of the same program, whereas an external call calls a procedure of a different program. The major difference between internal and external procedure calls is that the program might have to be loaded first for an external call. With internal calls, the program is already loaded. Possible external calls, where a program might have to be loaded, include:

-   Methods of global classes in class pools
-   Function modules in function pools
-   Subroutines in all programs that can contain subroutines (PERFORM...IN PROGRAM)
-   Methods of local classes, where the name of the class is specified dynamically using an absolute type name (\\PROGRAM= ... \\CLASS=...\\)

The programs loaded within an [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry") are grouped into program groups. There is always one main program group and a number of optional additional program groups. Each program group contains a main program and possibly several additional programs (loaded due to external use). The loaded programs are not always the result of a call. The reason could also have to do with other references to components of external programs, such as a reference to a visible data type of a global class. The loaded programs are not always the result of a call. The reason could also have to do with other references to components of external programs, such as a reference to a visible data type of a global class.

If shared resources of the program group are accessed in an externally called procedure, the information about which program group the program was loaded into is very important. Whether a program creates a separate program group when loaded or whether it is loaded into an existing program group, largely depends on the program type:

-   Class pools and function pools (and external calls of global class methods or function modules) always create a new program group when loaded.
-   If subroutines or methods of local classes of other program types (not class pools and function pools) are called externally, the programs are loaded into the program group of the calling program.

Rule

Only call suitable procedures externally

Only call procedures externally that are intended for external calls. The methods of global classes and function modules are intended for external calls. Subroutines and the methods of local classes are not designed for external calls.

Details

The only procedures designed for external calls are the visible methods of global classes and function modules. The master programs of these procedures are always main programs of their program groups and the procedure always works with the resources of this program group.

However, external calls of subroutines and dynamic calls of methods in local classes of other programs are problematic. Usually, subroutines and local classes are intended for internal use within their program. External calls are not anticipated during the development phase. (On the other hand, no problems occur when an already loaded program deliberately passes a reference to an object of a local class to another program). Therefore, these subroutines and local classes should always be handled as private components of the program, even though they are technically public.

In addition, an assignment to a particular program group is not statically defined. Because the call order can depend on user actions or data content, the program of the called procedure can belong to the main program group in one instance and can belong to an additional program group in another instance. This does not define which program group the shared resources belong to. The shared resources are:

-   Classic dynpros (including selection screens and classic lists) and GUI statuses
    
    The classic dynpros and GUI statuses are always shared within a program group (the classic dynpros and GUI statuses of the main program in this program group). For example, the CALL SCREEN statement in an externally called procedure always calls a dynpro of the main program of the program group and not a dynpro of the compilation unit of the procedure. The response to user actions in the dynpro (called as described above) is also handled in the main program of the program group.
    
-   Interface work areas
    
    Interface work areas are defined as table work areas using the TABLES and NODES statements or using the obsolete statement DATA ... COMMON PART. They are only created once for each program group and are shared by the main program and the loaded additional programs.
    

Hint

Except for the warning regarding dynamic calls of methods of local classes from other programs, this rule is basically intended to raise the awareness of problems when using existing programs. In new programs, the creation of new subroutines and the use of [shared resources](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentable_work_area_guidl.htm "Guideline") are largely obsolete anyway. The problems mentioned above can only occur if classic dynpros or selection screens (and therefore GUI statuses and table work areas) are used.

Example

The following source code demonstrates how to assign interface work areas to program groups, in the case of external subroutine calls. The table work area dbtab declared in sapssubr is shared either with sapmprog or with saplfugr. If share has the value 'FUGR', saplfugr and sapssubr share the table work area. Otherwise it is shared by sapmprog and sapssubr. It is not possible to rely on a specific assignment.

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
PROGRAM sapmprog.
TABLES dbtab.
...
IF share = 'FUGR'.
  CALL FUNCTION 'FUNC'.
ENDIF.
...
PERFORM sub IN PROGRAM sapssubr.
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
FUNCTION-POOL saplfugr. 
TABLES dbtab.
...
FUNCTION func.
  PERFORM sub IN PROGRAM sapssubr.
ENDFUNCTION.
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
PROGRAM sapssubr.
TABLES dbtab.
...
FORM sub.
  ...
ENDFORM.
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*


### abenexit_procedure_guidl.htm

---
title: "Exiting Procedures"
description: |
  Background You can exit procedures in the usual way using the END... statement or by using one of the following statements: -   RETURN -   EXIT -   CHECK log_exp These statements end a procedure properly, that is, the system passes output parameters for which passing by value is specified and retur
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenexit_procedure_guidl.htm"
abapFile: "abenexit_procedure_guidl.htm"
keywords: ["update", "loop", "do", "if", "case", "try", "method", "abenexit", "procedure", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Modularization Units](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_unit_gdl.htm) → 

Exiting Procedures

Background

You can exit procedures in the usual way using the END... statement or by using one of the following statements:

-   RETURN
-   EXIT
-   CHECK log\_exp

These statements end a procedure properly, that is, the system passes output parameters for which passing by value is specified and returns values to the assigned actual parameters. In addition, you can terminate the processing of a procedure as follows, without supplying the actual parameters with values:

-   Calling another unit (program, dynpro) without returning to the procedure
-   Triggering an exception or sending a dialog message if an [error occurs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenerror_handling_gdl.htm)

Rule

Only use RETURN to exit procedures

Use the statement RETURN to properly exit a procedure (method, see rule [no implementations in function modules and subroutines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) early.

Details

The statement RETURN is used to exit procedures and always has this result. The behavior of the EXIT and CHECK statements (conditional exit), in contrast, is context- dependent: Within a loop, only the loop is exited; outside a loop, the surrounding procedure is exited. This ambiguity limits the legibility of source code. Therefore, EXIT and CHECK should only be used to exit loops, and RETURN only to exit procedures. Only RETURN enables you to exit a procedure in a loop context.

The statements for [exiting programs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_leave_program.htm) are not recommended inside procedures. They are not allowed in contexts like [unit tests](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenunit_test_glosry.htm "Glossary Entry") or during [update](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendb_commit_during_update.htm) and lead to exceptions if a procedure is called from such a context.

Hint

As well as the statements RETURN, EXIT, and CHECK specified here, the statements REJECT and STOP can be used to exit special [event blocks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendial_mod_event_block_guidl.htm "Guideline"). Conversely, RETURN, EXIT, and CHECK can also exit processing blocks other than procedures. In both cases, you must consider the particular behavior of the ABAP runtime framework regarding the exited processing block. Because other processing blocks are only supposed to contain one method call according to the rules [use ABAP Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") and [no implementations in dialog modules and event blocks](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendial_mod_event_block_guidl.htm "Guideline"), these cases should no longer occur in new programs.

Exception

An exception to the rule to only use RETURN to exit procedures are CHECK statements that are located at the beginning of a procedure and that check the prerequisites for the execution of the procedure there. Using the CHECK statement in such a way does not impair the legibility and is thus allowed. However, this exception does not apply to other positions within a procedure and outside loops.

Bad Example

The following source code shows how a method is left early with a CHECK statement, whose meaning cannot be identified by simply looking at it. You have to know that CHECK exits the procedure if the following logical expression is wrong, which is why a double negation is necessary here.

METHOD some\_method.
   ...
   CHECK is\_finished = abap\_false.
   ...
ENDMETHOD.

Good Example

The following source code corrects and simplifies the above example by implementing a conditional exit with an IF control structure that is easy to read.

METHOD some\_method.
   ...
   IF is\_finished = abap\_true.
      RETURN.
   ENDIF.
   ...
ENDMETHOD.


### abendial_mod_event_block_guidl.htm

---
title: "Dialog Modules and Event Blocks"
description: |
  Background Besides procedures, there are two further types of processing blocks. However, they do not have a parameter interface and do not allow declaration of local data: (AT SELECTION-SCREEN and GET are exceptions but they should not be exploited): -   Dialog modules Dialog modules are introduced
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendial_mod_event_block_guidl.htm"
abapFile: "abendial_mod_event_block_guidl.htm"
keywords: ["select", "do", "if", "case", "method", "class", "data", "types", "abendial", "mod", "event", "block", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Modularization Units](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_unit_gdl.htm) → 

Dialog Modules and Event Blocks

Background

Besides procedures, there are two further types of processing blocks. However, they do not have a parameter interface and do not allow declaration of local data: (AT SELECTION-SCREEN and GET are exceptions but they should not be exploited):

-   Dialog modules
    
    Dialog modules are introduced using the statement MODULE and ended using the statement ENDMODULE. These modules form the functional interface between classic dynpros and the associated ABAP program. They are called from within the dynpro flow logic.
    
-   Event blocks
    
    Event blocks are introduced by the corresponding keyword and implicitly ended by the next processing block. The processing of an event block is raised by the ABAP runtime framework when the relevant event occurs. There are event blocks for:
    
    -   Loading a program (LOAD-OF-PROGRAM)
    -   Reporting events that occur during the processing of an executable program (with a logical database) (INITIALIZATION, START-OF-SELECTION, GET, END-OF-SELECTION)
    -   Selection screen events (AT SELECTION-SCREEN ...)
    -   List events of classic list processing (AT LINE-SELECTION, AT USER-COMMAND)

Rule

No implementations in dialog modules and event blocks

Only use dialog modules and event routines if they are necessary from a technical viewpoint. In these cases, do not implement the required function. Instead, call the relevant (local) methods.

Details

Since it is not possible to declare local data in dialog modules and event blocks, you cannot implement any useful program logic. This means that any dialog modules and event blocks (provided that they are still necessary) should only contain one method call. If you [use ABAP Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") consistently, only the following elements are required:

-   LOAD-OF-PROGRAM or INITIALIZATION as the program constructor in cases where [program types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_type_guidl.htm "Guideline") other than class pools are used
-   Dialog modules and AT SELECTION-SCREEN when [classic dynpros and selection screens](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenencap_class_interf_guidl.htm "Guideline") are processed
-   START-OF-SELECTION in [executable programs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenprogram_type_guidl.htm "Guideline") for background processing. To improve readability, you should always specify the statement explicitly (although it is optional in many situations).
-   Although possible in the syntax, you should never specify an event block more than once within a program.

Hint

Using LOAD-OF-PROGRAM in a function pool is basically the same as using a static constructor in a global class. In executable programs, you can use INITIALIZATION instead, if any parameters passed using SUBMIT need to be evaluated.

Example

The following source code shows the PAI modules of the function pool DEMO\_CR\_CAR\_RENTAL\_SCREENS from the package SABAP\_DEMOS\_CAR\_RENTAL\_DYNPRO. The screens in this package can be called using transaction DEMO\_CR\_CAR\_RENTAL. These dialog modules adhere to the above rule. They do not contain their own implementations. They call methods of a local class of the function pool.

MODULE cancel INPUT.
  screen\_handler=>cancel( ).
ENDMODULE.

MODULE user\_command\_0100 INPUT.
  screen\_handler=>user\_command\_0100( ).
ENDMODULE.

MODULE customers\_mark INPUT.
  customer\_table=>mark( ).
ENDMODULE.

MODULE reservations\_mark INPUT.
  reservation\_table=>mark( ).
ENDMODULE.


### abenmacros_guidl.htm

---
title: "Macros"
description: |
  Background A macro(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_macros.htm) is a summary of a statement list for internal reuse within a program between DEFINE(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapdefine.htm) and END-OF-DEFINITION(https://help.s
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmacros_guidl.htm"
abapFile: "abenmacros_guidl.htm"
keywords: ["select", "do", "if", "case", "method", "data", "types", "internal-table", "abenmacros", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Modularization Units](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodularization_unit_gdl.htm) → 

Macros

Background

A [macro](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_macros.htm) is a summary of a statement list for internal reuse within a program between [DEFINE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapdefine.htm) and [END-OF-DEFINITION](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapend-of-definition.htm). The statement list is included in another position in the program by specifying the macro name. A macro can contain up to nine placeholders, &1 to &9, in place of ABAP words and operands (or parts of operands). These placeholders must be replaced by fixed words when the macro is included.

Rule

Only use macros in exceptional cases.

We recommend that procedures ([methods](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) or expressions with appropriate operators are used instead of macros.

Details

Macros are often used as callable units, instead of real procedures. This is rarely a good idea however. Macros do not have a real context, and cannot be executed in steps in ABAP Debugger. This makes it practically impossible to look for errors in programs that use large or complex macros. For these reasons, a macro cannot be viewed as a worthy replacement for a genuine procedure.

In addition, in the past macros were not just used to replace procedures, they were also used to perform recurrent declarations of structured data. Today, macros are, of course, avoided and [standalone types](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenbound_independent_dtype_guidl.htm "Guideline") are used instead.

Nowadays, expressions can be used instead of macros in many cases. One example is using the value operator [VALUE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconstructor_expression_value.htm) to fill internal tables, which makes it unnecessary to use macros (which mostly contain the statement APPEND.

In certain cases, however, the use of macros could be justified, as long as the statement patterns are simple and recurring. Here, a macro can be seen as a design-time generation tool. The following (good) example shows how a macro can be used in this way. In a situation like this, a macro may be preferable to a procedure for the following reasons:

-   The statement list in the macro is clear and simple enough that it does not matter that it cannot be debugged.
-   The syntax check performs static checks on the correctness of the statements. When using the dynamic language methods required in a procedure, any errors (in this case, incorrect names) would not be detected until runtime. [Dynamic access](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm) would also be more time-consuming.
-   Unlike listing all statements separately, using these macros makes the source code clearer, particularly if the statement list is repeated frequently. There is a lower risk of trivial typing errors being made, since there is no need to create and edit a large volume of similar source code. It is easier to make subsequent changes to the logic.

This means that, in certain cases, using macros can improve the correctness and maintainability of source code. Macros that contain non-trivial control structures, however, always present a maintenance problem because they cannot run in steps in ABAP Debugger. For this reason, use macros very sparingly and only if they contain no more than a few lines. Errors in macros are almost impossible to analyze.

Hint

As well as existing in the source code of a program, macros can also be saved as cross-program macros in type pools or in database table TRMAC. . However, no new macros should be defined in type pools or TRMAC.

Bad Example

The following source code is an example where a macro is an unsuitable replacement for a genuine procedure. In this case, the macro could only be used once and in a single context, since the work area wa can only be declared once there. In this example, a procedure with dynamic components would be a better idea.

DEFINE get\_data.
  DATA wa TYPE &1.
  SELECT SINGLE \*
         FROM &1
         WHERE &2 = @&3 AND
               &4 = @&5
         INTO @wa.
END-OF-DEFINITION.

get\_data spfli carrid 'LH' connid '0400'.

Good Example

The following source code shows an example where using a macro could be a good idea. Here, a few simple statement lists (assignments enclosed in IF) are to be repeated often. The names of the operands are also very regular. This function could also be implemented using other means (such as a procedure) by using dynamic means to access the variables or by expanding every IF block. In this particular case, however, using a small macro makes the program far easier to understand and maintain.

TYPES: BEGIN OF value\_and\_flag,
         value TYPE string,
         flag TYPE c LENGTH 1,
       END OF value\_and\_flag.

TYPES: BEGIN OF structure,
         component\_up TYPE value\_and\_flag,
         component\_down TYPE value\_and\_flag,
         ...
         component\_top TYPE value\_and\_flag,
       END OF structure.

DATA struct TYPE structure.

DEFINE macro\_set\_value\_if\_flag\_is\_set.
   IF struct-component\_&1-flag = abap\_true.
      struct-component\_&1-value = &2.
   ENDIF.
END-OF-DEFINITION.

...

macro\_set\_value\_if\_flag\_is\_set up 'ABC'.
macro\_set\_value\_if\_flag\_is\_set down 'IJK'.
...
macro\_set\_value\_if\_flag\_is\_set top 'XYZ'.
...


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Robust ABAP / Dynamic Programming Techniques

**Files**: 8 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Robust ABAP / Dynamic Programming Techniques

Included pages: 8


### abendynamic_prog_technique_gdl.htm

---
title: "Dynamic Programming Techniques"
description: |
  Dynamic programming techniques are all techniques whose functions or effects are detectable only at runtime of a program in the runtime framework. -   Using Dynamic Programming Techniques(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_dynamic_progr_tech_guidl.htm 'Guideline') -
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm"
abapFile: "abendynamic_prog_technique_gdl.htm"
keywords: ["do", "if", "class", "data", "abendynamic", "prog", "technique", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) → 

Dynamic Programming Techniques

Dynamic programming techniques are all techniques whose functions or effects are detectable only at runtime of a program in the runtime framework.

-   [Using Dynamic Programming Techniques](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_dynamic_progr_tech_guidl.htm "Guideline")
-   [Runtime Errors in Dynamic Processing](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenruntime_error_dyn_proc_guidl.htm "Guideline")
-   [Using Dynamic Data Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_dyn_data_object_guidl.htm "Guideline")
-   [Memory Consumption of Dynamic Memory Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmem_cons_dyn_mem_obj_guidl.htm "Guideline")
-   [Administration Costs of Dynamic Memory Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadmin_costs_dyn_mem_obj_guidl.htm "Guideline")
-   [Accessing Data Objects Dynamically](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendyn_access_data_obj_guidl.htm "Guideline")
-   [Generic Programming](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_progr_guidl.htm "Guideline")
    

Security Hint

If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm).

Continue
[Using Dynamic Programming Techniques](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_dynamic_progr_tech_guidl.htm)
[Runtime Errors in Dynamic Processing](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenruntime_error_dyn_proc_guidl.htm)
[Using Dynamic Data Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_dyn_data_object_guidl.htm)
[Memory Consumption of Dynamic Memory Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmem_cons_dyn_mem_obj_guidl.htm)
[Administration Costs of Dynamic Memory Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadmin_costs_dyn_mem_obj_guidl.htm)
[Accessing Data Objects Dynamically](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendyn_access_data_obj_guidl.htm)
[Generic Programming](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_progr_guidl.htm)


### abenuse_dynamic_progr_tech_guidl.htm

---
title: "Using Dynamic Programming Techniques"
description: |
  Background The use of dynamic programming techniques includes the following: -   Accessing dynamic memory objects, that is, dynamic data objects (strings and internal tables), as well as instances of classes and anonymous data objects -   Dynamically accessing data objects using reference variables
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_dynamic_progr_tech_guidl.htm"
abapFile: "abenuse_dynamic_progr_tech_guidl.htm"
keywords: ["do", "if", "case", "try", "class", "data", "types", "internal-table", "field-symbol", "abenuse", "dynamic", "progr", "tech", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Dynamic Programming Techniques](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm) → 

Using Dynamic Programming Techniques

Background

The use of dynamic programming techniques includes the following:

-   Accessing dynamic memory objects, that is, dynamic data objects (strings and internal tables), as well as instances of classes and anonymous data objects
-   Dynamically accessing data objects using reference variables and field symbols (to a certain extent, this also includes accessing generically typed formal parameters in procedures)
-   Dynamically invoking procedures or entire programs
-   Creating data types generically and using them to create anonymous data objects
-   Generic program development, where parts of the statements are specified using dynamic tokens or entire programs are not created until runtime

In this sense, handling reference variables can also be considered a dynamic technique. The dynamic type (the object to which the reference points) can be more specific than the static type of the variable, which entails polymorphic behavior and becomes apparent in assignments made using [up casts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenup_cast_glosry.htm "Glossary Entry") or [down casts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendown_cast_glosry.htm "Glossary Entry").

Rule

Use dynamic programming techniques with care

Use dynamic programming techniques only when this is necessary and reasonable. Use only as many dynamic language elements as required to carry out the assigned task.

Details

The advantage of dynamic programming techniques is an increased flexibility when creating programs. Dynamic programming techniques enable flexible and generic services to be developed that meet various requirements. The price to be paid for this advantage is that dynamic programming techniques may decrease the static checkability, legibility, maintainability, testability, performance, and also [security](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_security.htm). [Security standards](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm "Guideline") may even prohibit the use of high-risk dynamic programming techniques.

This section describes various dynamic programming techniques. These range from [using strings](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstrings_guidl.htm "Guideline"), which we explicitly recommend, and [using internal tables](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenitab_gdl.htm), which form a basis of ABAP programming, to [generating entire programs](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_progr_guidl.htm "Guideline"), which we advise against. The higher the dynamics, the more comprehensive the precautionary measures to be taken when using these techniques. Already the simple access to data objects involves a corresponding partial aspect, which was addressed in the rule for [Runtime Errors when Accessing Data Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenruntime_error_dyn_proc_guidl.htm "Guideline"). The rules in this section expand these specific rules and provide a more general framework.

Always consider the following aspects when deploying dynamic techniques:

-   Programs that work with dynamic techniques are usually more complex and harder to understand than programs that use only static techniques. This has a negative effect on maintainability.
-   In dynamic programming, many checks that are otherwise performed in compilations can be performed only at runtime. This considerably increases the risk of exceptions or runtime errors.
-   Checking the dynamic parts at runtime can reduce the processing speed, as the checks must be repeated each time the parts are used again.
-   More tests are required, since numerous states of a dynamic program and possible error situations must be checked.
-   If used incorrectly, dynamic programming techniques can present a serious security risk. Any dynamic content that is passed to a program from the outside must be checked thoroughly or escaped before it is used in dynamic statements. This can be done using the system class CL\_ABAP\_DYN\_PRG or the built-in function [escape](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenescape_functions.htm).

The significance of these aspects differs for the various dynamic programming techniques. For example, a program that uses strings is by no means more complex than a program that works only with text fields. In cases like this, a range of details must nevertheless be taken into account.


### abenruntime_error_dyn_proc_guidl.htm

---
title: "Runtime Errors in Dynamic Processing"
description: |
  Background When dynamic techniques are used, various exception situations can arise that can never occur when the corresponding static techniques are used because they can be checked statically. Rule Prevent runtime errors in dynamic processing Respond appropriately to all possible error situations
version: "7.56"
category: "error-handling"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenruntime_error_dyn_proc_guidl.htm"
abapFile: "abenruntime_error_dyn_proc_guidl.htm"
keywords: ["delete", "do", "if", "case", "try", "catch", "method", "class", "data", "internal-table", "field-symbol", "abenruntime", "error", "dyn", "proc", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Dynamic Programming Techniques](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm) → 

Runtime Errors in Dynamic Processing

Background

When dynamic techniques are used, various exception situations can arise that can never occur when the corresponding static techniques are used because they can be checked statically.

Rule

Prevent runtime errors in dynamic processing

Respond appropriately to all possible error situations when using dynamic techniques.

Details

The different dynamic techniques also require different reactions to the possible exception situations. Examples:

-   When dynamic data objects are accessed, [their limitations must not be violated](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenruntime_error_data_obj_guidl.htm "Guideline"). For internal tables, for example, no line numbers must be specified for which no line exists.
-   Before data objects are accessed dynamically by using data references or field symbols, it must be ensured, before execution, that these are bound to a data object and this binding checked using IS BOUND or IS ASSIGNED, if necessary. Afterwards, the return code should be checked to see whether execution was successful.
-   In dynamic calls, exceptions must be caught that are raised due to nonexistent programs, classes, or procedures, or due to inappropriate parameters.
-   In the case of a dynamically specified token, for example, a dynamic WHERE condition in ABAP SQL or internal tables, possible exceptions must be caught and responded to accordingly.
-   If programs are developed generically, the programs in question must checked using the statement SYNTAX-CHECK.

These examples illustrate how the use of dynamic techniques can lead to more complex and less clear code due to the numerous possible exception situations. Of course, the more the mentioned techniques are combined, the more complex and less clear the code becomes. Therefore, [dynamic programming techniques must always be used with care](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_dynamic_progr_tech_guidl.htm "Guideline").

Hint

If it is not possible to particular error situations, for example, because no exception that can be handled exists, it must be ensured that this error situation never occurs and this then verified in extensive test scenarios.

Bad Example

The seemingly legible source code section uses almost only dynamic operands and tokens. Neither ABAP Compiler nor the reader can know the content of the specified variables at runtime. An error in one of these variables results in a termination of the program.

READ TABLE where\_clauses ASSIGNING <where\_clause> WITH ...
DELETE FROM (dbtab\_name) WHERE (<where\_clause>).
IF sy-subrc = 0.
  CALL METHOD (class\_name)=>(method\_name).
ENDIF.

Good Example

The following source code corrects the above example with an appropriate error handling - this reduces the legibility, of course. Here, the fact that an initial dynamic WHERE condition means that no restrictions are imposed is also taken into account. As shown here, this case must be explicitly avoided. Otherwise, the entire table content will be deleted.

UNASSIGN <where\_clause>.
ASSIGN where\_clauses\[ ... \] TO <where\_clause>.
IF sy-subrc <> 0.
   RAISE EXCEPTION ...
ENDIF.
ASSERT <where\_clause> IS ASSIGNED.
IF <where\_clause> IS NOT INITIAL.
   TRY.
       DELETE FROM (dbtab\_name) WHERE (<where\_clause>).
     CATCH cx\_sy\_dynamic\_osql\_error.
       ...
   ENDTRY.
   IF sy-subrc = 0.
      TRY.
            CALL METHOD (class\_name)=>(method\_name).
          CATCH cx\_sy\_dyn\_call\_error.
            ...
       ENDTRY.
   ENDIF.
ENDIF.


### abenuse_dyn_data_object_guidl.htm

---
title: "Using Dynamic Data Objects"
description: |
  Background Dynamic data objects are a subgroup of dynamic memory objects(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmem_cons_dyn_mem_obj_guidl.htm 'Guideline') and simply consist of: -   Strings -   Internal tables The data type statically defines all properties for dynamic dat
version: "7.56"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_dyn_data_object_guidl.htm"
abapFile: "abenuse_dyn_data_object_guidl.htm"
keywords: ["select", "delete", "do", "if", "case", "class", "data", "types", "internal-table", "abenuse", "dyn", "object", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Dynamic Programming Techniques](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm) → 

Using Dynamic Data Objects

Background

Dynamic data objects are a subgroup of [dynamic memory objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmem_cons_dyn_mem_obj_guidl.htm "Guideline") and simply consist of:

-   Strings
-   Internal tables

The data type statically defines all properties for dynamic data objects, apart from memory consumption. Although the objects are managed internally using references, they are addressed by their names and value semantics applies. This means the referenced internal reference is always used for access.

Rule

Use appropriate dynamic data objects

To store dynamic data sets transiently when using dynamic data objects, always select the type that best corresponds to the content and the required access:

-   Strings for data that cannot be divided
-   Internal tables for data that can be divided

To avoid memory bottlenecks for large data sets, you might need to use other procedures as well.

Details

When using dynamic data objects, selecting the type is a key decision. The general rule is:

-   Data that can be handled as one piece is stored as a character string or byte string (string or xstring data type).
-   Structured data or data that can be sensibly divided into individual sections is stored as internal table lines.

However, if you need to store a very large data set as dynamic data objects, different aspects must be considered. string and xstring data objects must be stored as one piece in the memory, whereas the content of internal tables is stored in blocks. This is more likely to cause resource bottlenecks when strings are used. Even if sufficient [memory](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmem_cons_dyn_mem_obj_guidl.htm "Guideline") space is available, the memory cannot handle a string of the requested length, due to fragmentation. In these cases, it makes more sense to store the data as an internal table instead of storing the data in a string as one piece.

The EXPORT statement for storing data in a cluster supports both storage types, for example: EXPORT ... TO DATA BUFFER stores the cluster in a single long byte string, whereas EXPORT ... TO INTERNAL TABLE distributes the cluster across numerous lines of an internal table. The latter possibility (EXPORT ... TO INTERNAL TABLE) is more secure (for the reason explained above), if the cluster needs to contain a very large data set.

Hint

Strings and internal tables are contained directly in the ABAP language in the form of data types and the corresponding access statements. In other programming languages, however, they are often implemented as libraries (such as string classes and container classes). In ABAP, it is usually [neither necessary nor useful](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenobj_oriented_gdl.htm) to define specific classes for storing strings or table-like data. However, in rare cases, it may be useful to wrap internal tables in classes, to release more [memory](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadmin_costs_dyn_mem_obj_guidl.htm "Guideline") when data is deleted.


### abenmem_cons_dyn_mem_obj_guidl.htm

---
title: "Memory Consumption of Dynamic Memory Objects"
description: |
  Background In dynamic objects, the actual data is addressed using a reference. This means that dynamic memory objects are always deep objects. Possible dynamic memory objects are: -   Table bodies of internal tables addressed using internal table references -   Text strings or byte strings addressed
version: "7.56"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmem_cons_dyn_mem_obj_guidl.htm"
abapFile: "abenmem_cons_dyn_mem_obj_guidl.htm"
keywords: ["select", "delete", "do", "if", "case", "try", "class", "data", "types", "internal-table", "abenmem", "cons", "dyn", "mem", "obj", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Dynamic Programming Techniques](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm) → 

Memory Consumption of Dynamic Memory Objects

Background

In dynamic objects, the actual data is addressed using a reference. This means that dynamic memory objects are always deep objects. Possible dynamic memory objects are:

-   Table bodies of internal tables addressed using internal table references
-   Text strings or byte strings addressed using internal string references
-   Anonymous data objects created using CREATE DATA and addressed using data references in data reference variables
-   Instances of classes created using CREATE OBJECT and addressed using object references in object reference variables

The maximum total size and number of all dynamically managed memory objects in an [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry") are defined in principle by the maximum amount of memory that this session can request to execute programs.

Alongside the available memory on the current AS instance, there are two further technical limits that can restrict the size of individual dynamic memory objects:

-   The upper limit is 2³¹-1 for the size of a string in bytes (in the character representation [UCS-2](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenucs2_glosry.htm "Glossary Entry") used by the ABAP programming language, every character in a string occupies 2 bytes) and the number of rows in an internal table.
-   The memory for the content of a string and for hash management of an internal hashed table must be provided as one piece. Therefore, the ztta/max\_ memreq\_mb profile parameter is relevant for these two memory object types. It defines the maximum amount of memory that can be requested as one piece. A maximum size for strings and a limitation on the number of rows in hashed tables can be directly derived from this amount. This limitation does not depend on the width of table rows. Only the hash management (and not the table content) must be provided as one piece in the memory. The current limitation is the highest power of two, which is less than or equal to an eighth of the value specified by the profile parameter. For example, if the profile parameter specifies 250MB, a hashed table can contain approximately 16 million rows.

Any attempt to exceed these limits produces a runtime error and the termination of the program.

Rule

Avoid memory bottlenecks

When using dynamic memory objects, ensure that the program is not terminated due to a lack of memory.

Details

Memory limits are fixed limitations that cannot be deactivated with programming. To avoid memory bottlenecks, we recommend that you account for:

-   The limits of the available physical memory when developing a program
-   The specified technical limits for strings and hashed tables

The only way to prevent memory limits from being exceeded is to use programming to restrict the data loaded into the memory. This applies to processing large data sets and also to object creation. The latter can produce memory bottlenecks if overly large objects or too many small objects are created. Memory leaks (unused, unreleased memory) can also cause memory problems.

Editing Large Data Sets
You need to process large data sets that are stored in a persistent repository as one piece, but the sets do not fit into the available memory. In this case, you must import and process these data sets, either in packages or sequentially. A common language element here is the PACKAGE SIZE addition. You can this addition when importing large data sets to internal tables with the ABAP SQL statement SELECT. Memory-saving processing of large strings (Large Object, LOB) in database tables is also possible. Locators enable you to access substrings of strings in database tables. Streaming allows a sequential and gradual transfer of data into the memory. Both concepts were predominantly introduced in ABAP to avoid memory bottlenecks.

Releasing Memory
The main advantage of dynamically managed memory is that it can be released again. Use this option to delete data and objects no longer required, to avoid memory leaks and possible memory bottlenecks:

-   You can delete strings using the CLEAR statement.
-   You can use CLEAR or FREE to delete internal tables. FREE releases the entire memory space occupied by rows, whereas the initial memory requirement of the table remains reserved if CLEAR is used. An appropriate size for the [initial memory requirement](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninitial_memory_requ_guidl.htm "Guideline") is usually defined by the ABAP runtime framework itself. However, it can also be predefined using the INITIAL SIZE addition.
-   Anonymous data objects and instances of classes are deleted by the Garbage Collector, after all reference variables that refer to these objects have been initialized. Here, you must ensure that all references are actually identified during initialization. This is not always straightforward, particularly in the case of complex object networks. To analyze memory problems and detect memory leaks, you can use Memory Inspector and the ABAP Debugger memory analysis. You can display memory consumption rankings for all dynamically managed memory objects.

Hint

Note that statically managed data objects can also involve unnecessary memory consumption. For example, large flat structures with unused or initial components, whose initial values require a lot of memory space. Here, strings that only contain blanks occupy 2 bytes for each blank. The situation can become particularly critical if these structures are combined with dynamic techniques (if they are used as internal table rows, for example). Consequently, boxed components were introduced. They support initial value sharing for initial substructures, which means that the initial value of a substructure is created only once in memory. For structures with substructures that have a sparse fill level, this can reduce memory consumption and copy costs significantly.

Bad Example

In the following source code, all the data in a very large database table is imported into an internal table. Here there is an obvious risk of memory bottlenecks.

SELECT \*
       FROM very\_large\_table
       INTO TABLE ...

Good Example

In the following source code, the PACKAGE SIZE addition is used. This restricts the maximum size of the internal table to a secure level.

SELECT \*
       FROM very\_large\_table
       INTO TABLE ... PACKAGE SIZE 1000.
       ENDSELECT.


### abenadmin_costs_dyn_mem_obj_guidl.htm

---
title: "Administration Costs of Dynamic Memory Objects"
description: |
  Background Dynamic memory objects provide flexibility, but this comes at a price. The administration of these objects incurs internal costs, which are reflected in increased memory consumption, and in the worst case possibly far too high. The total memory requirements of a dynamic memory object comp
version: "7.56"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenadmin_costs_dyn_mem_obj_guidl.htm"
abapFile: "abenadmin_costs_dyn_mem_obj_guidl.htm"
keywords: ["delete", "do", "while", "if", "case", "class", "data", "types", "internal-table", "abenadmin", "costs", "dyn", "mem", "obj", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Dynamic Programming Techniques](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm) → 

Administration Costs of Dynamic Memory Objects

Background

Dynamic memory objects provide flexibility, but this comes at a price. The administration of these objects incurs internal costs, which are reflected in increased memory consumption, and in the worst case possibly far too high.

The total memory requirements of a dynamic memory object comprise the requirements of the objects themselves and the requirements of the administration data. The administration data consists of the reference, with a fixed size of 8 bytes, and a header that contains the address of the data itself and additional administration information. The reference initially points to a header and not directly to the object. The size of the header is itself dynamic and depends on the category of memory object as follows:

-   String headers of strings whose length is less than approximately 30 characters or 60 bytes require between 10 and 40 bytes approximately, depending on the string length. For longer strings, the header requires approximately 50 bytes, regardless of the string length.
-   Table headers require approximately 150 bytes (in 32 bit architecture) or approximately 200 bytes (in 64 bit architecture).
-   Object headers of anonymous data objects and instances of classes require approximately 30 bytes, regardless of the object.

The headers are created when dynamic data objects are provided with content or when objects are created. When a dynamic data object (a string or internal table) is initialized, only the content itself is deleted, while the header is retained to be used again. Only the statement FREE deletes (some) table headers that are too big. When it deletes an object, Garbage Collector also deletes the object header.

In internal tables, the administration data in the header is mostly independent of the number of rows but there can be additions to the data such as index or hash management. This memory is not created in the table header but in parallel to the table body. Depending on the table category, every table has at least one primary index (standard tables, sorted tables) or hash management (hashed tables). The costs are:

-   6 bytes on average per each table line for the primary index.
-   18 bytes per table line on average, provided that the table is not accessed using the DELETE or SORT statements. If one of these access types occurs, an average of 30 bytes is required per table line.

With each additional secondary table key, the [memory](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensecondary_key_guidl.htm "Guideline") requirement increases by the memory needed for secondary key management (secondary index or secondary hash management).

Rule

Consider the ratio of administration and application data

When using dynamically managed memory objects, it should remembered that memory is required for administration purposes, in addition to memory for the actual data. The size of the administrative memory should be relatively small compared to the application data.

Details

Memory management of dynamic memory objects is generally invisible for developers and cannot be controlled by developers. However, it is important to consider administration costs during the design and development phases, to ensure that the costs do not become disproportionately high compared to the actual data content. For internal tables, for example, the administration data consists of a part that is mainly independent of the number of lines and a part for each line. Consequently, tables with only a few lines and tables with very narrow lines are unfavorable. A sorted table of integers, for instance, always uses more memory for its administrative information than for the actual application data. Hashed tables require even more administration for each line.

In addition, the fill level of complex data objects assumes a significant role. If the application data is only stored in a small number of large memory objects, the administrative part usually does not play a role. However, if complex data objects (structures, internal tables) have a lot of deep components, care must be taken: For example, a disproportionate amount of memory space is lost for tables with a lot of relatively small strings or for nested tables containing relatively small tables. We distinguish the following three cases:

-   Complex data objects with a sparse fill level
    
    These data objects contain a lot of deep components and most of them are initial.
    
-   Complex data objects with a duplicative fill level
    
    These data objects contain a lot of deep components and most of them point to the same application data by means of a reference variable or sharing.
    
-   Complex data objects with a low fill level
    
    These data objects contain a lot of deep components that refer to different objects, strings, or internal tables, which only contain a small amount of application data or are empty.
    

Deep data objects with a fill level that is sparse or duplicative can usually be used without problems. But for complex data objects with a low fill level, a disparity between administration data and application data can easily occur. ABAP is inappropriate for large-scale use of data objects with a low fill level.

At a low dataset level, class wrapping can be considered as an alternative to internal tables. This is because the extra costs for objects are comparatively low and objects can be completely deleted from the memory (unlike dynamic data objects). This is an exception to the rule that [dynamic data objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenuse_dyn_data_object_guidl.htm "Guideline") should be used wherever possible.

Hint

Besides the ratio of administration data to application data, the ratio of the [memory allocated](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninitial_memory_requ_guidl.htm "Guideline") for application data and the memory actually used is also interesting for internal tables.

Example

The executable example [DEMO\_MEMORY\_USAGE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmemory_usage_abexa.htm) demonstrates the administration costs of deep components with low data content.


### abendyn_access_data_obj_guidl.htm

---
title: "Accessing Data Objects Dynamically"
description: |
  Background Field symbols and data references are used to access data objects whose name and attributes are not known until runtime. -   Field symbols A field symbol is a symbolic name for a data object declared with FIELD-SYMBOLS, to which memory areas can be assigned using the ASSIGN statement or,
version: "7.56"
category: "oop"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendyn_access_data_obj_guidl.htm"
abapFile: "abendyn_access_data_obj_guidl.htm"
keywords: ["loop", "do", "if", "try", "method", "class", "data", "internal-table", "field-symbol", "abendyn", "access", "obj", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Dynamic Programming Techniques](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm) → 

Accessing Data Objects Dynamically

Background

Field symbols and data references are used to access data objects whose name and attributes are not known until runtime.

-   Field symbols
    
    A field symbol is a symbolic name for a data object declared with FIELD-SYMBOLS, to which memory areas can be assigned using the ASSIGN statement or, if internal tables are processed, using the ASSIGNING addition. Field symbols are typed either generically or completely and can be used like a data object in all appropriate operand positions. For typing, the same rules apply as for [formal parameters of procedures](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentype_formal_param_guidl.htm "Guideline"). When accessing field symbols, value semantics applies, which means that the assigned memory content is addressed directly. Field symbols are thus always handled like dereferenced pointers.
    
-   Data references
    
    A data reference is the content of a data reference variable that is declared using REF TO and points to any data objects or parts of data objects. Data references are needed to create anonymous data objects using CREATE DATA or [NEW](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconstructor_expression_new.htm). They can also be generated for existing data objects, however, using the statement GET REFERENCE, the reference operator [REF](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconstructor_expression_ref.htm), or, if internal tables are processed, using the REFERENCE INTO addition. A data reference variable is either completely generic or completely typed. When accessing data reference variables, reference semantics applies, which means that the data reference itself is addressed. To access the referenced memory content, a data reference variable must be dereferenced explicitly using the dereferencing operator (->\*).
    

Field symbols and data references are closely related because only completely typed data reference variables can be dereferenced in any operand position. Completely generic data reference variables (REF TO data) can be dereferenced in the ASSIGN statement only.

Data reference variables can be [declared](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendeclaration_variables_guidl.htm "Guideline") in the same context as all other data objects, especially also as attributes of classes. Field symbols, in contrast, can only be declared within procedures ([methods](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline")) or in the global declaration part. However, the latter is [no longer allowed](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendeclaration_variables_guidl.htm "Guideline").

Rule

Use field symbols and data references in appropriate ways

Use field symbols and data references for the purpose that best matches their semantics:

-   Field symbols for value access (value semantics)
-   Data references for working with the references (reference semantics)

Details

Both field symbols and data references can be understood as pointers to memory areas. The main difference is in the different access semantics.

-   Due to their value semantics, field symbols should always be used if the focus is on the access to referenced data. Field symbols provide specific functions for this purpose, which are not available for data references:
    -   Dynamic access to attributes of classes and objects
        
        ASSIGN (class\_name)=>(attr\_name) ...
        ASSIGN oref->(attr\_name) ...
        
    -   Dynamic access to structure components
        
        ASSIGN ... COMPONENT ...
        
    -   Explicit casting
        
        ASSIGN ... CASTING ...
        
    -   Dereferencing of generic data reference variables
        
        ASSIGN dref->\* ...
        
-   Due to their reference semantics, data references are to be used if the focus is on the explicit handling of references to data objects. Data references are vital for creating anonymous data objects or complex dynamic data structures, such as trees or chained lists in the [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry") or in the shared objects memory. Furthermore, data references are the preferred element for implementing explicit sharing between any data objects, and for passing pointers to data objects to procedures.

Note

Actually, data reference variables can be better used in programs that are based on [ABAP Objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline") because they have the same semantics as object reference variables and therefore represent a more [modern](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenmodern_abap_guidl.htm "Guideline") programming concept. Field symbols, on the other hand, provide more functions than data references and can thus not always be replaced by them. Consequently, the usage of field symbols for dynamic accesses to data objects is still recommended, although the sole use of data references would be preferred for consistency and simplicity reasons.

Bad Example

The following source code shows a loop for an internal table in which the system is supposed to directly [access the current line](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentable_output_guidl.htm "Guideline"). If a generic data reference variable is used for this purpose, a field symbol is also needed for its dereferencing.

METHOD some\_method.
  "IMPORTING i\_itab TYPE INDEX TABLE
  DATA dref TYPE REF TO data.
  FIELD-SYMBOLS <fs> TYPE data.
  ...
  LOOP AT i\_itab REFERENCE INTO dref.
    ASSIGN dref->\* TO <fs>.
    <fs> = ...
  ENDLOOP.
  ...
ENDMETHOD.

Good Example

The following source code simplifies the above example by using a field symbol, which is required to access table lines anyway, directly and without using a data reference. The direct use of the field symbol thus also complies with the [KISS principle](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenkiss_principle_guidl.htm "Guideline").

METHOD some\_method.
  "IMPORTING i\_itab TYPE INDEX TABLE
  FIELD-SYMBOLS <fs> TYPE data.
  ...
  LOOP AT i\_itab ASSIGNING <fs>.
    <fs> = ...
  ENDLOOP.
...
ENDMETHOD.


### abengeneric_progr_guidl.htm

---
title: "Generic Programming"
description: |
  Background Generic programming (dynamic creation of source code) makes programs as dynamic as possible. The following methods can be used to achieve this: -   Dynamic token specification Dynamic token specification involves specifying individual operands or whole parts of statements (clauses) in the
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abengeneric_progr_guidl.htm"
abapFile: "abengeneric_progr_guidl.htm"
keywords: ["select", "insert", "do", "if", "case", "try", "catch", "method", "class", "data", "types", "internal-table", "field-symbol", "abengeneric", "progr", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Dynamic Programming Techniques](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendynamic_prog_technique_gdl.htm) → 

Generic Programming

Background

Generic programming (dynamic creation of source code) makes programs as dynamic as possible. The following methods can be used to achieve this:

-   Dynamic token specification
    
    Dynamic token specification involves specifying individual operands or whole parts of statements (clauses) in the form of character-like data objects. These are usually enclosed in parentheses and must contain source code with correct syntax at runtime. Important examples:
    
    -   Dynamic access to attributes of classes
    -   Dynamic calls of procedures, particularly methods (known as dynamic invokes)
    -   Dynamic type specifications when anonymous data objects are created. In this case, types can be used that are only created at runtime using Run Time Type Services ([RTTS](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrtti.htm)).
    -   Dynamic specifications of clauses when internal tables are accessed or in ABAP SQL.
        
        Dynamic token specifications are often used in combination with [dynamic access to data objects](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendyn_access_data_obj_guidl.htm "Guideline").
        
-   Program generation
    
    Program generation involves preparing complete programs as content for internal tables and then creating the programs. A distinction is made between the following cases:
    
    -   Transient program generation using GENERATE SUBROUTINE POOL, where the generated programs only exist in the [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry") of the current program.
    -   Persistent program generation with INSERT REPORT. The generated programs are saved as repository objects.

Rule

Avoiding Program Generation

Program generation should only be used as a last resort for generic programming. Other dynamic methods (especially in application programs) should be tried first, such as dynamic token specification, runtime type services (RTTS) and dynamic access to data objects.

Details

Program generation has a lot of conceptual problems such as checking, testing, and editing the new programs. In addition, programs generated hastily can be a security risk because they cannot be statically checked. Creating programs is usually very intensive in terms of runtime and resources. Due to the above reasons, program generation should be avoided wherever possible and other dynamic methods used instead:

-   The dynamic token specification has the advantage that only parts of the statements are dynamic. The rest can be checked statically.
-   Runtime type services (RTTS) can be used as follows:
    -   RTTS define the type attributes of data objects at runtime (Runtime Type Information, RTTI). The capabilities of RTTI extend far beyond the statement DESCRIBE FIELD.
    -   It creates types at runtime (Runtime Type Creation, RTTC). RTTC should be used if the CREATE DATA statement does not offer sufficient options for the planned implementation (for example, building new structures).

These methods, combined with [field symbols and data references](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abendyn_access_data_obj_guidl.htm "Guideline"), are now usually sufficient for most tasks that could only be solved using program generation in older releases.

Exception

Program generation should only be used as a last resort if the other methods are not sufficient to achieve dynamic program control. Another reason is the processing speed. When program generation is used, the costs incurred due to checking and generation occur less frequently than with the other dynamic methods. However, program generation usually has worse system performance than dynamic token specification. The conceptual problems explained at the start are still applicable here and therefore careful consideration is needed.

Unlike application programs, system programs usually frequently rely on program generation and the associated language constructs. Examples include the generation of proxy classes for Web Dynpro or Web Services. ABAP Editor itself also uses statements such as READ REPORT and INSERT REPORT.

Hints

-   Even generated programs should always adhere to the predefined guidelines. For example, in a generated subroutine pool the program logic should be implemented/generated in the form of [local classes](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline"). The generated functions are usually called by means of a single [subroutine](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenfunct_module_subroutine_guidl.htm "Guideline") that is used as an entry point into the generated local classes (see the following example).
-   To minimize the risks involved, it can be useful to save templates with correct syntax that adhere to the guidelines in the repository. READ REPORT can then be used to load the templates as templates for dynamically generated programs, in which only small parts are changed or added at runtime.
-   Subroutines in generated subroutine pools are an exception to the [rule](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_obj_progr_model_guidl.htm "Guideline"), which states that subroutines should no longer be created, and an exception to the [rule](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenintern_extern_proc_call_guidl.htm "Guideline"), which states that subroutines should no longer be called. In addition, absolute type names can be used to access the local classes of a generated subroutine pool. However, this violates the rule [Only call suitable procedures externally](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenintern_extern_proc_call_guidl.htm "Guideline").

Bad Example

The following source code demonstrates unnecessary program generation. The only reason for generating the program are dynamic reads on a database table. The name of the database table and the row type of the internal table into which data is read are replaced by a parameter value in the source code of the program to be generated. The value operator [VALUE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenconstructor_expression_value.htm) is used to create the internal table. As recommended, the subroutine of the generated subroutine pool only contains the call for a method of a local class where the actual implementation is located. Instead of filling the program table row by row, it would have also been possible in this case to create a corresponding program in the repository and load this program using READ REPORT.

PARAMETERS dbtab TYPE c LENGTH 16.

DATA table TYPE REF TO data.
FIELD-SYMBOLS <table> TYPE STANDARD TABLE.

DATA: source TYPE TABLE OF string,
      program TYPE string,
      mess TYPE string.

source = VALUE #(
  ( \`program.\` )
  ( \`class main definition.\` )
  ( \`   public section.\` )
  ( \`     class-data\` )
  ( \`       dyn\_table type standard table of dyn\_name.\` )
  ( \`     class-methods meth\` )
  ( \`       exporting table type ref to data.\` )
  ( \`endclass.\` )
  ( \`class main implementation.\` )
  ( \`   method meth.\` )
  ( \`     select \*\` )
  ( \`            from dyn\_name\` )
  ( \`            into table @dyn\_table.\` )
  ( \`     get reference of dyn\_table into table.\` )
  ( \`   endmethod.\` )
  ( \`endclass.\` )
  ( \`form subr changing table type ref to data.\` )
  ( \`   main=>meth(\` )
  ( \` importing table = table ).\` )
  ( \`endform.\` ) ).

REPLACE ALL OCCURRENCES OF 'dyn\_name'
        IN TABLE source WITH dbtab.
GENERATE SUBROUTINE POOL source NAME program MESSAGE mess.
IF sy-subrc = 0.
   PERFORM subr IN PROGRAM (program) CHANGING table.
   IF table IS BOUND.
     ASSIGN table->\* TO <table>.
   ENDIF.
ELSE.
   ...

ENDIF.

Good Example

The following source code produces the same result as the example above, when executed successfully. In other words, the field symbol <table> points to an internal table that is filled with data from the dynamically specified database table. However, this task is performed much more efficiently in the example below due to the creation of an anonymous data object and a dynamically specified token. If the target table cannot be structured in exactly the same way as the database table, Runtime Type Creation (RTTC) must also be used.

PARAMETERS dbtab TYPE c LENGTH 20.
DATA table TYPE REF TO data.
FIELD-SYMBOLS <table> TYPE STANDARD TABLE.

TRY.
   CREATE DATA table TYPE TABLE OF (dbtab).
   ASSIGN table->\* TO <table>.
   SELECT \*
         FROM (dbtab)
         INTO TABLE @<table>.
  CATCH cx\_sy\_create\_data\_error cx\_sy\_dynamic\_osql\_error.
  ...
ENDTRY.


---


## ABAP - Keyword Documentation / ABAP - Programming Guidelines / Robust ABAP / Internationalization

**Files**: 7 | **Difficulty**: intermediate

# ABAP - Keyword Documentation / ABAP - Programming Guidelines / Robust ABAP / Internationalization

Included pages: 7


### abeninternationalization_gdl.htm

---
title: "Internationalization"
description: |
  Business software used by internationally operating enterprises has to meet certain localization requirements, for example by providing different logon languages or by meeting different legal requirements. In the SAP environment, the language aspect is known as internationalization and is part of th
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternationalization_gdl.htm"
abapFile: "abeninternationalization_gdl.htm"
keywords: ["do", "if", "abeninternationalization", "gdl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) → 

Internationalization

Business software used by internationally operating enterprises has to meet certain localization requirements, for example by providing different logon languages or by meeting different legal requirements. In the SAP environment, the language aspect is known as internationalization and is part of the Globalization [product standard](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencorrectness_quality_guidl.htm "Guideline"). As a consequence, translatable text sources must be used when developing in ABAP, and the technical requirements for handling variable character sets must be respected.

-   [Storing System Texts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_text_guidl.htm "Guideline")
-   [Translation-Friendly Message Texts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentrans_relevant_text_guidl.htm "Guideline")
-   [Text Environment](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_environm_guidl.htm "Guideline")
-   [Character Set in Source Code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencharacter_set_guidl.htm "Guideline")
-   [Splitting Texts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensplit_text_guidl.htm "Guideline")
-   [Code Pages for Files](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencodepage_file_guidl.htm "Guideline")

Continue
[Storing System Texts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_text_guidl.htm)
[Translation-Friendly Message Texts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentrans_relevant_text_guidl.htm)
[Text Environment](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_environm_guidl.htm)
[Character Set of ABAP Source Code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencharacter_set_guidl.htm)
[Splitting Texts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensplit_text_guidl.htm)
[Code Pages for Files](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencodepage_file_guidl.htm)


### abensystem_text_guidl.htm

---
title: "Storing System Texts"
description: |
  Background In ABAP programs, texts are used as parts of processed data but also as a means to communicate with the user. The latter are called system texts, which are delivered with an ABAP application. The ABAP Workbench manages system texts in such a way that they can be translated from the origi
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_text_guidl.htm"
abapFile: "abensystem_text_guidl.htm"
keywords: ["do", "if", "try", "class", "data", "abensystem", "text", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Internationalization](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternationalization_gdl.htm) → 

Storing System Texts

Background

In ABAP programs, texts are used as parts of processed data but also as a means to communicate with the user. The latter are called system texts, which are delivered with an ABAP application. The ABAP Workbench manages system texts in such a way that they can be translated from the [original language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenoriginal_langu_guidl.htm "Guideline") into other languages independently of the actual development object. The following are examples of translatable system texts:

-   Texts and documentation of data elements in the ABAP Dictionary
-   Short texts and documentation of the components of local classes
-   UI texts of dynpros, in Web Dynpro applications and in menu entries
-   Message texts
-   Text pools of ABAP programs that include the text elements of the program, for example, text symbols
-   Texts of the Online Text Repository (OTR)

In addition to translatable system texts, an ABAP program can also contain untranslatable texts. These are usually the [character literals](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenliterals_guidl.htm "Guideline") and the [comments](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomments_gdl.htm) that are stored as a part of the source code.

Rule

Send only translatable system texts to the user

Specify all texts that a program uses to communicate with the user as translatable system texts. When translatable system texts are created, there must be enough space for translations.

Details

This rule is not only critical when programs are used in an international environment; it applies when working in [multilingual development groups](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenoriginal_langu_guidl.htm "Guideline") too. The prohibition of the use of character literals in the ABAP source code for all texts that are relevant for user dialogs is derived from this rule. Character literals cannot be translated. Their content is independent of the respective logon language. Instead of character literals, [text symbols](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_symbol_glosry.htm "Glossary Entry") should be used or character literals linked with text symbols. This is also checked in the [extended program check](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenextended_program_check_guidl.htm "Guideline").

When system texts are created, there must be enough space. It is not usually possible to change the text length during translation, so the translator relies on there being sufficient space for a reasonable translation defined at the development stage. This aspect is very important for longer texts, particularly if the original language is English, because facts can normally be expressed in fewer words in English than in other languages. The opposite can be true for short texts, for example, "Feld" (German) and "field" (English), or for compound words that are written as two or more words in English.

Exception

For purely technical texts (such as HTML tags or regular expressions) that are not to be translated, character literals or literal content of string templates can be used. These should be marked as not relevant for translation for the extended program check using pragmas.

Good Example

The following source code shows how to handle translation-relevant and non-translation-relevant text elements in source code: Technical texts that are not relevant for translation are specified as character literals. Other texts are linked with a text symbol. If the additions of the statement CONCATENATE are ignored (for example, SEPARATED BY), it is preferable to use the concatenation operator &&, as shown here, since this makes the source code clearer.

html\_line = '<title>' && 'Some Title'(ttl) && '</title>'.
APPEND html\_line TO html\_body.
...


### abentrans_relevant_text_guidl.htm

---
title: "Translation-Friendly Message Texts"
description: |
  Background Message texts are translatable system texts(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_text_guidl.htm 'Guideline'). You can use placeholders in the short and long texts of messages. Placeholders in short texts can either be defined uniquely in the form &i, whe
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentrans_relevant_text_guidl.htm"
abapFile: "abentrans_relevant_text_guidl.htm"
keywords: ["do", "if", "case", "try", "class", "data", "abentrans", "relevant", "text", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Internationalization](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternationalization_gdl.htm) → 

Translation-Friendly Message Texts

Background

Message texts are translatable [system texts](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensystem_text_guidl.htm "Guideline"). You can use placeholders in the short and long texts of messages. Placeholders in short texts can either be defined uniquely in the form &i, where i can be a digit between 1 and 4, or anonymously with &.

When the message is sent using the statement MESSAGE, you can use the addition WITH dobj1 ... dobj4, which replaces the placeholders &1 to &4 and & of the short text with the content of data objects dobj1, ..., and dobj4. The content of the first data object replaces the placeholder &1 and the first &, the content of the second replaces &2 and the second &, and so on. In addition, the content of the data objects dobj1, ..., dobj4 is assigned in order to the system fields sy-msgv1 to symsgv4.

Rule

Do not use anonymous placeholders (&) in message texts

Create placeholders in message texts with the unique names &1, &2, &3, and &4 only.

Details

As the syntax in the various languages differs, a translator may need to change the order of the replacement texts when translating message texts. However, the translator can adapt the order of replacement texts only if the different placeholders in a message text each have unique names. In messages with multiple placeholders, you should therefore work with the numbered placeholders &1, &2, &3, and &4, instead of using the anonymous placeholder (&).

Hint

The same applies to all other constructs in which such placeholders are possible, for example, GUI titles of classic dynpros. In cases where text in text symbols is explicitly replaced by self-defined placeholders, the placeholders in the text symbol must have unique names and must be known clearly to translators as placeholders that are not supposed to be translated.

Bad Example

A bad example of a message text might look as follows:

"In Tabelle & wurde der Eintrag & nicht gefunden"

If this message text was translated to

"In table & the entry & was not found"

this would not cause any problems.

If this message text was translated to

The entry & was not found in table &

a MESSAGE statement when logged on in English would produce an incorrect text.

Good Example

The following message text corrects the bad example:

In Tabelle &1 wurde der Eintrag &2 nicht gefunden

For both translations,

In table &1 the entry &2 was not found

and

The entry &2 was not found in table &1

a MESSAGE statement when logged on in English would produce a correct text.


### abentext_environm_guidl.htm

---
title: "Text Environment"
description: |
  Background The text environment(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_environment_glosry.htm 'Glossary Entry') is part of the runtime framework of an ABAP program and is made up of a text environment language, a locale, and a system code page. All programs in an inte
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_environm_guidl.htm"
abapFile: "abentext_environm_guidl.htm"
keywords: ["do", "if", "case", "try", "method", "class", "data", "abentext", "environm", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Internationalization](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternationalization_gdl.htm) → 

Text Environment

Background

The [text environment](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_environment_glosry.htm "Glossary Entry") is part of the runtime framework of an ABAP program and is made up of a text environment language, a locale, and a system code page. All programs in an [internal session](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternal_session_glosry.htm "Glossary Entry") have a common text environment.

By default, the text environment of an internal session is determined by the [logon language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogon_language_glosry.htm "Glossary Entry") and can be set programmatically by the statement [SET LOCALE LANGUAGE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_locale.htm). The current text environment language is contained in the system field sy-langu and is returned by the method GET\_LANGUAGE of the class CL\_ABAP\_SYST.

Rule

If possible, do not switch the text environment within the code

Set the statement [SET LOCALE LANGUAGE](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapset_locale.htm) in exceptional cases only, and reverse any text environment switches in good time.

Details

ABAP-coded services usually expect the text environment to be specified by the current user's logon language. The services are not designed to handle text environment switches of internal sessions within the coding.

If the text environment has to be switched for a specific service due to the following exceptions, this must be done only temporarily. This means that a switched text environment must be reset within the same program context to prevent unexpected behavior in other programs within the same internal session.

Exception

Switching the text environment within the code may be necessary in the following cases:

-   Sorting of texts not written in the logon language using [SORT ... AS TEXT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapsort_itab.htm) or [CONVERT TEXT](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abapconvert_text.htm)
-   For accessing external files

Bad Example

The following source code shows a text environment switch within a method, where the text environment is not reset before exiting the method. This poses the danger of continuing within the wrong text environment after returning from the method.

METHOD ...
   SET LOCALE LANGUAGE ...
   ...
ENDMETHOD.

Good Example

The following source code shows a text environment switch within a method, where the text environment is reset to its original state before exiting the method.

METHOD ...
  DATA env\_lang TYPE tcp0c-langu.
  GET LOCALE LANGUAGE env\_lang.
  SET LOCALE LANGUAGE ...
  ...
  SET LOCALE LANGUAGE env\_lang.
ENDMETHOD.


### abencharacter_set_guidl.htm

---
title: "Character Set of ABAP Source Code"
description: |
  Background ABAP source code(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_source_code_glosry.htm 'Glossary Entry') is edited in the ABAP Editor tool in ABAP Workbench, itself an ABAP program. ABAP Editor saves and processes the ABAP source code internally in a data object (an
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencharacter_set_guidl.htm"
abapFile: "abencharacter_set_guidl.htm"
keywords: ["do", "if", "case", "try", "data", "internal-table", "abencharacter", "set", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Internationalization](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternationalization_gdl.htm) → 

Character Set of ABAP Source Code

Background

[ABAP source code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_source_code_glosry.htm "Glossary Entry") is edited in the ABAP Editor tool in ABAP Workbench, itself an ABAP program. ABAP Editor saves and processes the ABAP source code internally in a data object (an internal table).

The source code is processed in the current

[text environment](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_environment_glosry.htm "Glossary Entry") of the developer, using the associated code page.

Rule

Use only 7-bit ASCII characters in source code

Use only characters from the 7-bit ASCII character set in ABAP source code. This avoids problems in systems with different code pages.

Details

The 7 bit ASCII character set contains only characters that also exist in all other code pages. Restricting the characters used in source code to this character set guarantees that this code can be edited and executed regardless of the [logon language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenlogon_language_glosry.htm "Glossary Entry") or [text environment language](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abentext_env_langu_glosry.htm "Glossary Entry"). Source code that contains characters from other character sets could, in the worst case, have incorrect syntax in a system with a different code page.

ABAP words in ABAP statements use only 7-bit ASCII characters anyway, which means that this rules to names, literals, and comments.

Hint

Since the programs with the ABAP language version [Standard ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenstandard_abap_glosry.htm "Glossary Entry") are now the only possible programs, so names comply with the rule above automatically. Comments are supposed to be [written in English](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencomment_langu_guidl.htm "Guideline") anyway, which removes the need for any country-specific special characters.

In a current system, all [ABAP source code](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_source_code_glosry.htm "Glossary Entry") is stored in Unicode and this is why this problem does not occur there. If a guarantee could be given that a program was written only for Unicode systems, the rule above would not be needed for literals and comments (at the very least). It is not possible to ensure that a program is not used in any non-Unicode systems, which is why general robustness rules should always be followed. This ensures that programs can be transported from Unicode systems to non-Unicode systems without conversion losses.


### abensplit_text_guidl.htm

---
title: "Splitting Texts"
description: |
  Background Usually the characters in a character string are encoded based on a code page using a fixed number of bytes. This means that it is always known in the memory where a character begins and ends. However, in some code pages, a character can be formed from a combination of multiple separately
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensplit_text_guidl.htm"
abapFile: "abensplit_text_guidl.htm"
keywords: ["do", "if", "try", "method", "class", "abensplit", "text", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Internationalization](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternationalization_gdl.htm) → 

Splitting Texts

Background

Usually the characters in a character string are encoded based on a code page using a fixed number of bytes. This means that it is always known in the memory where a character begins and ends. However, in some code pages, a character can be formed from a combination of multiple separately saved characters. This applies in particular to the characters of the surrogate area of the Unicode character set, that are collectively represented in the Unicode character representation [UTF-16](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenutf16_glosry.htm "Glossary Entry") by two consecutive 16-bit replacement codes ([surrogate](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abensurrogates_glosry.htm "Glossary Entry")). The surrogate area, for example, includes several Chinese characters that are predominantly used in Hong Kong. The ABAP programming area does not support this area. ABAP supports the subset of UTF-16 covered by [UCS-2](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenucs2_glosry.htm "Glossary Entry"), in which each character occupies two bytes. One character in the surrogate area occupies four bytes and is handled as two characters by ABAP.

Rule

Only split texts between characters

Make sure that statements do not split character strings in any places with composite characters or surrogates.

Details

Operations that split character strings include:

-   Substring accesses with offsets/lengths or substring functions
-   The SPLIT statement
-   Every assignment to a character-like field that is too short, where one side of the original value is cut off

If texts containing combined characters or surrogates are split, this can produce undefined characters that cannot be displayed. If there is a risk of this occurring, you can define a suitable separation position by using the method STRING\_SPLIT\_AT\_POSITION of classCL\_SCP\_LINEBREAK\_UTIL.


### abencodepage_file_guidl.htm

---
title: "Code Pages for Files"
description: |
  Background When you open text files on the host computer(https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenhost_computer_glosry.htm 'Glossary Entry') of the current AS instance using the OPEN DATASET statement, you specify the following options that are very important for internationa
version: "7.56"
category: "general"
type: "abap-reference"
sourceUrl: "https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abencodepage_file_guidl.htm"
abapFile: "abencodepage_file_guidl.htm"
keywords: ["select", "insert", "do", "if", "try", "data", "abencodepage", "file", "guidl"]
---

* * *

AS ABAP Release 756, ©Copyright 2021 SAP SE. All rights reserved.

[ABAP - Keyword Documentation](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap.htm) →  [ABAP - Programming Guidelines](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenabap_pgl.htm) →  [Robust ABAP](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenrobust_abap_gdl.htm) →  [Internationalization](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abeninternationalization_gdl.htm) → 

Code Pages for Files

Background

When you open text files on the [host computer](https://help.sap.com/doc/abapdocu_756_index_htm/7.56/en-US/abenhost_computer_glosry.htm "Glossary Entry") of the current AS instance using the OPEN DATASET statement, you specify the following options that are very important for internationalization:

-   The ENCODING addition specifies the character representation where the content of the file is handled.
-   The WITH BYTE-ORDER MARK addition, which is only possible for UTF-8 files, specifies that a byte order mark (BOM) is inserted at the beginning of a text file when it is written.

If the code page is not specified explicitly when a file is written, it is set implicitly (to UTF-8 in a Unicode system). If nothing is specified, a BOM is not set.

Rule

Write text files in UTF-8 and with a byte order mark.

Open text files for output explicitly in the UTF-8 code page. The byte order mark should be inserted and taken into account when the file is read.

Details

When a file is read, the code page used is usually very difficult to identify. However, if the byte-order mark is inserted, a file is clearly defined as a UTF-8. Therefore, you should always specify the ENCODING UTF-8 WITH BYTE-ORDER MARK additions when opening a text output file with the OPEN DATASET statement. When a text file of this type is read, it should only be opened with the SKIPPING BYTE-ORDER MARK addition, so that the byte order mark is automatically skipped and does not appear in the read application data.

Exception

Files used for data exchange with applications that do not support UTF-8 format must be output in a suitable code page.

Bad Example

The following source code shows how a text file is opened for writes without explicitly specifying the code page. In Unicode systems, UTF-8 is selected implicitly, but a byte order mark is not inserted.

OPEN DATASET dset
  FOR OUTPUT IN TEXT MODE
  ENCODING DEFAULT.

Good Example

The following source code shows how a text file is opened for writes by explicitly specifying the UTF-8 code page and using the byte order mark.

OPEN DATASET dset
  FOR OUTPUT IN TEXT MODE
  ENCODING UTF-8 WITH BYTE-ORDER MARK.


---
